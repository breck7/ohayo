"use strict";
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";var e,i;function c(){return e.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function u(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function l(e){return void 0===e}function h(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function d(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function f(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function m(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function _(e,t){for(var n in t)m(t,n)&&(e[n]=t[n]);return m(t,"toString")&&(e.toString=t.toString),m(t,"valueOf")&&(e.valueOf=t.valueOf),e}function y(e,t,n,s){return Tt(e,t,n,s,!0).utc()}function g(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function v(e){if(null==e._isValid){var t=g(e),n=i.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function p(e){var t=y(NaN);return null!=e?_(g(t),e):g(t).userInvalidated=!0,t}i=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var r=c.momentProperties=[];function w(e,t){var n,s,i;if(l(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),l(t._i)||(e._i=t._i),l(t._f)||(e._f=t._f),l(t._l)||(e._l=t._l),l(t._strict)||(e._strict=t._strict),l(t._tzm)||(e._tzm=t._tzm),l(t._isUTC)||(e._isUTC=t._isUTC),l(t._offset)||(e._offset=t._offset),l(t._pf)||(e._pf=g(t)),l(t._locale)||(e._locale=t._locale),0<r.length)for(n=0;n<r.length;n++)l(i=t[s=r[n]])||(e[s]=i);return e}var t=!1;function M(e){w(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===t&&(t=!0,c.updateOffset(this),t=!1)}function k(e){return e instanceof M||null!=e&&null!=e._isAMomentObject}function S(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function D(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=S(t)),n}function a(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&D(e[s])!==D(t[s]))&&a++;return a+r}function Y(e){!1===c.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function n(i,r){var a=!0;return _(function(){if(null!=c.deprecationHandler&&c.deprecationHandler(null,i),a){for(var e,t=[],n=0;n<arguments.length;n++){if(e="","object"==typeof arguments[n]){for(var s in e+="\n["+n+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2)}else e=arguments[n];t.push(e)}Y(i+"\nArguments: "+Array.prototype.slice.call(t).join("")+"\n"+(new Error).stack),a=!1}return r.apply(this,arguments)},r)}var s,O={};function T(e,t){null!=c.deprecationHandler&&c.deprecationHandler(e,t),O[e]||(Y(t),O[e]=!0)}function b(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function x(e,t){var n,s=_({},e);for(n in t)m(t,n)&&(u(e[n])&&u(t[n])?(s[n]={},_(s[n],e[n]),_(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)m(e,n)&&!m(t,n)&&u(e[n])&&(s[n]=_({},s[n]));return s}function P(e){null!=e&&this.set(e)}c.suppressDeprecationWarnings=!1,c.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)m(e,t)&&n.push(t);return n};var W={};function C(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e}function H(e){return"string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function R(e){var t,n,s={};for(n in e)m(e,n)&&(t=H(n))&&(s[t]=e[n]);return s}var U={};function F(e,t){U[e]=t}function L(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(0<=e?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return L(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(s){var e,i,t,r=s.match(N);for(e=0,i=r.length;e<i;e++)E[r[e]]?r[e]=E[r[e]]:r[e]=(t=r[e]).match(/\[[\s\S]/)?t.replace(/^\[|\]$/g,""):t.replace(/\\/g,"");return function(e){var t,n="";for(t=0;t<i;t++)n+=b(r[t])?r[t].call(e,s):r[t];return n}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;0<=n&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,n,s){oe[e]=b(n)?n:function(e,t){return e&&s?s:n}}function le(e,t){return m(oe,e)?oe[e](t._strict,t._locale):new RegExp(he(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function he(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var de={};function ce(e,n){var t,s=n;for("string"==typeof e&&(e=[e]),h(n)&&(s=function(e,t){t[n]=D(e)}),t=0;t<e.length;t++)de[e[t]]=s}function fe(e,i){ce(e,function(e,t,n,s){n._w=n._w||{},i(e,n._w,n,s)})}var me=0,_e=1,ye=2,ge=3,ve=4,pe=5,we=6,Me=7,ke=8;function Se(e){return De(e)?366:365}function De(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),C("year","y"),F("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],me),ce("YYYY",function(e,t){t[me]=2===e.length?c.parseTwoDigitYear(e):D(e)}),ce("YY",function(e,t){t[me]=c.parseTwoDigitYear(e)}),ce("Y",function(e,t){t[me]=parseInt(e,10)}),c.parseTwoDigitYear=function(e){return D(e)+(68<D(e)?1900:2e3)};var Ye,Oe=Te("FullYear",!0);function Te(t,n){return function(e){return null!=e?(xe(this,t,e),c.updateOffset(this,n),this):be(this,t)}}function be(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function xe(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&De(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Pe(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function Pe(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?De(e)?29:28:31-s%7%2}Ye=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),C("month","M"),F("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[_e]=D(e)-1}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[_e]=i:g(n).invalidMonth=e});var We=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Ce="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var He="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Re(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=D(t);else if(!h(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),Pe(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Ue(e){return null!=e?(Re(this,e),c.updateOffset(this,!0),this):be(this,"Month")}var Fe=ae;var Le=ae;function Ne(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=y([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=he(s[t]),i[t]=he(i[t]);for(t=0;t<24;t++)r[t]=he(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Ge(e){var t;if(e<100&&0<=e){var n=Array.prototype.slice.call(arguments);n[0]=e+400,t=new Date(Date.UTC.apply(null,n)),isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e)}else t=new Date(Date.UTC.apply(null,arguments));return t}function Ve(e,t,n){var s=7+t-n;return-((7+Ge(e,0,s).getUTCDay()-t)%7)+s-1}function Ee(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ve(e,s,i);return a=o<=0?Se(r=e-1)+o:o>Se(e)?(r=e+1,o-Se(e)):(r=e,o),{year:r,dayOfYear:a}}function Ie(e,t,n){var s,i,r=Ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+Ae(i=e.year()-1,t,n):a>Ae(e.year(),t,n)?(s=a-Ae(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function Ae(e,t,n){var s=Ve(e,t,n),i=Ve(e+1,t,n);return(Se(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),C("week","w"),C("isoWeek","W"),F("week",5),F("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=D(e)});function je(e,t){return e.slice(t,7).concat(e.slice(0,t))}I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),C("day","d"),C("weekday","e"),C("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:g(n).invalidWeekday=e}),fe(["d","e","E"],function(e,t,n,s){t[s]=D(e)});var Ze="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var $e="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var qe=ae;var Je=ae;var Be=ae;function Qe(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=y([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=he(o[t]),u[t]=he(u[t]),l[t]=he(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Xe(){return this.hours()%12||12}function Ke(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function et(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Xe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)}),I("hmmss",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)+L(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+L(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+L(this.minutes(),2)+L(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),C("hour","h"),F("hour",13),ue("a",et),ue("A",et),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],ge),ce(["k","kk"],function(e,t,n){var s=D(e);t[ge]=24===s?0:s}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),ce(["h","hh"],function(e,t,n){t[ge]=D(e),g(n).bigHour=!0}),ce("hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s)),g(n).bigHour=!0}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i)),g(n).bigHour=!0}),ce("Hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s))}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i))});var tt,nt=Te("Hours",!0),st={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Ce,monthsShort:He,week:{dow:0,doy:6},weekdays:Ze,weekdaysMin:$e,weekdaysShort:ze,meridiemParse:/[ap]\.?m?\.?/i},it={},rt={};function at(e){return e?e.toLowerCase().replace("_","-"):e}function ot(e){var t=null;if(!it[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=tt._abbr,require("./locale/"+e),ut(t)}catch(e){}return it[e]}function ut(e,t){var n;return e&&((n=l(t)?ht(e):lt(e,t))?tt=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),tt._abbr}function lt(e,t){if(null===t)return delete it[e],null;var n,s=st;if(t.abbr=e,null!=it[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=it[e]._config;else if(null!=t.parentLocale)if(null!=it[t.parentLocale])s=it[t.parentLocale]._config;else{if(null==(n=ot(t.parentLocale)))return rt[t.parentLocale]||(rt[t.parentLocale]=[]),rt[t.parentLocale].push({name:e,config:t}),null;s=n._config}return it[e]=new P(x(s,t)),rt[e]&&rt[e].forEach(function(e){lt(e.name,e.config)}),ut(e),it[e]}function ht(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return tt;if(!o(e)){if(t=ot(e))return t;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=at(e[r]).split("-")).length,n=(n=at(e[r+1]))?n.split("-"):null;0<t;){if(s=ot(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&a(i,n,!0)>=t-1)break;t--}r++}return tt}(e)}function dt(e){var t,n=e._a;return n&&-2===g(e).overflow&&(t=n[_e]<0||11<n[_e]?_e:n[ye]<1||n[ye]>Pe(n[me],n[_e])?ye:n[ge]<0||24<n[ge]||24===n[ge]&&(0!==n[ve]||0!==n[pe]||0!==n[we])?ge:n[ve]<0||59<n[ve]?ve:n[pe]<0||59<n[pe]?pe:n[we]<0||999<n[we]?we:-1,g(e)._overflowDayOfYear&&(t<me||ye<t)&&(t=ye),g(e)._overflowWeeks&&-1===t&&(t=Me),g(e)._overflowWeekday&&-1===t&&(t=ke),g(e).overflow=t),e}function ct(e,t,n){return null!=e?e:null!=t?t:n}function ft(e){var t,n,s,i,r,a=[];if(!e._d){var o,u;for(o=e,u=new Date(c.now()),s=o._useUTC?[u.getUTCFullYear(),u.getUTCMonth(),u.getUTCDate()]:[u.getFullYear(),u.getMonth(),u.getDate()],e._w&&null==e._a[ye]&&null==e._a[_e]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ct(t.GG,e._a[me],Ie(bt(),1,4).year),s=ct(t.W,1),((i=ct(t.E,1))<1||7<i)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Ie(bt(),r,a);n=ct(t.gg,e._a[me],l.year),s=ct(t.w,l.week),null!=t.d?((i=t.d)<0||6<i)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||6<t.e)&&(u=!0)):i=r}s<1||s>Ae(n,r,a)?g(e)._overflowWeeks=!0:null!=u?g(e)._overflowWeekday=!0:(o=Ee(n,s,i,r,a),e._a[me]=o.year,e._dayOfYear=o.dayOfYear)}(e),null!=e._dayOfYear&&(r=ct(e._a[me],s[me]),(e._dayOfYear>Se(r)||0===e._dayOfYear)&&(g(e)._overflowDayOfYear=!0),n=Ge(r,0,e._dayOfYear),e._a[_e]=n.getUTCMonth(),e._a[ye]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=a[t]=s[t];for(;t<7;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ge]&&0===e._a[ve]&&0===e._a[pe]&&0===e._a[we]&&(e._nextDay=!0,e._a[ge]=0),e._d=(e._useUTC?Ge:function(e,t,n,s,i,r,a){var o;return e<100&&0<=e?(o=new Date(e+400,t,n,s,i,r,a),isFinite(o.getFullYear())&&o.setFullYear(e)):o=new Date(e,t,n,s,i,r,a),o}).apply(null,a),i=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ge]=24),e._w&&void 0!==e._w.d&&e._w.d!==i&&(g(e).weekdayMismatch=!0)}}var mt=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,yt=/Z|[+-]\d\d(?::?\d\d)?/,gt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],vt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],pt=/^\/?Date\((\-?\d+)/i;function wt(e){var t,n,s,i,r,a,o=e._i,u=mt.exec(o)||_t.exec(o);if(u){for(g(e).iso=!0,t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[1])){i=gt[t][0],s=!1!==gt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=vt.length;t<n;t++)if(vt[t][1].exec(u[3])){r=(u[2]||" ")+vt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!yt.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),Yt(e)}else e._isValid=!1}var Mt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function kt(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),He.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var St={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Dt(e){var t,n,s,i=Mt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(i){var r=kt(i[4],i[3],i[2],i[5],i[6],i[7]);if(t=i[1],n=r,s=e,t&&ze.indexOf(t)!==new Date(n[0],n[1],n[2]).getDay()&&(g(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=r,e._tzm=function(e,t,n){if(e)return St[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(i[8],i[9],i[10]),e._d=Ge.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),g(e).rfc2822=!0}else e._isValid=!1}function Yt(e){if(e._f!==c.ISO_8601)if(e._f!==c.RFC_2822){e._a=[],g(e).empty=!0;var t,n,s,i,r,a,o,u,l=""+e._i,h=l.length,d=0;for(s=j(e._f,e._locale).match(N)||[],t=0;t<s.length;t++)i=s[t],(n=(l.match(le(i,e))||[])[0])&&(0<(r=l.substr(0,l.indexOf(n))).length&&g(e).unusedInput.push(r),l=l.slice(l.indexOf(n)+n.length),d+=n.length),E[i]?(n?g(e).empty=!1:g(e).unusedTokens.push(i),a=i,u=e,null!=(o=n)&&m(de,a)&&de[a](o,u._a,u,a)):e._strict&&!n&&g(e).unusedTokens.push(i);g(e).charsLeftOver=h-d,0<l.length&&g(e).unusedInput.push(l),e._a[ge]<=12&&!0===g(e).bigHour&&0<e._a[ge]&&(g(e).bigHour=void 0),g(e).parsedDateParts=e._a.slice(0),g(e).meridiem=e._meridiem,e._a[ge]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):(null!=e.isPM&&((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0)),t)}(e._locale,e._a[ge],e._meridiem),ft(e),dt(e)}else Dt(e);else wt(e)}function Ot(e){var t,n,s,i,r=e._i,a=e._f;return e._locale=e._locale||ht(e._l),null===r||void 0===a&&""===r?p({nullInput:!0}):("string"==typeof r&&(e._i=r=e._locale.preparse(r)),k(r)?new M(dt(r)):(d(r)?e._d=r:o(a)?function(e){var t,n,s,i,r;if(0===e._f.length)return g(e).invalidFormat=!0,e._d=new Date(NaN);for(i=0;i<e._f.length;i++)r=0,t=w({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],Yt(t),v(t)&&(r+=g(t).charsLeftOver,r+=10*g(t).unusedTokens.length,g(t).score=r,(null==s||r<s)&&(s=r,n=t));_(e,n||t)}(e):a?Yt(e):l(n=(t=e)._i)?t._d=new Date(c.now()):d(n)?t._d=new Date(n.valueOf()):"string"==typeof n?(s=t,null===(i=pt.exec(s._i))?(wt(s),!1===s._isValid&&(delete s._isValid,Dt(s),!1===s._isValid&&(delete s._isValid,c.createFromInputFallback(s)))):s._d=new Date(+i[1])):o(n)?(t._a=f(n.slice(0),function(e){return parseInt(e,10)}),ft(t)):u(n)?function(e){if(!e._d){var t=R(e._i);e._a=f([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ft(e)}}(t):h(n)?t._d=new Date(n):c.createFromInputFallback(t),v(e)||(e._d=null),e))}function Tt(e,t,n,s,i){var r,a={};return!0!==n&&!1!==n||(s=n,n=void 0),(u(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||o(e)&&0===e.length)&&(e=void 0),a._isAMomentObject=!0,a._useUTC=a._isUTC=i,a._l=n,a._i=e,a._f=t,a._strict=s,(r=new M(dt(Ot(a))))._nextDay&&(r.add(1,"d"),r._nextDay=void 0),r}function bt(e,t,n,s){return Tt(e,t,n,s,!1)}c.createFromInputFallback=n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),c.ISO_8601=function(){},c.RFC_2822=function(){};var xt=n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:p()}),Pt=n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:p()});function Wt(e,t){var n,s;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return bt();for(n=t[0],s=1;s<t.length;++s)t[s].isValid()&&!t[s][e](n)||(n=t[s]);return n}var Ct=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ht(e){var t=R(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||t.isoWeek||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,h=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ye.call(Ct,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<Ct.length;++s)if(e[Ct[s]]){if(n)return!1;parseFloat(e[Ct[s]])!==D(e[Ct[s]])&&(n=!0)}return!0}(t),this._milliseconds=+h+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=ht(),this._bubble()}function Rt(e){return e instanceof Ht}function Ut(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ft(e,n){I(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+L(~~(e/60),2)+n+L(~~e%60,2)})}Ft("Z",":"),Ft("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Nt(re,e)});var Lt=/([\+\-]|\d\d)/gi;function Nt(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Lt)||["-",0,0],i=60*s[1]+D(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Gt(e,t){var n,s;return t._isUTC?(n=t.clone(),s=(k(e)||d(e)?e.valueOf():bt(e).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+s),c.updateOffset(n,!1),n):bt(e).local()}function Vt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Et(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}c.updateOffset=function(){};var It=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,At=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function jt(e,t){var n,s,i,r=e,a=null;return Rt(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:h(e)?(r={},t?r[t]=e:r.milliseconds=e):(a=It.exec(e))?(n="-"===a[1]?-1:1,r={y:0,d:D(a[ye])*n,h:D(a[ge])*n,m:D(a[ve])*n,s:D(a[pe])*n,ms:D(Ut(1e3*a[we]))*n}):(a=At.exec(e))?(n="-"===a[1]?-1:1,r={y:Zt(a[2],n),M:Zt(a[3],n),w:Zt(a[4],n),d:Zt(a[5],n),h:Zt(a[6],n),m:Zt(a[7],n),s:Zt(a[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Gt(t,e),e.isBefore(t)?n=zt(e,t):((n=zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(bt(r.from),bt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Ht(r),Rt(e)&&m(e,"_locale")&&(s._locale=e._locale),s}function Zt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function zt(e,t){var n={};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function $t(s,i){return function(e,t){var n;return null===t||isNaN(+t)||(T(i,"moment()."+i+"(period, number) is deprecated. Please use moment()."+i+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),n=e,e=t,t=n),qt(this,jt(e="string"==typeof e?+e:e,t),s),this}}function qt(e,t,n,s){var i=t._milliseconds,r=Ut(t._days),a=Ut(t._months);e.isValid()&&(s=null==s||s,a&&Re(e,be(e,"Month")+a*n),r&&xe(e,"Date",be(e,"Date")+r*n),i&&e._d.setTime(e._d.valueOf()+i*n),s&&c.updateOffset(e,r||a))}jt.fn=Ht.prototype,jt.invalid=function(){return jt(NaN)};var Jt=$t(1,"add"),Bt=$t(-1,"subtract");function Qt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return-(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Xt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=ht(e))&&(this._locale=t),this)}c.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",c.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Kt=n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function en(){return this._locale}var tn=126227808e5;function nn(e,t){return(e%t+t)%t}function sn(e,t,n){return e<100&&0<=e?new Date(e+400,t,n)-tn:new Date(e,t,n).valueOf()}function rn(e,t,n){return e<100&&0<=e?Date.UTC(e+400,t,n)-tn:Date.UTC(e,t,n)}function an(e,t){I(0,[e,e.length],0,t)}function on(e,t,n,s,i){var r;return null==e?Ie(this,s,i).year:((r=Ae(e,s,i))<t&&(t=r),function(e,t,n,s,i){var r=Ee(e,t,n,s,i),a=Ge(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),an("gggg","weekYear"),an("ggggg","weekYear"),an("GGGG","isoWeekYear"),an("GGGGG","isoWeekYear"),C("weekYear","gg"),C("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=D(e)}),fe(["gg","GG"],function(e,t,n,s){t[s]=c.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),C("quarter","Q"),F("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[_e]=3*(D(e)-1)}),I("D",["DD",2],"Do","date"),C("date","D"),F("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ye),ce("Do",function(e,t){t[ye]=D(e.match(B)[0])});var un=Te("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),C("dayOfYear","DDD"),F("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=D(e)}),I("m",["mm",2],0,"minute"),C("minute","m"),F("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],ve);var ln=Te("Minutes",!1);I("s",["ss",2],0,"second"),C("second","s"),F("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],pe);var hn,dn=Te("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),C("millisecond","ms"),F("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),hn="SSSS";hn.length<=9;hn+="S")ue(hn,ne);function cn(e,t){t[we]=D(1e3*("0."+e))}for(hn="S";hn.length<=9;hn+="S")ce(hn,cn);var fn=Te("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var mn=M.prototype;function _n(e){return e}mn.add=Jt,mn.calendar=function(e,t){var n=e||bt(),s=Gt(n,this).startOf("day"),i=c.calendarFormat(this,s)||"sameElse",r=t&&(b(t[i])?t[i].call(this,n):t[i]);return this.format(r||this.localeData().calendar(i,this,bt(n)))},mn.clone=function(){return new M(this)},mn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Gt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=H(t)){case"year":r=Qt(this,s)/12;break;case"month":r=Qt(this,s);break;case"quarter":r=Qt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:S(r)},mn.endOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year()+1,0,1)-1;break;case"quarter":t=n(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":t=n(this.year(),this.month()+1,1)-1;break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":t=n(this.year(),this.month(),this.date()+1)-1;break;case"hour":t=this._d.valueOf(),t+=36e5-nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5)-1;break;case"minute":t=this._d.valueOf(),t+=6e4-nn(t,6e4)-1;break;case"second":t=this._d.valueOf(),t+=1e3-nn(t,1e3)-1;break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.format=function(e){e||(e=this.isUtc()?c.defaultFormatUtc:c.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},mn.from=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.fromNow=function(e){return this.from(bt(),e)},mn.to=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.toNow=function(e){return this.to(bt(),e)},mn.get=function(e){return b(this[e=H(e)])?this[e]():this},mn.invalidAt=function(){return g(this).overflow},mn.isAfter=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},mn.isBefore=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},mn.isBetween=function(e,t,n,s){var i=k(e)?e:bt(e),r=k(t)?t:bt(t);return!!(this.isValid()&&i.isValid()&&r.isValid())&&("("===(s=s||"()")[0]?this.isAfter(i,n):!this.isBefore(i,n))&&(")"===s[1]?this.isBefore(r,n):!this.isAfter(r,n))},mn.isSame=function(e,t){var n,s=k(e)?e:bt(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},mn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},mn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},mn.isValid=function(){return v(this)},mn.lang=Kt,mn.locale=Xt,mn.localeData=en,mn.max=Pt,mn.min=xt,mn.parsingFlags=function(){return _({},g(this))},mn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:U[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=R(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(b(this[e=H(e)]))return this[e](t);return this},mn.startOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year(),0,1);break;case"quarter":t=n(this.year(),this.month()-this.month()%3,1);break;case"month":t=n(this.year(),this.month(),1);break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":t=n(this.year(),this.month(),this.date());break;case"hour":t=this._d.valueOf(),t-=nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5);break;case"minute":t=this._d.valueOf(),t-=nn(t,6e4);break;case"second":t=this._d.valueOf(),t-=nn(t,1e3);break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.subtract=Bt,mn.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},mn.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},mn.toDate=function(){return new Date(this.valueOf())},mn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||9999<n.year()?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):b(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},mn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},mn.toJSON=function(){return this.isValid()?this.toISOString():null},mn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},mn.unix=function(){return Math.floor(this.valueOf()/1e3)},mn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},mn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},mn.year=Oe,mn.isLeapYear=function(){return De(this.year())},mn.weekYear=function(e){return on.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},mn.isoWeekYear=function(e){return on.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},mn.quarter=mn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},mn.month=Ue,mn.daysInMonth=function(){return Pe(this.year(),this.month())},mn.week=mn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},mn.isoWeek=mn.isoWeeks=function(e){var t=Ie(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},mn.weeksInYear=function(){var e=this.localeData()._week;return Ae(this.year(),e.dow,e.doy)},mn.isoWeeksInYear=function(){return Ae(this.year(),1,4)},mn.date=un,mn.day=mn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t,n,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(t=e,n=this.localeData(),e="string"!=typeof t?t:isNaN(t)?"number"==typeof(t=n.weekdaysParse(t))?t:null:parseInt(t,10),this.add(e-s,"d")):s},mn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},mn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null==e)return this.day()||7;var t,n,s=(t=e,n=this.localeData(),"string"==typeof t?n.weekdaysParse(t)%7||7:isNaN(t)?null:t);return this.day(this.day()%7?s:s-7)},mn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},mn.hour=mn.hours=nt,mn.minute=mn.minutes=ln,mn.second=mn.seconds=dn,mn.millisecond=mn.milliseconds=fn,mn.utcOffset=function(e,t,n){var s,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null==e)return this._isUTC?i:Vt(this);if("string"==typeof e){if(null===(e=Nt(re,e)))return this}else Math.abs(e)<16&&!n&&(e*=60);return!this._isUTC&&t&&(s=Vt(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==e&&(!t||this._changeInProgress?qt(this,jt(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,c.updateOffset(this,!0),this._changeInProgress=null)),this},mn.utc=function(e){return this.utcOffset(0,e)},mn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Vt(this),"m")),this},mn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Nt(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},mn.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?bt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},mn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},mn.isLocal=function(){return!!this.isValid()&&!this._isUTC},mn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},mn.isUtc=Et,mn.isUTC=Et,mn.zoneAbbr=function(){return this._isUTC?"UTC":""},mn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},mn.dates=n("dates accessor is deprecated. Use date instead.",un),mn.months=n("months accessor is deprecated. Use month instead",Ue),mn.years=n("years accessor is deprecated. Use year instead",Oe),mn.zone=n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),mn.isDSTShifted=n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!l(this._isDSTShifted))return this._isDSTShifted;var e={};if(w(e,this),(e=Ot(e))._a){var t=e._isUTC?y(e._a):bt(e._a);this._isDSTShifted=this.isValid()&&0<a(e._a,t.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted});var yn=P.prototype;function gn(e,t,n,s){var i=ht(),r=y().set(s,t);return i[n](r,e)}function vn(e,t,n){if(h(e)&&(t=e,e=void 0),e=e||"",null!=t)return gn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=gn(e,s,n,"month");return i}function pn(e,t,n,s){t=("boolean"==typeof e?h(t)&&(n=t,t=void 0):(t=e,e=!1,h(n=t)&&(n=t,t=void 0)),t||"");var i,r=ht(),a=e?r._week.dow:0;if(null!=n)return gn(t,(n+a)%7,s,"day");var o=[];for(i=0;i<7;i++)o[i]=gn(t,(i+a)%7,s,"day");return o}yn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return b(s)?s.call(t,n):s},yn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},yn.invalidDate=function(){return this._invalidDate},yn.ordinal=function(e){return this._ordinal.replace("%d",e)},yn.preparse=_n,yn.postformat=_n,yn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return b(i)?i(e,t,n,s):i.replace(/%d/i,e)},yn.pastFuture=function(e,t){var n=this._relativeTime[0<e?"future":"past"];return b(n)?n(t):n.replace(/%s/i,t)},yn.set=function(e){var t,n;for(n in e)b(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},yn.months=function(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||We).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone},yn.monthsShort=function(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[We.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},yn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=y([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=y([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},yn.monthsRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsStrictRegex:this._monthsRegex):(m(this,"_monthsRegex")||(this._monthsRegex=Le),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},yn.monthsShortRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(m(this,"_monthsShortRegex")||(this._monthsShortRegex=Fe),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},yn.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},yn.firstDayOfYear=function(){return this._week.doy},yn.firstDayOfWeek=function(){return this._week.dow},yn.weekdays=function(e,t){var n=o(this._weekdays)?this._weekdays:this._weekdays[e&&!0!==e&&this._weekdays.isFormat.test(t)?"format":"standalone"];return!0===e?je(n,this._week.dow):e?n[e.day()]:n},yn.weekdaysMin=function(e){return!0===e?je(this._weekdaysMin,this._week.dow):e?this._weekdaysMin[e.day()]:this._weekdaysMin},yn.weekdaysShort=function(e){return!0===e?je(this._weekdaysShort,this._week.dow):e?this._weekdaysShort[e.day()]:this._weekdaysShort},yn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=y([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=y([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},yn.weekdaysRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(m(this,"_weekdaysRegex")||(this._weekdaysRegex=qe),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},yn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(m(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Je),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},yn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(m(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Be),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},yn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},yn.meridiem=function(e,t,n){return 11<e?n?"pm":"PM":n?"am":"AM"},ut("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===D(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),c.lang=n("moment.lang is deprecated. Use moment.locale instead.",ut),c.langData=n("moment.langData is deprecated. Use moment.localeData instead.",ht);var wn=Math.abs;function Mn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function kn(e){return e<0?Math.floor(e):Math.ceil(e)}function Sn(e){return 4800*e/146097}function Dn(e){return 146097*e/4800}function Yn(e){return function(){return this.as(e)}}var On=Yn("ms"),Tn=Yn("s"),bn=Yn("m"),xn=Yn("h"),Pn=Yn("d"),Wn=Yn("w"),Cn=Yn("M"),Hn=Yn("Q"),Rn=Yn("y");function Un(e){return function(){return this.isValid()?this._data[e]:NaN}}var Fn=Un("milliseconds"),Ln=Un("seconds"),Nn=Un("minutes"),Gn=Un("hours"),Vn=Un("days"),En=Un("months"),In=Un("years");var An=Math.round,jn={ss:44,s:45,m:45,h:22,d:26,M:11};var Zn=Math.abs;function zn(e){return(0<e)-(e<0)||+e}function $n(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Zn(this._milliseconds)/1e3,s=Zn(this._days),i=Zn(this._months);t=S((e=S(n/60))/60),n%=60,e%=60;var r=S(i/12),a=i%=12,o=s,u=t,l=e,h=n?n.toFixed(3).replace(/\.?0+$/,""):"",d=this.asSeconds();if(!d)return"P0D";var c=d<0?"-":"",f=zn(this._months)!==zn(d)?"-":"",m=zn(this._days)!==zn(d)?"-":"",_=zn(this._milliseconds)!==zn(d)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||h?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(h?_+h+"S":"")}var qn=Ht.prototype;return qn.isValid=function(){return this._isValid},qn.abs=function(){var e=this._data;return this._milliseconds=wn(this._milliseconds),this._days=wn(this._days),this._months=wn(this._months),e.milliseconds=wn(e.milliseconds),e.seconds=wn(e.seconds),e.minutes=wn(e.minutes),e.hours=wn(e.hours),e.months=wn(e.months),e.years=wn(e.years),this},qn.add=function(e,t){return Mn(this,e,t,1)},qn.subtract=function(e,t){return Mn(this,e,t,-1)},qn.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=H(e))||"quarter"===e||"year"===e)switch(t=this._days+s/864e5,n=this._months+Sn(t),e){case"month":return n;case"quarter":return n/3;case"year":return n/12}else switch(t=this._days+Math.round(Dn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},qn.asMilliseconds=On,qn.asSeconds=Tn,qn.asMinutes=bn,qn.asHours=xn,qn.asDays=Pn,qn.asWeeks=Wn,qn.asMonths=Cn,qn.asQuarters=Hn,qn.asYears=Rn,qn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*D(this._months/12):NaN},qn._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return 0<=r&&0<=a&&0<=o||r<=0&&a<=0&&o<=0||(r+=864e5*kn(Dn(o)+a),o=a=0),u.milliseconds=r%1e3,e=S(r/1e3),u.seconds=e%60,t=S(e/60),u.minutes=t%60,n=S(t/60),u.hours=n%24,o+=i=S(Sn(a+=S(n/24))),a-=kn(Dn(i)),s=S(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},qn.clone=function(){return jt(this)},qn.get=function(e){return e=H(e),this.isValid()?this[e+"s"]():NaN},qn.milliseconds=Fn,qn.seconds=Ln,qn.minutes=Nn,qn.hours=Gn,qn.days=Vn,qn.weeks=function(){return S(this.days()/7)},qn.months=En,qn.years=In,qn.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t,n,s,i,r,a,o,u,l,h,d,c=this.localeData(),f=(n=!e,s=c,i=jt(t=this).abs(),r=An(i.as("s")),a=An(i.as("m")),o=An(i.as("h")),u=An(i.as("d")),l=An(i.as("M")),h=An(i.as("y")),(d=r<=jn.ss&&["s",r]||r<jn.s&&["ss",r]||a<=1&&["m"]||a<jn.m&&["mm",a]||o<=1&&["h"]||o<jn.h&&["hh",o]||u<=1&&["d"]||u<jn.d&&["dd",u]||l<=1&&["M"]||l<jn.M&&["MM",l]||h<=1&&["y"]||["yy",h])[2]=n,d[3]=0<+t,d[4]=s,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d));return e&&(f=c.pastFuture(+this,f)),c.postformat(f)},qn.toISOString=$n,qn.toString=$n,qn.toJSON=$n,qn.locale=Xt,qn.localeData=en,qn.toIsoString=n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",$n),qn.lang=Kt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),ce("x",function(e,t,n){n._d=new Date(D(e))}),c.version="2.24.0",e=bt,c.fn=mn,c.min=function(){return Wt("isBefore",[].slice.call(arguments,0))},c.max=function(){return Wt("isAfter",[].slice.call(arguments,0))},c.now=function(){return Date.now?Date.now():+new Date},c.utc=y,c.unix=function(e){return bt(1e3*e)},c.months=function(e,t){return vn(e,t,"months")},c.isDate=d,c.locale=ut,c.invalid=p,c.duration=jt,c.isMoment=k,c.weekdays=function(e,t,n){return pn(e,t,n,"weekdays")},c.parseZone=function(){return bt.apply(null,arguments).parseZone()},c.localeData=ht,c.isDuration=Rt,c.monthsShort=function(e,t){return vn(e,t,"monthsShort")},c.weekdaysMin=function(e,t,n){return pn(e,t,n,"weekdaysMin")},c.defineLocale=lt,c.updateLocale=function(e,t){if(null!=t){var n,s,i=st;null!=(s=ot(e))&&(i=s._config),(n=new P(t=x(i,t))).parentLocale=it[e],it[e]=n,ut(e)}else null!=it[e]&&(null!=it[e].parentLocale?it[e]=it[e].parentLocale:null!=it[e]&&delete it[e]);return it[e]},c.locales=function(){return s(it)},c.weekdaysShort=function(e,t,n){return pn(e,t,n,"weekdaysShort")},c.normalizeUnits=H,c.relativeTimeRounding=function(e){return void 0===e?An:"function"==typeof e&&(An=e,!0)},c.relativeTimeThreshold=function(e,t){return void 0!==jn[e]&&(void 0===t?jn[e]:(jn[e]=t,"s"===e&&(jn.ss=t-1),!0))},c.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},c.prototype=mn,c.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},c});;

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.momentParseformat = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var parseFormat = require('./lib/parseformat')
module.exports = parseFormat

/* istanbul ignore next */
if (typeof window !== 'undefined' && window.moment) {
  window.moment.parseFormat = parseFormat
}

},{"./lib/parseformat":2}],2:[function(require,module,exports){
module.exports = parseFormat

var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
var abbreviatedDayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
var shortestDayNames = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']
var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
var abbreviatedMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

var regexDayNames = new RegExp(dayNames.join('|'), 'i')
var regexAbbreviatedDayNames = new RegExp(abbreviatedDayNames.join('|'), 'i')
var regexShortestDayNames = new RegExp('\\b(' + shortestDayNames.join('|') + ')\\b', 'i')
var regexMonthNames = new RegExp(monthNames.join('|'), 'i')
var regexAbbreviatedMonthNames = new RegExp(abbreviatedMonthNames.join('|'), 'i')

var regexFirstSecondThirdFourth = /(\d+)(st|nd|rd|th)\b/i
var regexEndian = /(\d{1,4})([/.-])(\d{1,2})[/.-](\d{1,4})/

var regexTimezone = /((\+|-)\d\d:?\d\d)$/
var amOrPm = '(' + ['AM?', 'PM?'].join('|') + ')'
var regexHoursWithLeadingZeroDigitMinutesSecondsAmPm = new RegExp('0\\d\\:\\d{1,2}\\:\\d{1,2}(\\s*)' + amOrPm, 'i')
var regexHoursWithLeadingZeroDigitMinutesAmPm = new RegExp('0\\d\\:\\d{1,2}(\\s*)' + amOrPm, 'i')
var regexHoursWithLeadingZeroDigitAmPm = new RegExp('0\\d(\\s*)' + amOrPm, 'i')
var regexHoursMinutesSecondsAmPm = new RegExp('\\d{1,2}\\:\\d{1,2}\\:\\d{1,2}(\\s*)' + amOrPm, 'i')
var regexHoursMinutesAmPm = new RegExp('\\d{1,2}\\:\\d{1,2}(\\s*)' + amOrPm, 'i')
var regexHoursAmPm = new RegExp('\\d{1,2}(\\s*)' + amOrPm, 'i')

var regexISO8601HoursWithLeadingZeroMinutesSecondsMilliseconds = /\d{2}:\d{2}:\d{2}\.\d{3}/
var regexISO8601HoursWithLeadingZeroMinutesSecondsCentiSeconds = /\d{2}:\d{2}:\d{2}\.\d{2}/
var regexISO8601HoursWithLeadingZeroMinutesSecondsDeciSeconds = /\d{2}:\d{2}:\d{2}\.\d{1}/
var regexHoursWithLeadingZeroMinutesSeconds = /0\d:\d{2}:\d{2}/
var regexHoursWithLeadingZeroMinutes = /0\d:\d{2}/
var regexHoursMinutesSeconds = /\d{1,2}:\d{2}:\d{2}/
var regexHoursMinutesSecondsMilliseconds = /\d{1,2}:\d{2}:\d{2}\.\d{3}/
var regexHoursMinutesSecondsCentiSeconds = /\d{1,2}:\d{2}:\d{2}\.\d{2}/
var regexHoursMinutesSecondsDeciSeconds = /\d{1,2}:\d{2}:\d{2}\.\d{1}/
var regexHoursMinutes = /\d{1,2}:\d{2}/
var regexYearLong = /\d{4}/
var regexDayLeadingZero = /0\d/
var regexDay = /\d{1,2}/
var regexYearShort = /\d{2}/

var regexDayShortMonthShort = /^([1-9])\/([1-9]|0[1-9])$/
var regexDayShortMonth = /^([1-9])\/(1[012])$/
var regexDayMonthShort = /^(0[1-9]|[12][0-9]|3[01])\/([1-9])$/
var regexDayMonth = /^(0[1-9]|[12][0-9]|3[01])\/(1[012]|0[1-9])$/

var regexMonthShortYearShort = /^([1-9])\/([1-9][0-9])$/
var regexMonthYearShort = /^(0[1-9]|1[012])\/([1-9][0-9])$/

var formatIncludesMonth = /([/][M]|[M][/]|[MM]|[MMMM])/

var regexFillingWords = /\b(at)\b/i

var regexUnixMillisecondTimestamp = /\d{13}/
var regexUnixTimestamp = /\d{10}/

// option defaults
var defaultOrder = {
  '/': 'MDY',
  '.': 'DMY',
  '-': 'YMD'
}

function parseFormat (dateString, options) {
  var format = dateString.toString()

  // default options
  options = options || {}
  options.preferredOrder = options.preferredOrder || defaultOrder

  // Unix Millisecond Timestamp ☛ x
  format = format.replace(regexUnixMillisecondTimestamp, 'x')
  // Unix Timestamp ☛ X
  format = format.replace(regexUnixTimestamp, 'X')

  // escape filling words
  format = format.replace(regexFillingWords, '[$1]')

  //  DAYS

  // Monday ☛ dddd
  format = format.replace(regexDayNames, 'dddd')
  // Mon ☛ ddd
  format = format.replace(regexAbbreviatedDayNames, 'ddd')
  // Mo ☛ dd
  format = format.replace(regexShortestDayNames, 'dd')

  // 1st, 2nd, 23rd ☛ do
  format = format.replace(regexFirstSecondThirdFourth, 'Do')

  // MONTHS

  // January ☛ MMMM
  format = format.replace(regexMonthNames, 'MMMM')
  // Jan ☛ MMM
  format = format.replace(regexAbbreviatedMonthNames, 'MMM')

  // replace endians, like 8/20/2010, 20.8.2010 or 2010-8-20
  format = format.replace(regexEndian, replaceEndian.bind(null, options))

  // TIME

  // timezone +02:00 ☛ Z
  format = format.replace(regexTimezone, 'Z')
  // 23:39:43.331 ☛ 'HH:mm:ss.SSS'
  format = format.replace(regexISO8601HoursWithLeadingZeroMinutesSecondsMilliseconds, 'HH:mm:ss.SSS')
  // 23:39:43.33 ☛ 'HH:mm:ss.SS'
  format = format.replace(regexISO8601HoursWithLeadingZeroMinutesSecondsCentiSeconds, 'HH:mm:ss.SS')
  // 23:39:43.3 ☛ 'HH:mm:ss.S'
  format = format.replace(regexISO8601HoursWithLeadingZeroMinutesSecondsDeciSeconds, 'HH:mm:ss.S')
  function replaceWithAmPm (timeFormat) {
    return function (match, whitespace, amPm) {
      return timeFormat + whitespace + (amPm[0].toUpperCase() === amPm[0] ? 'A' : 'a')
    }
  }
  // 05:30:20pm ☛ hh:mm:ssa
  format = format.replace(regexHoursWithLeadingZeroDigitMinutesSecondsAmPm, replaceWithAmPm('hh:mm:ss'))
  // 10:30:20pm ☛ h:mm:ssa
  format = format.replace(regexHoursMinutesSecondsAmPm, replaceWithAmPm('h:mm:ss'))
  // 05:30pm ☛ hh:mma
  format = format.replace(regexHoursWithLeadingZeroDigitMinutesAmPm, replaceWithAmPm('hh:mm'))
  // 10:30pm ☛ h:mma
  format = format.replace(regexHoursMinutesAmPm, replaceWithAmPm('h:mm'))
  // 05pm ☛ hha
  format = format.replace(regexHoursWithLeadingZeroDigitAmPm, replaceWithAmPm('hh'))
  // 10pm ☛ ha
  format = format.replace(regexHoursAmPm, replaceWithAmPm('h'))
  // 05:30:20 ☛ HH:mm:ss
  format = format.replace(regexHoursWithLeadingZeroMinutesSeconds, 'HH:mm:ss')
  // 5:30:20.222 ☛ H:mm:ss.SSS
  format = format.replace(regexHoursMinutesSecondsMilliseconds, 'H:mm:ss.SSS')
  // 5:30:20.22 ☛ H:mm:ss.SS
  format = format.replace(regexHoursMinutesSecondsCentiSeconds, 'H:mm:ss.SS')
  // 5:30:20.2 ☛ H:mm:ss.S
  format = format.replace(regexHoursMinutesSecondsDeciSeconds, 'H:mm:ss.S')
  // 10:30:20 ☛ H:mm:ss
  format = format.replace(regexHoursMinutesSeconds, 'H:mm:ss')
  // 05:30 ☛ H:mm
  format = format.replace(regexHoursWithLeadingZeroMinutes, 'HH:mm')
  // 10:30 ☛ HH:mm
  format = format.replace(regexHoursMinutes, 'H:mm')

  // do we still have numbers left?

  // Lets check for 4 digits first, these are years for sure
  format = format.replace(regexYearLong, 'YYYY')

  // check if both numbers are < 13, then it must be D/M
  format = format.replace(regexDayShortMonthShort, 'D/M')

  // check if first number is < 10 && last < 13, then it must be D/MM
  format = format.replace(regexDayShortMonth, 'D/MM')

  // check if last number is < 32 && last < 10, then it must be DD/M
  format = format.replace(regexDayMonthShort, 'DD/M')

  // check if both numbers are > 10, but first < 32 && last < 13, then it must be DD/MM
  format = format.replace(regexDayMonth, 'DD/MM')

  // check if first < 10 && last > 12, then it must be M/YY
  format = format.replace(regexMonthShortYearShort, 'M/YY')

  // check if first < 13 && last > 12, then it must be MM/YY
  format = format.replace(regexMonthYearShort, 'MM/YY')

  // to prevent 9.20 gets formated to D.Y, we format the complete date first, then go for the time
  if (format.match(formatIncludesMonth)) {
    var regexHoursDotWithLeadingZeroOrDoubleDigitMinutes = /0\d.\d{2}|\d{2}.\d{2}/
    var regexHoursDotMinutes = /\d{1}.\d{2}/

    format = format.replace(regexHoursDotWithLeadingZeroOrDoubleDigitMinutes, 'H.mm')
    format = format.replace(regexHoursDotMinutes, 'h.mm')
  }

  // now, the next number, if existing, must be a day
  format = format.replace(regexDayLeadingZero, 'DD')
  format = format.replace(regexDay, 'D')

  // last but not least, there could still be a year left
  format = format.replace(regexYearShort, 'YY')

  if (format.length < 1) {
    format = undefined
  }

  return format
}

// if we can't find an endian based on the separator, but
// there still is a short date with day, month & year,
// we try to make a smart decision to identify the order
function replaceEndian (options, matchedPart, first, separator, second, third) {
  var parts
  var hasSingleDigit = Math.min(first.length, second.length, third.length) === 1
  var hasQuadDigit = Math.max(first.length, second.length, third.length) === 4
  var preferredOrder = typeof options.preferredOrder === 'string' ? options.preferredOrder : options.preferredOrder[separator]

  first = parseInt(first, 10)
  second = parseInt(second, 10)
  third = parseInt(third, 10)
  parts = [first, second, third]
  preferredOrder = preferredOrder.toUpperCase()

  // If first is a year, order will always be Year-Month-Day
  if (first > 31) {
    parts[0] = hasQuadDigit ? 'YYYY' : 'YY'
    parts[1] = hasSingleDigit ? 'M' : 'MM'
    parts[2] = hasSingleDigit ? 'D' : 'DD'
    return parts.join(separator)
  }

  // Second will never be the year. And if it is a day,
  // the order will always be Month-Day-Year
  if (second > 12) {
    parts[0] = hasSingleDigit ? 'M' : 'MM'
    parts[1] = hasSingleDigit ? 'D' : 'DD'
    parts[2] = hasQuadDigit ? 'YYYY' : 'YY'
    return parts.join(separator)
  }

  // if third is a year ...
  if (third > 31) {
    parts[2] = hasQuadDigit ? 'YYYY' : 'YY'

    // ... try to find day in first and second.
    // If found, the remaining part is the month.
    if (preferredOrder[0] === 'M' && first < 13) {
      parts[0] = hasSingleDigit ? 'M' : 'MM'
      parts[1] = hasSingleDigit ? 'D' : 'DD'
      return parts.join(separator)
    }
    parts[0] = hasSingleDigit ? 'D' : 'DD'
    parts[1] = hasSingleDigit ? 'M' : 'MM'
    return parts.join(separator)
  }

  // if we had no luck until here, we use the preferred order
  parts[preferredOrder.indexOf('D')] = hasSingleDigit ? 'D' : 'DD'
  parts[preferredOrder.indexOf('M')] = hasSingleDigit ? 'M' : 'MM'
  parts[preferredOrder.indexOf('Y')] = hasQuadDigit ? 'YYYY' : 'YY'

  return parts.join(separator)
}

},{}]},{},[1])(1)
});;

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */
!function(e){"use strict";var x={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:f,hr:/^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,heading:/^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,nptable:f,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,html:"^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?\\?>\\n*|<![A-Z][\\s\\S]*?>\\n*|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))",def:/^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,table:f,lheading:/^([^\n]+)\n {0,3}(=|-){2,} *(?:\n+|$)/,paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,text:/^[^\n]+/};function a(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||b.defaults,this.rules=x.normal,this.options.pedantic?this.rules=x.pedantic:this.options.gfm&&(this.options.tables?this.rules=x.tables:this.rules=x.gfm)}x._label=/(?!\s*\])(?:\\[\[\]]|[^\[\]])+/,x._title=/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/,x.def=i(x.def).replace("label",x._label).replace("title",x._title).getRegex(),x.bullet=/(?:[*+-]|\d{1,9}\.)/,x.item=/^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/,x.item=i(x.item,"gm").replace(/bull/g,x.bullet).getRegex(),x.list=i(x.list).replace(/bull/g,x.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+x.def.source+")").getRegex(),x._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",x._comment=/<!--(?!-?>)[\s\S]*?-->/,x.html=i(x.html,"i").replace("comment",x._comment).replace("tag",x._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),x.paragraph=i(x.paragraph).replace("hr",x.hr).replace("heading",x.heading).replace("lheading",x.lheading).replace("tag",x._tag).getRegex(),x.blockquote=i(x.blockquote).replace("paragraph",x.paragraph).getRegex(),x.normal=d({},x),x.gfm=d({},x.normal,{fences:/^ {0,3}(`{3,}|~{3,})([^`\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,paragraph:/^/,heading:/^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/}),x.gfm.paragraph=i(x.paragraph).replace("(?!","(?!"+x.gfm.fences.source.replace("\\1","\\2")+"|"+x.list.source.replace("\\1","\\3")+"|").getRegex(),x.tables=d({},x.gfm,{nptable:/^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,table:/^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/}),x.pedantic=d({},x.normal,{html:i("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",x._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/}),a.rules=x,a.lex=function(e,t){return new a(t).lex(e)},a.prototype.lex=function(e){return e=e.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g,"\n"),this.token(e,!0)},a.prototype.token=function(e,t){var n,r,s,i,l,o,a,h,p,u,c,g,f,d,m,b;for(e=e.replace(/^ +$/gm,"");e;)if((s=this.rules.newline.exec(e))&&(e=e.substring(s[0].length),1<s[0].length&&this.tokens.push({type:"space"})),s=this.rules.code.exec(e)){var k=this.tokens[this.tokens.length-1];e=e.substring(s[0].length),k&&"paragraph"===k.type?k.text+="\n"+s[0].trimRight():(s=s[0].replace(/^ {4}/gm,""),this.tokens.push({type:"code",codeBlockStyle:"indented",text:this.options.pedantic?s:_(s,"\n")}))}else if(s=this.rules.fences.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"code",lang:s[2]?s[2].trim():s[2],text:s[3]||""});else if(s=this.rules.heading.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"heading",depth:s[1].length,text:s[2]});else if((s=this.rules.nptable.exec(e))&&(o={type:"table",header:y(s[1].replace(/^ *| *\| *$/g,"")),align:s[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:s[3]?s[3].replace(/\n$/,"").split("\n"):[]}).header.length===o.align.length){for(e=e.substring(s[0].length),c=0;c<o.align.length;c++)/^ *-+: *$/.test(o.align[c])?o.align[c]="right":/^ *:-+: *$/.test(o.align[c])?o.align[c]="center":/^ *:-+ *$/.test(o.align[c])?o.align[c]="left":o.align[c]=null;for(c=0;c<o.cells.length;c++)o.cells[c]=y(o.cells[c],o.header.length);this.tokens.push(o)}else if(s=this.rules.hr.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"hr"});else if(s=this.rules.blockquote.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"blockquote_start"}),s=s[0].replace(/^ *> ?/gm,""),this.token(s,t),this.tokens.push({type:"blockquote_end"});else if(s=this.rules.list.exec(e)){for(e=e.substring(s[0].length),a={type:"list_start",ordered:d=1<(i=s[2]).length,start:d?+i:"",loose:!1},this.tokens.push(a),n=!(h=[]),f=(s=s[0].match(this.rules.item)).length,c=0;c<f;c++)u=(o=s[c]).length,~(o=o.replace(/^ *([*+-]|\d+\.) */,"")).indexOf("\n ")&&(u-=o.length,o=this.options.pedantic?o.replace(/^ {1,4}/gm,""):o.replace(new RegExp("^ {1,"+u+"}","gm"),"")),c!==f-1&&(l=x.bullet.exec(s[c+1])[0],(1<i.length?1===l.length:1<l.length||this.options.smartLists&&l!==i)&&(e=s.slice(c+1).join("\n")+e,c=f-1)),r=n||/\n\n(?!\s*$)/.test(o),c!==f-1&&(n="\n"===o.charAt(o.length-1),r||(r=n)),r&&(a.loose=!0),b=void 0,(m=/^\[[ xX]\] /.test(o))&&(b=" "!==o[1],o=o.replace(/^\[[ xX]\] +/,"")),p={type:"list_item_start",task:m,checked:b,loose:r},h.push(p),this.tokens.push(p),this.token(o,!1),this.tokens.push({type:"list_item_end"});if(a.loose)for(f=h.length,c=0;c<f;c++)h[c].loose=!0;this.tokens.push({type:"list_end"})}else if(s=this.rules.html.exec(e))e=e.substring(s[0].length),this.tokens.push({type:this.options.sanitize?"paragraph":"html",pre:!this.options.sanitizer&&("pre"===s[1]||"script"===s[1]||"style"===s[1]),text:s[0]});else if(t&&(s=this.rules.def.exec(e)))e=e.substring(s[0].length),s[3]&&(s[3]=s[3].substring(1,s[3].length-1)),g=s[1].toLowerCase().replace(/\s+/g," "),this.tokens.links[g]||(this.tokens.links[g]={href:s[2],title:s[3]});else if((s=this.rules.table.exec(e))&&(o={type:"table",header:y(s[1].replace(/^ *| *\| *$/g,"")),align:s[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:s[3]?s[3].replace(/\n$/,"").split("\n"):[]}).header.length===o.align.length){for(e=e.substring(s[0].length),c=0;c<o.align.length;c++)/^ *-+: *$/.test(o.align[c])?o.align[c]="right":/^ *:-+: *$/.test(o.align[c])?o.align[c]="center":/^ *:-+ *$/.test(o.align[c])?o.align[c]="left":o.align[c]=null;for(c=0;c<o.cells.length;c++)o.cells[c]=y(o.cells[c].replace(/^ *\| *| *\| *$/g,""),o.header.length);this.tokens.push(o)}else if(s=this.rules.lheading.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"heading",depth:"="===s[2]?1:2,text:s[1]});else if(t&&(s=this.rules.paragraph.exec(e)))e=e.substring(s[0].length),this.tokens.push({type:"paragraph",text:"\n"===s[1].charAt(s[1].length-1)?s[1].slice(0,-1):s[1]});else if(s=this.rules.text.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"text",text:s[0]});else if(e)throw new Error("Infinite loop on byte: "+e.charCodeAt(0));return this.tokens};var n={escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:f,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,nolink:/^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,strong:/^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,em:/^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:f,text:/^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/};function p(e,t){if(this.options=t||b.defaults,this.links=e,this.rules=n.normal,this.renderer=this.options.renderer||new r,this.renderer.options=this.options,!this.links)throw new Error("Tokens array requires a `links` property.");this.options.pedantic?this.rules=n.pedantic:this.options.gfm&&(this.options.breaks?this.rules=n.breaks:this.rules=n.gfm)}function r(e){this.options=e||b.defaults}function s(){}function h(e){this.tokens=[],this.token=null,this.options=e||b.defaults,this.options.renderer=this.options.renderer||new r,this.renderer=this.options.renderer,this.renderer.options=this.options,this.slugger=new t}function t(){this.seen={}}function u(e,t){if(t){if(u.escapeTest.test(e))return e.replace(u.escapeReplace,function(e){return u.replacements[e]})}else if(u.escapeTestNoEncode.test(e))return e.replace(u.escapeReplaceNoEncode,function(e){return u.replacements[e]});return e}function c(e){return e.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,function(e,t){return"colon"===(t=t.toLowerCase())?":":"#"===t.charAt(0)?"x"===t.charAt(1)?String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring(1)):""})}function i(n,e){return n=n.source||n,e=e||"",{replace:function(e,t){return t=(t=t.source||t).replace(/(^|[^\[])\^/g,"$1"),n=n.replace(e,t),this},getRegex:function(){return new RegExp(n,e)}}}function l(e,t,n){if(e){try{var r=decodeURIComponent(c(n)).replace(/[^\w:]/g,"").toLowerCase()}catch(e){return null}if(0===r.indexOf("javascript:")||0===r.indexOf("vbscript:")||0===r.indexOf("data:"))return null}t&&!g.test(n)&&(n=function(e,t){o[" "+e]||(/^[^:]+:\/*[^/]*$/.test(e)?o[" "+e]=e+"/":o[" "+e]=_(e,"/",!0));return e=o[" "+e],"//"===t.slice(0,2)?e.replace(/:[\s\S]*/,":")+t:"/"===t.charAt(0)?e.replace(/(:\/*[^/]*)[\s\S]*/,"$1")+t:e+t}(t,n));try{n=encodeURI(n).replace(/%25/g,"%")}catch(e){return null}return n}n._punctuation="!\"#$%&'()*+,\\-./:;<=>?@\\[^_{|}~",n.em=i(n.em).replace(/punctuation/g,n._punctuation).getRegex(),n._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,n._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,n._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,n.autolink=i(n.autolink).replace("scheme",n._scheme).replace("email",n._email).getRegex(),n._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,n.tag=i(n.tag).replace("comment",x._comment).replace("attribute",n._attribute).getRegex(),n._label=/(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|`(?!`)|[^\[\]\\`])*?/,n._href=/\s*(<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*)/,n._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,n.link=i(n.link).replace("label",n._label).replace("href",n._href).replace("title",n._title).getRegex(),n.reflink=i(n.reflink).replace("label",n._label).getRegex(),n.normal=d({},n),n.pedantic=d({},n.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,link:i(/^!?\[(label)\]\((.*?)\)/).replace("label",n._label).getRegex(),reflink:i(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",n._label).getRegex()}),n.gfm=d({},n.normal,{escape:i(n.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,del:/^~+(?=\S)([\s\S]*?\S)~+/,text:/^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/}),n.gfm.url=i(n.gfm.url,"i").replace("email",n.gfm._extended_email).getRegex(),n.breaks=d({},n.gfm,{br:i(n.br).replace("{2,}","*").getRegex(),text:i(n.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()}),p.rules=n,p.output=function(e,t,n){return new p(t,n).output(e)},p.prototype.output=function(e){for(var t,n,r,s,i,l,o="";e;)if(i=this.rules.escape.exec(e))e=e.substring(i[0].length),o+=u(i[1]);else if(i=this.rules.tag.exec(e))!this.inLink&&/^<a /i.test(i[0])?this.inLink=!0:this.inLink&&/^<\/a>/i.test(i[0])&&(this.inLink=!1),!this.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(i[0])?this.inRawBlock=!0:this.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(i[0])&&(this.inRawBlock=!1),e=e.substring(i[0].length),o+=this.options.sanitize?this.options.sanitizer?this.options.sanitizer(i[0]):u(i[0]):i[0];else if(i=this.rules.link.exec(e)){var a=m(i[2],"()");if(-1<a){var h=i[0].length-(i[2].length-a)-(i[3]||"").length;i[2]=i[2].substring(0,a),i[0]=i[0].substring(0,h).trim(),i[3]=""}e=e.substring(i[0].length),this.inLink=!0,r=i[2],s=this.options.pedantic?(t=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r))?(r=t[1],t[3]):"":i[3]?i[3].slice(1,-1):"",r=r.trim().replace(/^<([\s\S]*)>$/,"$1"),o+=this.outputLink(i,{href:p.escapes(r),title:p.escapes(s)}),this.inLink=!1}else if((i=this.rules.reflink.exec(e))||(i=this.rules.nolink.exec(e))){if(e=e.substring(i[0].length),t=(i[2]||i[1]).replace(/\s+/g," "),!(t=this.links[t.toLowerCase()])||!t.href){o+=i[0].charAt(0),e=i[0].substring(1)+e;continue}this.inLink=!0,o+=this.outputLink(i,t),this.inLink=!1}else if(i=this.rules.strong.exec(e))e=e.substring(i[0].length),o+=this.renderer.strong(this.output(i[4]||i[3]||i[2]||i[1]));else if(i=this.rules.em.exec(e))e=e.substring(i[0].length),o+=this.renderer.em(this.output(i[6]||i[5]||i[4]||i[3]||i[2]||i[1]));else if(i=this.rules.code.exec(e))e=e.substring(i[0].length),o+=this.renderer.codespan(u(i[2].trim(),!0));else if(i=this.rules.br.exec(e))e=e.substring(i[0].length),o+=this.renderer.br();else if(i=this.rules.del.exec(e))e=e.substring(i[0].length),o+=this.renderer.del(this.output(i[1]));else if(i=this.rules.autolink.exec(e))e=e.substring(i[0].length),r="@"===i[2]?"mailto:"+(n=u(this.mangle(i[1]))):n=u(i[1]),o+=this.renderer.link(r,null,n);else if(this.inLink||!(i=this.rules.url.exec(e))){if(i=this.rules.text.exec(e))e=e.substring(i[0].length),this.inRawBlock?o+=this.renderer.text(i[0]):o+=this.renderer.text(u(this.smartypants(i[0])));else if(e)throw new Error("Infinite loop on byte: "+e.charCodeAt(0))}else{if("@"===i[2])r="mailto:"+(n=u(i[0]));else{for(;l=i[0],i[0]=this.rules._backpedal.exec(i[0])[0],l!==i[0];);n=u(i[0]),r="www."===i[1]?"http://"+n:n}e=e.substring(i[0].length),o+=this.renderer.link(r,null,n)}return o},p.escapes=function(e){return e?e.replace(p.rules._escapes,"$1"):e},p.prototype.outputLink=function(e,t){var n=t.href,r=t.title?u(t.title):null;return"!"!==e[0].charAt(0)?this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,u(e[1]))},p.prototype.smartypants=function(e){return this.options.smartypants?e.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…"):e},p.prototype.mangle=function(e){if(!this.options.mangle)return e;for(var t,n="",r=e.length,s=0;s<r;s++)t=e.charCodeAt(s),.5<Math.random()&&(t="x"+t.toString(16)),n+="&#"+t+";";return n},r.prototype.code=function(e,t,n){var r=(t||"").match(/\S*/)[0];if(this.options.highlight){var s=this.options.highlight(e,r);null!=s&&s!==e&&(n=!0,e=s)}return r?'<pre><code class="'+this.options.langPrefix+u(r,!0)+'">'+(n?e:u(e,!0))+"</code></pre>\n":"<pre><code>"+(n?e:u(e,!0))+"</code></pre>"},r.prototype.blockquote=function(e){return"<blockquote>\n"+e+"</blockquote>\n"},r.prototype.html=function(e){return e},r.prototype.heading=function(e,t,n,r){return this.options.headerIds?"<h"+t+' id="'+this.options.headerPrefix+r.slug(n)+'">'+e+"</h"+t+">\n":"<h"+t+">"+e+"</h"+t+">\n"},r.prototype.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},r.prototype.list=function(e,t,n){var r=t?"ol":"ul";return"<"+r+(t&&1!==n?' start="'+n+'"':"")+">\n"+e+"</"+r+">\n"},r.prototype.listitem=function(e){return"<li>"+e+"</li>\n"},r.prototype.checkbox=function(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},r.prototype.paragraph=function(e){return"<p>"+e+"</p>\n"},r.prototype.table=function(e,t){return t&&(t="<tbody>"+t+"</tbody>"),"<table>\n<thead>\n"+e+"</thead>\n"+t+"</table>\n"},r.prototype.tablerow=function(e){return"<tr>\n"+e+"</tr>\n"},r.prototype.tablecell=function(e,t){var n=t.header?"th":"td";return(t.align?"<"+n+' align="'+t.align+'">':"<"+n+">")+e+"</"+n+">\n"},r.prototype.strong=function(e){return"<strong>"+e+"</strong>"},r.prototype.em=function(e){return"<em>"+e+"</em>"},r.prototype.codespan=function(e){return"<code>"+e+"</code>"},r.prototype.br=function(){return this.options.xhtml?"<br/>":"<br>"},r.prototype.del=function(e){return"<del>"+e+"</del>"},r.prototype.link=function(e,t,n){if(null===(e=l(this.options.sanitize,this.options.baseUrl,e)))return n;var r='<a href="'+u(e)+'"';return t&&(r+=' title="'+t+'"'),r+=">"+n+"</a>"},r.prototype.image=function(e,t,n){if(null===(e=l(this.options.sanitize,this.options.baseUrl,e)))return n;var r='<img src="'+e+'" alt="'+n+'"';return t&&(r+=' title="'+t+'"'),r+=this.options.xhtml?"/>":">"},r.prototype.text=function(e){return e},s.prototype.strong=s.prototype.em=s.prototype.codespan=s.prototype.del=s.prototype.text=function(e){return e},s.prototype.link=s.prototype.image=function(e,t,n){return""+n},s.prototype.br=function(){return""},h.parse=function(e,t){return new h(t).parse(e)},h.prototype.parse=function(e){this.inline=new p(e.links,this.options),this.inlineText=new p(e.links,d({},this.options,{renderer:new s})),this.tokens=e.reverse();for(var t="";this.next();)t+=this.tok();return t},h.prototype.next=function(){return this.token=this.tokens.pop(),this.token},h.prototype.peek=function(){return this.tokens[this.tokens.length-1]||0},h.prototype.parseText=function(){for(var e=this.token.text;"text"===this.peek().type;)e+="\n"+this.next().text;return this.inline.output(e)},h.prototype.tok=function(){switch(this.token.type){case"space":return"";case"hr":return this.renderer.hr();case"heading":return this.renderer.heading(this.inline.output(this.token.text),this.token.depth,c(this.inlineText.output(this.token.text)),this.slugger);case"code":return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case"table":var e,t,n,r,s="",i="";for(n="",e=0;e<this.token.header.length;e++)n+=this.renderer.tablecell(this.inline.output(this.token.header[e]),{header:!0,align:this.token.align[e]});for(s+=this.renderer.tablerow(n),e=0;e<this.token.cells.length;e++){for(t=this.token.cells[e],n="",r=0;r<t.length;r++)n+=this.renderer.tablecell(this.inline.output(t[r]),{header:!1,align:this.token.align[r]});i+=this.renderer.tablerow(n)}return this.renderer.table(s,i);case"blockquote_start":for(i="";"blockquote_end"!==this.next().type;)i+=this.tok();return this.renderer.blockquote(i);case"list_start":i="";for(var l=this.token.ordered,o=this.token.start;"list_end"!==this.next().type;)i+=this.tok();return this.renderer.list(i,l,o);case"list_item_start":i="";var a=this.token.loose,h=this.token.checked,p=this.token.task;for(this.token.task&&(i+=this.renderer.checkbox(h));"list_item_end"!==this.next().type;)i+=a||"text"!==this.token.type?this.tok():this.parseText();return this.renderer.listitem(i,p,h);case"html":return this.renderer.html(this.token.text);case"paragraph":return this.renderer.paragraph(this.inline.output(this.token.text));case"text":return this.renderer.paragraph(this.parseText());default:var u='Token with "'+this.token.type+'" type was not found.';if(!this.options.silent)throw new Error(u);console.log(u)}},t.prototype.slug=function(e){var t=e.toLowerCase().trim().replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-");if(this.seen.hasOwnProperty(t))for(var n=t;this.seen[n]++,t=n+"-"+this.seen[n],this.seen.hasOwnProperty(t););return this.seen[t]=0,t},u.escapeTest=/[&<>"']/,u.escapeReplace=/[&<>"']/g,u.replacements={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},u.escapeTestNoEncode=/[<>"']|&(?!#?\w+;)/,u.escapeReplaceNoEncode=/[<>"']|&(?!#?\w+;)/g;var o={},g=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;function f(){}function d(e){for(var t,n,r=1;r<arguments.length;r++)for(n in t=arguments[r])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}function y(e,t){var n=e.replace(/\|/g,function(e,t,n){for(var r=!1,s=t;0<=--s&&"\\"===n[s];)r=!r;return r?"|":" |"}).split(/ \|/),r=0;if(n.length>t)n.splice(t);else for(;n.length<t;)n.push("");for(;r<n.length;r++)n[r]=n[r].trim().replace(/\\\|/g,"|");return n}function _(e,t,n){if(0===e.length)return"";for(var r=0;r<e.length;){var s=e.charAt(e.length-r-1);if(s!==t||n){if(s===t||!n)break;r++}else r++}return e.substr(0,e.length-r)}function m(e,t){if(-1===e.indexOf(t[1]))return-1;for(var n=0,r=0;r<e.length;r++)if("\\"===e[r])r++;else if(e[r]===t[0])n++;else if(e[r]===t[1]&&--n<0)return r;return-1}function b(e,n,r){if(null==e)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");if(r||"function"==typeof n){r||(r=n,n=null);var s,i,l=(n=d({},b.defaults,n||{})).highlight,t=0;try{s=a.lex(e,n)}catch(e){return r(e)}i=s.length;var o=function(t){if(t)return n.highlight=l,r(t);var e;try{e=h.parse(s,n)}catch(e){t=e}return n.highlight=l,t?r(t):r(null,e)};if(!l||l.length<3)return o();if(delete n.highlight,!i)return o();for(;t<s.length;t++)!function(n){"code"!==n.type?--i||o():l(n.text,n.lang,function(e,t){return e?o(e):null==t||t===n.text?--i||o():(n.text=t,n.escaped=!0,void(--i||o()))})}(s[t])}else try{return n&&(n=d({},b.defaults,n)),h.parse(a.lex(e,n),n)}catch(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",(n||b.defaults).silent)return"<p>An error occurred:</p><pre>"+u(e.message+"",!0)+"</pre>";throw e}}f.exec=f,b.options=b.setOptions=function(e){return d(b.defaults,e),b},b.getDefaults=function(){return{baseUrl:null,breaks:!1,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:new r,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tables:!0,xhtml:!1}},b.defaults=b.getDefaults(),b.Parser=h,b.parser=h.parse,b.Renderer=r,b.TextRenderer=s,b.Lexer=a,b.lexer=a.lex,b.InlineLexer=p,b.inlineLexer=p.output,b.Slugger=t,b.parse=b,"undefined"!=typeof module&&"object"==typeof exports?module.exports=b:"function"==typeof define&&define.amd?define(function(){return b}):e.marked=b}(this||("undefined"!=typeof window?window:global));;

/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */
!function(a,b){"function"==typeof define&&define.amd?define(b):"object"==typeof module&&module.exports?module.exports=b():a.numeral=b()}(this,function(){function a(a,b){this._input=a,this._value=b}var b,c,d="2.0.6",e={},f={},g={currentLocale:"en",zeroFormat:null,nullFormat:null,defaultFormat:"0,0",scalePercentBy100:!0},h={currentLocale:g.currentLocale,zeroFormat:g.zeroFormat,nullFormat:g.nullFormat,defaultFormat:g.defaultFormat,scalePercentBy100:g.scalePercentBy100};return b=function(d){var f,g,i,j;if(b.isNumeral(d))f=d.value();else if(0===d||"undefined"==typeof d)f=0;else if(null===d||c.isNaN(d))f=null;else if("string"==typeof d)if(h.zeroFormat&&d===h.zeroFormat)f=0;else if(h.nullFormat&&d===h.nullFormat||!d.replace(/[^0-9]+/g,"").length)f=null;else{for(g in e)if(j="function"==typeof e[g].regexps.unformat?e[g].regexps.unformat():e[g].regexps.unformat,j&&d.match(j)){i=e[g].unformat;break}i=i||b._.stringToNumber,f=i(d)}else f=Number(d)||null;return new a(d,f)},b.version=d,b.isNumeral=function(b){return b instanceof a},b._=c={numberToFormat:function(a,c,d){var e,g,h,i,j,k,l,m=f[b.options.currentLocale],n=!1,o=!1,p=0,q="",r=1e12,s=1e9,t=1e6,u=1e3,v="",w=!1;if(a=a||0,g=Math.abs(a),b._.includes(c,"(")?(n=!0,c=c.replace(/[\(|\)]/g,"")):(b._.includes(c,"+")||b._.includes(c,"-"))&&(j=b._.includes(c,"+")?c.indexOf("+"):0>a?c.indexOf("-"):-1,c=c.replace(/[\+|\-]/g,"")),b._.includes(c,"a")&&(e=c.match(/a(k|m|b|t)?/),e=e?e[1]:!1,b._.includes(c," a")&&(q=" "),c=c.replace(new RegExp(q+"a[kmbt]?"),""),g>=r&&!e||"t"===e?(q+=m.abbreviations.trillion,a/=r):r>g&&g>=s&&!e||"b"===e?(q+=m.abbreviations.billion,a/=s):s>g&&g>=t&&!e||"m"===e?(q+=m.abbreviations.million,a/=t):(t>g&&g>=u&&!e||"k"===e)&&(q+=m.abbreviations.thousand,a/=u)),b._.includes(c,"[.]")&&(o=!0,c=c.replace("[.]",".")),h=a.toString().split(".")[0],i=c.split(".")[1],k=c.indexOf(","),p=(c.split(".")[0].split(",")[0].match(/0/g)||[]).length,i?(b._.includes(i,"[")?(i=i.replace("]",""),i=i.split("["),v=b._.toFixed(a,i[0].length+i[1].length,d,i[1].length)):v=b._.toFixed(a,i.length,d),h=v.split(".")[0],v=b._.includes(v,".")?m.delimiters.decimal+v.split(".")[1]:"",o&&0===Number(v.slice(1))&&(v="")):h=b._.toFixed(a,0,d),q&&!e&&Number(h)>=1e3&&q!==m.abbreviations.trillion)switch(h=String(Number(h)/1e3),q){case m.abbreviations.thousand:q=m.abbreviations.million;break;case m.abbreviations.million:q=m.abbreviations.billion;break;case m.abbreviations.billion:q=m.abbreviations.trillion}if(b._.includes(h,"-")&&(h=h.slice(1),w=!0),h.length<p)for(var x=p-h.length;x>0;x--)h="0"+h;return k>-1&&(h=h.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g,"$1"+m.delimiters.thousands)),0===c.indexOf(".")&&(h=""),l=h+v+(q?q:""),n?l=(n&&w?"(":"")+l+(n&&w?")":""):j>=0?l=0===j?(w?"-":"+")+l:l+(w?"-":"+"):w&&(l="-"+l),l},stringToNumber:function(a){var b,c,d,e=f[h.currentLocale],g=a,i={thousand:3,million:6,billion:9,trillion:12};if(h.zeroFormat&&a===h.zeroFormat)c=0;else if(h.nullFormat&&a===h.nullFormat||!a.replace(/[^0-9]+/g,"").length)c=null;else{c=1,"."!==e.delimiters.decimal&&(a=a.replace(/\./g,"").replace(e.delimiters.decimal,"."));for(b in i)if(d=new RegExp("[^a-zA-Z]"+e.abbreviations[b]+"(?:\\)|(\\"+e.currency.symbol+")?(?:\\))?)?$"),g.match(d)){c*=Math.pow(10,i[b]);break}c*=(a.split("-").length+Math.min(a.split("(").length-1,a.split(")").length-1))%2?1:-1,a=a.replace(/[^0-9\.]+/g,""),c*=Number(a)}return c},isNaN:function(a){return"number"==typeof a&&isNaN(a)},includes:function(a,b){return-1!==a.indexOf(b)},insert:function(a,b,c){return a.slice(0,c)+b+a.slice(c)},reduce:function(a,b){if(null===this)throw new TypeError("Array.prototype.reduce called on null or undefined");if("function"!=typeof b)throw new TypeError(b+" is not a function");var c,d=Object(a),e=d.length>>>0,f=0;if(3===arguments.length)c=arguments[2];else{for(;e>f&&!(f in d);)f++;if(f>=e)throw new TypeError("Reduce of empty array with no initial value");c=d[f++]}for(;e>f;f++)f in d&&(c=b(c,d[f],f,d));return c},multiplier:function(a){var b=a.toString().split(".");return b.length<2?1:Math.pow(10,b[1].length)},correctionFactor:function(){var a=Array.prototype.slice.call(arguments);return a.reduce(function(a,b){var d=c.multiplier(b);return a>d?a:d},1)},toFixed:function(a,b,c,d){var e,f,g,h,i=a.toString().split("."),j=b-(d||0);return e=2===i.length?Math.min(Math.max(i[1].length,j),b):j,g=Math.pow(10,e),h=(c(a+"e+"+e)/g).toFixed(e),d>b-e&&(f=new RegExp("\\.?0{1,"+(d-(b-e))+"}$"),h=h.replace(f,"")),h}},b.options=h,b.formats=e,b.locales=f,b.locale=function(a){return a&&(h.currentLocale=a.toLowerCase()),h.currentLocale},b.localeData=function(a){if(!a)return f[h.currentLocale];if(a=a.toLowerCase(),!f[a])throw new Error("Unknown locale : "+a);return f[a]},b.reset=function(){for(var a in g)h[a]=g[a]},b.zeroFormat=function(a){h.zeroFormat="string"==typeof a?a:null},b.nullFormat=function(a){h.nullFormat="string"==typeof a?a:null},b.defaultFormat=function(a){h.defaultFormat="string"==typeof a?a:"0.0"},b.register=function(a,b,c){if(b=b.toLowerCase(),this[a+"s"][b])throw new TypeError(b+" "+a+" already registered.");return this[a+"s"][b]=c,c},b.validate=function(a,c){var d,e,f,g,h,i,j,k;if("string"!=typeof a&&(a+="",console.warn&&console.warn("Numeral.js: Value is not string. It has been co-erced to: ",a)),a=a.trim(),a.match(/^\d+$/))return!0;if(""===a)return!1;try{j=b.localeData(c)}catch(l){j=b.localeData(b.locale())}return f=j.currency.symbol,h=j.abbreviations,d=j.delimiters.decimal,e="."===j.delimiters.thousands?"\\.":j.delimiters.thousands,k=a.match(/^[^\d]+/),null!==k&&(a=a.substr(1),k[0]!==f)?!1:(k=a.match(/[^\d]+$/),null!==k&&(a=a.slice(0,-1),k[0]!==h.thousand&&k[0]!==h.million&&k[0]!==h.billion&&k[0]!==h.trillion)?!1:(i=new RegExp(e+"{2}"),a.match(/[^\d.,]/g)?!1:(g=a.split(d),g.length>2?!1:g.length<2?!!g[0].match(/^\d+.*\d$/)&&!g[0].match(i):1===g[0].length?!!g[0].match(/^\d+$/)&&!g[0].match(i)&&!!g[1].match(/^\d+$/):!!g[0].match(/^\d+.*\d$/)&&!g[0].match(i)&&!!g[1].match(/^\d+$/))))},b.fn=a.prototype={clone:function(){return b(this)},format:function(a,c){var d,f,g,i=this._value,j=a||h.defaultFormat;if(c=c||Math.round,0===i&&null!==h.zeroFormat)f=h.zeroFormat;else if(null===i&&null!==h.nullFormat)f=h.nullFormat;else{for(d in e)if(j.match(e[d].regexps.format)){g=e[d].format;break}g=g||b._.numberToFormat,f=g(i,j,c)}return f},value:function(){return this._value},input:function(){return this._input},set:function(a){return this._value=Number(a),this},add:function(a){function b(a,b,c,e){return a+Math.round(d*b)}var d=c.correctionFactor.call(null,this._value,a);return this._value=c.reduce([this._value,a],b,0)/d,this},subtract:function(a){function b(a,b,c,e){return a-Math.round(d*b)}var d=c.correctionFactor.call(null,this._value,a);return this._value=c.reduce([a],b,Math.round(this._value*d))/d,this},multiply:function(a){function b(a,b,d,e){var f=c.correctionFactor(a,b);return Math.round(a*f)*Math.round(b*f)/Math.round(f*f)}return this._value=c.reduce([this._value,a],b,1),this},divide:function(a){function b(a,b,d,e){var f=c.correctionFactor(a,b);return Math.round(a*f)/Math.round(b*f)}return this._value=c.reduce([this._value,a],b),this},difference:function(a){return Math.abs(b(this._value).subtract(a).value())}},b.register("locale","en",{delimiters:{thousands:",",decimal:"."},abbreviations:{thousand:"k",million:"m",billion:"b",trillion:"t"},ordinal:function(a){var b=a%10;return 1===~~(a%100/10)?"th":1===b?"st":2===b?"nd":3===b?"rd":"th"},currency:{symbol:"$"}}),function(){b.register("format","bps",{regexps:{format:/(BPS)/,unformat:/(BPS)/},format:function(a,c,d){var e,f=b._.includes(c," BPS")?" ":"";return a=1e4*a,c=c.replace(/\s?BPS/,""),e=b._.numberToFormat(a,c,d),b._.includes(e,")")?(e=e.split(""),e.splice(-1,0,f+"BPS"),e=e.join("")):e=e+f+"BPS",e},unformat:function(a){return+(1e-4*b._.stringToNumber(a)).toFixed(15)}})}(),function(){var a={base:1e3,suffixes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]},c={base:1024,suffixes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"]},d=a.suffixes.concat(c.suffixes.filter(function(b){return a.suffixes.indexOf(b)<0})),e=d.join("|");e="("+e.replace("B","B(?!PS)")+")",b.register("format","bytes",{regexps:{format:/([0\s]i?b)/,unformat:new RegExp(e)},format:function(d,e,f){var g,h,i,j,k=b._.includes(e,"ib")?c:a,l=b._.includes(e," b")||b._.includes(e," ib")?" ":"";for(e=e.replace(/\s?i?b/,""),h=0;h<=k.suffixes.length;h++)if(i=Math.pow(k.base,h),j=Math.pow(k.base,h+1),null===d||0===d||d>=i&&j>d){l+=k.suffixes[h],i>0&&(d/=i);break}return g=b._.numberToFormat(d,e,f),g+l},unformat:function(d){var e,f,g=b._.stringToNumber(d);if(g){for(e=a.suffixes.length-1;e>=0;e--){if(b._.includes(d,a.suffixes[e])){f=Math.pow(a.base,e);break}if(b._.includes(d,c.suffixes[e])){f=Math.pow(c.base,e);break}}g*=f||1}return g}})}(),function(){b.register("format","currency",{regexps:{format:/(\$)/},format:function(a,c,d){var e,f,g,h=b.locales[b.options.currentLocale],i={before:c.match(/^([\+|\-|\(|\s|\$]*)/)[0],after:c.match(/([\+|\-|\)|\s|\$]*)$/)[0]};for(c=c.replace(/\s?\$\s?/,""),e=b._.numberToFormat(a,c,d),a>=0?(i.before=i.before.replace(/[\-\(]/,""),i.after=i.after.replace(/[\-\)]/,"")):0>a&&!b._.includes(i.before,"-")&&!b._.includes(i.before,"(")&&(i.before="-"+i.before),g=0;g<i.before.length;g++)switch(f=i.before[g]){case"$":e=b._.insert(e,h.currency.symbol,g);break;case" ":e=b._.insert(e," ",g+h.currency.symbol.length-1)}for(g=i.after.length-1;g>=0;g--)switch(f=i.after[g]){case"$":e=g===i.after.length-1?e+h.currency.symbol:b._.insert(e,h.currency.symbol,-(i.after.length-(1+g)));break;case" ":e=g===i.after.length-1?e+" ":b._.insert(e," ",-(i.after.length-(1+g)+h.currency.symbol.length-1))}return e}})}(),function(){b.register("format","exponential",{regexps:{format:/(e\+|e-)/,unformat:/(e\+|e-)/},format:function(a,c,d){var e,f="number"!=typeof a||b._.isNaN(a)?"0e+0":a.toExponential(),g=f.split("e");return c=c.replace(/e[\+|\-]{1}0/,""),e=b._.numberToFormat(Number(g[0]),c,d),e+"e"+g[1]},unformat:function(a){function c(a,c,d,e){var f=b._.correctionFactor(a,c),g=a*f*(c*f)/(f*f);return g}var d=b._.includes(a,"e+")?a.split("e+"):a.split("e-"),e=Number(d[0]),f=Number(d[1]);return f=b._.includes(a,"e-")?f*=-1:f,b._.reduce([e,Math.pow(10,f)],c,1)}})}(),function(){b.register("format","ordinal",{regexps:{format:/(o)/},format:function(a,c,d){var e,f=b.locales[b.options.currentLocale],g=b._.includes(c," o")?" ":"";return c=c.replace(/\s?o/,""),g+=f.ordinal(a),e=b._.numberToFormat(a,c,d),e+g}})}(),function(){b.register("format","percentage",{regexps:{format:/(%)/,unformat:/(%)/},format:function(a,c,d){var e,f=b._.includes(c," %")?" ":"";return b.options.scalePercentBy100&&(a=100*a),c=c.replace(/\s?\%/,""),e=b._.numberToFormat(a,c,d),b._.includes(e,")")?(e=e.split(""),e.splice(-1,0,f+"%"),e=e.join("")):e=e+f+"%",e},unformat:function(a){var c=b._.stringToNumber(a);return b.options.scalePercentBy100?.01*c:c}})}(),function(){b.register("format","time",{regexps:{format:/(:)/,unformat:/(:)/},format:function(a,b,c){var d=Math.floor(a/60/60),e=Math.floor((a-60*d*60)/60),f=Math.round(a-60*d*60-60*e);return d+":"+(10>e?"0"+e:e)+":"+(10>f?"0"+f:f)},unformat:function(a){var b=a.split(":"),c=0;return 3===b.length?(c+=60*Number(b[0])*60,c+=60*Number(b[1]),c+=Number(b[2])):2===b.length&&(c+=60*Number(b[0]),c+=Number(b[1])),Number(c)}})}(),b});;

// https://d3js.org/d3-format/ v1.4.1 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;

        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

exports.FormatSpecifier = FormatSpecifier;
exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

}));
;

/**
 * @license
 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 */
;(function(){function n(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function t(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function r(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function e(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););return n}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;
return true}function i(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function o(n,t){return!(null==n||!n.length)&&-1<v(n,t,0)}function f(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function c(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function a(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function l(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);
return r}function s(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function h(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function p(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function _(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function v(n,t,r){if(t===t)n:{--r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=_(n,d,r);return n}function g(n,t,r,e){
--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function d(n){return n!==n}function y(n,t){var r=null==n?0:n.length;return r?m(n,t)/r:F}function b(n){return function(t){return null==t?T:t[n]}}function x(n){return function(t){return null==n?T:n[t]}}function j(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function w(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;return n}function m(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==T&&(r=r===T?i:r+i)}return r;
}function A(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function E(n,t){return c(t,function(t){return[t,n[t]]})}function k(n){return function(t){return n(t)}}function S(n,t){return c(t,function(t){return n[t]})}function O(n,t){return n.has(t)}function I(n,t){for(var r=-1,e=n.length;++r<e&&-1<v(t,n[r],0););return r}function R(n,t){for(var r=n.length;r--&&-1<v(t,n[r],0););return r}function z(n){return"\\"+Un[n]}function W(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n];
}),r}function B(n,t){return function(r){return n(t(r))}}function L(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function U(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function C(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function D(n){if(Rn.test(n)){for(var t=On.lastIndex=0;On.test(n);)++t;n=t}else n=Qn(n);return n}function M(n){return Rn.test(n)?n.match(On)||[]:n.split("");
}var T,$=1/0,F=NaN,N=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],P=/\b__p\+='';/g,Z=/\b(__p\+=)''\+/g,q=/(__e\(.*?\)|\b__t\))\+'';/g,V=/&(?:amp|lt|gt|quot|#39);/g,K=/[&<>"']/g,G=RegExp(V.source),H=RegExp(K.source),J=/<%-([\s\S]+?)%>/g,Y=/<%([\s\S]+?)%>/g,Q=/<%=([\s\S]+?)%>/g,X=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,nn=/^\w*$/,tn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,rn=/[\\^$.*+?()[\]{}|]/g,en=RegExp(rn.source),un=/^\s+|\s+$/g,on=/^\s+/,fn=/\s+$/,cn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,an=/\{\n\/\* \[wrapped with (.+)\] \*/,ln=/,? & /,sn=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,hn=/\\(\\)?/g,pn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,_n=/\w*$/,vn=/^[-+]0x[0-9a-f]+$/i,gn=/^0b[01]+$/i,dn=/^\[object .+?Constructor\]$/,yn=/^0o[0-7]+$/i,bn=/^(?:0|[1-9]\d*)$/,xn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,jn=/($^)/,wn=/['\n\r\u2028\u2029\\]/g,mn="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",An="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+mn,En="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",kn=RegExp("['\u2019]","g"),Sn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),On=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+En+mn,"g"),In=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])|\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])|\\d+",An].join("|"),"g"),Rn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),zn=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Wn="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Bn={};
Bn["[object Float32Array]"]=Bn["[object Float64Array]"]=Bn["[object Int8Array]"]=Bn["[object Int16Array]"]=Bn["[object Int32Array]"]=Bn["[object Uint8Array]"]=Bn["[object Uint8ClampedArray]"]=Bn["[object Uint16Array]"]=Bn["[object Uint32Array]"]=true,Bn["[object Arguments]"]=Bn["[object Array]"]=Bn["[object ArrayBuffer]"]=Bn["[object Boolean]"]=Bn["[object DataView]"]=Bn["[object Date]"]=Bn["[object Error]"]=Bn["[object Function]"]=Bn["[object Map]"]=Bn["[object Number]"]=Bn["[object Object]"]=Bn["[object RegExp]"]=Bn["[object Set]"]=Bn["[object String]"]=Bn["[object WeakMap]"]=false;
var Ln={};Ln["[object Arguments]"]=Ln["[object Array]"]=Ln["[object ArrayBuffer]"]=Ln["[object DataView]"]=Ln["[object Boolean]"]=Ln["[object Date]"]=Ln["[object Float32Array]"]=Ln["[object Float64Array]"]=Ln["[object Int8Array]"]=Ln["[object Int16Array]"]=Ln["[object Int32Array]"]=Ln["[object Map]"]=Ln["[object Number]"]=Ln["[object Object]"]=Ln["[object RegExp]"]=Ln["[object Set]"]=Ln["[object String]"]=Ln["[object Symbol]"]=Ln["[object Uint8Array]"]=Ln["[object Uint8ClampedArray]"]=Ln["[object Uint16Array]"]=Ln["[object Uint32Array]"]=true,
Ln["[object Error]"]=Ln["[object Function]"]=Ln["[object WeakMap]"]=false;var Un={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Cn=parseFloat,Dn=parseInt,Mn=typeof global=="object"&&global&&global.Object===Object&&global,Tn=typeof self=="object"&&self&&self.Object===Object&&self,$n=Mn||Tn||Function("return this")(),Fn=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Nn=Fn&&typeof module=="object"&&module&&!module.nodeType&&module,Pn=Nn&&Nn.exports===Fn,Zn=Pn&&Mn.process,qn=function(){
try{var n=Nn&&Nn.f&&Nn.f("util").types;return n?n:Zn&&Zn.binding&&Zn.binding("util")}catch(n){}}(),Vn=qn&&qn.isArrayBuffer,Kn=qn&&qn.isDate,Gn=qn&&qn.isMap,Hn=qn&&qn.isRegExp,Jn=qn&&qn.isSet,Yn=qn&&qn.isTypedArray,Qn=b("length"),Xn=x({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I",
"\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C",
"\u0108":"C","\u010a":"C","\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i",
"\u012b":"i","\u012d":"i","\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r",
"\u015a":"S","\u015c":"S","\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij",
"\u0152":"Oe","\u0153":"oe","\u0149":"'n","\u017f":"s"}),nt=x({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),tt=x({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),rt=function x(mn){function An(n){if(yu(n)&&!ff(n)&&!(n instanceof Un)){if(n instanceof On)return n;if(oi.call(n,"__wrapped__"))return Fe(n)}return new On(n)}function En(){}function On(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=T}function Un(n){this.__wrapped__=n,
this.__actions__=[],this.__dir__=1,this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Mn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Fn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Fn;++t<r;)this.add(n[t]);
}function Zn(n){this.size=(this.__data__=new Tn(n)).size}function qn(n,t){var r,e=ff(n),u=!e&&of(n),i=!e&&!u&&af(n),o=!e&&!u&&!i&&_f(n),u=(e=e||u||i||o)?A(n.length,ni):[],f=u.length;for(r in n)!t&&!oi.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Se(r,f))||u.push(r);return u}function Qn(n){var t=n.length;return t?n[ir(0,t-1)]:T}function et(n,t){return De(Ur(n),pt(t,0,n.length))}function ut(n){return De(Ur(n))}function it(n,t,r){(r===T||lu(n[t],r))&&(r!==T||t in n)||st(n,t,r);
}function ot(n,t,r){var e=n[t];oi.call(n,t)&&lu(e,r)&&(r!==T||t in n)||st(n,t,r)}function ft(n,t){for(var r=n.length;r--;)if(lu(n[r][0],t))return r;return-1}function ct(n,t,r,e){return uo(n,function(n,u,i){t(e,n,r(n),i)}),e}function at(n,t){return n&&Cr(t,Wu(t),n)}function lt(n,t){return n&&Cr(t,Bu(t),n)}function st(n,t,r){"__proto__"==t&&Ai?Ai(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function ht(n,t){for(var r=-1,e=t.length,u=Ku(e),i=null==n;++r<e;)u[r]=i?T:Ru(n,t[r]);return u;
}function pt(n,t,r){return n===n&&(r!==T&&(n=n<=r?n:r),t!==T&&(n=n>=t?n:t)),n}function _t(n,t,e,u,i,o){var f,c=1&t,a=2&t,l=4&t;if(e&&(f=i?e(n,u,i,o):e(n)),f!==T)return f;if(!du(n))return n;if(u=ff(n)){if(f=me(n),!c)return Ur(n,f)}else{var s=vo(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(af(n))return Ir(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:Ae(n),!c)return a?Mr(n,lt(f,n)):Dr(n,at(f,n))}else{if(!Ln[s])return i?n:{};f=Ee(n,s,c)}}if(o||(o=new Zn),
i=o.get(n))return i;o.set(n,f),pf(n)?n.forEach(function(r){f.add(_t(r,t,e,r,n,o))}):sf(n)&&n.forEach(function(r,u){f.set(u,_t(r,t,e,u,n,o))});var a=l?a?ve:_e:a?Bu:Wu,p=u?T:a(n);return r(p||n,function(r,u){p&&(u=r,r=n[u]),ot(f,u,_t(r,t,e,u,n,o))}),f}function vt(n){var t=Wu(n);return function(r){return gt(r,n,t)}}function gt(n,t,r){var e=r.length;if(null==n)return!e;for(n=Qu(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===T&&!(u in n)||!i(o))return false}return true}function dt(n,t,r){if(typeof n!="function")throw new ti("Expected a function");
return bo(function(){n.apply(T,r)},t)}function yt(n,t,r,e){var u=-1,i=o,a=true,l=n.length,s=[],h=t.length;if(!l)return s;r&&(t=c(t,k(r))),e?(i=f,a=false):200<=t.length&&(i=O,a=false,t=new Nn(t));n:for(;++u<l;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(a&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function bt(n,t){var r=true;return uo(n,function(n,e,u){return r=!!t(n,e,u)}),r}function xt(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===T?o===o&&!wu(o):r(o,f)))var f=o,c=i;
}return c}function jt(n,t){var r=[];return uo(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function wt(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=ke),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?wt(f,t-1,r,e,u):a(u,f):e||(u[u.length]=f)}return u}function mt(n,t){return n&&oo(n,t,Wu)}function At(n,t){return n&&fo(n,t,Wu)}function Et(n,t){return i(t,function(t){return _u(n[t])})}function kt(n,t){t=Sr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[Me(t[r++])];return r&&r==e?n:T}function St(n,t,r){return t=t(n),
ff(n)?t:a(t,r(n))}function Ot(n){if(null==n)n=n===T?"[object Undefined]":"[object Null]";else if(mi&&mi in Qu(n)){var t=oi.call(n,mi),r=n[mi];try{n[mi]=T;var e=true}catch(n){}var u=ai.call(n);e&&(t?n[mi]=r:delete n[mi]),n=u}else n=ai.call(n);return n}function It(n,t){return n>t}function Rt(n,t){return null!=n&&oi.call(n,t)}function zt(n,t){return null!=n&&t in Qu(n)}function Wt(n,t,r){for(var e=r?f:o,u=n[0].length,i=n.length,a=i,l=Ku(i),s=1/0,h=[];a--;){var p=n[a];a&&t&&(p=c(p,k(t))),s=Ci(p.length,s),
l[a]=!r&&(t||120<=u&&120<=p.length)?new Nn(a&&p):T}var p=n[0],_=-1,v=l[0];n:for(;++_<u&&h.length<s;){var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;if(v?!O(v,d):!e(h,d,r)){for(a=i;--a;){var y=l[a];if(y?!O(y,d):!e(n[a],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Bt(n,t,r){var e={};return mt(n,function(n,u,i){t(e,r(n),u,i)}),e}function Lt(t,r,e){return r=Sr(r,t),t=2>r.length?t:kt(t,hr(r,0,-1)),r=null==t?t:t[Me(Ve(r))],null==r?T:n(r,t,e)}function Ut(n){return yu(n)&&"[object Arguments]"==Ot(n)}function Ct(n){
return yu(n)&&"[object ArrayBuffer]"==Ot(n)}function Dt(n){return yu(n)&&"[object Date]"==Ot(n)}function Mt(n,t,r,e,u){if(n===t)t=true;else if(null==n||null==t||!yu(n)&&!yu(t))t=n!==n&&t!==t;else n:{var i=ff(n),o=ff(t),f=i?"[object Array]":vo(n),c=o?"[object Array]":vo(t),f="[object Arguments]"==f?"[object Object]":f,c="[object Arguments]"==c?"[object Object]":c,a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&af(n)){if(!af(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Zn),t=i||_f(n)?se(n,t,r,e,Mt,u):he(n,t,f,r,e,Mt,u);else{
if(!(1&r)&&(i=a&&oi.call(n,"__wrapped__"),f=o&&oi.call(t,"__wrapped__"),i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Zn),t=Mt(n,t,r,e,u);break n}if(c)t:if(u||(u=new Zn),i=1&r,f=_e(n),o=f.length,c=_e(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:oi.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===T?h!==p&&!Mt(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l);
}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Tt(n){return yu(n)&&"[object Map]"==vo(n)}function $t(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=Qu(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===T&&!(c in n))return false;
}else{if(f=new Zn,e)var s=e(a,l,c,n,t,f);if(s===T?!Mt(l,a,3,e,f):!s)return false}}return true}function Ft(n){return!(!du(n)||ci&&ci in n)&&(_u(n)?hi:dn).test(Te(n))}function Nt(n){return yu(n)&&"[object RegExp]"==Ot(n)}function Pt(n){return yu(n)&&"[object Set]"==vo(n)}function Zt(n){return yu(n)&&gu(n.length)&&!!Bn[Ot(n)]}function qt(n){return typeof n=="function"?n:null==n?$u:typeof n=="object"?ff(n)?Jt(n[0],n[1]):Ht(n):Zu(n)}function Vt(n){if(!ze(n))return Li(n);var t,r=[];for(t in Qu(n))oi.call(n,t)&&"constructor"!=t&&r.push(t);
return r}function Kt(n,t){return n<t}function Gt(n,t){var r=-1,e=su(n)?Ku(n.length):[];return uo(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Ht(n){var t=xe(n);return 1==t.length&&t[0][2]?We(t[0][0],t[0][1]):function(r){return r===n||$t(r,n,t)}}function Jt(n,t){return Ie(n)&&t===t&&!du(t)?We(Me(n),t):function(r){var e=Ru(r,n);return e===T&&e===t?zu(r,n):Mt(t,e,3)}}function Yt(n,t,r,e,u){n!==t&&oo(t,function(i,o){if(u||(u=new Zn),du(i)){var f=u,c=Le(n,o),a=Le(t,o),l=f.get(a);if(l)it(n,o,l);else{
var l=e?e(c,a,o+"",n,t,f):T,s=l===T;if(s){var h=ff(a),p=!h&&af(a),_=!h&&!p&&_f(a),l=a;h||p||_?ff(c)?l=c:hu(c)?l=Ur(c):p?(s=false,l=Ir(a,true)):_?(s=false,l=zr(a,true)):l=[]:xu(a)||of(a)?(l=c,of(c)?l=Ou(c):du(c)&&!_u(c)||(l=Ae(a))):s=false}s&&(f.set(a,l),Yt(l,a,r,e,f),f.delete(a)),it(n,o,l)}}else f=e?e(Le(n,o),i,o+"",n,t,u):T,f===T&&(f=i),it(n,o,f)},Bu)}function Qt(n,t){var r=n.length;if(r)return t+=0>t?r:0,Se(t,r)?n[t]:T}function Xt(n,t,r){var e=-1;return t=c(t.length?t:[$u],k(ye())),n=Gt(n,function(n){return{
a:c(t,function(t){return t(n)}),b:++e,c:n}}),w(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Wr(u[e],i[e]);if(c){e=e>=f?c:c*("desc"==r[e]?-1:1);break n}}e=n.b-t.b}return e})}function nr(n,t){return tr(n,t,function(t,r){return zu(n,r)})}function tr(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=kt(n,o);r(f,o)&&lr(i,Sr(o,n),f)}return i}function rr(n){return function(t){return kt(t,n)}}function er(n,t,r,e){var u=e?g:v,i=-1,o=t.length,f=n;for(n===t&&(t=Ur(t)),
r&&(f=c(n,k(r)));++i<o;)for(var a=0,l=t[i],l=r?r(l):l;-1<(a=u(f,l,a,e));)f!==n&&xi.call(f,a,1),xi.call(n,a,1);return n}function ur(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];if(r==e||u!==i){var i=u;Se(u)?xi.call(n,u,1):xr(n,u)}}}function ir(n,t){return n+Ii(Ti()*(t-n+1))}function or(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=Ii(t/2))&&(n+=n);while(t);return r}function fr(n,t){return xo(Be(n,t,$u),n+"")}function cr(n){return Qn(Uu(n))}function ar(n,t){var r=Uu(n);
return De(r,pt(t,0,r.length))}function lr(n,t,r,e){if(!du(n))return n;t=Sr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=Me(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):T;a===T&&(a=du(l)?l:Se(t[u+1])?[]:{})}ot(f,c,a),f=f[c]}return n}function sr(n){return De(Uu(n))}function hr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Ku(u);++e<u;)r[e]=n[e+t];return r}function pr(n,t){var r;return uo(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}
function _r(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!wu(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return vr(n,t,$u,r)}function vr(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=wu(t),a=t===T;u<i;){var l=Ii((u+i)/2),s=r(n[l]),h=s!==T,p=null===s,_=s===s,v=wu(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Ci(i,4294967294)}function gr(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){
var o=n[r],f=t?t(o):o;if(!r||!lu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function dr(n){return typeof n=="number"?n:wu(n)?F:+n}function yr(n){if(typeof n=="string")return n;if(ff(n))return c(n,yr)+"";if(wu(n))return ro?ro.call(n):"";var t=n+"";return"0"==t&&1/n==-$?"-0":t}function br(n,t,r){var e=-1,u=o,i=n.length,c=true,a=[],l=a;if(r)c=false,u=f;else if(200<=i){if(u=t?null:so(n))return U(u);c=false,u=O,l=new Nn}else l=t?[]:a;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(c&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;
t&&l.push(h),a.push(s)}else u(l,h,r)||(l!==a&&l.push(h),a.push(s))}return a}function xr(n,t){return t=Sr(t,n),n=2>t.length?n:kt(n,hr(t,0,-1)),null==n||delete n[Me(Ve(t))]}function jr(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?hr(n,e?0:i,e?i+1:u):hr(n,e?i+1:0,e?u:i)}function wr(n,t){var r=n;return r instanceof Un&&(r=r.value()),l(t,function(n,t){return t.func.apply(t.thisArg,a([n],t.args))},r)}function mr(n,t,r){var e=n.length;if(2>e)return e?br(n[0]):[];for(var u=-1,i=Ku(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=yt(i[u]||o,n[f],t,r));
return br(wt(i,1),t,r)}function Ar(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:T);return o}function Er(n){return hu(n)?n:[]}function kr(n){return typeof n=="function"?n:$u}function Sr(n,t){return ff(n)?n:Ie(n,t)?[n]:jo(Iu(n))}function Or(n,t,r){var e=n.length;return r=r===T?e:r,!t&&r>=e?n:hr(n,t,r)}function Ir(n,t){if(t)return n.slice();var r=n.length,r=gi?gi(r):new n.constructor(r);return n.copy(r),r}function Rr(n){var t=new n.constructor(n.byteLength);return new vi(t).set(new vi(n)),
t}function zr(n,t){return new n.constructor(t?Rr(n.buffer):n.buffer,n.byteOffset,n.length)}function Wr(n,t){if(n!==t){var r=n!==T,e=null===n,u=n===n,i=wu(n),o=t!==T,f=null===t,c=t===t,a=wu(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Br(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Ui(i-o,0),l=Ku(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];
return l}function Lr(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Ui(i-f,0),s=Ku(l+a);for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Ur(n,t){var r=-1,e=n.length;for(t||(t=Ku(e));++r<e;)t[r]=n[r];return t}function Cr(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):T;c===T&&(c=n[f]),u?st(r,f,c):ot(r,f,c)}return r}function Dr(n,t){return Cr(n,po(n),t)}function Mr(n,t){return Cr(n,_o(n),t);
}function Tr(n,r){return function(e,u){var i=ff(e)?t:ct,o=r?r():{};return i(e,n,ye(u,2),o)}}function $r(n){return fr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:T,o=2<u?r[2]:T,i=3<n.length&&typeof i=="function"?(u--,i):T;for(o&&Oe(r[0],r[1],o)&&(i=3>u?T:i,u=1),t=Qu(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function Fr(n,t){return function(r,e){if(null==r)return r;if(!su(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=Qu(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function Nr(n){return function(t,r,e){
var u=-1,i=Qu(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break}return t}}function Pr(n,t,r){function e(){return(this&&this!==$n&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Vr(n);return e}function Zr(n){return function(t){t=Iu(t);var r=Rn.test(t)?M(t):T,e=r?r[0]:t.charAt(0);return t=r?Or(r,1).join(""):t.slice(1),e[n]()+t}}function qr(n){return function(t){return l(Mu(Du(t).replace(kn,"")),n,"")}}function Vr(n){return function(){var t=arguments;switch(t.length){
case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=eo(n.prototype),t=n.apply(r,t);return du(t)?t:r}}function Kr(t,r,e){function u(){for(var o=arguments.length,f=Ku(o),c=o,a=de(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:L(f,a),
o-=c.length,o<e?ue(t,r,Jr,u.placeholder,T,f,c,T,T,e-o):n(this&&this!==$n&&this instanceof u?i:t,this,f)}var i=Vr(t);return u}function Gr(n){return function(t,r,e){var u=Qu(t);if(!su(t)){var i=ye(r,3);t=Wu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:T}}function Hr(n){return pe(function(t){var r=t.length,e=r,u=On.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ti("Expected a function");if(u&&!o&&"wrapper"==ge(i))var o=new On([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=ge(i),f="wrapper"==u?ho(i):T,o=f&&Re(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[ge(f[0])].apply(o,f[3]):1==i.length&&Re(i)?o[u]():o.thru(i);
return function(){var n=arguments,e=n[0];if(o&&1==n.length&&ff(e))return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function Jr(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Ku(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=de(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Br(y,e,u,_)),i&&(y=Lr(y,i,o,_)),d-=x,_&&d<a)return j=L(y,j),ue(n,t,Jr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;for(var w=Ci(f.length,x),m=Ur(y);w--;){
var A=f[w];y[w]=Se(A,x)?m[A]:T}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==$n&&this instanceof l&&(b=g||Vr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?T:Vr(n);return l}function Yr(n,t){return function(r,e){return Bt(r,n,t(e))}}function Qr(n,t){return function(r,e){var u;if(r===T&&e===T)return t;if(r!==T&&(u=r),e!==T){if(u===T)return e;typeof r=="string"||typeof e=="string"?(r=yr(r),e=yr(e)):(r=dr(r),e=dr(e)),u=n(r,e)}return u}}function Xr(t){return pe(function(r){
return r=c(r,k(ye())),fr(function(e){var u=this;return t(r,function(t){return n(t,u,e)})})})}function ne(n,t){t=t===T?" ":yr(t);var r=t.length;return 2>r?r?or(t,n):t:(r=or(t,Oi(n/D(t))),Rn.test(t)?Or(M(r),0,n).join(""):r.slice(0,n))}function te(t,r,e,u){function i(){for(var r=-1,c=arguments.length,a=-1,l=u.length,s=Ku(l+c),h=this&&this!==$n&&this instanceof i?f:t;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++r];return n(h,o?e:this,s)}var o=1&r,f=Vr(t);return i}function re(n){return function(t,r,e){
e&&typeof e!="number"&&Oe(t,r,e)&&(r=e=T),t=Au(t),r===T?(r=t,t=0):r=Au(r),e=e===T?t<r?1:-1:Au(e);var u=-1;r=Ui(Oi((r-t)/(e||1)),0);for(var i=Ku(r);r--;)i[n?r:++u]=t,t+=e;return i}}function ee(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Su(t),r=Su(r)),n(t,r)}}function ue(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:T;o=l?T:o;var h=l?i:T;return i=l?T:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(T,u),Re(n)&&yo(r,u),r.placeholder=e,Ue(r,n,t)}function ie(n){
var t=Yu[n];return function(n,r){if(n=Su(n),(r=null==r?0:Ci(Eu(r),292))&&Wi(n)){var e=(Iu(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(Iu(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function oe(n){return function(t){var r=vo(t);return"[object Map]"==r?W(t):"[object Set]"==r?C(t):E(t,n(t))}}function fe(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ti("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=T),o=o===T?o:Ui(Eu(o),0),f=f===T?f:Eu(f),a-=u?u.length:0,
64&t){var l=e,s=u;e=u=T}var h=c?T:ho(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Br(e,r,h[4]):r,i[4]=e?L(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Lr(e,r,h[6]):r,i[6]=e?L(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Ci(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=t),n=i[0],
t=i[1],r=i[2],e=i[3],u=i[4],f=i[9]=i[9]===T?c?0:n.length:Ui(i[9]-a,0),!f&&24&t&&(t&=-25),Ue((h?co:yo)(t&&1!=t?8==t||16==t?Kr(n,t,f):32!=t&&33!=t||u.length?Jr.apply(T,i):te(n,t,r,e):Pr(n,t,r),i),n,t)}function ce(n,t,r,e){return n===T||lu(n,ei[r])&&!oi.call(e,r)?t:n}function ae(n,t,r,e,u,i){return du(n)&&du(t)&&(i.set(t,n),Yt(n,t,T,ae,i),i.delete(t)),n}function le(n){return xu(n)?T:n}function se(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;
var c=-1,a=true,l=2&r?new Nn:T;for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],p=t[c];if(e)var _=o?e(p,s,c,t,n,i):e(s,p,c,n,t,i);if(_!==T){if(_)continue;a=false;break}if(l){if(!h(t,function(n,t){if(!O(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==p&&!u(s,p,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function he(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":
if(n.byteLength!=t.byteLength||!i(new vi(n),new vi(t)))break;return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return lu(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=W;case"[object Set]":if(f||(f=U),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=se(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(to)return to.call(n)==to.call(t)}
return false}function pe(n){return xo(Be(n,T,Ze),n+"")}function _e(n){return St(n,Wu,po)}function ve(n){return St(n,Bu,_o)}function ge(n){for(var t=n.name+"",r=Gi[t],e=oi.call(Gi,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function de(n){return(oi.call(An,"placeholder")?An:n).placeholder}function ye(){var n=An.iteratee||Fu,n=n===Fu?qt:n;return arguments.length?n(arguments[0],arguments[1]):n}function be(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map;
}function xe(n){for(var t=Wu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!du(u)]}return t}function je(n,t){var r=null==n?T:n[t];return Ft(r)?r:T}function we(n,t,r){t=Sr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=Me(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&gu(u)&&Se(o,u)&&(ff(n)||of(n)))}function me(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&oi.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ae(n){
return typeof n.constructor!="function"||ze(n)?{}:eo(di(n))}function Ee(n,t,r){var e=n.constructor;switch(t){case"[object ArrayBuffer]":return Rr(n);case"[object Boolean]":case"[object Date]":return new e(+n);case"[object DataView]":return t=r?Rr(n.buffer):n.buffer,new n.constructor(t,n.byteOffset,n.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":
case"[object Uint16Array]":case"[object Uint32Array]":return zr(n,r);case"[object Map]":return new e;case"[object Number]":case"[object String]":return new e(n);case"[object RegExp]":return t=new n.constructor(n.source,_n.exec(n)),t.lastIndex=n.lastIndex,t;case"[object Set]":return new e;case"[object Symbol]":return to?Qu(to.call(n)):{}}}function ke(n){return ff(n)||of(n)||!!(ji&&n&&n[ji])}function Se(n,t){var r=typeof n;return t=null==t?9007199254740991:t,!!t&&("number"==r||"symbol"!=r&&bn.test(n))&&-1<n&&0==n%1&&n<t;
}function Oe(n,t,r){if(!du(r))return false;var e=typeof t;return!!("number"==e?su(r)&&Se(t,r.length):"string"==e&&t in r)&&lu(r[t],n)}function Ie(n,t){if(ff(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!wu(n))||(nn.test(n)||!X.test(n)||null!=t&&n in Qu(t))}function Re(n){var t=ge(n),r=An[t];return typeof r=="function"&&t in Un.prototype&&(n===r||(t=ho(r),!!t&&n===t[0]))}function ze(n){var t=n&&n.constructor;return n===(typeof t=="function"&&t.prototype||ei)}function We(n,t){
return function(r){return null!=r&&(r[n]===t&&(t!==T||n in Qu(r)))}}function Be(t,r,e){return r=Ui(r===T?t.length-1:r,0),function(){for(var u=arguments,i=-1,o=Ui(u.length-r,0),f=Ku(o);++i<o;)f[i]=u[r+i];for(i=-1,o=Ku(r+1);++i<r;)o[i]=u[i];return o[r]=e(f),n(t,this,o)}}function Le(n,t){if(("constructor"!==t||"function"!=typeof n[t])&&"__proto__"!=t)return n[t]}function Ue(n,t,r){var e=t+"";t=xo;var u,i=$e;return u=(u=e.match(an))?u[1].split(ln):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],
r=r.join(2<i?", ":" "),e=e.replace(cn,"{\n/* [wrapped with "+r+"] */\n")),t(n,e)}function Ce(n){var t=0,r=0;return function(){var e=Di(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(T,arguments)}}function De(n,t){var r=-1,e=n.length,u=e-1;for(t=t===T?e:t;++r<t;){var e=ir(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function Me(n){if(typeof n=="string"||wu(n))return n;var t=n+"";return"0"==t&&1/n==-$?"-0":t}function Te(n){if(null!=n){try{return ii.call(n)}catch(n){}
return n+""}return""}function $e(n,t){return r(N,function(r){var e="_."+r[0];t&r[1]&&!o(n,e)&&n.push(e)}),n.sort()}function Fe(n){if(n instanceof Un)return n.clone();var t=new On(n.__wrapped__,n.__chain__);return t.__actions__=Ur(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Ne(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Eu(r),0>r&&(r=Ui(e+r,0)),_(n,ye(t,3),r)):-1}function Pe(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==T&&(u=Eu(r),u=0>r?Ui(e+u,0):Ci(u,e-1)),
_(n,ye(t,3),u,true)}function Ze(n){return(null==n?0:n.length)?wt(n,1):[]}function qe(n){return n&&n.length?n[0]:T}function Ve(n){var t=null==n?0:n.length;return t?n[t-1]:T}function Ke(n,t){return n&&n.length&&t&&t.length?er(n,t):n}function Ge(n){return null==n?n:$i.call(n)}function He(n){if(!n||!n.length)return[];var t=0;return n=i(n,function(n){if(hu(n))return t=Ui(n.length,t),true}),A(t,function(t){return c(n,b(t))})}function Je(t,r){if(!t||!t.length)return[];var e=He(t);return null==r?e:c(e,function(t){
return n(r,T,t)})}function Ye(n){return n=An(n),n.__chain__=true,n}function Qe(n,t){return t(n)}function Xe(){return this}function nu(n,t){return(ff(n)?r:uo)(n,ye(t,3))}function tu(n,t){return(ff(n)?e:io)(n,ye(t,3))}function ru(n,t){return(ff(n)?c:Gt)(n,ye(t,3))}function eu(n,t,r){return t=r?T:t,t=n&&null==t?n.length:t,fe(n,128,T,T,T,T,t)}function uu(n,t){var r;if(typeof t!="function")throw new ti("Expected a function");return n=Eu(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=T),
r}}function iu(n,t,r){return t=r?T:t,n=fe(n,8,T,T,T,T,T,t),n.placeholder=iu.placeholder,n}function ou(n,t,r){return t=r?T:t,n=fe(n,16,T,T,T,T,T,t),n.placeholder=ou.placeholder,n}function fu(n,t,r){function e(t){var r=c,e=a;return c=a=T,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===T||r>=t||0>r||g&&n>=l}function i(){var n=Go();if(u(n))return o(n);var r,e=bo;r=n-_,n=t-(n-p),r=g?Ci(n,l-r):n,h=e(i,r)}function o(n){return h=T,d&&c?e(n):(c=a=T,s)}function f(){var n=Go(),r=u(n);if(c=arguments,
a=this,p=n,r){if(h===T)return _=n=p,h=bo(i,t),v?e(n):s;if(g)return lo(h),h=bo(i,t),e(p)}return h===T&&(h=bo(i,t)),s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ti("Expected a function");return t=Su(t)||0,du(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Ui(Su(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==T&&lo(h),_=0,c=p=a=h=T},f.flush=function(){return h===T?s:o(Go())},f}function cu(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;
return i.has(u)?i.get(u):(e=n.apply(this,e),r.cache=i.set(u,e)||i,e)}if(typeof n!="function"||null!=t&&typeof t!="function")throw new ti("Expected a function");return r.cache=new(cu.Cache||Fn),r}function au(n){if(typeof n!="function")throw new ti("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function lu(n,t){return n===t||n!==n&&t!==t;
}function su(n){return null!=n&&gu(n.length)&&!_u(n)}function hu(n){return yu(n)&&su(n)}function pu(n){if(!yu(n))return false;var t=Ot(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!xu(n)}function _u(n){return!!du(n)&&(n=Ot(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function vu(n){return typeof n=="number"&&n==Eu(n)}function gu(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n;
}function du(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function yu(n){return null!=n&&typeof n=="object"}function bu(n){return typeof n=="number"||yu(n)&&"[object Number]"==Ot(n)}function xu(n){return!(!yu(n)||"[object Object]"!=Ot(n))&&(n=di(n),null===n||(n=oi.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&ii.call(n)==li))}function ju(n){return typeof n=="string"||!ff(n)&&yu(n)&&"[object String]"==Ot(n)}function wu(n){return typeof n=="symbol"||yu(n)&&"[object Symbol]"==Ot(n);
}function mu(n){if(!n)return[];if(su(n))return ju(n)?M(n):Ur(n);if(wi&&n[wi]){n=n[wi]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}return t=vo(n),("[object Map]"==t?W:"[object Set]"==t?U:Uu)(n)}function Au(n){return n?(n=Su(n),n===$||n===-$?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function Eu(n){n=Au(n);var t=n%1;return n===n?t?n-t:n:0}function ku(n){return n?pt(Eu(n),0,4294967295):0}function Su(n){if(typeof n=="number")return n;if(wu(n))return F;if(du(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,
n=du(n)?n+"":n),typeof n!="string")return 0===n?n:+n;n=n.replace(un,"");var t=gn.test(n);return t||yn.test(n)?Dn(n.slice(2),t?2:8):vn.test(n)?F:+n}function Ou(n){return Cr(n,Bu(n))}function Iu(n){return null==n?"":yr(n)}function Ru(n,t,r){return n=null==n?T:kt(n,t),n===T?r:n}function zu(n,t){return null!=n&&we(n,t,zt)}function Wu(n){return su(n)?qn(n):Vt(n)}function Bu(n){if(su(n))n=qn(n,true);else if(du(n)){var t,r=ze(n),e=[];for(t in n)("constructor"!=t||!r&&oi.call(n,t))&&e.push(t);n=e}else{if(t=[],
null!=n)for(r in Qu(n))t.push(r);n=t}return n}function Lu(n,t){if(null==n)return{};var r=c(ve(n),function(n){return[n]});return t=ye(t),tr(n,r,function(n,r){return t(n,r[0])})}function Uu(n){return null==n?[]:S(n,Wu(n))}function Cu(n){return $f(Iu(n).toLowerCase())}function Du(n){return(n=Iu(n))&&n.replace(xn,Xn).replace(Sn,"")}function Mu(n,t,r){return n=Iu(n),t=r?T:t,t===T?zn.test(n)?n.match(In)||[]:n.match(sn)||[]:n.match(t)||[]}function Tu(n){return function(){return n}}function $u(n){return n;
}function Fu(n){return qt(typeof n=="function"?n:_t(n,1))}function Nu(n,t,e){var u=Wu(t),i=Et(t,u);null!=e||du(t)&&(i.length||!u.length)||(e=t,t=n,n=this,i=Et(t,Wu(t)));var o=!(du(e)&&"chain"in e&&!e.chain),f=_u(n);return r(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Ur(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,a([this.value()],arguments))})}),n}function Pu(){}
function Zu(n){return Ie(n)?b(Me(n)):rr(n)}function qu(){return[]}function Vu(){return false}mn=null==mn?$n:rt.defaults($n.Object(),mn,rt.pick($n,Wn));var Ku=mn.Array,Gu=mn.Date,Hu=mn.Error,Ju=mn.Function,Yu=mn.Math,Qu=mn.Object,Xu=mn.RegExp,ni=mn.String,ti=mn.TypeError,ri=Ku.prototype,ei=Qu.prototype,ui=mn["__core-js_shared__"],ii=Ju.prototype.toString,oi=ei.hasOwnProperty,fi=0,ci=function(){var n=/[^.]+$/.exec(ui&&ui.keys&&ui.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),ai=ei.toString,li=ii.call(Qu),si=$n._,hi=Xu("^"+ii.call(oi).replace(rn,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),pi=Pn?mn.Buffer:T,_i=mn.Symbol,vi=mn.Uint8Array,gi=pi?pi.g:T,di=B(Qu.getPrototypeOf,Qu),yi=Qu.create,bi=ei.propertyIsEnumerable,xi=ri.splice,ji=_i?_i.isConcatSpreadable:T,wi=_i?_i.iterator:T,mi=_i?_i.toStringTag:T,Ai=function(){
try{var n=je(Qu,"defineProperty");return n({},"",{}),n}catch(n){}}(),Ei=mn.clearTimeout!==$n.clearTimeout&&mn.clearTimeout,ki=Gu&&Gu.now!==$n.Date.now&&Gu.now,Si=mn.setTimeout!==$n.setTimeout&&mn.setTimeout,Oi=Yu.ceil,Ii=Yu.floor,Ri=Qu.getOwnPropertySymbols,zi=pi?pi.isBuffer:T,Wi=mn.isFinite,Bi=ri.join,Li=B(Qu.keys,Qu),Ui=Yu.max,Ci=Yu.min,Di=Gu.now,Mi=mn.parseInt,Ti=Yu.random,$i=ri.reverse,Fi=je(mn,"DataView"),Ni=je(mn,"Map"),Pi=je(mn,"Promise"),Zi=je(mn,"Set"),qi=je(mn,"WeakMap"),Vi=je(Qu,"create"),Ki=qi&&new qi,Gi={},Hi=Te(Fi),Ji=Te(Ni),Yi=Te(Pi),Qi=Te(Zi),Xi=Te(qi),no=_i?_i.prototype:T,to=no?no.valueOf:T,ro=no?no.toString:T,eo=function(){
function n(){}return function(t){return du(t)?yi?yi(t):(n.prototype=t,t=new n,n.prototype=T,t):{}}}();An.templateSettings={escape:J,evaluate:Y,interpolate:Q,variable:"",imports:{_:An}},An.prototype=En.prototype,An.prototype.constructor=An,On.prototype=eo(En.prototype),On.prototype.constructor=On,Un.prototype=eo(En.prototype),Un.prototype.constructor=Un,Mn.prototype.clear=function(){this.__data__=Vi?Vi(null):{},this.size=0},Mn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
this.size-=n?1:0,n},Mn.prototype.get=function(n){var t=this.__data__;return Vi?(n=t[n],"__lodash_hash_undefined__"===n?T:n):oi.call(t,n)?t[n]:T},Mn.prototype.has=function(n){var t=this.__data__;return Vi?t[n]!==T:oi.call(t,n)},Mn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Vi&&t===T?"__lodash_hash_undefined__":t,this},Tn.prototype.clear=function(){this.__data__=[],this.size=0},Tn.prototype.delete=function(n){var t=this.__data__;return n=ft(t,n),!(0>n)&&(n==t.length-1?t.pop():xi.call(t,n,1),
--this.size,true)},Tn.prototype.get=function(n){var t=this.__data__;return n=ft(t,n),0>n?T:t[n][1]},Tn.prototype.has=function(n){return-1<ft(this.__data__,n)},Tn.prototype.set=function(n,t){var r=this.__data__,e=ft(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Fn.prototype.clear=function(){this.size=0,this.__data__={hash:new Mn,map:new(Ni||Tn),string:new Mn}},Fn.prototype.delete=function(n){return n=be(this,n).delete(n),this.size-=n?1:0,n},Fn.prototype.get=function(n){return be(this,n).get(n);
},Fn.prototype.has=function(n){return be(this,n).has(n)},Fn.prototype.set=function(n,t){var r=be(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},Nn.prototype.add=Nn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},Nn.prototype.has=function(n){return this.__data__.has(n)},Zn.prototype.clear=function(){this.__data__=new Tn,this.size=0},Zn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Zn.prototype.get=function(n){
return this.__data__.get(n)},Zn.prototype.has=function(n){return this.__data__.has(n)},Zn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Tn){var e=r.__data__;if(!Ni||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Fn(e)}return r.set(n,t),this.size=r.size,this};var uo=Fr(mt),io=Fr(At,true),oo=Nr(),fo=Nr(true),co=Ki?function(n,t){return Ki.set(n,t),n}:$u,ao=Ai?function(n,t){return Ai(n,"toString",{configurable:true,enumerable:false,value:Tu(t),writable:true})}:$u,lo=Ei||function(n){
return $n.clearTimeout(n)},so=Zi&&1/U(new Zi([,-0]))[1]==$?function(n){return new Zi(n)}:Pu,ho=Ki?function(n){return Ki.get(n)}:Pu,po=Ri?function(n){return null==n?[]:(n=Qu(n),i(Ri(n),function(t){return bi.call(n,t)}))}:qu,_o=Ri?function(n){for(var t=[];n;)a(t,po(n)),n=di(n);return t}:qu,vo=Ot;(Fi&&"[object DataView]"!=vo(new Fi(new ArrayBuffer(1)))||Ni&&"[object Map]"!=vo(new Ni)||Pi&&"[object Promise]"!=vo(Pi.resolve())||Zi&&"[object Set]"!=vo(new Zi)||qi&&"[object WeakMap]"!=vo(new qi))&&(vo=function(n){
var t=Ot(n);if(n=(n="[object Object]"==t?n.constructor:T)?Te(n):"")switch(n){case Hi:return"[object DataView]";case Ji:return"[object Map]";case Yi:return"[object Promise]";case Qi:return"[object Set]";case Xi:return"[object WeakMap]"}return t});var go=ui?_u:Vu,yo=Ce(co),bo=Si||function(n,t){return $n.setTimeout(n,t)},xo=Ce(ao),jo=function(n){n=cu(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(tn,function(n,r,e,u){
t.push(e?u.replace(hn,"$1"):r||n)}),t}),wo=fr(function(n,t){return hu(n)?yt(n,wt(t,1,hu,true)):[]}),mo=fr(function(n,t){var r=Ve(t);return hu(r)&&(r=T),hu(n)?yt(n,wt(t,1,hu,true),ye(r,2)):[]}),Ao=fr(function(n,t){var r=Ve(t);return hu(r)&&(r=T),hu(n)?yt(n,wt(t,1,hu,true),T,r):[]}),Eo=fr(function(n){var t=c(n,Er);return t.length&&t[0]===n[0]?Wt(t):[]}),ko=fr(function(n){var t=Ve(n),r=c(n,Er);return t===Ve(r)?t=T:r.pop(),r.length&&r[0]===n[0]?Wt(r,ye(t,2)):[]}),So=fr(function(n){var t=Ve(n),r=c(n,Er);return(t=typeof t=="function"?t:T)&&r.pop(),
r.length&&r[0]===n[0]?Wt(r,T,t):[]}),Oo=fr(Ke),Io=pe(function(n,t){var r=null==n?0:n.length,e=ht(n,t);return ur(n,c(t,function(n){return Se(n,r)?+n:n}).sort(Wr)),e}),Ro=fr(function(n){return br(wt(n,1,hu,true))}),zo=fr(function(n){var t=Ve(n);return hu(t)&&(t=T),br(wt(n,1,hu,true),ye(t,2))}),Wo=fr(function(n){var t=Ve(n),t=typeof t=="function"?t:T;return br(wt(n,1,hu,true),T,t)}),Bo=fr(function(n,t){return hu(n)?yt(n,t):[]}),Lo=fr(function(n){return mr(i(n,hu))}),Uo=fr(function(n){var t=Ve(n);return hu(t)&&(t=T),
mr(i(n,hu),ye(t,2))}),Co=fr(function(n){var t=Ve(n),t=typeof t=="function"?t:T;return mr(i(n,hu),T,t)}),Do=fr(He),Mo=fr(function(n){var t=n.length,t=1<t?n[t-1]:T,t=typeof t=="function"?(n.pop(),t):T;return Je(n,t)}),To=pe(function(n){function t(t){return ht(t,n)}var r=n.length,e=r?n[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Un&&Se(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:Qe,args:[t],thisArg:T}),new On(u,this.__chain__).thru(function(n){return r&&!n.length&&n.push(T),
n})):this.thru(t)}),$o=Tr(function(n,t,r){oi.call(n,r)?++n[r]:st(n,r,1)}),Fo=Gr(Ne),No=Gr(Pe),Po=Tr(function(n,t,r){oi.call(n,r)?n[r].push(t):st(n,r,[t])}),Zo=fr(function(t,r,e){var u=-1,i=typeof r=="function",o=su(t)?Ku(t.length):[];return uo(t,function(t){o[++u]=i?n(r,t,e):Lt(t,r,e)}),o}),qo=Tr(function(n,t,r){st(n,r,t)}),Vo=Tr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Ko=fr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&Oe(n,t[0],t[1])?t=[]:2<r&&Oe(t[0],t[1],t[2])&&(t=[t[0]]),
Xt(n,wt(t,1),[])}),Go=ki||function(){return $n.Date.now()},Ho=fr(function(n,t,r){var e=1;if(r.length)var u=L(r,de(Ho)),e=32|e;return fe(n,e,t,r,u)}),Jo=fr(function(n,t,r){var e=3;if(r.length)var u=L(r,de(Jo)),e=32|e;return fe(t,e,n,r,u)}),Yo=fr(function(n,t){return dt(n,1,t)}),Qo=fr(function(n,t,r){return dt(n,Su(t)||0,r)});cu.Cache=Fn;var Xo=fr(function(t,r){r=1==r.length&&ff(r[0])?c(r[0],k(ye())):c(wt(r,1),k(ye()));var e=r.length;return fr(function(u){for(var i=-1,o=Ci(u.length,e);++i<o;)u[i]=r[i].call(this,u[i]);
return n(t,this,u)})}),nf=fr(function(n,t){return fe(n,32,T,t,L(t,de(nf)))}),tf=fr(function(n,t){return fe(n,64,T,t,L(t,de(tf)))}),rf=pe(function(n,t){return fe(n,256,T,T,T,t)}),ef=ee(It),uf=ee(function(n,t){return n>=t}),of=Ut(function(){return arguments}())?Ut:function(n){return yu(n)&&oi.call(n,"callee")&&!bi.call(n,"callee")},ff=Ku.isArray,cf=Vn?k(Vn):Ct,af=zi||Vu,lf=Kn?k(Kn):Dt,sf=Gn?k(Gn):Tt,hf=Hn?k(Hn):Nt,pf=Jn?k(Jn):Pt,_f=Yn?k(Yn):Zt,vf=ee(Kt),gf=ee(function(n,t){return n<=t}),df=$r(function(n,t){
if(ze(t)||su(t))Cr(t,Wu(t),n);else for(var r in t)oi.call(t,r)&&ot(n,r,t[r])}),yf=$r(function(n,t){Cr(t,Bu(t),n)}),bf=$r(function(n,t,r,e){Cr(t,Bu(t),n,e)}),xf=$r(function(n,t,r,e){Cr(t,Wu(t),n,e)}),jf=pe(ht),wf=fr(function(n,t){n=Qu(n);var r=-1,e=t.length,u=2<e?t[2]:T;for(u&&Oe(t[0],t[1],u)&&(e=1);++r<e;)for(var u=t[r],i=Bu(u),o=-1,f=i.length;++o<f;){var c=i[o],a=n[c];(a===T||lu(a,ei[c])&&!oi.call(n,c))&&(n[c]=u[c])}return n}),mf=fr(function(t){return t.push(T,ae),n(Of,T,t)}),Af=Yr(function(n,t,r){
null!=t&&typeof t.toString!="function"&&(t=ai.call(t)),n[t]=r},Tu($u)),Ef=Yr(function(n,t,r){null!=t&&typeof t.toString!="function"&&(t=ai.call(t)),oi.call(n,t)?n[t].push(r):n[t]=[r]},ye),kf=fr(Lt),Sf=$r(function(n,t,r){Yt(n,t,r)}),Of=$r(function(n,t,r,e){Yt(n,t,r,e)}),If=pe(function(n,t){var r={};if(null==n)return r;var e=false;t=c(t,function(t){return t=Sr(t,n),e||(e=1<t.length),t}),Cr(n,ve(n),r),e&&(r=_t(r,7,le));for(var u=t.length;u--;)xr(r,t[u]);return r}),Rf=pe(function(n,t){return null==n?{}:nr(n,t);
}),zf=oe(Wu),Wf=oe(Bu),Bf=qr(function(n,t,r){return t=t.toLowerCase(),n+(r?Cu(t):t)}),Lf=qr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Uf=qr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Cf=Zr("toLowerCase"),Df=qr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Mf=qr(function(n,t,r){return n+(r?" ":"")+$f(t)}),Tf=qr(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),$f=Zr("toUpperCase"),Ff=fr(function(t,r){try{return n(t,T,r)}catch(n){return pu(n)?n:new Hu(n)}}),Nf=pe(function(n,t){
return r(t,function(t){t=Me(t),st(n,t,Ho(n[t],n))}),n}),Pf=Hr(),Zf=Hr(true),qf=fr(function(n,t){return function(r){return Lt(r,n,t)}}),Vf=fr(function(n,t){return function(r){return Lt(n,r,t)}}),Kf=Xr(c),Gf=Xr(u),Hf=Xr(h),Jf=re(),Yf=re(true),Qf=Qr(function(n,t){return n+t},0),Xf=ie("ceil"),nc=Qr(function(n,t){return n/t},1),tc=ie("floor"),rc=Qr(function(n,t){return n*t},1),ec=ie("round"),uc=Qr(function(n,t){return n-t},0);return An.after=function(n,t){if(typeof t!="function")throw new ti("Expected a function");
return n=Eu(n),function(){if(1>--n)return t.apply(this,arguments)}},An.ary=eu,An.assign=df,An.assignIn=yf,An.assignInWith=bf,An.assignWith=xf,An.at=jf,An.before=uu,An.bind=Ho,An.bindAll=Nf,An.bindKey=Jo,An.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return ff(n)?n:[n]},An.chain=Ye,An.chunk=function(n,t,r){if(t=(r?Oe(n,t,r):t===T)?1:Ui(Eu(t),0),r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Ku(Oi(r/t));e<r;)i[u++]=hr(n,e,e+=t);return i},An.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){
var i=n[t];i&&(u[e++]=i)}return u},An.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Ku(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return a(ff(r)?Ur(r):[r],wt(t,1))},An.cond=function(t){var r=null==t?0:t.length,e=ye();return t=r?c(t,function(n){if("function"!=typeof n[1])throw new ti("Expected a function");return[e(n[0]),n[1]]}):[],fr(function(e){for(var u=-1;++u<r;){var i=t[u];if(n(i[0],this,e))return n(i[1],this,e)}})},An.conforms=function(n){return vt(_t(n,1))},An.constant=Tu,
An.countBy=$o,An.create=function(n,t){var r=eo(n);return null==t?r:at(r,t)},An.curry=iu,An.curryRight=ou,An.debounce=fu,An.defaults=wf,An.defaultsDeep=mf,An.defer=Yo,An.delay=Qo,An.difference=wo,An.differenceBy=mo,An.differenceWith=Ao,An.drop=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:Eu(t),hr(n,0>t?0:t,e)):[]},An.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:Eu(t),t=e-t,hr(n,0,0>t?0:t)):[]},An.dropRightWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),true,true):[];
},An.dropWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),true):[]},An.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&Oe(n,t,r)&&(r=0,e=u),u=n.length,r=Eu(r),0>r&&(r=-r>u?0:u+r),e=e===T||e>u?u:Eu(e),0>e&&(e+=u),e=r>e?0:ku(e);r<e;)n[r++]=t;return n},An.filter=function(n,t){return(ff(n)?i:jt)(n,ye(t,3))},An.flatMap=function(n,t){return wt(ru(n,t),1)},An.flatMapDeep=function(n,t){return wt(ru(n,t),$)},An.flatMapDepth=function(n,t,r){return r=r===T?1:Eu(r),
wt(ru(n,t),r)},An.flatten=Ze,An.flattenDeep=function(n){return(null==n?0:n.length)?wt(n,$):[]},An.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===T?1:Eu(t),wt(n,t)):[]},An.flip=function(n){return fe(n,512)},An.flow=Pf,An.flowRight=Zf,An.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e},An.functions=function(n){return null==n?[]:Et(n,Wu(n))},An.functionsIn=function(n){return null==n?[]:Et(n,Bu(n))},An.groupBy=Po,An.initial=function(n){
return(null==n?0:n.length)?hr(n,0,-1):[]},An.intersection=Eo,An.intersectionBy=ko,An.intersectionWith=So,An.invert=Af,An.invertBy=Ef,An.invokeMap=Zo,An.iteratee=Fu,An.keyBy=qo,An.keys=Wu,An.keysIn=Bu,An.map=ru,An.mapKeys=function(n,t){var r={};return t=ye(t,3),mt(n,function(n,e,u){st(r,t(n,e,u),n)}),r},An.mapValues=function(n,t){var r={};return t=ye(t,3),mt(n,function(n,e,u){st(r,e,t(n,e,u))}),r},An.matches=function(n){return Ht(_t(n,1))},An.matchesProperty=function(n,t){return Jt(n,_t(t,1))},An.memoize=cu,
An.merge=Sf,An.mergeWith=Of,An.method=qf,An.methodOf=Vf,An.mixin=Nu,An.negate=au,An.nthArg=function(n){return n=Eu(n),fr(function(t){return Qt(t,n)})},An.omit=If,An.omitBy=function(n,t){return Lu(n,au(ye(t)))},An.once=function(n){return uu(2,n)},An.orderBy=function(n,t,r,e){return null==n?[]:(ff(t)||(t=null==t?[]:[t]),r=e?T:r,ff(r)||(r=null==r?[]:[r]),Xt(n,t,r))},An.over=Kf,An.overArgs=Xo,An.overEvery=Gf,An.overSome=Hf,An.partial=nf,An.partialRight=tf,An.partition=Vo,An.pick=Rf,An.pickBy=Lu,An.property=Zu,
An.propertyOf=function(n){return function(t){return null==n?T:kt(n,t)}},An.pull=Oo,An.pullAll=Ke,An.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?er(n,t,ye(r,2)):n},An.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?er(n,t,T,r):n},An.pullAt=Io,An.range=Jf,An.rangeRight=Yf,An.rearg=rf,An.reject=function(n,t){return(ff(n)?i:jt)(n,au(ye(t,3)))},An.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=ye(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),
u.push(e))}return ur(n,u),r},An.rest=function(n,t){if(typeof n!="function")throw new ti("Expected a function");return t=t===T?t:Eu(t),fr(n,t)},An.reverse=Ge,An.sampleSize=function(n,t,r){return t=(r?Oe(n,t,r):t===T)?1:Eu(t),(ff(n)?et:ar)(n,t)},An.set=function(n,t,r){return null==n?n:lr(n,t,r)},An.setWith=function(n,t,r,e){return e=typeof e=="function"?e:T,null==n?n:lr(n,t,r,e)},An.shuffle=function(n){return(ff(n)?ut:sr)(n)},An.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&Oe(n,t,r)?(t=0,
r=e):(t=null==t?0:Eu(t),r=r===T?e:Eu(r)),hr(n,t,r)):[]},An.sortBy=Ko,An.sortedUniq=function(n){return n&&n.length?gr(n):[]},An.sortedUniqBy=function(n,t){return n&&n.length?gr(n,ye(t,2)):[]},An.split=function(n,t,r){return r&&typeof r!="number"&&Oe(n,t,r)&&(t=r=T),r=r===T?4294967295:r>>>0,r?(n=Iu(n))&&(typeof t=="string"||null!=t&&!hf(t))&&(t=yr(t),!t&&Rn.test(n))?Or(M(n),0,r):n.split(t,r):[]},An.spread=function(t,r){if(typeof t!="function")throw new ti("Expected a function");return r=null==r?0:Ui(Eu(r),0),
fr(function(e){var u=e[r];return e=Or(e,0,r),u&&a(e,u),n(t,this,e)})},An.tail=function(n){var t=null==n?0:n.length;return t?hr(n,1,t):[]},An.take=function(n,t,r){return n&&n.length?(t=r||t===T?1:Eu(t),hr(n,0,0>t?0:t)):[]},An.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===T?1:Eu(t),t=e-t,hr(n,0>t?0:t,e)):[]},An.takeRightWhile=function(n,t){return n&&n.length?jr(n,ye(t,3),false,true):[]},An.takeWhile=function(n,t){return n&&n.length?jr(n,ye(t,3)):[]},An.tap=function(n,t){return t(n),
n},An.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ti("Expected a function");return du(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),fu(n,t,{leading:e,maxWait:t,trailing:u})},An.thru=Qe,An.toArray=mu,An.toPairs=zf,An.toPairsIn=Wf,An.toPath=function(n){return ff(n)?c(n,Me):wu(n)?[n]:Ur(jo(Iu(n)))},An.toPlainObject=Ou,An.transform=function(n,t,e){var u=ff(n),i=u||af(n)||_f(n);if(t=ye(t,4),null==e){var o=n&&n.constructor;e=i?u?new o:[]:du(n)&&_u(o)?eo(di(n)):{};
}return(i?r:mt)(n,function(n,r,u){return t(e,n,r,u)}),e},An.unary=function(n){return eu(n,1)},An.union=Ro,An.unionBy=zo,An.unionWith=Wo,An.uniq=function(n){return n&&n.length?br(n):[]},An.uniqBy=function(n,t){return n&&n.length?br(n,ye(t,2)):[]},An.uniqWith=function(n,t){return t=typeof t=="function"?t:T,n&&n.length?br(n,T,t):[]},An.unset=function(n,t){return null==n||xr(n,t)},An.unzip=He,An.unzipWith=Je,An.update=function(n,t,r){return null==n?n:lr(n,t,kr(r)(kt(n,t)),void 0)},An.updateWith=function(n,t,r,e){
return e=typeof e=="function"?e:T,null!=n&&(n=lr(n,t,kr(r)(kt(n,t)),e)),n},An.values=Uu,An.valuesIn=function(n){return null==n?[]:S(n,Bu(n))},An.without=Bo,An.words=Mu,An.wrap=function(n,t){return nf(kr(t),n)},An.xor=Lo,An.xorBy=Uo,An.xorWith=Co,An.zip=Do,An.zipObject=function(n,t){return Ar(n||[],t||[],ot)},An.zipObjectDeep=function(n,t){return Ar(n||[],t||[],lr)},An.zipWith=Mo,An.entries=zf,An.entriesIn=Wf,An.extend=yf,An.extendWith=bf,Nu(An,An),An.add=Qf,An.attempt=Ff,An.camelCase=Bf,An.capitalize=Cu,
An.ceil=Xf,An.clamp=function(n,t,r){return r===T&&(r=t,t=T),r!==T&&(r=Su(r),r=r===r?r:0),t!==T&&(t=Su(t),t=t===t?t:0),pt(Su(n),t,r)},An.clone=function(n){return _t(n,4)},An.cloneDeep=function(n){return _t(n,5)},An.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:T,_t(n,5,t)},An.cloneWith=function(n,t){return t=typeof t=="function"?t:T,_t(n,4,t)},An.conformsTo=function(n,t){return null==t||gt(n,t,Wu(t))},An.deburr=Du,An.defaultTo=function(n,t){return null==n||n!==n?t:n},An.divide=nc,An.endsWith=function(n,t,r){
n=Iu(n),t=yr(t);var e=n.length,e=r=r===T?e:pt(Eu(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},An.eq=lu,An.escape=function(n){return(n=Iu(n))&&H.test(n)?n.replace(K,nt):n},An.escapeRegExp=function(n){return(n=Iu(n))&&en.test(n)?n.replace(rn,"\\$&"):n},An.every=function(n,t,r){var e=ff(n)?u:bt;return r&&Oe(n,t,r)&&(t=T),e(n,ye(t,3))},An.find=Fo,An.findIndex=Ne,An.findKey=function(n,t){return p(n,ye(t,3),mt)},An.findLast=No,An.findLastIndex=Pe,An.findLastKey=function(n,t){return p(n,ye(t,3),At);
},An.floor=tc,An.forEach=nu,An.forEachRight=tu,An.forIn=function(n,t){return null==n?n:oo(n,ye(t,3),Bu)},An.forInRight=function(n,t){return null==n?n:fo(n,ye(t,3),Bu)},An.forOwn=function(n,t){return n&&mt(n,ye(t,3))},An.forOwnRight=function(n,t){return n&&At(n,ye(t,3))},An.get=Ru,An.gt=ef,An.gte=uf,An.has=function(n,t){return null!=n&&we(n,t,Rt)},An.hasIn=zu,An.head=qe,An.identity=$u,An.includes=function(n,t,r,e){return n=su(n)?n:Uu(n),r=r&&!e?Eu(r):0,e=n.length,0>r&&(r=Ui(e+r,0)),ju(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<v(n,t,r);
},An.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Eu(r),0>r&&(r=Ui(e+r,0)),v(n,t,r)):-1},An.inRange=function(n,t,r){return t=Au(t),r===T?(r=t,t=0):r=Au(r),n=Su(n),n>=Ci(t,r)&&n<Ui(t,r)},An.invoke=kf,An.isArguments=of,An.isArray=ff,An.isArrayBuffer=cf,An.isArrayLike=su,An.isArrayLikeObject=hu,An.isBoolean=function(n){return true===n||false===n||yu(n)&&"[object Boolean]"==Ot(n)},An.isBuffer=af,An.isDate=lf,An.isElement=function(n){return yu(n)&&1===n.nodeType&&!xu(n)},An.isEmpty=function(n){
if(null==n)return true;if(su(n)&&(ff(n)||typeof n=="string"||typeof n.splice=="function"||af(n)||_f(n)||of(n)))return!n.length;var t=vo(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(ze(n))return!Vt(n).length;for(var r in n)if(oi.call(n,r))return false;return true},An.isEqual=function(n,t){return Mt(n,t)},An.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:T)?r(n,t):T;return e===T?Mt(n,t,T,r):!!e},An.isError=pu,An.isFinite=function(n){return typeof n=="number"&&Wi(n)},An.isFunction=_u,
An.isInteger=vu,An.isLength=gu,An.isMap=sf,An.isMatch=function(n,t){return n===t||$t(n,t,xe(t))},An.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:T,$t(n,t,xe(t),r)},An.isNaN=function(n){return bu(n)&&n!=+n},An.isNative=function(n){if(go(n))throw new Hu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");return Ft(n)},An.isNil=function(n){return null==n},An.isNull=function(n){return null===n},An.isNumber=bu,An.isObject=du,An.isObjectLike=yu,An.isPlainObject=xu,An.isRegExp=hf,
An.isSafeInteger=function(n){return vu(n)&&-9007199254740991<=n&&9007199254740991>=n},An.isSet=pf,An.isString=ju,An.isSymbol=wu,An.isTypedArray=_f,An.isUndefined=function(n){return n===T},An.isWeakMap=function(n){return yu(n)&&"[object WeakMap]"==vo(n)},An.isWeakSet=function(n){return yu(n)&&"[object WeakSet]"==Ot(n)},An.join=function(n,t){return null==n?"":Bi.call(n,t)},An.kebabCase=Lf,An.last=Ve,An.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==T&&(u=Eu(r),u=0>u?Ui(e+u,0):Ci(u,e-1)),
t===t){for(r=u+1;r--&&n[r]!==t;);n=r}else n=_(n,d,u,true);return n},An.lowerCase=Uf,An.lowerFirst=Cf,An.lt=vf,An.lte=gf,An.max=function(n){return n&&n.length?xt(n,$u,It):T},An.maxBy=function(n,t){return n&&n.length?xt(n,ye(t,2),It):T},An.mean=function(n){return y(n,$u)},An.meanBy=function(n,t){return y(n,ye(t,2))},An.min=function(n){return n&&n.length?xt(n,$u,Kt):T},An.minBy=function(n,t){return n&&n.length?xt(n,ye(t,2),Kt):T},An.stubArray=qu,An.stubFalse=Vu,An.stubObject=function(){return{}},An.stubString=function(){
return""},An.stubTrue=function(){return true},An.multiply=rc,An.nth=function(n,t){return n&&n.length?Qt(n,Eu(t)):T},An.noConflict=function(){return $n._===this&&($n._=si),this},An.noop=Pu,An.now=Go,An.pad=function(n,t,r){n=Iu(n);var e=(t=Eu(t))?D(n):0;return!t||e>=t?n:(t=(t-e)/2,ne(Ii(t),r)+n+ne(Oi(t),r))},An.padEnd=function(n,t,r){n=Iu(n);var e=(t=Eu(t))?D(n):0;return t&&e<t?n+ne(t-e,r):n},An.padStart=function(n,t,r){n=Iu(n);var e=(t=Eu(t))?D(n):0;return t&&e<t?ne(t-e,r)+n:n},An.parseInt=function(n,t,r){
return r||null==t?t=0:t&&(t=+t),Mi(Iu(n).replace(on,""),t||0)},An.random=function(n,t,r){if(r&&typeof r!="boolean"&&Oe(n,t,r)&&(t=r=T),r===T&&(typeof t=="boolean"?(r=t,t=T):typeof n=="boolean"&&(r=n,n=T)),n===T&&t===T?(n=0,t=1):(n=Au(n),t===T?(t=n,n=0):t=Au(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=Ti(),Ci(n+r*(t-n+Cn("1e-"+((r+"").length-1))),t)):ir(n,t)},An.reduce=function(n,t,r){var e=ff(n)?l:j,u=3>arguments.length;return e(n,ye(t,4),r,u,uo)},An.reduceRight=function(n,t,r){var e=ff(n)?s:j,u=3>arguments.length;
return e(n,ye(t,4),r,u,io)},An.repeat=function(n,t,r){return t=(r?Oe(n,t,r):t===T)?1:Eu(t),or(Iu(n),t)},An.replace=function(){var n=arguments,t=Iu(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},An.result=function(n,t,r){t=Sr(t,n);var e=-1,u=t.length;for(u||(u=1,n=T);++e<u;){var i=null==n?T:n[Me(t[e])];i===T&&(e=u,i=r),n=_u(i)?i.call(n):i}return n},An.round=ec,An.runInContext=x,An.sample=function(n){return(ff(n)?Qn:cr)(n)},An.size=function(n){if(null==n)return 0;if(su(n))return ju(n)?D(n):n.length;
var t=vo(n);return"[object Map]"==t||"[object Set]"==t?n.size:Vt(n).length},An.snakeCase=Df,An.some=function(n,t,r){var e=ff(n)?h:pr;return r&&Oe(n,t,r)&&(t=T),e(n,ye(t,3))},An.sortedIndex=function(n,t){return _r(n,t)},An.sortedIndexBy=function(n,t,r){return vr(n,t,ye(r,2))},An.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){var e=_r(n,t);if(e<r&&lu(n[e],t))return e}return-1},An.sortedLastIndex=function(n,t){return _r(n,t,true)},An.sortedLastIndexBy=function(n,t,r){return vr(n,t,ye(r,2),true);
},An.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=_r(n,t,true)-1;if(lu(n[r],t))return r}return-1},An.startCase=Mf,An.startsWith=function(n,t,r){return n=Iu(n),r=null==r?0:pt(Eu(r),0,n.length),t=yr(t),n.slice(r,r+t.length)==t},An.subtract=uc,An.sum=function(n){return n&&n.length?m(n,$u):0},An.sumBy=function(n,t){return n&&n.length?m(n,ye(t,2)):0},An.template=function(n,t,r){var e=An.templateSettings;r&&Oe(n,t,r)&&(t=T),n=Iu(n),t=bf({},t,e,ce),r=bf({},t.imports,e.imports,ce);var u,i,o=Wu(r),f=S(r,o),c=0;
r=t.interpolate||jn;var a="__p+='";r=Xu((t.escape||jn).source+"|"+r.source+"|"+(r===Q?pn:jn).source+"|"+(t.evaluate||jn).source+"|$","g");var l=oi.call(t,"sourceURL")?"//# sourceURL="+(t.sourceURL+"").replace(/[\r\n]/g," ")+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(wn,z),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=oi.call(t,"variable")&&t.variable)||(a="with(obj){"+a+"}"),
a=(i?a.replace(P,""):a).replace(Z,"$1").replace(q,"$1;"),a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Ff(function(){return Ju(o,l+"return "+a).apply(T,f)}),t.source=a,pu(t))throw t;return t},An.times=function(n,t){if(n=Eu(n),1>n||9007199254740991<n)return[];var r=4294967295,e=Ci(n,4294967295);for(t=ye(t),n-=4294967295,e=A(e,t);++r<n;)t(r);return e},An.toFinite=Au,
An.toInteger=Eu,An.toLength=ku,An.toLower=function(n){return Iu(n).toLowerCase()},An.toNumber=Su,An.toSafeInteger=function(n){return n?pt(Eu(n),-9007199254740991,9007199254740991):0===n?n:0},An.toString=Iu,An.toUpper=function(n){return Iu(n).toUpperCase()},An.trim=function(n,t,r){return(n=Iu(n))&&(r||t===T)?n.replace(un,""):n&&(t=yr(t))?(n=M(n),r=M(t),t=I(n,r),r=R(n,r)+1,Or(n,t,r).join("")):n},An.trimEnd=function(n,t,r){return(n=Iu(n))&&(r||t===T)?n.replace(fn,""):n&&(t=yr(t))?(n=M(n),t=R(n,M(t))+1,
Or(n,0,t).join("")):n},An.trimStart=function(n,t,r){return(n=Iu(n))&&(r||t===T)?n.replace(on,""):n&&(t=yr(t))?(n=M(n),t=I(n,M(t)),Or(n,t).join("")):n},An.truncate=function(n,t){var r=30,e="...";if(du(t))var u="separator"in t?t.separator:u,r="length"in t?Eu(t.length):r,e="omission"in t?yr(t.omission):e;n=Iu(n);var i=n.length;if(Rn.test(n))var o=M(n),i=o.length;if(r>=i)return n;if(i=r-D(e),1>i)return e;if(r=o?Or(o,0,i).join(""):n.slice(0,i),u===T)return r+e;if(o&&(i+=r.length-i),hf(u)){if(n.slice(i).search(u)){
var f=r;for(u.global||(u=Xu(u.source,Iu(_n.exec(u))+"g")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===T?i:c)}}else n.indexOf(yr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},An.unescape=function(n){return(n=Iu(n))&&G.test(n)?n.replace(V,tt):n},An.uniqueId=function(n){var t=++fi;return Iu(n)+t},An.upperCase=Tf,An.upperFirst=$f,An.each=nu,An.eachRight=tu,An.first=qe,Nu(An,function(){var n={};return mt(An,function(t,r){oi.call(An.prototype,r)||(n[r]=t)}),n}(),{chain:false
}),An.VERSION="4.17.15",r("bind bindKey curry curryRight partial partialRight".split(" "),function(n){An[n].placeholder=An}),r(["drop","take"],function(n,t){Un.prototype[n]=function(r){r=r===T?1:Ui(Eu(r),0);var e=this.__filtered__&&!t?new Un(this):this.clone();return e.__filtered__?e.__takeCount__=Ci(r,e.__takeCount__):e.__views__.push({size:Ci(r,4294967295),type:n+(0>e.__dir__?"Right":"")}),e},Un.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),r(["filter","map","takeWhile"],function(n,t){
var r=t+1,e=1==r||3==r;Un.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:ye(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),r(["head","last"],function(n,t){var r="take"+(t?"Right":"");Un.prototype[n]=function(){return this[r](1).value()[0]}}),r(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Un.prototype[n]=function(){return this.__filtered__?new Un(this):this[r](1)}}),Un.prototype.compact=function(){return this.filter($u)},Un.prototype.find=function(n){
return this.filter(n).head()},Un.prototype.findLast=function(n){return this.reverse().find(n)},Un.prototype.invokeMap=fr(function(n,t){return typeof n=="function"?new Un(this):this.map(function(r){return Lt(r,n,t)})}),Un.prototype.reject=function(n){return this.filter(au(ye(n)))},Un.prototype.slice=function(n,t){n=Eu(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Un(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==T&&(t=Eu(t),r=0>t?r.dropRight(-t):r.take(t-n)),r)},Un.prototype.takeRightWhile=function(n){
return this.reverse().takeWhile(n).reverse()},Un.prototype.toArray=function(){return this.take(4294967295)},mt(Un.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=An[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(An.prototype[t]=function(){function t(n){return n=u.apply(An,a([n],f)),e&&h?n[0]:n}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Un,l=f[0],s=c||ff(o);s&&r&&typeof l=="function"&&1!=l.length&&(c=s=false);var h=this.__chain__,p=!!this.__actions__.length,l=i&&!h,c=c&&!p;
return!i&&s?(o=c?o:new Un(this),o=n.apply(o,f),o.__actions__.push({func:Qe,args:[t],thisArg:T}),new On(o,h)):l&&c?n.apply(this,f):(o=this.thru(t),l?e?o.value()[0]:o.value():o)})}),r("pop push shift sort splice unshift".split(" "),function(n){var t=ri[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);An.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(ff(u)?u:[],n)}return this[r](function(r){return t.apply(ff(r)?r:[],n)});
}}),mt(Un.prototype,function(n,t){var r=An[t];if(r){var e=r.name+"";oi.call(Gi,e)||(Gi[e]=[]),Gi[e].push({name:t,func:r})}}),Gi[Jr(T,2).name]=[{name:"wrapper",func:T}],Un.prototype.clone=function(){var n=new Un(this.__wrapped__);return n.__actions__=Ur(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Ur(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Ur(this.__views__),n},Un.prototype.reverse=function(){if(this.__filtered__){var n=new Un(this);
n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},Un.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=ff(t),u=0>r,i=e?t.length:0;n=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=Ci(n,f+s);break;case"takeRight":f=Ui(f,n-s)}}if(n={start:f,end:n},o=n.start,f=n.end,n=f-o,o=u?f:o-1,f=this.__iteratees__,c=f.length,a=0,l=Ci(n,this.__takeCount__),!e||!u&&i==n&&l==n)return wr(t,this.__actions__);
e=[];n:for(;n--&&a<l;){for(o+=r,u=-1,i=t[o];++u<c;){var h=f[u],s=h.type,h=(0,h.iteratee)(i);if(2==s)i=h;else if(!h){if(1==s)continue n;break n}}e[a++]=i}return e},An.prototype.at=To,An.prototype.chain=function(){return Ye(this)},An.prototype.commit=function(){return new On(this.value(),this.__chain__)},An.prototype.next=function(){this.__values__===T&&(this.__values__=mu(this.value()));var n=this.__index__>=this.__values__.length;return{done:n,value:n?T:this.__values__[this.__index__++]}},An.prototype.plant=function(n){
for(var t,r=this;r instanceof En;){var e=Fe(r);e.__index__=0,e.__values__=T,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},An.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Un?(this.__actions__.length&&(n=new Un(this)),n=n.reverse(),n.__actions__.push({func:Qe,args:[Ge],thisArg:T}),new On(n,this.__chain__)):this.thru(Ge)},An.prototype.toJSON=An.prototype.valueOf=An.prototype.value=function(){return wr(this.__wrapped__,this.__actions__)},An.prototype.first=An.prototype.head,
wi&&(An.prototype[wi]=Xe),An}();typeof define=="function"&&typeof define.amd=="object"&&define.amd?($n._=rt, define(function(){return rt})):Nn?((Nn.exports=rt)._=rt,Fn._=rt):$n._=rt}).call(this);;

/* store.js - Copyright (c) 2010-2017 Marcus Westin */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,t.store=e()}}(function(){return function e(t,n,r){function o(a,u){if(!n[a]){if(!t[a]){var s="function"==typeof require&&require;if(!u&&s)return s(a,!0);if(i)return i(a,!0);var c=new Error("Cannot find module '"+a+"'");throw c.code="MODULE_NOT_FOUND",c}var f=n[a]={exports:{}};t[a][0].call(f.exports,function(e){var n=t[a][1][e];return o(n?n:e)},f,f.exports,e,t,n,r)}return n[a].exports}for(var i="function"==typeof require&&require,a=0;a<r.length;a++)o(r[a]);return o}({1:[function(e,t,n){"use strict";var r=e("../src/store-engine"),o=[e("../storages/localStorage"),e("../storages/sessionStorage"),e("../storages/cookieStorage"),e("../storages/memoryStorage")],i=[];t.exports=r.createStore(o,i)},{"../src/store-engine":2,"../storages/cookieStorage":4,"../storages/localStorage":5,"../storages/memoryStorage":6,"../storages/sessionStorage":7}],2:[function(e,t,n){"use strict";function r(){var e="undefined"==typeof console?null:console;if(e){var t=e.warn?e.warn:e.log;t.apply(e,arguments)}}function o(e,t,n){n||(n=""),e&&!l(e)&&(e=[e]),t&&!l(t)&&(t=[t]);var o=n?"__storejs_"+n+"_":"",i=n?new RegExp("^"+o):null,h=/^[a-zA-Z0-9_\-]*$/;if(!h.test(n))throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");var v={_namespacePrefix:o,_namespaceRegexp:i,_testStorage:function(e){try{var t="__storejs__test__";e.write(t,t);var n=e.read(t)===t;return e.remove(t),n}catch(r){return!1}},_assignPluginFnProp:function(e,t){var n=this[t];this[t]=function(){function t(){if(n)return s(arguments,function(e,t){r[t]=e}),n.apply(o,r)}var r=a(arguments,0),o=this,i=[t].concat(r);return e.apply(o,i)}},_serialize:function(e){return JSON.stringify(e)},_deserialize:function(e,t){if(!e)return t;var n="";try{n=JSON.parse(e)}catch(r){n=e}return void 0!==n?n:t},_addStorage:function(e){this.enabled||this._testStorage(e)&&(this.storage=e,this.enabled=!0)},_addPlugin:function(e){var t=this;if(l(e))return void s(e,function(e){t._addPlugin(e)});var n=u(this.plugins,function(t){return e===t});if(!n){if(this.plugins.push(e),!p(e))throw new Error("Plugins must be function values that return objects");var r=e.call(this);if(!g(r))throw new Error("Plugins must return an object of function properties");s(r,function(n,r){if(!p(n))throw new Error("Bad plugin property: "+r+" from plugin "+e.name+". Plugins should only return functions.");t._assignPluginFnProp(n,r)})}},addStorage:function(e){r("store.addStorage(storage) is deprecated. Use createStore([storages])"),this._addStorage(e)}},m=f(v,d,{plugins:[]});return m.raw={},s(m,function(e,t){p(e)&&(m.raw[t]=c(m,e))}),s(e,function(e){m._addStorage(e)}),s(t,function(e){m._addPlugin(e)}),m}var i=e("./util"),a=i.slice,u=i.pluck,s=i.each,c=i.bind,f=i.create,l=i.isList,p=i.isFunction,g=i.isObject;t.exports={createStore:o};var d={version:"2.0.12",enabled:!1,get:function(e,t){var n=this.storage.read(this._namespacePrefix+e);return this._deserialize(n,t)},set:function(e,t){return void 0===t?this.remove(e):(this.storage.write(this._namespacePrefix+e,this._serialize(t)),t)},remove:function(e){this.storage.remove(this._namespacePrefix+e)},each:function(e){var t=this;this.storage.each(function(n,r){e.call(t,t._deserialize(n),(r||"").replace(t._namespaceRegexp,""))})},clearAll:function(){this.storage.clearAll()},hasNamespace:function(e){return this._namespacePrefix=="__storejs_"+e+"_"},createStore:function(){return o.apply(this,arguments)},addPlugin:function(e){this._addPlugin(e)},namespace:function(e){return o(this.storage,this.plugins,e)}}},{"./util":3}],3:[function(e,t,n){(function(e){"use strict";function n(){return Object.assign?Object.assign:function(e,t,n,r){for(var o=1;o<arguments.length;o++)u(Object(arguments[o]),function(t,n){e[n]=t});return e}}function r(){if(Object.create)return function(e,t,n,r){var o=a(arguments,1);return g.apply(this,[Object.create(e)].concat(o))};var e=function(){};return function(t,n,r,o){var i=a(arguments,1);return e.prototype=t,g.apply(this,[new e].concat(i))}}function o(){return String.prototype.trim?function(e){return String.prototype.trim.call(e)}:function(e){return e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}}function i(e,t){return function(){return t.apply(e,Array.prototype.slice.call(arguments,0))}}function a(e,t){return Array.prototype.slice.call(e,t||0)}function u(e,t){c(e,function(e,n){return t(e,n),!1})}function s(e,t){var n=f(e)?[]:{};return c(e,function(e,r){return n[r]=t(e,r),!1}),n}function c(e,t){if(f(e)){for(var n=0;n<e.length;n++)if(t(e[n],n))return e[n]}else for(var r in e)if(e.hasOwnProperty(r)&&t(e[r],r))return e[r]}function f(e){return null!=e&&"function"!=typeof e&&"number"==typeof e.length}function l(e){return e&&"[object Function]"==={}.toString.call(e)}function p(e){return e&&"[object Object]"==={}.toString.call(e)}var g=n(),d=r(),h=o(),v="undefined"!=typeof window?window:e;t.exports={assign:g,create:d,trim:h,bind:i,slice:a,each:u,map:s,pluck:c,isList:f,isFunction:l,isObject:p,Global:v}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],4:[function(e,t,n){"use strict";function r(e){if(!e||!s(e))return null;var t="(?:^|.*;\\s*)"+escape(e).replace(/[\-\.\+\*]/g,"\\$&")+"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";return unescape(p.cookie.replace(new RegExp(t),"$1"))}function o(e){for(var t=p.cookie.split(/; ?/g),n=t.length-1;n>=0;n--)if(l(t[n])){var r=t[n].split("="),o=unescape(r[0]),i=unescape(r[1]);e(i,o)}}function i(e,t){e&&(p.cookie=escape(e)+"="+escape(t)+"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/")}function a(e){e&&s(e)&&(p.cookie=escape(e)+"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/")}function u(){o(function(e,t){a(t)})}function s(e){return new RegExp("(?:^|;\\s*)"+escape(e).replace(/[\-\.\+\*]/g,"\\$&")+"\\s*\\=").test(p.cookie)}var c=e("../src/util"),f=c.Global,l=c.trim;t.exports={name:"cookieStorage",read:r,write:i,each:o,remove:a,clearAll:u};var p=f.document},{"../src/util":3}],5:[function(e,t,n){"use strict";function r(){return f.localStorage}function o(e){return r().getItem(e)}function i(e,t){return r().setItem(e,t)}function a(e){for(var t=r().length-1;t>=0;t--){var n=r().key(t);e(o(n),n)}}function u(e){return r().removeItem(e)}function s(){return r().clear()}var c=e("../src/util"),f=c.Global;t.exports={name:"localStorage",read:o,write:i,each:a,remove:u,clearAll:s}},{"../src/util":3}],6:[function(e,t,n){"use strict";function r(e){return s[e]}function o(e,t){s[e]=t}function i(e){for(var t in s)s.hasOwnProperty(t)&&e(s[t],t)}function a(e){delete s[e]}function u(e){s={}}t.exports={name:"memoryStorage",read:r,write:o,each:i,remove:a,clearAll:u};var s={}},{}],7:[function(e,t,n){"use strict";function r(){return f.sessionStorage}function o(e){return r().getItem(e)}function i(e,t){return r().setItem(e,t)}function a(e){for(var t=r().length-1;t>=0;t--){var n=r().key(t);e(o(n),n)}}function u(e){return r().removeItem(e)}function s(){return r().clear()}var c=e("../src/util"),f=c.Global;t.exports={name:"sessionStorage",read:o,write:i,each:a,remove:u,clearAll:s}},{"../src/util":3}]},{},[1])(1)});;

// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// 2016-07-07, Brian Grinstead, MIT License
!function(a){function b(a,d){if(a=a?a:"",d=d||{},a instanceof b)return a;if(!(this instanceof b))return new b(a,d);var e=c(a);this._originalInput=a,this._r=e.r,this._g=e.g,this._b=e.b,this._a=e.a,this._roundA=P(100*this._a)/100,this._format=d.format||e.format,this._gradientType=d.gradientType,this._r<1&&(this._r=P(this._r)),this._g<1&&(this._g=P(this._g)),this._b<1&&(this._b=P(this._b)),this._ok=e.ok,this._tc_id=O++}function c(a){var b={r:0,g:0,b:0},c=1,e=null,g=null,i=null,j=!1,k=!1;return"string"==typeof a&&(a=K(a)),"object"==typeof a&&(J(a.r)&&J(a.g)&&J(a.b)?(b=d(a.r,a.g,a.b),j=!0,k="%"===String(a.r).substr(-1)?"prgb":"rgb"):J(a.h)&&J(a.s)&&J(a.v)?(e=G(a.s),g=G(a.v),b=h(a.h,e,g),j=!0,k="hsv"):J(a.h)&&J(a.s)&&J(a.l)&&(e=G(a.s),i=G(a.l),b=f(a.h,e,i),j=!0,k="hsl"),a.hasOwnProperty("a")&&(c=a.a)),c=z(c),{ok:j,format:a.format||k,r:Q(255,R(b.r,0)),g:Q(255,R(b.g,0)),b:Q(255,R(b.b,0)),a:c}}function d(a,b,c){return{r:255*A(a,255),g:255*A(b,255),b:255*A(c,255)}}function e(a,b,c){a=A(a,255),b=A(b,255),c=A(c,255);var d,e,f=R(a,b,c),g=Q(a,b,c),h=(f+g)/2;if(f==g)d=e=0;else{var i=f-g;switch(e=h>.5?i/(2-f-g):i/(f+g),f){case a:d=(b-c)/i+(c>b?6:0);break;case b:d=(c-a)/i+2;break;case c:d=(a-b)/i+4}d/=6}return{h:d,s:e,l:h}}function f(a,b,c){function d(a,b,c){return 0>c&&(c+=1),c>1&&(c-=1),1/6>c?a+6*(b-a)*c:.5>c?b:2/3>c?a+6*(b-a)*(2/3-c):a}var e,f,g;if(a=A(a,360),b=A(b,100),c=A(c,100),0===b)e=f=g=c;else{var h=.5>c?c*(1+b):c+b-c*b,i=2*c-h;e=d(i,h,a+1/3),f=d(i,h,a),g=d(i,h,a-1/3)}return{r:255*e,g:255*f,b:255*g}}function g(a,b,c){a=A(a,255),b=A(b,255),c=A(c,255);var d,e,f=R(a,b,c),g=Q(a,b,c),h=f,i=f-g;if(e=0===f?0:i/f,f==g)d=0;else{switch(f){case a:d=(b-c)/i+(c>b?6:0);break;case b:d=(c-a)/i+2;break;case c:d=(a-b)/i+4}d/=6}return{h:d,s:e,v:h}}function h(b,c,d){b=6*A(b,360),c=A(c,100),d=A(d,100);var e=a.floor(b),f=b-e,g=d*(1-c),h=d*(1-f*c),i=d*(1-(1-f)*c),j=e%6,k=[d,h,g,g,i,d][j],l=[i,d,d,h,g,g][j],m=[g,g,i,d,d,h][j];return{r:255*k,g:255*l,b:255*m}}function i(a,b,c,d){var e=[F(P(a).toString(16)),F(P(b).toString(16)),F(P(c).toString(16))];return d&&e[0].charAt(0)==e[0].charAt(1)&&e[1].charAt(0)==e[1].charAt(1)&&e[2].charAt(0)==e[2].charAt(1)?e[0].charAt(0)+e[1].charAt(0)+e[2].charAt(0):e.join("")}function j(a,b,c,d,e){var f=[F(P(a).toString(16)),F(P(b).toString(16)),F(P(c).toString(16)),F(H(d))];return e&&f[0].charAt(0)==f[0].charAt(1)&&f[1].charAt(0)==f[1].charAt(1)&&f[2].charAt(0)==f[2].charAt(1)&&f[3].charAt(0)==f[3].charAt(1)?f[0].charAt(0)+f[1].charAt(0)+f[2].charAt(0)+f[3].charAt(0):f.join("")}function k(a,b,c,d){var e=[F(H(d)),F(P(a).toString(16)),F(P(b).toString(16)),F(P(c).toString(16))];return e.join("")}function l(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.s-=c/100,d.s=B(d.s),b(d)}function m(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.s+=c/100,d.s=B(d.s),b(d)}function n(a){return b(a).desaturate(100)}function o(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.l+=c/100,d.l=B(d.l),b(d)}function p(a,c){c=0===c?0:c||10;var d=b(a).toRgb();return d.r=R(0,Q(255,d.r-P(255*-(c/100)))),d.g=R(0,Q(255,d.g-P(255*-(c/100)))),d.b=R(0,Q(255,d.b-P(255*-(c/100)))),b(d)}function q(a,c){c=0===c?0:c||10;var d=b(a).toHsl();return d.l-=c/100,d.l=B(d.l),b(d)}function r(a,c){var d=b(a).toHsl(),e=(d.h+c)%360;return d.h=0>e?360+e:e,b(d)}function s(a){var c=b(a).toHsl();return c.h=(c.h+180)%360,b(c)}function t(a){var c=b(a).toHsl(),d=c.h;return[b(a),b({h:(d+120)%360,s:c.s,l:c.l}),b({h:(d+240)%360,s:c.s,l:c.l})]}function u(a){var c=b(a).toHsl(),d=c.h;return[b(a),b({h:(d+90)%360,s:c.s,l:c.l}),b({h:(d+180)%360,s:c.s,l:c.l}),b({h:(d+270)%360,s:c.s,l:c.l})]}function v(a){var c=b(a).toHsl(),d=c.h;return[b(a),b({h:(d+72)%360,s:c.s,l:c.l}),b({h:(d+216)%360,s:c.s,l:c.l})]}function w(a,c,d){c=c||6,d=d||30;var e=b(a).toHsl(),f=360/d,g=[b(a)];for(e.h=(e.h-(f*c>>1)+720)%360;--c;)e.h=(e.h+f)%360,g.push(b(e));return g}function x(a,c){c=c||6;for(var d=b(a).toHsv(),e=d.h,f=d.s,g=d.v,h=[],i=1/c;c--;)h.push(b({h:e,s:f,v:g})),g=(g+i)%1;return h}function y(a){var b={};for(var c in a)a.hasOwnProperty(c)&&(b[a[c]]=c);return b}function z(a){return a=parseFloat(a),(isNaN(a)||0>a||a>1)&&(a=1),a}function A(b,c){D(b)&&(b="100%");var d=E(b);return b=Q(c,R(0,parseFloat(b))),d&&(b=parseInt(b*c,10)/100),a.abs(b-c)<1e-6?1:b%c/parseFloat(c)}function B(a){return Q(1,R(0,a))}function C(a){return parseInt(a,16)}function D(a){return"string"==typeof a&&-1!=a.indexOf(".")&&1===parseFloat(a)}function E(a){return"string"==typeof a&&-1!=a.indexOf("%")}function F(a){return 1==a.length?"0"+a:""+a}function G(a){return 1>=a&&(a=100*a+"%"),a}function H(b){return a.round(255*parseFloat(b)).toString(16)}function I(a){return C(a)/255}function J(a){return!!V.CSS_UNIT.exec(a)}function K(a){a=a.replace(M,"").replace(N,"").toLowerCase();var b=!1;if(T[a])a=T[a],b=!0;else if("transparent"==a)return{r:0,g:0,b:0,a:0,format:"name"};var c;return(c=V.rgb.exec(a))?{r:c[1],g:c[2],b:c[3]}:(c=V.rgba.exec(a))?{r:c[1],g:c[2],b:c[3],a:c[4]}:(c=V.hsl.exec(a))?{h:c[1],s:c[2],l:c[3]}:(c=V.hsla.exec(a))?{h:c[1],s:c[2],l:c[3],a:c[4]}:(c=V.hsv.exec(a))?{h:c[1],s:c[2],v:c[3]}:(c=V.hsva.exec(a))?{h:c[1],s:c[2],v:c[3],a:c[4]}:(c=V.hex8.exec(a))?{r:C(c[1]),g:C(c[2]),b:C(c[3]),a:I(c[4]),format:b?"name":"hex8"}:(c=V.hex6.exec(a))?{r:C(c[1]),g:C(c[2]),b:C(c[3]),format:b?"name":"hex"}:(c=V.hex4.exec(a))?{r:C(c[1]+""+c[1]),g:C(c[2]+""+c[2]),b:C(c[3]+""+c[3]),a:I(c[4]+""+c[4]),format:b?"name":"hex8"}:(c=V.hex3.exec(a))?{r:C(c[1]+""+c[1]),g:C(c[2]+""+c[2]),b:C(c[3]+""+c[3]),format:b?"name":"hex"}:!1}function L(a){var b,c;return a=a||{level:"AA",size:"small"},b=(a.level||"AA").toUpperCase(),c=(a.size||"small").toLowerCase(),"AA"!==b&&"AAA"!==b&&(b="AA"),"small"!==c&&"large"!==c&&(c="small"),{level:b,size:c}}var M=/^\s+/,N=/\s+$/,O=0,P=a.round,Q=a.min,R=a.max,S=a.random;b.prototype={isDark:function(){return this.getBrightness()<128},isLight:function(){return!this.isDark()},isValid:function(){return this._ok},getOriginalInput:function(){return this._originalInput},getFormat:function(){return this._format},getAlpha:function(){return this._a},getBrightness:function(){var a=this.toRgb();return(299*a.r+587*a.g+114*a.b)/1e3},getLuminance:function(){var b,c,d,e,f,g,h=this.toRgb();return b=h.r/255,c=h.g/255,d=h.b/255,e=.03928>=b?b/12.92:a.pow((b+.055)/1.055,2.4),f=.03928>=c?c/12.92:a.pow((c+.055)/1.055,2.4),g=.03928>=d?d/12.92:a.pow((d+.055)/1.055,2.4),.2126*e+.7152*f+.0722*g},setAlpha:function(a){return this._a=z(a),this._roundA=P(100*this._a)/100,this},toHsv:function(){var a=g(this._r,this._g,this._b);return{h:360*a.h,s:a.s,v:a.v,a:this._a}},toHsvString:function(){var a=g(this._r,this._g,this._b),b=P(360*a.h),c=P(100*a.s),d=P(100*a.v);return 1==this._a?"hsv("+b+", "+c+"%, "+d+"%)":"hsva("+b+", "+c+"%, "+d+"%, "+this._roundA+")"},toHsl:function(){var a=e(this._r,this._g,this._b);return{h:360*a.h,s:a.s,l:a.l,a:this._a}},toHslString:function(){var a=e(this._r,this._g,this._b),b=P(360*a.h),c=P(100*a.s),d=P(100*a.l);return 1==this._a?"hsl("+b+", "+c+"%, "+d+"%)":"hsla("+b+", "+c+"%, "+d+"%, "+this._roundA+")"},toHex:function(a){return i(this._r,this._g,this._b,a)},toHexString:function(a){return"#"+this.toHex(a)},toHex8:function(a){return j(this._r,this._g,this._b,this._a,a)},toHex8String:function(a){return"#"+this.toHex8(a)},toRgb:function(){return{r:P(this._r),g:P(this._g),b:P(this._b),a:this._a}},toRgbString:function(){return 1==this._a?"rgb("+P(this._r)+", "+P(this._g)+", "+P(this._b)+")":"rgba("+P(this._r)+", "+P(this._g)+", "+P(this._b)+", "+this._roundA+")"},toPercentageRgb:function(){return{r:P(100*A(this._r,255))+"%",g:P(100*A(this._g,255))+"%",b:P(100*A(this._b,255))+"%",a:this._a}},toPercentageRgbString:function(){return 1==this._a?"rgb("+P(100*A(this._r,255))+"%, "+P(100*A(this._g,255))+"%, "+P(100*A(this._b,255))+"%)":"rgba("+P(100*A(this._r,255))+"%, "+P(100*A(this._g,255))+"%, "+P(100*A(this._b,255))+"%, "+this._roundA+")"},toName:function(){return 0===this._a?"transparent":this._a<1?!1:U[i(this._r,this._g,this._b,!0)]||!1},toFilter:function(a){var c="#"+k(this._r,this._g,this._b,this._a),d=c,e=this._gradientType?"GradientType = 1, ":"";if(a){var f=b(a);d="#"+k(f._r,f._g,f._b,f._a)}return"progid:DXImageTransform.Microsoft.gradient("+e+"startColorstr="+c+",endColorstr="+d+")"},toString:function(a){var b=!!a;a=a||this._format;var c=!1,d=this._a<1&&this._a>=0,e=!b&&d&&("hex"===a||"hex6"===a||"hex3"===a||"hex4"===a||"hex8"===a||"name"===a);return e?"name"===a&&0===this._a?this.toName():this.toRgbString():("rgb"===a&&(c=this.toRgbString()),"prgb"===a&&(c=this.toPercentageRgbString()),("hex"===a||"hex6"===a)&&(c=this.toHexString()),"hex3"===a&&(c=this.toHexString(!0)),"hex4"===a&&(c=this.toHex8String(!0)),"hex8"===a&&(c=this.toHex8String()),"name"===a&&(c=this.toName()),"hsl"===a&&(c=this.toHslString()),"hsv"===a&&(c=this.toHsvString()),c||this.toHexString())},clone:function(){return b(this.toString())},_applyModification:function(a,b){var c=a.apply(null,[this].concat([].slice.call(b)));return this._r=c._r,this._g=c._g,this._b=c._b,this.setAlpha(c._a),this},lighten:function(){return this._applyModification(o,arguments)},brighten:function(){return this._applyModification(p,arguments)},darken:function(){return this._applyModification(q,arguments)},desaturate:function(){return this._applyModification(l,arguments)},saturate:function(){return this._applyModification(m,arguments)},greyscale:function(){return this._applyModification(n,arguments)},spin:function(){return this._applyModification(r,arguments)},_applyCombination:function(a,b){return a.apply(null,[this].concat([].slice.call(b)))},analogous:function(){return this._applyCombination(w,arguments)},complement:function(){return this._applyCombination(s,arguments)},monochromatic:function(){return this._applyCombination(x,arguments)},splitcomplement:function(){return this._applyCombination(v,arguments)},triad:function(){return this._applyCombination(t,arguments)},tetrad:function(){return this._applyCombination(u,arguments)}},b.fromRatio=function(a,c){if("object"==typeof a){var d={};for(var e in a)a.hasOwnProperty(e)&&(d[e]="a"===e?a[e]:G(a[e]));a=d}return b(a,c)},b.equals=function(a,c){return a&&c?b(a).toRgbString()==b(c).toRgbString():!1},b.random=function(){return b.fromRatio({r:S(),g:S(),b:S()})},b.mix=function(a,c,d){d=0===d?0:d||50;var e=b(a).toRgb(),f=b(c).toRgb(),g=d/100,h={r:(f.r-e.r)*g+e.r,g:(f.g-e.g)*g+e.g,b:(f.b-e.b)*g+e.b,a:(f.a-e.a)*g+e.a};return b(h)},b.readability=function(c,d){var e=b(c),f=b(d);return(a.max(e.getLuminance(),f.getLuminance())+.05)/(a.min(e.getLuminance(),f.getLuminance())+.05)},b.isReadable=function(a,c,d){var e,f,g=b.readability(a,c);switch(f=!1,e=L(d),e.level+e.size){case"AAsmall":case"AAAlarge":f=g>=4.5;break;case"AAlarge":f=g>=3;break;case"AAAsmall":f=g>=7}return f},b.mostReadable=function(a,c,d){var e,f,g,h,i=null,j=0;d=d||{},f=d.includeFallbackColors,g=d.level,h=d.size;for(var k=0;k<c.length;k++)e=b.readability(a,c[k]),e>j&&(j=e,i=b(c[k]));return b.isReadable(a,i,{level:g,size:h})||!f?i:(d.includeFallbackColors=!1,b.mostReadable(a,["#fff","#000"],d))};var T=b.names={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"0ff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000",blanchedalmond:"ffebcd",blue:"00f",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",burntsienna:"ea7e5d",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"0ff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkgrey:"a9a9a9",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkslategrey:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dimgrey:"696969",dodgerblue:"1e90ff",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"f0f",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",grey:"808080",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgray:"d3d3d3",lightgreen:"90ee90",lightgrey:"d3d3d3",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslategray:"789",lightslategrey:"789",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"0f0",limegreen:"32cd32",linen:"faf0e6",magenta:"f0f",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370db",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"db7093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",rebeccapurple:"663399",red:"f00",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",slategrey:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",wheat:"f5deb3",white:"fff",whitesmoke:"f5f5f5",yellow:"ff0",yellowgreen:"9acd32"},U=b.hexNames=y(T),V=function(){var a="[-\\+]?\\d+%?",b="[-\\+]?\\d*\\.\\d+%?",c="(?:"+b+")|(?:"+a+")",d="[\\s|\\(]+("+c+")[,|\\s]+("+c+")[,|\\s]+("+c+")\\s*\\)?",e="[\\s|\\(]+("+c+")[,|\\s]+("+c+")[,|\\s]+("+c+")[,|\\s]+("+c+")\\s*\\)?";return{CSS_UNIT:new RegExp(c),rgb:new RegExp("rgb"+d),rgba:new RegExp("rgba"+e),hsl:new RegExp("hsl"+d),hsla:new RegExp("hsla"+e),hsv:new RegExp("hsv"+d),hsva:new RegExp("hsva"+e),hex3:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex6:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,hex4:/^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,hex8:/^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/}}();"undefined"!=typeof module&&module.exports?module.exports=b:"function"==typeof define&&define.amd?define(function(){return b}):window.tinycolor=b}(Math);;

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.superagent = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

/**
 * Expose `Emitter`.
 */
if (typeof module !== 'undefined') {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  } // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.


  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],2:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = stringify;
stringify.default = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;
var arr = []; // Regular stringify

function stringify(obj, replacer, spacer) {
  decirc(obj, '', [], undefined);
  var res = JSON.stringify(obj, replacer, spacer);

  while (arr.length !== 0) {
    var part = arr.pop();
    part[0][part[1]] = part[2];
  }

  return res;
}

function decirc(val, k, stack, parent) {
  var i;

  if (_typeof(val) === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]';
        arr.push([parent, k, val]);
        return;
      }
    }

    stack.push(val); // Optimize for Arrays. Big arrays could kill the performance otherwise!

    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, stack, val);
      }
    } else {
      var keys = Object.keys(val);

      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, stack, val);
      }
    }

    stack.pop();
  }
} // Stable-stringify


function compareFunction(a, b) {
  if (a < b) {
    return -1;
  }

  if (a > b) {
    return 1;
  }

  return 0;
}

function deterministicStringify(obj, replacer, spacer) {
  var tmp = deterministicDecirc(obj, '', [], undefined) || obj;
  var res = JSON.stringify(tmp, replacer, spacer);

  while (arr.length !== 0) {
    var part = arr.pop();
    part[0][part[1]] = part[2];
  }

  return res;
}

function deterministicDecirc(val, k, stack, parent) {
  var i;

  if (_typeof(val) === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        parent[k] = '[Circular]';
        arr.push([parent, k, val]);
        return;
      }
    }

    if (typeof val.toJSON === 'function') {
      return;
    }

    stack.push(val); // Optimize for Arrays. Big arrays could kill the performance otherwise!

    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, stack, val);
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {};
      var keys = Object.keys(val).sort(compareFunction);

      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        deterministicDecirc(val[key], key, stack, val);
        tmp[key] = val[key];
      }

      if (parent !== undefined) {
        arr.push([parent, k, val]);
        parent[k] = tmp;
      } else {
        return tmp;
      }
    }

    stack.pop();
  }
}

},{}],3:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function Agent() {
  this._defaults = [];
}

['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert'].forEach(function (fn) {
  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this._defaults.push({
      fn: fn,
      args: args
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, _toConsumableArray(def.args));
  });
};

module.exports = Agent;

},{}],4:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
function isObject(obj) {
  return obj !== null && _typeof(obj) === 'object';
}

module.exports = isObject;

},{}],5:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Root reference for iframes.
 */
var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self === 'undefined') {
  // Other environments
  console.warn('Using browser-only version of superagent in non-browser environment');
  root = void 0;
} else {
  // Web Worker
  root = self;
}

var Emitter = require('component-emitter');

var safeStringify = require('fast-safe-stringify');

var RequestBase = require('./request-base');

var isObject = require('./is-object');

var ResponseBase = require('./response-base');

var Agent = require('./agent-base');
/**
 * Noop.
 */


function noop() {}
/**
 * Expose `request`.
 */


module.exports = function (method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (arguments.length === 1) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports = module.exports;
var request = exports;
exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || root.location.protocol !== 'file:' || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  }

  try {
    return new ActiveXObject('Microsoft.XMLHTTP');
  } catch (err) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.6.0');
  } catch (err) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP.3.0');
  } catch (err) {}

  try {
    return new ActiveXObject('Msxml2.XMLHTTP');
  } catch (err) {}

  throw new Error('Browser-only version of superagent could not find XHR');
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */


var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) pushEncodedKeyValuePair(pairs, key, obj[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */


function pushEncodedKeyValuePair(pairs, key, val) {
  if (val === undefined) return;

  if (val === null) {
    pairs.push(encodeURIComponent(key));
    return;
  }

  if (Array.isArray(val)) {
    val.forEach(function (v) {
      pushEncodedKeyValuePair(pairs, key, v);
    });
  } else if (isObject(val)) {
    for (var subkey in val) {
      if (Object.prototype.hasOwnProperty.call(val, subkey)) pushEncodedKeyValuePair(pairs, "".concat(key, "[").concat(subkey, "]"), val[subkey]);
    }
  } else {
    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
  }
}
/**
 * Expose serialization method.
 */


request.serializeObject = serialize;
/**
 * Parse the given x-www-form-urlencoded `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos === -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}
/**
 * Expose parser.
 */


request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  form: 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': safeStringify
};
/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(str){
 *       return { object parsed from str };
 *     };
 *
 */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[/+]json($|[^-\w])/.test(mime);
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */


function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method !== 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  this.header = this.headers; // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (this.text === null && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method === 'HEAD' ? null : this._parseBody(this.text ? this.text : this.xhr.response);
  }
} // eslint-disable-next-line new-cap


ResponseBase(Response.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, str);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && str && (str.length > 0 || str instanceof Object) ? parse(str) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var msg = "cannot ".concat(method, " ").concat(url, " (").concat(this.status, ")");
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;
  return err;
};
/**
 * Expose `Response`.
 */


request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (err2) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = err2; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType === 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);
    var new_err;

    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (err2) {
      new_err = err2; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */
// eslint-disable-next-line new-cap


Emitter(Request.prototype); // eslint-disable-next-line new-cap

RequestBase(Request.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: typeof btoa === 'function' ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if (typeof btoa === 'function') {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (val) {
  if (typeof val !== 'string') val = serialize(val);
  if (val) this._query.push(val);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */


Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;
  err.status = this.status;
  err.method = this.method;
  err.url = this.url;
  this.callback(err);
}; // This only warns, because the request is still likely to work


Request.prototype.agent = function () {
  console.warn('This is not supported in browser version of superagent');
  return this;
};

Request.prototype.buffer = Request.prototype.ca;
Request.prototype.ca = Request.prototype.agent; // This throws, because it can't send/receive data as expected

Request.prototype.write = function () {
  throw new Error('Streaming is not supported in browser version of superagent');
};

Request.prototype.pipe = Request.prototype.write;
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj host object
 * @return {Boolean} is a host object
 * @api private
 */

Request.prototype._isHost = function (obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && _typeof(obj) === 'object' && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn('Warning: .end() was called twice. This is not supported in superagent');
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  this._end();
};

Request.prototype._setUploadTimeout = function () {
  var self = this; // upload timeout it's wokrs only if deadline timeout is off

  if (this._uploadTimeout && !this._uploadTimeoutTimer) {
    this._uploadTimeoutTimer = setTimeout(function () {
      self._timeoutError('Upload timeout of ', self._uploadTimeout, 'ETIMEDOUT');
    }, this._uploadTimeout);
  }
}; // eslint-disable-next-line complexity


Request.prototype._end = function () {
  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  var self = this;
  this.xhr = request.getXHR();
  var xhr = this.xhr;
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (readyState !== 4) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (err) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }; // progress


  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;

      if (e.percent === 100) {
        clearTimeout(self._uploadTimeoutTimer);
      }
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.addEventListener('progress', handleProgress.bind(null, 'download'));

      if (xhr.upload) {
        xhr.upload.addEventListener('progress', handleProgress.bind(null, 'upload'));
      }
    } catch (err) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  if (xhr.upload) {
    this._setUploadTimeout();
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && this.method !== 'GET' && this.method !== 'HEAD' && typeof data !== 'string' && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];

    var _serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!_serialize && isJSON(contentType)) {
      _serialize = request.serialize['application/json'];
    }

    if (_serialize) data = _serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (this.header[field] === null) continue;
    if (Object.prototype.hasOwnProperty.call(this.header, field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data === 'undefined' ? null : data);
};

request.agent = function () {
  return new Agent();
};

['GET', 'POST', 'OPTIONS', 'PATCH', 'PUT', 'DELETE'].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);

    this._setDefaults(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype.delete;
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.head = function (url, data, fn) {
  var req = request('HEAD', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


function del(url, data, fn) {
  var req = request('DELETE', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request.del = del;
request.delete = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.post = function (url, data, fn) {
  var req = request('POST', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.put = function (url, data, fn) {
  var req = request('PUT', url);

  if (typeof data === 'function') {
    fn = data;
    data = null;
  }

  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":3,"./is-object":4,"./request-base":6,"./response-base":7,"component-emitter":1,"fast-safe-stringify":2}],6:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in RequestBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(RequestBase.prototype, key)) obj[key] = RequestBase.prototype[key];
  }

  return obj;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function () {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  clearTimeout(this._uploadTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  delete this._uploadTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function (fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function (fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 * - upload is the time  since last bit of data was sent or received. This timeout works only if deadline timeout is off
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function (options) {
  if (!options || _typeof(options) !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    this._uploadTimeout = 0;
    return this;
  }

  for (var option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      switch (option) {
        case 'deadline':
          this._timeout = options.deadline;
          break;

        case 'response':
          this._responseTimeout = options.response;
          break;

        case 'upload':
          this._uploadTimeout = options.upload;
          break;

        default:
          console.warn('Unknown timeout option', option);
      }
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function (count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];
/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err an error
 * @param {Response} [res] response
 * @returns {Boolean} if segment should be retried
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (err2) {
      console.error(err2);
    }
  }

  if (res && res.status && res.status >= 500 && res.status !== 501) return true;

  if (err) {
    if (err.code && ERROR_CODES.indexOf(err.code) !== -1) return true; // Superagent timeout

    if (err.timeout && err.code === 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function (resolve, reject) {
  var _this = this;

  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }

    this._fullfilledPromise = new Promise(function (resolve, reject) {
      self.on('abort', function () {
        var err = new Error('Aborted');
        err.code = 'ABORTED';
        err.status = _this.status;
        err.method = _this.method;
        err.url = _this.url;
        reject(err);
      });
      self.end(function (err, res) {
        if (err) reject(err);else resolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype.catch = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function (fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if (typeof cb !== 'function') throw new Error('Callback required');
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      if (Object.prototype.hasOwnProperty.call(field, key)) this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
}; // eslint-disable-next-line valid-jsdoc

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field field name
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name name of field
 * @param {String|Blob|File|Buffer|fs.ReadStream} val value of field
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      if (Object.prototype.hasOwnProperty.call(name, key)) this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      if (Object.prototype.hasOwnProperty.call(val, i)) this.field(name, val[i]);
    }

    return this;
  } // val should be defined now


  if (val === null || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if (typeof val === 'boolean') {
    val = String(val);
  }

  this._getFormData().append(name, val);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request} request
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  if (this.xhr) this.xhr.abort(); // browser

  if (this.req) this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', "Basic ".concat(base64Encoder("".concat(user, ":").concat(pass))));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', "Bearer ".concat(user));
      break;

    default:
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on === undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does nothing in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n number of bytes
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */
// eslint-disable-next-line complexity


RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  } // merge


  if (isObj && isObject(this._data)) {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) this._data[key] = data[key];
    }
  } else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];

    if (type === 'application/x-www-form-urlencoded') {
      this._data = this._data ? "".concat(this._data, "&").concat(data) : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');

      if (typeof this._sort === 'function') {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }

      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.warn('Unsupported');
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error("".concat(reason + timeout, "ms exceeded"));
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":4}],7:[function(require,module,exports){
"use strict";

/**
 * Module dependencies.
 */
var utils = require('./utils');
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    if (Object.prototype.hasOwnProperty.call(ResponseBase.prototype, key)) obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    if (Object.prototype.hasOwnProperty.call(params, key)) this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.statusCode = status;
  this.status = this.statusCode;
  this.statusType = type; // basics

  this.info = type === 1;
  this.ok = type === 2;
  this.redirect = type === 3;
  this.clientError = type === 4;
  this.serverError = type === 5;
  this.error = type === 4 || type === 5 ? this.toError() : false; // sugar

  this.created = status === 201;
  this.accepted = status === 202;
  this.noContent = status === 204;
  this.badRequest = status === 400;
  this.unauthorized = status === 401;
  this.notAcceptable = status === 406;
  this.forbidden = status === 403;
  this.notFound = status === 404;
  this.unprocessableEntity = status === 422;
};

},{"./utils":8}],8:[function(require,module,exports){
"use strict";

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */
exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();
    if (key && val) obj[key] = val;
    return obj;
  }, {});
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host; // secuirty

  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }

  return header;
};

},{}]},{},[5])(5)
});
;

/* mousetrap v1.6.3 craig.is/killing/mice */
(function(q,u,c){function v(a,b,g){a.addEventListener?a.addEventListener(b,g,!1):a.attachEvent("on"+b,g)}function z(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return n[a.which]?n[a.which]:r[a.which]?r[a.which]:String.fromCharCode(a.which).toLowerCase()}function F(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function w(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function A(a,b){var g,d=[];var e=a;"+"===e?e=["+"]:(e=e.replace(/\+{2}/g,"+plus"),e=e.split("+"));for(g=0;g<e.length;++g){var m=e[g];B[m]&&(m=B[m]);b&&"keypress"!=b&&C[m]&&(m=C[m],d.push("shift"));w(m)&&d.push(m)}e=m;g=b;if(!g){if(!p){p={};for(var c in n)95<c&&112>c||n.hasOwnProperty(c)&&(p[n[c]]=c)}g=p[e]?"keydown":"keypress"}"keypress"==g&&d.length&&(g="keydown");return{key:m,modifiers:d,action:g}}function D(a,b){return null===a||a===u?!1:a===b?!0:D(a.parentNode,b)}function d(a){function b(a){a=
a||{};var b=!1,l;for(l in p)a[l]?b=!0:p[l]=0;b||(x=!1)}function g(a,b,t,f,g,d){var l,E=[],h=t.type;if(!k._callbacks[a])return[];"keyup"==h&&w(a)&&(b=[a]);for(l=0;l<k._callbacks[a].length;++l){var c=k._callbacks[a][l];if((f||!c.seq||p[c.seq]==c.level)&&h==c.action){var e;(e="keypress"==h&&!t.metaKey&&!t.ctrlKey)||(e=c.modifiers,e=b.sort().join(",")===e.sort().join(","));e&&(e=f&&c.seq==f&&c.level==d,(!f&&c.combo==g||e)&&k._callbacks[a].splice(l,1),E.push(c))}}return E}function c(a,b,c,f){k.stopCallback(b,
b.target||b.srcElement,c,f)||!1!==a(b,c)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=z(a);b&&("keyup"==a.type&&y===b?y=!1:k.handleKey(b,F(a),a))}function m(a,g,t,f){function h(c){return function(){x=c;++p[a];clearTimeout(q);q=setTimeout(b,1E3)}}function l(g){c(t,g,a);"keyup"!==f&&(y=z(g));setTimeout(b,10)}for(var d=p[a]=0;d<g.length;++d){var e=d+1===g.length?l:h(f||
A(g[d+1]).action);n(g[d],e,f,a,d)}}function n(a,b,c,f,d){k._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var e=a.split(" ");1<e.length?m(a,e,b,c):(c=A(a,c),k._callbacks[c.key]=k._callbacks[c.key]||[],g(c.key,c.modifiers,{type:c.action},f,a,d),k._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:d,combo:a}))}var k=this;a=a||u;if(!(k instanceof d))return new d(a);k.target=a;k._callbacks={};k._directMap={};var p={},q,y=!1,r=!1,x=!1;k._handleKey=function(a,
d,e){var f=g(a,d,e),h;d={};var k=0,l=!1;for(h=0;h<f.length;++h)f[h].seq&&(k=Math.max(k,f[h].level));for(h=0;h<f.length;++h)f[h].seq?f[h].level==k&&(l=!0,d[f[h].seq]=1,c(f[h].callback,e,f[h].combo,f[h].seq)):l||c(f[h].callback,e,f[h].combo);f="keypress"==e.type&&r;e.type!=x||w(a)||f||b(d);r=l&&"keydown"==e.type};k._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)n(a[d],b,c)};v(a,"keypress",e);v(a,"keydown",e);v(a,"keyup",e)}if(q){var n={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},r={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},C={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},B={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},p;for(c=1;20>c;++c)n[111+c]="f"+c;for(c=0;9>=c;++c)n[c+96]=c.toString();d.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};d.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};d.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};d.prototype.reset=function(){this._callbacks={};
this._directMap={};return this};d.prototype.stopCallback=function(a,b){if(-1<(" "+b.className+" ").indexOf(" mousetrap ")||D(b,this.target))return!1;if("composedPath"in a&&"function"===typeof a.composedPath){var c=a.composedPath()[0];c!==a.target&&(b=c)}return"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};d.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};d.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(n[b]=a[b]);p=null};
d.init=function(){var a=d(u),b;for(b in a)"_"!==b.charAt(0)&&(d[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};d.init();q.Mousetrap=d;"undefined"!==typeof module&&module.exports&&(module.exports=d);"function"===typeof define&&define.amd&&define(function(){return d})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);
;

/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});
;

/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)})(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}function i(t){for(var e,i;t.length&&t[0]!==document;){if(e=t.css("position"),("absolute"===e||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!isNaN(i)&&0!==i))return i;t=t.parent()}return 0}function s(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},t.extend(this._defaults,this.regional[""]),this.regional.en=t.extend(!0,{},this.regional[""]),this.regional["en-US"]=t.extend(!0,{},this.regional.en),this.dpDiv=n(t("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function n(e){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return e.on("mouseout",i,function(){t(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",i,o)}function o(){t.datepicker._isDisabledDatepicker(m.inline?m.dpDiv.parent()[0]:m.input[0])||(t(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),t(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).addClass("ui-datepicker-next-hover"))}function a(e,i){t.extend(e,i);for(var s in i)null==i[s]&&(e[s]=i[s]);return e}function r(t){return function(){var e=this.element.val();t.apply(this,arguments),this._refresh(),e!==this.element.val()&&this._trigger("change")}}t.ui=t.ui||{},t.ui.version="1.12.1";var h=0,l=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},h=e.split(".")[0];e=e.split(".")[1];var l=h+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[h]=t[h]||{},n=t[h][e],o=t[h][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:h,widgetName:e,widgetFullName:l}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var i,s,n=l.call(arguments,1),o=0,a=n.length;a>o;o++)for(i in n[o])s=n[o][i],n[o].hasOwnProperty(i)&&void 0!==s&&(e[i]=t.isPlainObject(s)?t.isPlainObject(e[i])?t.widget.extend({},e[i],s):t.widget.extend({},s):s);return e},t.widget.bridge=function(e,i){var s=i.prototype.widgetFullName||e;t.fn[e]=function(n){var o="string"==typeof n,a=l.call(arguments,1),r=this;return o?this.length||"instance"!==n?this.each(function(){var i,o=t.data(this,s);return"instance"===n?(r=o,!1):o?t.isFunction(o[n])&&"_"!==n.charAt(0)?(i=o[n].apply(o,a),i!==o&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+n+"'")}):r=void 0:(a.length&&(n=t.widget.extend.apply(null,[n].concat(a))),this.each(function(){var e=t.data(this,s);e?(e.option(n||{}),e._init&&e._init()):t.data(this,s,new i(n,this))})),r}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,i){i=t(i||this.defaultElement||this)[0],this.element=t(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},i!==this&&(t.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===i&&this.destroy()}}),this.document=t(i.style?i.ownerDocument:i.document||i),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+o.eventNamespace,c=h[2];c?n.on(l,c,r):i.on(l,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var n,o=Math.max,a=Math.abs,r=/left|center|right/,h=/top|center|bottom/,l=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,d=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType,o=!s&&!n;return{element:i,isWindow:s,isDocument:n,offset:o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return d.apply(this,arguments);n=t.extend({},n);var u,p,f,g,m,_,v=t(n.of),b=t.position.getWithinInfo(n.within),y=t.position.getScrollInfo(b),w=(n.collision||"flip").split(" "),k={};return _=s(v),v[0].preventDefault&&(n.at="left top"),p=_.width,f=_.height,g=_.offset,m=t.extend({},g),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=r.test(i[0])?i.concat(["center"]):h.test(i[0])?["center"].concat(i):["center","center"]),i[0]=r.test(i[0])?i[0]:"center",i[1]=h.test(i[1])?i[1]:"center",t=l.exec(i[0]),e=l.exec(i[1]),k[this]=[t?t[0]:0,e?e[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===n.at[0]?m.left+=p:"center"===n.at[0]&&(m.left+=p/2),"bottom"===n.at[1]?m.top+=f:"center"===n.at[1]&&(m.top+=f/2),u=e(k.at,p,f),m.left+=u[0],m.top+=u[1],this.each(function(){var s,r,h=t(this),l=h.outerWidth(),c=h.outerHeight(),d=i(this,"marginLeft"),_=i(this,"marginTop"),x=l+d+i(this,"marginRight")+y.width,C=c+_+i(this,"marginBottom")+y.height,D=t.extend({},m),I=e(k.my,h.outerWidth(),h.outerHeight());"right"===n.my[0]?D.left-=l:"center"===n.my[0]&&(D.left-=l/2),"bottom"===n.my[1]?D.top-=c:"center"===n.my[1]&&(D.top-=c/2),D.left+=I[0],D.top+=I[1],s={marginLeft:d,marginTop:_},t.each(["left","top"],function(e,i){t.ui.position[w[e]]&&t.ui.position[w[e]][i](D,{targetWidth:p,targetHeight:f,elemWidth:l,elemHeight:c,collisionPosition:s,collisionWidth:x,collisionHeight:C,offset:[u[0]+I[0],u[1]+I[1]],my:n.my,at:n.at,within:b,elem:h})}),n.using&&(r=function(t){var e=g.left-D.left,i=e+p-l,s=g.top-D.top,r=s+f-c,u={target:{element:v,left:g.left,top:g.top,width:p,height:f},element:{element:h,left:D.left,top:D.top,width:l,height:c},horizontal:0>i?"left":e>0?"right":"center",vertical:0>r?"top":s>0?"bottom":"middle"};l>p&&p>a(e+i)&&(u.horizontal="center"),c>f&&f>a(s+r)&&(u.vertical="middle"),u.important=o(a(e),a(i))>o(a(s),a(r))?"horizontal":"vertical",n.using.call(this,t,u)}),h.offset(t.extend(D,{using:r}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,h=n-r,l=r+e.collisionWidth-a-n;e.collisionWidth>a?h>0&&0>=l?(i=t.left+h+e.collisionWidth-a-n,t.left+=h-i):t.left=l>0&&0>=h?n:h>l?n+a-e.collisionWidth:n:h>0?t.left+=h:l>0?t.left-=l:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,h=n-r,l=r+e.collisionHeight-a-n;e.collisionHeight>a?h>0&&0>=l?(i=t.top+h+e.collisionHeight-a-n,t.top+=h-i):t.top=l>0&&0>=h?n:h>l?n+a-e.collisionHeight:n:h>0?t.top+=h:l>0?t.top-=l:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,r=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-h,u=l+e.collisionWidth-r-h,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-r-o,(0>i||a(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-h,(s>0||u>a(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,r=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-h,u=l+e.collisionHeight-r-h,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-r-o,(0>s||a(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-h,(i>0||u>a(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}});var c="ui-effects-",u="ui-effects-style",d="ui-effects-animated",p=t;t.effects={effect:{}},function(t,e){function i(t,e,i){var s=u[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:0>t?0:t>s.max?s.max:t)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(t,o){var a,r=o.re.exec(i),h=r&&o.parse(r),l=o.space||"rgba";return h?(a=s[l](h),s[c[l].cache]=a[c[l].cache],n=s._rgba=a._rgba,!1):e}),n.length?("0,0,0,0"===n.join()&&t.extend(n,o.transparent),s):o[i]}function n(t,e,i){return i=(i+1)%1,1>6*i?t+6*(e-t)*i:1>2*i?e:2>3*i?t+6*(e-t)*(2/3-i):t}var o,a="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],l=t.Color=function(e,i,s,n){return new t.Color.fn.parse(e,i,s,n)},c={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},u={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},d=l.support={},p=t("<p>")[0],f=t.each;p.style.cssText="background-color:rgba(1,1,1,.5)",d.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(c,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),l.fn=t.extend(l.prototype,{parse:function(n,a,r,h){if(n===e)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=t(n).css(a),a=e);var u=this,d=t.type(n),p=this._rgba=[];return a!==e&&(n=[n,a,r,h],d="array"),"string"===d?this.parse(s(n)||o._default):"array"===d?(f(c.rgba.props,function(t,e){p[e.idx]=i(n[e.idx],e)}),this):"object"===d?(n instanceof l?f(c,function(t,e){n[e.cache]&&(u[e.cache]=n[e.cache].slice())}):f(c,function(e,s){var o=s.cache;f(s.props,function(t,e){if(!u[o]&&s.to){if("alpha"===t||null==n[t])return;u[o]=s.to(u._rgba)}u[o][e.idx]=i(n[t],e,!0)}),u[o]&&0>t.inArray(null,u[o].slice(0,3))&&(u[o][3]=1,s.from&&(u._rgba=s.from(u[o])))}),this):e},is:function(t){var i=l(t),s=!0,n=this;return f(c,function(t,o){var a,r=i[o.cache];return r&&(a=n[o.cache]||o.to&&o.to(n._rgba)||[],f(o.props,function(t,i){return null!=r[i.idx]?s=r[i.idx]===a[i.idx]:e})),s}),s},_space:function(){var t=[],e=this;return f(c,function(i,s){e[s.cache]&&t.push(i)}),t.pop()},transition:function(t,e){var s=l(t),n=s._space(),o=c[n],a=0===this.alpha()?l("transparent"):this,r=a[o.cache]||o.to(a._rgba),h=r.slice();return s=s[o.cache],f(o.props,function(t,n){var o=n.idx,a=r[o],l=s[o],c=u[n.type]||{};null!==l&&(null===a?h[o]=l:(c.mod&&(l-a>c.mod/2?a+=c.mod:a-l>c.mod/2&&(a-=c.mod)),h[o]=i((l-a)*e+a,n)))}),this[n](h)},blend:function(e){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(e)._rgba;return l(t.map(i,function(t,e){return(1-s)*n[e]+s*t}))},toRgbaString:function(){var e="rgba(",i=t.map(this._rgba,function(t,e){return null==t?e>2?1:0:t});return 1===i[3]&&(i.pop(),e="rgb("),e+i.join()+")"},toHslaString:function(){var e="hsla(",i=t.map(this.hsla(),function(t,e){return null==t&&(t=e>2?1:0),e&&3>e&&(t=Math.round(100*t)+"%"),t});return 1===i[3]&&(i.pop(),e="hsl("),e+i.join()+")"},toHexString:function(e){var i=this._rgba.slice(),s=i.pop();return e&&i.push(~~(255*s)),"#"+t.map(i,function(t){return t=(t||0).toString(16),1===t.length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,c.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e,i,s=t[0]/255,n=t[1]/255,o=t[2]/255,a=t[3],r=Math.max(s,n,o),h=Math.min(s,n,o),l=r-h,c=r+h,u=.5*c;return e=h===r?0:s===r?60*(n-o)/l+360:n===r?60*(o-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=u?l/c:l/(2-c),[Math.round(e)%360,i,u,null==a?1:a]},c.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],o=t[3],a=.5>=s?s*(1+i):s+i-s*i,r=2*s-a;return[Math.round(255*n(r,a,e+1/3)),Math.round(255*n(r,a,e)),Math.round(255*n(r,a,e-1/3)),o]},f(c,function(s,n){var o=n.props,a=n.cache,h=n.to,c=n.from;l.fn[s]=function(s){if(h&&!this[a]&&(this[a]=h(this._rgba)),s===e)return this[a].slice();var n,r=t.type(s),u="array"===r||"object"===r?s:arguments,d=this[a].slice();return f(o,function(t,e){var s=u["object"===r?t:e.idx];null==s&&(s=d[e.idx]),d[e.idx]=i(s,e)}),c?(n=l(c(d)),n[a]=d,n):l(d)},f(o,function(e,i){l.fn[e]||(l.fn[e]=function(n){var o,a=t.type(n),h="alpha"===e?this._hsla?"hsla":"rgba":s,l=this[h](),c=l[i.idx];return"undefined"===a?c:("function"===a&&(n=n.call(this,c),a=t.type(n)),null==n&&i.empty?this:("string"===a&&(o=r.exec(n),o&&(n=c+parseFloat(o[2])*("+"===o[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(e){var i=e.split(" ");f(i,function(e,i){t.cssHooks[i]={set:function(e,n){var o,a,r="";if("transparent"!==n&&("string"!==t.type(n)||(o=s(n)))){if(n=l(o||n),!d.rgba&&1!==n._rgba[3]){for(a="backgroundColor"===i?e.parentNode:e;(""===r||"transparent"===r)&&a&&a.style;)try{r=t.css(a,"backgroundColor"),a=a.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{e.style[i]=n}catch(h){}}},t.fx.step[i]=function(e){e.colorInit||(e.start=l(e.elem,i),e.end=l(e.end),e.colorInit=!0),t.cssHooks[i].set(e.elem,e.start.transition(e.end,e.pos))}})},l.hook(a),t.cssHooks.borderColor={expand:function(t){var e={};return f(["Top","Right","Bottom","Left"],function(i,s){e["border"+s+"Color"]=t}),e}},o=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(p),function(){function e(e){var i,s,n=e.ownerDocument.defaultView?e.ownerDocument.defaultView.getComputedStyle(e,null):e.currentStyle,o={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(o[t.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(o[i]=n[i]);return o}function i(e,i){var s,o,a={};for(s in i)o=i[s],e[s]!==o&&(n[s]||(t.fx.step[s]||!isNaN(parseFloat(o)))&&(a[s]=o));return a}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};t.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(e,i){t.fx.step[i]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(p.style(t.elem,i,t.end),t.setAttr=!0)}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.effects.animateClass=function(n,o,a,r){var h=t.speed(o,a,r);return this.queue(function(){var o,a=t(this),r=a.attr("class")||"",l=h.children?a.find("*").addBack():a;l=l.map(function(){var i=t(this);return{el:i,start:e(this)}}),o=function(){t.each(s,function(t,e){n[e]&&a[e+"Class"](n[e])})},o(),l=l.map(function(){return this.end=e(this.el[0]),this.diff=i(this.start,this.end),this}),a.attr("class",r),l=l.map(function(){var e=this,i=t.Deferred(),s=t.extend({},h,{queue:!1,complete:function(){i.resolve(e)}});return this.el.animate(this.diff,s),i.promise()}),t.when.apply(t,l.get()).done(function(){o(),t.each(arguments,function(){var e=this.el;t.each(this.diff,function(t){e.css(t,"")})}),h.complete.call(a[0])})})},t.fn.extend({addClass:function(e){return function(i,s,n,o){return s?t.effects.animateClass.call(this,{add:i},s,n,o):e.apply(this,arguments)}}(t.fn.addClass),removeClass:function(e){return function(i,s,n,o){return arguments.length>1?t.effects.animateClass.call(this,{remove:i},s,n,o):e.apply(this,arguments)}}(t.fn.removeClass),toggleClass:function(e){return function(i,s,n,o,a){return"boolean"==typeof s||void 0===s?n?t.effects.animateClass.call(this,s?{add:i}:{remove:i},n,o,a):e.apply(this,arguments):t.effects.animateClass.call(this,{toggle:i},s,n,o)}}(t.fn.toggleClass),switchClass:function(e,i,s,n,o){return t.effects.animateClass.call(this,{add:i,remove:e},s,n,o)}})}(),function(){function e(e,i,s,n){return t.isPlainObject(e)&&(i=e,e=e.effect),e={effect:e},null==i&&(i={}),t.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||t.fx.speeds[i])&&(n=s,s=i,i={}),t.isFunction(s)&&(n=s,s=null),i&&t.extend(e,i),s=s||i.duration,e.duration=t.fx.off?0:"number"==typeof s?s:s in t.fx.speeds?t.fx.speeds[s]:t.fx.speeds._default,e.complete=n||i.complete,e}function i(e){return!e||"number"==typeof e||t.fx.speeds[e]?!0:"string"!=typeof e||t.effects.effect[e]?t.isFunction(e)?!0:"object"!=typeof e||e.effect?!1:!0:!0}function s(t,e){var i=e.outerWidth(),s=e.outerHeight(),n=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,o=n.exec(t)||["",0,i,s,0];return{top:parseFloat(o[1])||0,right:"auto"===o[2]?i:parseFloat(o[2]),bottom:"auto"===o[3]?s:parseFloat(o[3]),left:parseFloat(o[4])||0}}t.expr&&t.expr.filters&&t.expr.filters.animated&&(t.expr.filters.animated=function(e){return function(i){return!!t(i).data(d)||e(i)}}(t.expr.filters.animated)),t.uiBackCompat!==!1&&t.extend(t.effects,{save:function(t,e){for(var i=0,s=e.length;s>i;i++)null!==e[i]&&t.data(c+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;n>s;s++)null!==e[s]&&(i=t.data(c+e[s]),t.css(e[s],i))},setMode:function(t,e){return"toggle"===e&&(e=t.is(":hidden")?"show":"hide"),e},createWrapper:function(e){if(e.parent().is(".ui-effects-wrapper"))return e.parent();var i={width:e.outerWidth(!0),height:e.outerHeight(!0),"float":e.css("float")},s=t("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:e.width(),height:e.height()},o=document.activeElement;try{o.id}catch(a){o=document.body}return e.wrap(s),(e[0]===o||t.contains(e[0],o))&&t(o).trigger("focus"),s=e.parent(),"static"===e.css("position")?(s.css({position:"relative"}),e.css({position:"relative"})):(t.extend(i,{position:e.css("position"),zIndex:e.css("z-index")}),t.each(["top","left","bottom","right"],function(t,s){i[s]=e.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),e.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),e.css(n),s.css(i).show()},removeWrapper:function(e){var i=document.activeElement;return e.parent().is(".ui-effects-wrapper")&&(e.parent().replaceWith(e),(e[0]===i||t.contains(e[0],i))&&t(i).trigger("focus")),e}}),t.extend(t.effects,{version:"1.12.1",define:function(e,i,s){return s||(s=i,i="effect"),t.effects.effect[e]=s,t.effects.effect[e].mode=i,s},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,n="vertical"!==i?(e||100)/100:1;return{height:t.height()*n,width:t.width()*s,outerHeight:t.outerHeight()*n,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();e>1&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(u,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(u)||"",t.removeData(u)},mode:function(t,e){var i=t.is(":hidden");return"toggle"===e&&(e=i?"show":"hide"),(i?"hide"===e:"show"===e)&&(e="none"),e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(e){var i,s=e.css("position"),n=e.position();return e.css({marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()),/^(static|relative)/.test(s)&&(s="absolute",i=t("<"+e[0].nodeName+">").insertAfter(e).css({display:/^(inline|ruby)/.test(e.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight"),"float":e.css("float")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"),e.data(c+"placeholder",i)),e.css({position:s,left:n.left,top:n.top}),i},removePlaceholder:function(t){var e=c+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(e){t.effects.restoreStyle(e),t.effects.removePlaceholder(e)},setTransition:function(e,i,s,n){return n=n||{},t.each(i,function(t,i){var o=e.cssUnit(i);o[0]>0&&(n[i]=o[0]*s+o[1])}),n}}),t.fn.extend({effect:function(){function i(e){function i(){r.removeData(d),t.effects.cleanUp(r),"hide"===s.mode&&r.hide(),a()}function a(){t.isFunction(h)&&h.call(r[0]),t.isFunction(e)&&e()}var r=t(this);s.mode=c.shift(),t.uiBackCompat===!1||o?"none"===s.mode?(r[l](),a()):n.call(r[0],s,i):(r.is(":hidden")?"hide"===l:"show"===l)?(r[l](),a()):n.call(r[0],s,a)}var s=e.apply(this,arguments),n=t.effects.effect[s.effect],o=n.mode,a=s.queue,r=a||"fx",h=s.complete,l=s.mode,c=[],u=function(e){var i=t(this),s=t.effects.mode(i,l)||o;i.data(d,!0),c.push(s),o&&("show"===s||s===o&&"hide"===s)&&i.show(),o&&"none"===s||t.effects.saveStyle(i),t.isFunction(e)&&e()};return t.fx.off||!n?l?this[l](s.duration,h):this.each(function(){h&&h.call(this)}):a===!1?this.each(u).each(i):this.queue(r,u).queue(r,i)},show:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="show",this.effect.call(this,n)
}}(t.fn.show),hide:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(t.fn.hide),toggle:function(t){return function(s){if(i(s)||"boolean"==typeof s)return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(t.fn.toggle),cssUnit:function(e){var i=this.css(e),s=[];return t.each(["em","px","%","pt"],function(t,e){i.indexOf(e)>0&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):s(this.css("clip"),this)},transfer:function(e,i){var s=t(this),n=t(e.to),o="fixed"===n.css("position"),a=t("body"),r=o?a.scrollTop():0,h=o?a.scrollLeft():0,l=n.offset(),c={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},u=s.offset(),d=t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({top:u.top-r,left:u.left-h,height:s.innerHeight(),width:s.innerWidth(),position:o?"fixed":"absolute"}).animate(c,e.duration,e.easing,function(){d.remove(),t.isFunction(i)&&i()})}}),t.fx.step.clip=function(e){e.clipInit||(e.start=t(e.elem).cssClip(),"string"==typeof e.end&&(e.end=s(e.end,e.elem)),e.clipInit=!0),t(e.elem).cssClip({top:e.pos*(e.end.top-e.start.top)+e.start.top,right:e.pos*(e.end.right-e.start.right)+e.start.right,bottom:e.pos*(e.end.bottom-e.start.bottom)+e.start.bottom,left:e.pos*(e.end.left-e.start.left)+e.start.left})}}(),function(){var e={};t.each(["Quad","Cubic","Quart","Quint","Expo"],function(t,i){e[i]=function(e){return Math.pow(e,t+2)}}),t.extend(e,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;((e=Math.pow(2,--i))-1)/11>t;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),t.each(e,function(e,i){t.easing["easeIn"+e]=i,t.easing["easeOut"+e]=function(t){return 1-i(1-t)},t.easing["easeInOut"+e]=function(t){return.5>t?i(2*t)/2:1-i(-2*t+2)/2}})}();var f=t.effects;t.effects.define("blind","hide",function(e,i){var s={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},n=t(this),o=e.direction||"up",a=n.cssClip(),r={clip:t.extend({},a)},h=t.effects.createPlaceholder(n);r.clip[s[o][0]]=r.clip[s[o][1]],"show"===e.mode&&(n.cssClip(r.clip),h&&h.css(t.effects.clipToBox(r)),r.clip=a),h&&h.animate(t.effects.clipToBox(r),e.duration,e.easing),n.animate(r,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("bounce",function(e,i){var s,n,o,a=t(this),r=e.mode,h="hide"===r,l="show"===r,c=e.direction||"up",u=e.distance,d=e.times||5,p=2*d+(l||h?1:0),f=e.duration/p,g=e.easing,m="up"===c||"down"===c?"top":"left",_="up"===c||"left"===c,v=0,b=a.queue().length;for(t.effects.createPlaceholder(a),o=a.css(m),u||(u=a["top"===m?"outerHeight":"outerWidth"]()/3),l&&(n={opacity:1},n[m]=o,a.css("opacity",0).css(m,_?2*-u:2*u).animate(n,f,g)),h&&(u/=Math.pow(2,d-1)),n={},n[m]=o;d>v;v++)s={},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g).animate(n,f,g),u=h?2*u:u/2;h&&(s={opacity:0},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g)),a.queue(i),t.effects.unshift(a,b,p+1)}),t.effects.define("clip","hide",function(e,i){var s,n={},o=t(this),a=e.direction||"vertical",r="both"===a,h=r||"horizontal"===a,l=r||"vertical"===a;s=o.cssClip(),n.clip={top:l?(s.bottom-s.top)/2:s.top,right:h?(s.right-s.left)/2:s.right,bottom:l?(s.bottom-s.top)/2:s.bottom,left:h?(s.right-s.left)/2:s.left},t.effects.createPlaceholder(o),"show"===e.mode&&(o.cssClip(n.clip),n.clip=s),o.animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("drop","hide",function(e,i){var s,n=t(this),o=e.mode,a="show"===o,r=e.direction||"left",h="up"===r||"down"===r?"top":"left",l="up"===r||"left"===r?"-=":"+=",c="+="===l?"-=":"+=",u={opacity:0};t.effects.createPlaceholder(n),s=e.distance||n["top"===h?"outerHeight":"outerWidth"](!0)/2,u[h]=l+s,a&&(n.css(u),u[h]=c+s,u.opacity=1),n.animate(u,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("explode","hide",function(e,i){function s(){b.push(this),b.length===u*d&&n()}function n(){p.css({visibility:"visible"}),t(b).remove(),i()}var o,a,r,h,l,c,u=e.pieces?Math.round(Math.sqrt(e.pieces)):3,d=u,p=t(this),f=e.mode,g="show"===f,m=p.show().css("visibility","hidden").offset(),_=Math.ceil(p.outerWidth()/d),v=Math.ceil(p.outerHeight()/u),b=[];for(o=0;u>o;o++)for(h=m.top+o*v,c=o-(u-1)/2,a=0;d>a;a++)r=m.left+a*_,l=a-(d-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-a*_,top:-o*v}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:_,height:v,left:r+(g?l*_:0),top:h+(g?c*v:0),opacity:g?0:1}).animate({left:r+(g?0:l*_),top:h+(g?0:c*v),opacity:g?1:0},e.duration||500,e.easing,s)}),t.effects.define("fade","toggle",function(e,i){var s="show"===e.mode;t(this).css("opacity",s?0:1).animate({opacity:s?1:0},{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("fold","hide",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=e.size||15,h=/([0-9]+)%/.exec(r),l=!!e.horizFirst,c=l?["right","bottom"]:["bottom","right"],u=e.duration/2,d=t.effects.createPlaceholder(s),p=s.cssClip(),f={clip:t.extend({},p)},g={clip:t.extend({},p)},m=[p[c[0]],p[c[1]]],_=s.queue().length;h&&(r=parseInt(h[1],10)/100*m[a?0:1]),f.clip[c[0]]=r,g.clip[c[0]]=r,g.clip[c[1]]=0,o&&(s.cssClip(g.clip),d&&d.css(t.effects.clipToBox(g)),g.clip=p),s.queue(function(i){d&&d.animate(t.effects.clipToBox(f),u,e.easing).animate(t.effects.clipToBox(g),u,e.easing),i()}).animate(f,u,e.easing).animate(g,u,e.easing).queue(i),t.effects.unshift(s,_,4)}),t.effects.define("highlight","show",function(e,i){var s=t(this),n={backgroundColor:s.css("backgroundColor")};"hide"===e.mode&&(n.opacity=0),t.effects.saveStyle(s),s.css({backgroundImage:"none",backgroundColor:e.color||"#ffff99"}).animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("size",function(e,i){var s,n,o,a=t(this),r=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],l=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],c=e.mode,u="effect"!==c,d=e.scale||"both",p=e.origin||["middle","center"],f=a.css("position"),g=a.position(),m=t.effects.scaledDimensions(a),_=e.from||m,v=e.to||t.effects.scaledDimensions(a,0);t.effects.createPlaceholder(a),"show"===c&&(o=_,_=v,v=o),n={from:{y:_.height/m.height,x:_.width/m.width},to:{y:v.height/m.height,x:v.width/m.width}},("box"===d||"both"===d)&&(n.from.y!==n.to.y&&(_=t.effects.setTransition(a,h,n.from.y,_),v=t.effects.setTransition(a,h,n.to.y,v)),n.from.x!==n.to.x&&(_=t.effects.setTransition(a,l,n.from.x,_),v=t.effects.setTransition(a,l,n.to.x,v))),("content"===d||"both"===d)&&n.from.y!==n.to.y&&(_=t.effects.setTransition(a,r,n.from.y,_),v=t.effects.setTransition(a,r,n.to.y,v)),p&&(s=t.effects.getBaseline(p,m),_.top=(m.outerHeight-_.outerHeight)*s.y+g.top,_.left=(m.outerWidth-_.outerWidth)*s.x+g.left,v.top=(m.outerHeight-v.outerHeight)*s.y+g.top,v.left=(m.outerWidth-v.outerWidth)*s.x+g.left),a.css(_),("content"===d||"both"===d)&&(h=h.concat(["marginTop","marginBottom"]).concat(r),l=l.concat(["marginLeft","marginRight"]),a.find("*[width]").each(function(){var i=t(this),s=t.effects.scaledDimensions(i),o={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},a={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x};n.from.y!==n.to.y&&(o=t.effects.setTransition(i,h,n.from.y,o),a=t.effects.setTransition(i,h,n.to.y,a)),n.from.x!==n.to.x&&(o=t.effects.setTransition(i,l,n.from.x,o),a=t.effects.setTransition(i,l,n.to.x,a)),u&&t.effects.saveStyle(i),i.css(o),i.animate(a,e.duration,e.easing,function(){u&&t.effects.restoreStyle(i)})})),a.animate(v,{queue:!1,duration:e.duration,easing:e.easing,complete:function(){var e=a.offset();0===v.opacity&&a.css("opacity",_.opacity),u||(a.css("position","static"===f?"relative":f).offset(e),t.effects.saveStyle(a)),i()}})}),t.effects.define("scale",function(e,i){var s=t(this),n=e.mode,o=parseInt(e.percent,10)||(0===parseInt(e.percent,10)?0:"effect"!==n?0:100),a=t.extend(!0,{from:t.effects.scaledDimensions(s),to:t.effects.scaledDimensions(s,o,e.direction||"both"),origin:e.origin||["middle","center"]},e);e.fade&&(a.from.opacity=1,a.to.opacity=0),t.effects.effect.size.call(this,a,i)}),t.effects.define("puff","hide",function(e,i){var s=t.extend(!0,{},e,{fade:!0,percent:parseInt(e.percent,10)||150});t.effects.effect.scale.call(this,s,i)}),t.effects.define("pulsate","show",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=o||a,h=2*(e.times||5)+(r?1:0),l=e.duration/h,c=0,u=1,d=s.queue().length;for((o||!s.is(":visible"))&&(s.css("opacity",0).show(),c=1);h>u;u++)s.animate({opacity:c},l,e.easing),c=1-c;s.animate({opacity:c},l,e.easing),s.queue(i),t.effects.unshift(s,d,h+1)}),t.effects.define("shake",function(e,i){var s=1,n=t(this),o=e.direction||"left",a=e.distance||20,r=e.times||3,h=2*r+1,l=Math.round(e.duration/h),c="up"===o||"down"===o?"top":"left",u="up"===o||"left"===o,d={},p={},f={},g=n.queue().length;for(t.effects.createPlaceholder(n),d[c]=(u?"-=":"+=")+a,p[c]=(u?"+=":"-=")+2*a,f[c]=(u?"-=":"+=")+2*a,n.animate(d,l,e.easing);r>s;s++)n.animate(p,l,e.easing).animate(f,l,e.easing);n.animate(p,l,e.easing).animate(d,l/2,e.easing).queue(i),t.effects.unshift(n,g,h+1)}),t.effects.define("slide","show",function(e,i){var s,n,o=t(this),a={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},r=e.mode,h=e.direction||"left",l="up"===h||"down"===h?"top":"left",c="up"===h||"left"===h,u=e.distance||o["top"===l?"outerHeight":"outerWidth"](!0),d={};t.effects.createPlaceholder(o),s=o.cssClip(),n=o.position()[l],d[l]=(c?-1:1)*u+n,d.clip=o.cssClip(),d.clip[a[h][1]]=d.clip[a[h][0]],"show"===r&&(o.cssClip(d.clip),o.css(l,d[l]),d.clip=s,d[l]=n),o.animate(d,{queue:!1,duration:e.duration,easing:e.easing,complete:i})});var f;t.uiBackCompat!==!1&&(f=t.effects.define("transfer",function(e,i){t(this).transfer(e,i)})),t.ui.focusable=function(i,s){var n,o,a,r,h,l=i.nodeName.toLowerCase();return"area"===l?(n=i.parentNode,o=n.name,i.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']"),a.length>0&&a.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(l)?(r=!i.disabled,r&&(h=t(i).closest("fieldset")[0],h&&(r=!h.disabled))):r="a"===l?i.href||s:s,r&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,o){return t.each(n,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),o&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],o=i.toLowerCase(),a={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?a["inner"+i].call(this):this.each(function(){t(this).css(o,s(this,e)+"px")})},t.fn["outer"+i]=function(e,n){return"number"!=typeof e?a["outer"+i].call(this,e):this.each(function(){t(this).css(o,s(this,e,!0,n)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,n,o;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(n=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),o=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",n=n.add(o.find(i).addBack(i))),this.pushStack(n))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.widget("ui.accordion",{version:"1.12.1",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!1,event:"click",header:"> li > :first-child, > :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var e=this.options;this.prevShow=this.prevHide=t(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),e.collapsible||e.active!==!1&&null!=e.active||(e.active=0),this._processPanels(),0>e.active&&(e.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():t()}},_createIcons:function(){var e,i,s=this.options.icons;s&&(e=t("<span>"),this._addClass(e,"ui-accordion-header-icon","ui-icon "+s.header),e.prependTo(this.headers),i=this.active.children(".ui-accordion-header-icon"),this._removeClass(i,s.header)._addClass(i,null,s.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!==t||e||this.options.active!==!1||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons()),void 0)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!t)},_keydown:function(e){if(!e.altKey&&!e.ctrlKey){var i=t.ui.keyCode,s=this.headers.length,n=this.headers.index(e.target),o=!1;switch(e.keyCode){case i.RIGHT:case i.DOWN:o=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:o=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(e);break;case i.HOME:o=this.headers[0];break;case i.END:o=this.headers[s-1]}o&&(t(e.target).attr("tabIndex",-1),t(o).attr("tabIndex",0),t(o).trigger("focus"),e.preventDefault())}},_panelKeyDown:function(e){e.keyCode===t.ui.keyCode.UP&&e.ctrlKey&&t(e.currentTarget).prev().trigger("focus")},refresh:function(){var e=this.options;this._processPanels(),e.active===!1&&e.collapsible===!0||!this.headers.length?(e.active=!1,this.active=t()):e.active===!1?this._activate(0):this.active.length&&!t.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(e.active=!1,this.active=t()):this._activate(Math.max(0,e.active-1)):e.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var e,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var e=t(this),i=e.uniqueId().attr("id"),s=e.next(),n=s.uniqueId().attr("id");e.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(e=n.height(),this.element.siblings(":visible").each(function(){var i=t(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(e-=i.outerHeight(!0))}),this.headers.each(function(){e-=t(this).outerHeight(!0)}),this.headers.next().each(function(){t(this).height(Math.max(0,e-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===s&&(e=0,this.headers.next().each(function(){var i=t(this).is(":visible");i||t(this).show(),e=Math.max(e,t(this).css("height","").height()),i||t(this).hide()}).height(e))},_activate:function(e){var i=this._findActive(e)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return"number"==typeof e?this.headers.eq(e):t()},_setupEvents:function(e){var i={keydown:"_keydown"};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(e){var i,s,n=this.options,o=this.active,a=t(e.currentTarget),r=a[0]===o[0],h=r&&n.collapsible,l=h?t():a.next(),c=o.next(),u={oldHeader:o,oldPanel:c,newHeader:h?t():a,newPanel:l};e.preventDefault(),r&&!n.collapsible||this._trigger("beforeActivate",e,u)===!1||(n.active=h?!1:this.headers.index(a),this.active=r?t():a,this._toggle(u),this._removeClass(o,"ui-accordion-header-active","ui-state-active"),n.icons&&(i=o.children(".ui-accordion-header-icon"),this._removeClass(i,null,n.icons.activeHeader)._addClass(i,null,n.icons.header)),r||(this._removeClass(a,"ui-accordion-header-collapsed")._addClass(a,"ui-accordion-header-active","ui-state-active"),n.icons&&(s=a.children(".ui-accordion-header-icon"),this._removeClass(s,null,n.icons.header)._addClass(s,null,n.icons.activeHeader)),this._addClass(a.next(),"ui-accordion-content-active")))},_toggle:function(e){var i=e.newPanel,s=this.prevShow.length?this.prevShow:e.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,e):(s.hide(),i.show(),this._toggleComplete(e)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(t(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,e,i){var s,n,o,a=this,r=0,h=t.css("box-sizing"),l=t.length&&(!e.length||t.index()<e.index()),c=this.options.animate||{},u=l&&c.down||c,d=function(){a._toggleComplete(i)};return"number"==typeof u&&(o=u),"string"==typeof u&&(n=u),n=n||u.easing||c.easing,o=o||u.duration||c.duration,e.length?t.length?(s=t.show().outerHeight(),e.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),t.hide().animate(this.showProps,{duration:o,easing:n,complete:d,step:function(t,i){i.now=Math.round(t),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==a.options.heightStyle&&(i.now=Math.round(s-e.outerHeight()-r),r=0)}}),void 0):e.animate(this.hideProps,o,n,d):t.animate(this.showProps,o,n,d)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault()},"click .ui-menu-item":function(e){var i=t(e.target),s=t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&s.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){if(!this.previousFilter){var i=t(e.target).closest(".ui-menu-item"),s=t(e.currentTarget);i[0]===s[0]&&(this._removeClass(s.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(e,s))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.find(this.options.items).eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){var i=!t.contains(this.element[0],t.ui.safeActiveElement(this.document[0]));i&&this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t),this.mouseHandled=!1}})},_destroy:function(){var e=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),i=e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),i.children().each(function(){var e=t(this);e.data("ui-menu-submenu-caret")&&e.remove()})},_keydown:function(e){var i,s,n,o,a=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:a=!1,s=this.previousFilter||"",o=!1,n=e.keyCode>=96&&105>=e.keyCode?""+(e.keyCode-96):String.fromCharCode(e.keyCode),clearTimeout(this.filterTimer),n===s?o=!0:n=s+n,i=this._filterMenuItems(n),i=o&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(e.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(e,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}a&&e.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i,s,n,o,a=this,r=this.options.icons.submenu,h=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),s=h.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),i=e.prev(),s=t("<span>").data("ui-menu-submenu-caret",!0);a._addClass(s,"ui-menu-icon","ui-icon "+r),i.attr("aria-haspopup","true").prepend(s),e.attr("aria-labelledby",i.attr("id"))}),this._addClass(s,"ui-menu","ui-widget ui-widget-content ui-front"),e=h.add(this.element),i=e.find(this.options.items),i.not(".ui-menu-item").each(function(){var e=t(this);a._isDivider(e)&&a._addClass(e,"ui-menu-divider","ui-widget-content")}),n=i.not(".ui-menu-item, .ui-menu-divider"),o=n.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(n,"ui-menu-item")._addClass(o,"ui-menu-item-wrapper"),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){if("icons"===t){var i=this.element.find(".ui-menu-icon");this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)}this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t+""),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i,s,n;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children(".ui-menu-item-wrapper"),this._addClass(s,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),n=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(n,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,o,a,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,o=this.activeMenu.scrollTop(),a=this.activeMenu.height(),r=e.outerHeight(),0>n?this.activeMenu.scrollTop(o+n):n+r>a&&this.activeMenu.scrollTop(o+n-a+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this._removeClass(s.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(e){return!t(e.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(e),void 0)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items).first())),void 0):(this.next(e),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)},_filterMenuItems:function(e){var i=e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()))})}}),t.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var e,i,s,n=this.element[0].nodeName.toLowerCase(),o="textarea"===n,a="input"===n;
this.isMultiLine=o||!a&&this._isContentEditable(this.element),this.valueMethod=this.element[o||a?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return e=!0,s=!0,i=!0,void 0;e=!1,s=!1,i=!1;var o=t.ui.keyCode;switch(n.keyCode){case o.PAGE_UP:e=!0,this._move("previousPage",n);break;case o.PAGE_DOWN:e=!0,this._move("nextPage",n);break;case o.UP:e=!0,this._keyEvent("previous",n);break;case o.DOWN:e=!0,this._keyEvent("next",n);break;case o.ENTER:this.menu.active&&(e=!0,n.preventDefault(),this.menu.select(n));break;case o.TAB:this.menu.active&&this.menu.select(n);break;case o.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(e)return e=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=t.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(t){return s?(s=!1,t.preventDefault(),void 0):(this._searchTimeout(t),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(t),this._change(t),void 0)}}),this._initSource(),this.menu=t("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(e){e.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==t.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(e,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,e.originalEvent&&/^mouse/.test(e.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){t(e.target).trigger(e.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",e,{item:n})&&e.originalEvent&&/^key/.test(e.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&t.trim(s).length&&(this.liveRegion.children().hide(),t("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,i){var s=i.item.data("ui-autocomplete-item"),n=this.previous;this.element[0]!==t.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=n,this._delay(function(){this.previous=n,this.selectedItem=s})),!1!==this._trigger("select",e,{item:s})&&this._value(s.value),this.term=this._value(),this.close(e),this.selectedItem=s}}),this.liveRegion=t("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(e){var i=this.menu.element[0];return e.target===this.element[0]||e.target===i||t.contains(i,e.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_initSource:function(){var e,i,s=this;t.isArray(this.options.source)?(e=this.options.source,this.source=function(i,s){s(t.ui.autocomplete.filter(e,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(e,n){s.xhr&&s.xhr.abort(),s.xhr=t.ajax({url:i,data:e,dataType:"json",success:function(t){n(t)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(t){clearTimeout(this.searching),this.searching=this._delay(function(){var e=this.term===this._value(),i=this.menu.element.is(":visible"),s=t.altKey||t.ctrlKey||t.metaKey||t.shiftKey;(!e||e&&!i&&!s)&&(this.selectedItem=null,this.search(null,t))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):this._trigger("search",e)!==!1?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return t.proxy(function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(t){t&&(t=this._normalize(t)),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(e){return e.length&&e[0].label&&e[0].value?e:t.map(e,function(e){return"string"==typeof e?{label:e,value:e}:t.extend({},e,{label:e.label||e.value,value:e.value||e.label})})},_suggest:function(e){var i=this.menu.element.empty();this._renderMenu(i,e),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(t.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(e,i){var s=this;t.each(i,function(t,i){s._renderItemData(e,i)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(e,i){return t("<li>").append(t("<div>").text(i.label)).appendTo(e)},_move:function(t,e){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[t](e),void 0):(this.search(null,e),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),t.extend(t.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(e,i){var s=RegExp(t.ui.autocomplete.escapeRegex(i),"i");return t.grep(e,function(t){return s.test(t.label||t.value||t)})}}),t.widget("ui.autocomplete",t.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(t>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.children().hide(),t("<div>").text(i).appendTo(this.liveRegion))}}),t.ui.autocomplete;var g=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.1",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,n){var o,a={};return n?"controlgroupLabel"===s?(o=e.element.find(n),o.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(o,null,"ui-widget ui-widget-content ui-state-default"),i=i.concat(o.get()),void 0):(t.fn[s]&&(a=e["_"+s+"Options"]?e["_"+s+"Options"]("middle"):{classes:{}},e.element.find(n).each(function(){var n=t(this),o=n[s]("instance"),r=t.widget.extend({},a);if("button"!==s||!n.parent(".ui-spinner").length){o||(o=n[s]()[s]("instance")),o&&(r.classes=e._resolveClassesValues(r.classes,o)),n[s](r);var h=n[s]("widget");t.data(h[0],"ui-controlgroup-data",o?o:n[s]("instance")),i.push(h[0])}})),void 0):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(n){var o=i.options.classes[n]||"";o=t.trim(o.replace(g,"")),s[n]=(o+" "+e[n]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?(this._callChildMethod(e?"disable":"enable"),void 0):(this.refresh(),void 0)},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var n=e[s]().data("ui-controlgroup-data");if(n&&i["_"+n.widgetName+"Options"]){var o=i["_"+n.widgetName+"Options"](1===e.length?"only":s);o.classes=i._resolveClassesValues(o.classes,n),n.element[n.widgetName](o)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.1",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,n=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element[0]).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(n.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(n.disabled=e),n},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),this.element[0].disabled=e,void 0):(this.refresh(),void 0)):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),this.iconSpace&&(t=t.not(this.iconSpace[0])),t.remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.1",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,n=s?this.options.iconPosition:i,o="top"===n||"bottom"===n;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(n),o?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(n))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?(this._super("showLabel",e),void 0):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments),void 0)}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.extend(t.ui,{datepicker:{version:"1.12.1"}});var m;t.extend(s.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return a(this._defaults,t||{}),this},_attachDatepicker:function(e,i){var s,n,o;s=e.nodeName.toLowerCase(),n="div"===s||"span"===s,e.id||(this.uuid+=1,e.id="dp"+this.uuid),o=this._newInst(t(e),n),o.settings=t.extend({},i||{}),"input"===s?this._connectDatepicker(e,o):n&&this._inlineDatepicker(e,o)},_newInst:function(e,i){var s=e[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:e,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?n(t("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(e,i){var s=t(e);i.append=t([]),i.trigger=t([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(i),t.data(e,"datepicker",i),i.settings.disabled&&this._disableDatepicker(e))},_attachments:function(e,i){var s,n,o,a=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),a&&(i.append=t("<span class='"+this._appendClass+"'>"+a+"</span>"),e[r?"before":"after"](i.append)),e.off("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&e.on("focus",this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),o=this._get(i,"buttonImage"),i.trigger=t(this._get(i,"buttonImageOnly")?t("<img/>").addClass(this._triggerClass).attr({src:o,alt:n,title:n}):t("<button type='button'></button>").addClass(this._triggerClass).html(o?t("<img/>").attr({src:o,alt:n,title:n}):n)),e[r?"before":"after"](i.trigger),i.trigger.on("click",function(){return t.datepicker._datepickerShowing&&t.datepicker._lastInput===e[0]?t.datepicker._hideDatepicker():t.datepicker._datepickerShowing&&t.datepicker._lastInput!==e[0]?(t.datepicker._hideDatepicker(),t.datepicker._showDatepicker(e[0])):t.datepicker._showDatepicker(e[0]),!1}))},_autoSize:function(t){if(this._get(t,"autoSize")&&!t.inline){var e,i,s,n,o=new Date(2009,11,20),a=this._get(t,"dateFormat");a.match(/[DM]/)&&(e=function(t){for(i=0,s=0,n=0;t.length>n;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length)}},_inlineDatepicker:function(e,i){var s=t(e);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),t.data(e,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(e),i.dpDiv.css("display","block"))},_dialogDatepicker:function(e,i,s,n,o){var r,h,l,c,u,d=this._dialogInst;return d||(this.uuid+=1,r="dp"+this.uuid,this._dialogInput=t("<input type='text' id='"+r+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.on("keydown",this._doKeyDown),t("body").append(this._dialogInput),d=this._dialogInst=this._newInst(this._dialogInput,!1),d.settings={},t.data(this._dialogInput[0],"datepicker",d)),a(d.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(d,i):i,this._dialogInput.val(i),this._pos=o?o.length?o:[o.pageX,o.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,c=document.documentElement.scrollLeft||document.body.scrollLeft,u=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+c,l/2-150+u]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),d.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),t.blockUI&&t.blockUI(this.dpDiv),t.data(this._dialogInput[0],"datepicker",d),this},_destroyDatepicker:function(e){var i,s=t(e),n=t.data(e,"datepicker");s.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),t.removeData(e,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),m===n&&(m=null))},_enableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!1,o.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!0,o.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!t)return!1;for(var e=0;this._disabledInputs.length>e;e++)if(this._disabledInputs[e]===t)return!0;return!1},_getInst:function(e){try{return t.data(e,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(e,i,s){var n,o,r,h,l=this._getInst(e);return 2===arguments.length&&"string"==typeof i?"defaults"===i?t.extend({},t.datepicker._defaults):l?"all"===i?t.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),o=this._getDateDatepicker(e,!0),r=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),a(l.settings,n),null!==r&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,r)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(e):this._enableDatepicker(e)),this._attachments(t(e),l),this._autoSize(l),this._setDate(l,o),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){var e=this._getInst(t);e&&this._updateDatepicker(e)},_setDateDatepicker:function(t,e){var i=this._getInst(t);i&&(this._setDate(i,e),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(t,e){var i=this._getInst(t);return i&&!i.inline&&this._setDateFromField(i,e),i?this._getDate(i):null},_doKeyDown:function(e){var i,s,n,o=t.datepicker._getInst(e.target),a=!0,r=o.dpDiv.is(".ui-datepicker-rtl");if(o._keyEvent=!0,t.datepicker._datepickerShowing)switch(e.keyCode){case 9:t.datepicker._hideDatepicker(),a=!1;break;case 13:return n=t("td."+t.datepicker._dayOverClass+":not(."+t.datepicker._currentClass+")",o.dpDiv),n[0]&&t.datepicker._selectDay(e.target,o.selectedMonth,o.selectedYear,n[0]),i=t.datepicker._get(o,"onSelect"),i?(s=t.datepicker._formatDate(o),i.apply(o.input?o.input[0]:null,[s,o])):t.datepicker._hideDatepicker(),!1;case 27:t.datepicker._hideDatepicker();break;case 33:t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 34:t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 35:(e.ctrlKey||e.metaKey)&&t.datepicker._clearDate(e.target),a=e.ctrlKey||e.metaKey;break;case 36:(e.ctrlKey||e.metaKey)&&t.datepicker._gotoToday(e.target),a=e.ctrlKey||e.metaKey;break;case 37:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?1:-1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 38:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,-7,"D"),a=e.ctrlKey||e.metaKey;break;case 39:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?-1:1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 40:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,7,"D"),a=e.ctrlKey||e.metaKey;break;default:a=!1}else 36===e.keyCode&&e.ctrlKey?t.datepicker._showDatepicker(this):a=!1;a&&(e.preventDefault(),e.stopPropagation())},_doKeyPress:function(e){var i,s,n=t.datepicker._getInst(e.target);return t.datepicker._get(n,"constrainInput")?(i=t.datepicker._possibleChars(t.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),e.ctrlKey||e.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(e){var i,s=t.datepicker._getInst(e.target);if(s.input.val()!==s.lastVal)try{i=t.datepicker.parseDate(t.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,t.datepicker._getFormatConfig(s)),i&&(t.datepicker._setDateFromField(s),t.datepicker._updateAlternate(s),t.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(e){if(e=e.target||e,"input"!==e.nodeName.toLowerCase()&&(e=t("input",e.parentNode)[0]),!t.datepicker._isDisabledDatepicker(e)&&t.datepicker._lastInput!==e){var s,n,o,r,h,l,c;s=t.datepicker._getInst(e),t.datepicker._curInst&&t.datepicker._curInst!==s&&(t.datepicker._curInst.dpDiv.stop(!0,!0),s&&t.datepicker._datepickerShowing&&t.datepicker._hideDatepicker(t.datepicker._curInst.input[0])),n=t.datepicker._get(s,"beforeShow"),o=n?n.apply(e,[e,s]):{},o!==!1&&(a(s.settings,o),s.lastVal=null,t.datepicker._lastInput=e,t.datepicker._setDateFromField(s),t.datepicker._inDialog&&(e.value=""),t.datepicker._pos||(t.datepicker._pos=t.datepicker._findPos(e),t.datepicker._pos[1]+=e.offsetHeight),r=!1,t(e).parents().each(function(){return r|="fixed"===t(this).css("position"),!r}),h={left:t.datepicker._pos[0],top:t.datepicker._pos[1]},t.datepicker._pos=null,s.dpDiv.empty(),s.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),t.datepicker._updateDatepicker(s),h=t.datepicker._checkOffset(s,h,r),s.dpDiv.css({position:t.datepicker._inDialog&&t.blockUI?"static":r?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),s.inline||(l=t.datepicker._get(s,"showAnim"),c=t.datepicker._get(s,"duration"),s.dpDiv.css("z-index",i(t(e))+1),t.datepicker._datepickerShowing=!0,t.effects&&t.effects.effect[l]?s.dpDiv.show(l,t.datepicker._get(s,"showOptions"),c):s.dpDiv[l||"show"](l?c:null),t.datepicker._shouldFocusInput(s)&&s.input.trigger("focus"),t.datepicker._curInst=s))
}},_updateDatepicker:function(e){this.maxRows=4,m=e,e.dpDiv.empty().append(this._generateHTML(e)),this._attachHandlers(e);var i,s=this._getNumberOfMonths(e),n=s[1],a=17,r=e.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&e.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),e.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),e.dpDiv[(this._get(e,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),e===t.datepicker._curInst&&t.datepicker._datepickerShowing&&t.datepicker._shouldFocusInput(e)&&e.input.trigger("focus"),e.yearshtml&&(i=e.yearshtml,setTimeout(function(){i===e.yearshtml&&e.yearshtml&&e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml),i=e.yearshtml=null},0))},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!t.input.is(":disabled")&&!t.input.is(":focus")},_checkOffset:function(e,i,s){var n=e.dpDiv.outerWidth(),o=e.dpDiv.outerHeight(),a=e.input?e.input.outerWidth():0,r=e.input?e.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:t(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:t(document).scrollTop());return i.left-=this._get(e,"isRTL")?n-a:0,i.left-=s&&i.left===e.input.offset().left?t(document).scrollLeft():0,i.top-=s&&i.top===e.input.offset().top+r?t(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+o>l&&l>o?Math.abs(o+r):0),i},_findPos:function(e){for(var i,s=this._getInst(e),n=this._get(s,"isRTL");e&&("hidden"===e.type||1!==e.nodeType||t.expr.filters.hidden(e));)e=e[n?"previousSibling":"nextSibling"];return i=t(e).offset(),[i.left,i.top]},_hideDatepicker:function(e){var i,s,n,o,a=this._curInst;!a||e&&a!==t.data(e,"datepicker")||this._datepickerShowing&&(i=this._get(a,"showAnim"),s=this._get(a,"duration"),n=function(){t.datepicker._tidyDialog(a)},t.effects&&(t.effects.effect[i]||t.effects[i])?a.dpDiv.hide(i,t.datepicker._get(a,"showOptions"),s,n):a.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,o=this._get(a,"onClose"),o&&o.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),t.blockUI&&(t.unblockUI(),t("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(e){if(t.datepicker._curInst){var i=t(e.target),s=t.datepicker._getInst(i[0]);(i[0].id!==t.datepicker._mainDivId&&0===i.parents("#"+t.datepicker._mainDivId).length&&!i.hasClass(t.datepicker.markerClassName)&&!i.closest("."+t.datepicker._triggerClass).length&&t.datepicker._datepickerShowing&&(!t.datepicker._inDialog||!t.blockUI)||i.hasClass(t.datepicker.markerClassName)&&t.datepicker._curInst!==s)&&t.datepicker._hideDatepicker()}},_adjustDate:function(e,i,s){var n=t(e),o=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(o,i+("M"===s?this._get(o,"showCurrentAtPos"):0),s),this._updateDatepicker(o))},_gotoToday:function(e){var i,s=t(e),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(e,i,s){var n=t(e),o=this._getInst(n[0]);o["selected"+("M"===s?"Month":"Year")]=o["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(o),this._adjustDate(n)},_selectDay:function(e,i,s,n){var o,a=t(e);t(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(a[0])||(o=this._getInst(a[0]),o.selectedDay=o.currentDay=t("a",n).html(),o.selectedMonth=o.currentMonth=i,o.selectedYear=o.currentYear=s,this._selectDate(e,this._formatDate(o,o.currentDay,o.currentMonth,o.currentYear)))},_clearDate:function(e){var i=t(e);this._selectDate(i,"")},_selectDate:function(e,i){var s,n=t(e),o=this._getInst(n[0]);i=null!=i?i:this._formatDate(o),o.input&&o.input.val(i),this._updateAlternate(o),s=this._get(o,"onSelect"),s?s.apply(o.input?o.input[0]:null,[i,o]):o.input&&o.input.trigger("change"),o.inline?this._updateDatepicker(o):(this._hideDatepicker(),this._lastInput=o.input[0],"object"!=typeof o.input[0]&&o.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(e){var i,s,n,o=this._get(e,"altField");o&&(i=this._get(e,"altFormat")||this._get(e,"dateFormat"),s=this._getDate(e),n=this.formatDate(i,s,this._getFormatConfig(e)),t(o).val(n))},noWeekends:function(t){var e=t.getDay();return[e>0&&6>e,""]},iso8601Week:function(t){var e,i=new Date(t.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),e=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((e-i)/864e5)/7)+1},parseDate:function(e,i,s){if(null==e||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,o,a,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,c="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),u=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,d=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,g=-1,m=-1,_=-1,v=-1,b=!1,y=function(t){var i=e.length>n+1&&e.charAt(n+1)===t;return i&&n++,i},w=function(t){var e=y(t),s="@"===t?14:"!"===t?20:"y"===t&&e?4:"o"===t?3:2,n="y"===t?s:1,o=RegExp("^\\d{"+n+","+s+"}"),a=i.substring(h).match(o);if(!a)throw"Missing number at position "+h;return h+=a[0].length,parseInt(a[0],10)},k=function(e,s,n){var o=-1,a=t.map(y(e)?n:s,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(t.each(a,function(t,e){var s=e[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(o=e[0],h+=s.length,!1):void 0}),-1!==o)return o+1;throw"Unknown name at position "+h},x=function(){if(i.charAt(h)!==e.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;e.length>n;n++)if(b)"'"!==e.charAt(n)||y("'")?x():b=!1;else switch(e.charAt(n)){case"d":_=w("d");break;case"D":k("D",u,d);break;case"o":v=w("o");break;case"m":m=w("m");break;case"M":m=k("M",p,f);break;case"y":g=w("y");break;case"@":r=new Date(w("@")),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"!":r=new Date((w("!")-this._ticksTo1970)/1e4),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"'":y("'")?x():b=!0;break;default:x()}if(i.length>h&&(a=i.substr(h),!/^\s+/.test(a)))throw"Extra/unparsed characters found in date: "+a;if(-1===g?g=(new Date).getFullYear():100>g&&(g+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c>=g?0:-100)),v>-1)for(m=1,_=v;;){if(o=this._getDaysInMonth(g,m-1),o>=_)break;m++,_-=o}if(r=this._daylightSavingAdjust(new Date(g,m-1,_)),r.getFullYear()!==g||r.getMonth()+1!==m||r.getDate()!==_)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(t,e,i){if(!e)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,o=(i?i.dayNames:null)||this._defaults.dayNames,a=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(e){var i=t.length>s+1&&t.charAt(s+1)===e;return i&&s++,i},l=function(t,e,i){var s=""+e;if(h(t))for(;i>s.length;)s="0"+s;return s},c=function(t,e,i,s){return h(t)?s[e]:i[e]},u="",d=!1;if(e)for(s=0;t.length>s;s++)if(d)"'"!==t.charAt(s)||h("'")?u+=t.charAt(s):d=!1;else switch(t.charAt(s)){case"d":u+=l("d",e.getDate(),2);break;case"D":u+=c("D",e.getDay(),n,o);break;case"o":u+=l("o",Math.round((new Date(e.getFullYear(),e.getMonth(),e.getDate()).getTime()-new Date(e.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=l("m",e.getMonth()+1,2);break;case"M":u+=c("M",e.getMonth(),a,r);break;case"y":u+=h("y")?e.getFullYear():(10>e.getFullYear()%100?"0":"")+e.getFullYear()%100;break;case"@":u+=e.getTime();break;case"!":u+=1e4*e.getTime()+this._ticksTo1970;break;case"'":h("'")?u+="'":d=!0;break;default:u+=t.charAt(s)}return u},_possibleChars:function(t){var e,i="",s=!1,n=function(i){var s=t.length>e+1&&t.charAt(e+1)===i;return s&&e++,s};for(e=0;t.length>e;e++)if(s)"'"!==t.charAt(e)||n("'")?i+=t.charAt(e):s=!1;else switch(t.charAt(e)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=t.charAt(e)}return i},_get:function(t,e){return void 0!==t.settings[e]?t.settings[e]:this._defaults[e]},_setDateFromField:function(t,e){if(t.input.val()!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(r){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(e,i,s){var n=function(t){var e=new Date;return e.setDate(e.getDate()+t),e},o=function(i){try{return t.datepicker.parseDate(t.datepicker._get(e,"dateFormat"),i,t.datepicker._getFormatConfig(e))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?t.datepicker._getDate(e):null)||new Date,o=n.getFullYear(),a=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":a+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a));break;case"y":case"Y":o+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a))}l=h.exec(i)}return new Date(o,a,r)},a=null==i||""===i?s:"string"==typeof i?o(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return a=a&&"Invalid Date"==""+a?s:a,a&&(a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)),this._daylightSavingAdjust(a)},_daylightSavingAdjust:function(t){return t?(t.setHours(t.getHours()>12?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!e,n=t.selectedMonth,o=t.selectedYear,a=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=a.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=a.getMonth(),t.drawYear=t.selectedYear=t.currentYear=a.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){var e=!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return e},_attachHandlers:function(e){var i=this._get(e,"stepMonths"),s="#"+e.id.replace(/\\\\/g,"\\");e.dpDiv.find("[data-handler]").map(function(){var e={prev:function(){t.datepicker._adjustDate(s,-i,"M")},next:function(){t.datepicker._adjustDate(s,+i,"M")},hide:function(){t.datepicker._hideDatepicker()},today:function(){t.datepicker._gotoToday(s)},selectDay:function(){return t.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return t.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return t.datepicker._selectMonthYear(s,this,"Y"),!1}};t(this).on(this.getAttribute("data-event"),e[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,h,l,c,u,d,p,f,g,m,_,v,b,y,w,k,x,C,D,I,T,P,M,S,H,z,O,A,N,W,E,F,L,R=new Date,B=this._daylightSavingAdjust(new Date(R.getFullYear(),R.getMonth(),R.getDate())),Y=this._get(t,"isRTL"),j=this._get(t,"showButtonPanel"),q=this._get(t,"hideIfNoPrevNext"),K=this._get(t,"navigationAsDateFormat"),U=this._getNumberOfMonths(t),V=this._get(t,"showCurrentAtPos"),$=this._get(t,"stepMonths"),X=1!==U[0]||1!==U[1],G=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),Q=this._getMinMaxDate(t,"min"),J=this._getMinMaxDate(t,"max"),Z=t.drawMonth-V,te=t.drawYear;if(0>Z&&(Z+=12,te--),J)for(e=this._daylightSavingAdjust(new Date(J.getFullYear(),J.getMonth()-U[0]*U[1]+1,J.getDate())),e=Q&&Q>e?Q:e;this._daylightSavingAdjust(new Date(te,Z,1))>e;)Z--,0>Z&&(Z=11,te--);for(t.drawMonth=Z,t.drawYear=te,i=this._get(t,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(te,Z-$,1)),this._getFormatConfig(t)):i,s=this._canAdjustMonth(t,-1,te,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":q?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(t,"nextText"),n=K?this.formatDate(n,this._daylightSavingAdjust(new Date(te,Z+$,1)),this._getFormatConfig(t)):n,o=this._canAdjustMonth(t,1,te,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":q?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",a=this._get(t,"currentText"),r=this._get(t,"gotoCurrent")&&t.currentDay?G:B,a=K?this.formatDate(a,r,this._getFormatConfig(t)):a,h=t.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(t,"closeText")+"</button>",l=j?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(t,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+a+"</button>":"")+(Y?"":h)+"</div>":"",c=parseInt(this._get(t,"firstDay"),10),c=isNaN(c)?0:c,u=this._get(t,"showWeek"),d=this._get(t,"dayNames"),p=this._get(t,"dayNamesMin"),f=this._get(t,"monthNames"),g=this._get(t,"monthNamesShort"),m=this._get(t,"beforeShowDay"),_=this._get(t,"showOtherMonths"),v=this._get(t,"selectOtherMonths"),b=this._getDefaultDate(t),y="",k=0;U[0]>k;k++){for(x="",this.maxRows=4,C=0;U[1]>C;C++){if(D=this._daylightSavingAdjust(new Date(te,Z,t.selectedDay)),I=" ui-corner-all",T="",X){if(T+="<div class='ui-datepicker-group",U[1]>1)switch(C){case 0:T+=" ui-datepicker-group-first",I=" ui-corner-"+(Y?"right":"left");break;case U[1]-1:T+=" ui-datepicker-group-last",I=" ui-corner-"+(Y?"left":"right");break;default:T+=" ui-datepicker-group-middle",I=""}T+="'>"}for(T+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+I+"'>"+(/all|left/.test(I)&&0===k?Y?o:s:"")+(/all|right/.test(I)&&0===k?Y?s:o:"")+this._generateMonthYearHeader(t,Z,te,Q,J,k>0||C>0,f,g)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",P=u?"<th class='ui-datepicker-week-col'>"+this._get(t,"weekHeader")+"</th>":"",w=0;7>w;w++)M=(w+c)%7,P+="<th scope='col'"+((w+c+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+d[M]+"'>"+p[M]+"</span></th>";for(T+=P+"</tr></thead><tbody>",S=this._getDaysInMonth(te,Z),te===t.selectedYear&&Z===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,S)),H=(this._getFirstDayOfMonth(te,Z)-c+7)%7,z=Math.ceil((H+S)/7),O=X?this.maxRows>z?this.maxRows:z:z,this.maxRows=O,A=this._daylightSavingAdjust(new Date(te,Z,1-H)),N=0;O>N;N++){for(T+="<tr>",W=u?"<td class='ui-datepicker-week-col'>"+this._get(t,"calculateWeek")(A)+"</td>":"",w=0;7>w;w++)E=m?m.apply(t.input?t.input[0]:null,[A]):[!0,""],F=A.getMonth()!==Z,L=F&&!v||!E[0]||Q&&Q>A||J&&A>J,W+="<td class='"+((w+c+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(A.getTime()===D.getTime()&&Z===t.selectedMonth&&t._keyEvent||b.getTime()===A.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!_?"":" "+E[1]+(A.getTime()===G.getTime()?" "+this._currentClass:"")+(A.getTime()===B.getTime()?" ui-datepicker-today":""))+"'"+(F&&!_||!E[2]?"":" title='"+E[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+A.getMonth()+"' data-year='"+A.getFullYear()+"'")+">"+(F&&!_?"&#xa0;":L?"<span class='ui-state-default'>"+A.getDate()+"</span>":"<a class='ui-state-default"+(A.getTime()===B.getTime()?" ui-state-highlight":"")+(A.getTime()===G.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+"' href='#'>"+A.getDate()+"</a>")+"</td>",A.setDate(A.getDate()+1),A=this._daylightSavingAdjust(A);T+=W+"</tr>"}Z++,Z>11&&(Z=0,te++),T+="</tbody></table>"+(X?"</div>"+(U[0]>0&&C===U[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),x+=T}y+=x}return y+=l,t._keyEvent=!1,y},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var h,l,c,u,d,p,f,g,m=this._get(t,"changeMonth"),_=this._get(t,"changeYear"),v=this._get(t,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",y="";if(o||!m)y+="<span class='ui-datepicker-month'>"+a[e]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,y+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",c=0;12>c;c++)(!h||c>=s.getMonth())&&(!l||n.getMonth()>=c)&&(y+="<option value='"+c+"'"+(c===e?" selected='selected'":"")+">"+r[c]+"</option>");y+="</select>"}if(v||(b+=y+(!o&&m&&_?"":"&#xa0;")),!t.yearshtml)if(t.yearshtml="",o||!_)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(u=this._get(t,"yearRange").split(":"),d=(new Date).getFullYear(),p=function(t){var e=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?d+parseInt(t,10):parseInt(t,10);return isNaN(e)?d:e},f=p(u[0]),g=Math.max(f,p(u[1]||"")),f=s?Math.max(f,s.getFullYear()):f,g=n?Math.min(g,n.getFullYear()):g,t.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";g>=f;f++)t.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),v&&(b+=(!o&&m&&_?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),o=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),a=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,o)));t.selectedDay=a.getDate(),t.drawMonth=t.selectedMonth=a.getMonth(),t.drawYear=t.selectedYear=a.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=i&&i>e?i:e;return s&&n>s?s:n},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){var e=this._get(t,"numberOfMonths");return null==e?[1,1]:"number"==typeof e?[1,e]:e},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),o=this._daylightSavingAdjust(new Date(i,s+(0>e?e:n[0]*n[1]),1));return 0>e&&o.setDate(this._getDaysInMonth(o.getFullYear(),o.getMonth())),this._isInRange(t,o)},_isInRange:function(t,e){var i,s,n=this._getMinMaxDate(t,"min"),o=this._getMinMaxDate(t,"max"),a=null,r=null,h=this._get(t,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),a=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(a+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||e.getTime()>=n.getTime())&&(!o||e.getTime()<=o.getTime())&&(!a||e.getFullYear()>=a)&&(!r||r>=e.getFullYear())},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return e="string"!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),{shortYearCutoff:e,dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);var n=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),n,this._getFormatConfig(t))}}),t.fn.datepicker=function(e){if(!this.length)return this;t.datepicker.initialized||(t(document).on("mousedown",t.datepicker._checkExternalClick),t.datepicker.initialized=!0),0===t("#"+t.datepicker._mainDivId).length&&t("body").append(t.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof e||"isDisabled"!==e&&"getDate"!==e&&"widget"!==e?"option"===e&&2===arguments.length&&"string"==typeof arguments[1]?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof e?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this].concat(i)):t.datepicker._attachDatepicker(this,e)}):t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i))},t.datepicker=new s,t.datepicker.initialized=!1,t.datepicker.uuid=(new Date).getTime(),t.datepicker.version="1.12.1",t.datepicker,t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var _=!1;t(document).on("mouseup",function(){_=!1}),t.widget("ui.mouse",{version:"1.12.1",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!_){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),_=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,_=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blurActiveElement(e),this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}
},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),h=t.pageX,l=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,h=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(h=this.originalPageX),"x"===a.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,h,l,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)h=s.snapElements[d].left-s.margins.left,l=h+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,h-g>_||m>l+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(h-_),r=g>=Math.abs(l-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(h-m),r=g>=Math.abs(l-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;default:}},_setupHandles:function(){var e,i,s,n,o,a=this.options,r=this;if(this.handles=a.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),n="ui-resizable-"+e,o=t("<div>"),this._addClass(o,"ui-resizable-handle "+n),o.css({zIndex:a.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(o);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:r._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){r.resizing||(this.className&&(o=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=o&&o[1]?o[1]:"se")}),a.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,h=this._change[o];return this._updatePrevProperties(),h?(i=h.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,h,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,h=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(a,{top:h,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,h=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&l&&(t.left=r-e.minWidth),s&&l&&(t.left=r-e.maxWidth),a&&c&&(t.top=h-e.minHeight),n&&c&&(t.top=h-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-a},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(h,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,h=t(this).resizable("instance"),l=h.options,c=h.element,u=l.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(h.containerElement=t(d),/document/.test(u)||u===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=h._num(e.css("padding"+s))}),h.containerOffset=e.offset(),h.containerPosition=e.position(),h.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,o=h.containerSize.width,a=h._hasScroll(d,"left")?d.scrollWidth:o,r=h._hasScroll(d)?d.scrollHeight:n,h.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,h=a.containerOffset,l=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=h),l.left<(a._helper?h.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-h.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?h.left:0),l.top<(a._helper?h.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-h.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?h.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-h.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-h.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),h=a.outerWidth()-e.sizeDiff.width,l=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,c=h[1]||1,u=Math.round((n.width-o.width)/l)*l,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=h,_&&(p+=l),v&&(f+=c),g&&(p-=l),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-l>0?(i.size.width=p,i.position.left=a.left-u):(p=l-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.dialog",{version:"1.12.1",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog
},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),o=Math.max.apply(null,n);return o>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",o+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),this.close(e),void 0;if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");e.target!==n[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){n.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?(this._removeClass(this.uiDialog,"ui-dialog-buttons"),void 0):(t.each(i,function(i,s){var n,o;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),n=s.click,o={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel,icons:s.icons,text:s.text},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,delete s.icons,"boolean"==typeof s.text&&delete s.text,t("<button></button>",s).button(o).appendTo(e.uiButtonSet).on("click",function(){n.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(n))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(n,o){var a=o.offset.left-i.document.scrollLeft(),r=o.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(a>=0?"+":"")+a+" "+"top"+(r>=0?"+":"")+r,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,e(o))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,n=s.resizable,o=this.uiDialog.css("position"),a="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:a,start:function(s,n){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(n))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(n,o){var a=i.uiDialog.offset(),r=a.left-i.document.scrollLeft(),h=a.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,e(o))}}).css("position",o)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,n={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,i){var s,n,o=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=o.is(":data(ui-draggable)"),s&&!i&&o.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(n=o.is(":data(ui-resizable)"),n&&!i&&o.resizable("destroy"),n&&"string"==typeof i&&o.resizable("option","handles",i),n||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog,t.widget("ui.droppable",{version:"1.12.1",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!0,greedy:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var e,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=t.isFunction(s)?s:function(t){return t.is(s)},this.proportions=function(){return arguments.length?(e=arguments[0],void 0):e?e:e={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this._addClass("ui-droppable")},_addToManager:function(e){t.ui.ddmanager.droppables[e]=t.ui.ddmanager.droppables[e]||[],t.ui.ddmanager.droppables[e].push(this)},_splice:function(t){for(var e=0;t.length>e;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var e=t.ui.ddmanager.droppables[this.options.scope];this._splice(e)},_setOption:function(e,i){if("accept"===e)this.accept=t.isFunction(i)?i:function(t){return t.is(i)};else if("scope"===e){var s=t.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(e,i)},_activate:function(e){var i=t.ui.ddmanager.current;this._addActiveClass(),i&&this._trigger("activate",e,this.ui(i))},_deactivate:function(e){var i=t.ui.ddmanager.current;this._removeActiveClass(),i&&this._trigger("deactivate",e,this.ui(i))},_over:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._addHoverClass(),this._trigger("over",e,this.ui(i)))},_out:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeHoverClass(),this._trigger("out",e,this.ui(i)))},_drop:function(e,i){var s=i||t.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=t(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&v(s,t.extend(i,{offset:i.element.offset()}),i.options.tolerance,e)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(s)),this.element):!1):!1},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}});var v=t.ui.intersect=function(){function t(t,e,i){return t>=e&&e+i>t}return function(e,i,s,n){if(!i.offset)return!1;var o=(e.positionAbs||e.position.absolute).left+e.margins.left,a=(e.positionAbs||e.position.absolute).top+e.margins.top,r=o+e.helperProportions.width,h=a+e.helperProportions.height,l=i.offset.left,c=i.offset.top,u=l+i.proportions().width,d=c+i.proportions().height;switch(s){case"fit":return o>=l&&u>=r&&a>=c&&d>=h;case"intersect":return o+e.helperProportions.width/2>l&&u>r-e.helperProportions.width/2&&a+e.helperProportions.height/2>c&&d>h-e.helperProportions.height/2;case"pointer":return t(n.pageY,c,i.proportions().height)&&t(n.pageX,l,i.proportions().width);case"touch":return(a>=c&&d>=a||h>=c&&d>=h||c>a&&h>d)&&(o>=l&&u>=o||r>=l&&u>=r||l>o&&r>u);default:return!1}}}();t.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(e,i){var s,n,o=t.ui.ddmanager.droppables[e.options.scope]||[],a=i?i.type:null,r=(e.currentItem||e.element).find(":data(ui-droppable)").addBack();t:for(s=0;o.length>s;s++)if(!(o[s].options.disabled||e&&!o[s].accept.call(o[s].element[0],e.currentItem||e.element))){for(n=0;r.length>n;n++)if(r[n]===o[s].element[0]){o[s].proportions().height=0;continue t}o[s].visible="none"!==o[s].element.css("display"),o[s].visible&&("mousedown"===a&&o[s]._activate.call(o[s],i),o[s].offset=o[s].element.offset(),o[s].proportions({width:o[s].element[0].offsetWidth,height:o[s].element[0].offsetHeight}))}},drop:function(e,i){var s=!1;return t.each((t.ui.ddmanager.droppables[e.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&v(e,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(e,i){e.element.parentsUntil("body").on("scroll.droppable",function(){e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)})},drag:function(e,i){e.options.refreshPositions&&t.ui.ddmanager.prepareOffsets(e,i),t.each(t.ui.ddmanager.droppables[e.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,o,a=v(e,this,this.options.tolerance,i),r=!a&&this.isover?"isout":a&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,o=this.element.parents(":data(ui-droppable)").filter(function(){return t(this).droppable("instance").options.scope===n}),o.length&&(s=t(o[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(e,i){e.element.parentsUntil("body").off("scroll.droppable"),e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)}},t.uiBackCompat!==!1&&t.widget("ui.droppable",t.ui.droppable,{options:{hoverClass:!1,activeClass:!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}}),t.ui.droppable,t.widget("ui.progressbar",{version:"1.12.1",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=t("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){return void 0===t?this.options.value:(this.options.value=this._constrainedValue(t),this._refreshValue(),void 0)},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=t===!1,"number"!=typeof t&&(t=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var e=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||e>this.min).width(i.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,e===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=t("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":e}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==e&&(this.oldValue=e,this._trigger("change")),e===this.options.max&&this._trigger("complete")}}),t.widget("ui.selectable",t.ui.mouse,{version:"1.12.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e.elementPos=t(e.element[0]).offset(),e.selectees=t(e.options.filter,e.element[0]),e._addClass(e.selectees,"ui-selectee"),e.selectees.each(function(){var i=t(this),s=i.offset(),n={left:s.left-e.elementPos.left,top:s.top-e.elementPos.top};t.data(this,"selectable-item",{element:this,$element:i,left:n.left,top:n.top,right:n.left+i.outerWidth(),bottom:n.top+i.outerHeight(),startselected:!1,selected:i.hasClass("ui-selected"),selecting:i.hasClass("ui-selecting"),unselecting:i.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=t("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.elementPos=t(this.element[0]).offset(),this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(i._removeClass(s.$element,"ui-selected"),s.selected=!1,i._addClass(s.$element,"ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),i._removeClass(n.$element,s?"ui-unselecting":"ui-selected")._addClass(n.$element,s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,h=e.pageY;return o>r&&(i=r,r=o,o=i),a>h&&(i=h,h=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:h-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),l=!1,c={};i&&i.element!==s.element[0]&&(c.left=i.left+s.elementPos.left,c.right=i.right+s.elementPos.left,c.top=i.top+s.elementPos.top,c.bottom=i.bottom+s.elementPos.top,"touch"===n.tolerance?l=!(c.left>r||o>c.right||c.top>h||a>c.bottom):"fit"===n.tolerance&&(l=c.left>o&&r>c.right&&c.top>a&&h>c.bottom),l?(i.selected&&(s._removeClass(i.$element,"ui-selected"),i.selected=!1),i.unselecting&&(s._removeClass(i.$element,"ui-unselecting"),i.unselecting=!1),i.selecting||(s._addClass(i.$element,"ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,s._addClass(i.$element,"ui-selected"),i.selected=!0):(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,i.startselected&&(s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(s._removeClass(i.$element,"ui-selected"),i.selected=!1,s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-selecting")._addClass(s.$element,"ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.selectmenu",[t.ui.formResetMixin,{version:"1.12.1",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!1,this.menuItems=t()},_drawButton:function(){var e,i=this,s=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.focus(),t.preventDefault()}}),this.element.hide(),this.button=t("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),e=t("<span>").appendTo(this.button),this._addClass(e,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(s).appendTo(this.button),this.options.width!==!1&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){i._rendered||i._refreshMenu()})},_drawMenu:function(){var e=this;this.menu=t("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=t("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,i){t.preventDefault(),e._setSelection(),e._select(i.item.data("ui-selectmenu-item"),t)},focus:function(t,i){var s=i.item.data("ui-selectmenu-item");null!=e.focusIndex&&s.index!==e.focusIndex&&(e._trigger("focus",t,{item:s}),e.isOpen||e._select(s,t)),e.focusIndex=s.index,e.button.attr("aria-activedescendant",e.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t,e=this.element.find("option");this.menu.empty(),this._parseOptions(e),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!0,e.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(t.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(e){var i=t("<span>");return this._setText(i,e.label),this._addClass(i,"ui-selectmenu-text"),i},_renderMenu:function(e,i){var s=this,n="";t.each(i,function(i,o){var a;o.optgroup!==n&&(a=t("<li>",{text:o.optgroup}),s._addClass(a,"ui-selectmenu-optgroup","ui-menu-divider"+(o.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),a.appendTo(e),n=o.optgroup),s._renderItemData(e,o)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(e,i){var s=t("<li>"),n=t("<div>",{title:i.element.attr("title")});return i.disabled&&this._addClass(s,null,"ui-state-disabled"),this._setText(n,i.label),s.append(n).appendTo(e)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),n+=":not(.ui-state-disabled)"),s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](n).eq(-1):i[t+"All"](n).eq(0),s.length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?(t=window.getSelection(),t.removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(e){this.isOpen&&(t(e.target).closest(".ui-selectmenu-menu, #"+t.ui.escapeSelector(this.ids.button)).length||this.close(e))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection(),t.rangeCount&&(this.range=t.getRangeAt(0))):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(e){var i=!0;switch(e.keyCode){case t.ui.keyCode.TAB:case t.ui.keyCode.ESCAPE:this.close(e),i=!1;break;case t.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(e);break;case t.ui.keyCode.UP:e.altKey?this._toggle(e):this._move("prev",e);break;case t.ui.keyCode.DOWN:e.altKey?this._toggle(e):this._move("next",e);break;case t.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(e):this._toggle(e);break;case t.ui.keyCode.LEFT:this._move("prev",e);break;case t.ui.keyCode.RIGHT:this._move("next",e);break;case t.ui.keyCode.HOME:case t.ui.keyCode.PAGE_UP:this._move("first",e);break;case t.ui.keyCode.END:case t.ui.keyCode.PAGE_DOWN:this._move("last",e);break;default:this.menu.trigger(e),i=!1}i&&e.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){var e=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":e,"aria-activedescendant":e}),this.menu.attr("aria-activedescendant",e)},_setOption:function(t,e){if("icons"===t){var i=this.button.find("span.ui-icon");this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)}this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var t=this.options.width;return t===!1?(this.button.css("width",""),void 0):(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t),void 0)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(e){var i=this,s=[];e.each(function(e,n){s.push(i._parseOption(t(n),e))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),t.widget("ui.slider",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"slide",options:{animate:!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!1
},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var e,i,s=this.options,n=this.element.find(".ui-slider-handle"),o="<span tabindex='0'></span>",a=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),e=n.length;i>e;e++)a.push(o);this.handles=n.add(t(a.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(e){t(this).data("ui-slider-handle-index",e).attr("tabIndex",0)})},_createRange:function(){var e=this.options;e.range?(e.range===!0&&(e.values?e.values.length&&2!==e.values.length?e.values=[e.values[0],e.values[0]]:t.isArray(e.values)&&(e.values=e.values.slice(0)):e.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=t("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),("min"===e.range||"max"===e.range)&&this._addClass(this.range,"ui-slider-range-"+e.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(e){var i,s,n,o,a,r,h,l,c=this,u=this.options;return u.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:e.pageX,y:e.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(e){var i=Math.abs(s-c.values(e));(n>i||n===i&&(e===c._lastChangedValue||c.values(e)===u.min))&&(n=i,o=t(this),a=e)}),r=this._start(e,a),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=a,this._addClass(o,null,"ui-state-active"),o.trigger("focus"),h=o.offset(),l=!t(e.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:e.pageX-h.left-o.width()/2,top:e.pageY-h.top-o.height()/2-(parseInt(o.css("borderTopWidth"),10)||0)-(parseInt(o.css("borderBottomWidth"),10)||0)+(parseInt(o.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(e,a,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,i),!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,i,s,n,o;return"horizontal"===this.orientation?(e=this.elementSize.width,i=t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,i=t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/e,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),o=this._valueMin()+s*n,this._trimAlignValue(o)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n,o=this.value(),a=this.values();this._hasMultipleValues()&&(n=this.values(e?0:1),o=this.values(e),2===this.options.values.length&&this.options.range===!0&&(i=0===e?Math.min(n,i):Math.max(n,i)),a[e]=i),i!==o&&(s=this._trigger("slide",t,this._uiHash(e,i,a)),s!==!1&&(this._hasMultipleValues()?this.values(e,i):this.value(i)))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(e,i){var s,n,o;if(arguments.length>1)return this.options.values[e]=this._trimAlignValue(i),this._refreshValue(),this._change(null,e),void 0;if(!arguments.length)return this._values();if(!t.isArray(arguments[0]))return this._hasMultipleValues()?this._values(e):this.value();for(s=this.options.values,n=arguments[0],o=0;s.length>o;o+=1)s[o]=this._trimAlignValue(n[o]),this._change(null,o);this._refreshValue()},_setOption:function(e,i){var s,n=0;switch("range"===e&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),t.isArray(this.options.values)&&(n=this.options.values.length),this._super(e,i),e){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(i),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=n-1;s>=0;s--)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i,s;if(arguments.length)return e=this.options.values[t],e=this._trimAlignValue(e);if(this._hasMultipleValues()){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(t){if(this._valueMin()>=t)return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=this.options.step>0?this.options.step:1,i=(t-this._valueMin())%e,s=t-i;return 2*Math.abs(i)>=e&&(s+=i>0?e:-e),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step,s=Math.round((t-e)/i)*i;t=s+e,t>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,s,n,o,a=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,c={};this._hasMultipleValues()?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),c["horizontal"===h.orientation?"left":"bottom"]=i+"%",t(this).stop(1,1)[l?"animate":"css"](c,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-e+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-e+"%"},{queue:!1,duration:r.animate}))),e=i}):(s=this.value(),n=this._valueMin(),o=this._valueMax(),i=o!==n?100*((s-n)/(o-n)):0,c["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](c,r.animate),"min"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},r.animate),"min"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},r.animate))},_handleEvents:{keydown:function(e){var i,s,n,o,a=t(e.target).data("ui-slider-handle-index");switch(e.keyCode){case t.ui.keyCode.HOME:case t.ui.keyCode.END:case t.ui.keyCode.PAGE_UP:case t.ui.keyCode.PAGE_DOWN:case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(e.preventDefault(),!this._keySliding&&(this._keySliding=!0,this._addClass(t(e.target),null,"ui-state-active"),i=this._start(e,a),i===!1))return}switch(o=this.options.step,s=n=this._hasMultipleValues()?this.values(a):this.value(),e.keyCode){case t.ui.keyCode.HOME:n=this._valueMin();break;case t.ui.keyCode.END:n=this._valueMax();break;case t.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+o);break;case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-o)}this._slide(e,a,n)},keyup:function(e){var i=t(e.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(e,i),this._change(e,i),this._removeClass(t(e.target),null,"ui-state-active"))}}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp(new t.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,h=r+t.height,l=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+l>r&&h>s+l,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),n="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),o=s&&n;return o?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],h=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(o=t(l[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&h.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(h.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,h,l,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,l=r.length;l>s;s++)h=t(r[s]),h.data(this.widgetName+"-item",a),c.push({item:h,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]);return e._addClass(n,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(n,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,h,l,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[a],l=!1,e[u]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(e[u]-h)&&(n=Math.abs(e[u]-h),o=this.items[s],this.direction=l?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;
this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}}),t.widget("ui.spinner",{version:"1.12.1",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var e=this._super(),i=this.element;return t.each(["min","max","step"],function(t,s){var n=i.attr(s);null!=n&&n.length&&(e[s]=n)}),e},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",t),void 0)},mousewheel:function(t,e){if(e){if(!this.spinning&&!this._start(t))return!1;this._spin((e>0?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(e){function i(){var e=this.element[0]===t.ui.safeActiveElement(this.document[0]);e||(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===t.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),e.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(e)!==!1&&this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(e){return t(e.currentTarget).hasClass("ui-state-active")?this._start(e)===!1?!1:(this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&this.uiSpinner.height()>0&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(e){var i=this.options,s=t.ui.keyCode;switch(e.keyCode){case s.UP:return this._repeat(null,1,e),!0;case s.DOWN:return this._repeat(null,-1,e),!0;case s.PAGE_UP:return this._repeat(null,i.page,e),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,e),!0}return!1},_start:function(t){return this.spinning||this._trigger("start",t)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&this._trigger("spin",e,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(e){var i=this.options.incremental;return i?t.isFunction(i)?i(e):Math.floor(e*e*e/5e4-e*e/500+17*e/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_adjustValue:function(t){var e,i,s=this.options;return e=null!==s.min?s.min:0,i=t-e,i=Math.round(i/s.step)*s.step,t=e+i,t=parseFloat(t.toFixed(this._precision())),null!==s.max&&t>s.max?s.max:null!==s.min&&s.min>t?s.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",t))},_setOption:function(t,e){var i,s,n;return"culture"===t||"numberFormat"===t?(i=this._parse(this.element.val()),this.options[t]=e,this.element.val(this._format(i)),void 0):(("max"===t||"min"===t||"step"===t)&&"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(s=this.buttons.first().find(".ui-icon"),this._removeClass(s,null,this.options.icons.up),this._addClass(s,null,e.up),n=this.buttons.last().find(".ui-icon"),this._removeClass(n,null,this.options.icons.down),this._addClass(n,null,e.down)),this._super(t,e),void 0)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable")},_setOptions:r(function(t){this._super(t)}),_parse:function(t){return"string"==typeof t&&""!==t&&(t=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t),""===t||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null===t?!1:t===this._adjustValue(t)},_value:function(t,e){var i;""!==t&&(i=this._parse(t),null!==i&&(e||(i=this._adjustValue(i)),t=this._format(i))),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:r(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:r(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:r(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:r(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){return arguments.length?(r(this._value).call(this,t),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),t.uiBackCompat!==!1&&t.widget("ui.spinner",t.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}}),t.ui.spinner,t.widget("ui.tabs",{version:"1.12.1",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var t=/#.*$/;return function(e){var i,s;i=e.href.replace(t,""),s=location.href.replace(t,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return e.hash.length>1&&i===s}}(),_create:function(){var e=this,i=this.options;this.running=!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,i.collapsible),this._processTabs(),i.active=this._initialActive(),t.isArray(i.disabled)&&(i.disabled=t.unique(i.disabled.concat(t.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):t(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var e=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===e&&(s&&this.tabs.each(function(i,n){return t(n).attr("aria-controls")===s?(e=i,!1):void 0}),null===e&&(e=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===e||-1===e)&&(e=this.tabs.length?0:!1)),e!==!1&&(e=this.tabs.index(this.tabs.eq(e)),-1===e&&(e=i?!1:0)),!i&&e===!1&&this.anchors.length&&(e=0),e},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):t()}},_tabKeydown:function(e){var i=t(t.ui.safeActiveElement(this.document[0])).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(e)){switch(e.keyCode){case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:s++;break;case t.ui.keyCode.UP:case t.ui.keyCode.LEFT:n=!1,s--;break;case t.ui.keyCode.END:s=this.anchors.length-1;break;case t.ui.keyCode.HOME:s=0;break;case t.ui.keyCode.SPACE:return e.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case t.ui.keyCode.ENTER:return e.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}e.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),e.ctrlKey||e.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(e){this._handlePageNav(e)||e.ctrlKey&&e.keyCode===t.ui.keyCode.UP&&(e.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(e){return e.altKey&&e.keyCode===t.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):e.altKey&&e.keyCode===t.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(e,i){function s(){return e>n&&(e=0),0>e&&(e=n),e}for(var n=this.tabs.length-1;-1!==t.inArray(s(),this.options.disabled);)e=i?e+1:e-1;return e},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||this.options.active!==!1||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e),void 0)},_sanitizeSelector:function(t){return t?t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var e=this.options,i=this.tablist.children(":has(a[href])");e.disabled=t.map(i.filter(".ui-state-disabled"),function(t){return i.index(t)}),this._processTabs(),e.active!==!1&&this.anchors.length?this.active.length&&!t.contains(this.tablist[0],this.active[0])?this.tabs.length===e.disabled.length?(e.active=!1,this.active=t()):this._activate(this._findNextTab(Math.max(0,e.active-1),!1)):e.active=this.tabs.index(this.active):(e.active=!1,this.active=t()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var e=this,i=this.tabs,s=this.anchors,n=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(e){t(this).is(".ui-state-disabled")&&e.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){t(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return t("a",this)[0]}).attr({role:"presentation",tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=t(),this.anchors.each(function(i,s){var n,o,a,r=t(s).uniqueId().attr("id"),h=t(s).closest("li"),l=h.attr("aria-controls");e._isLocal(s)?(n=s.hash,a=n.substring(1),o=e.element.find(e._sanitizeSelector(n))):(a=h.attr("aria-controls")||t({}).uniqueId()[0].id,n="#"+a,o=e.element.find(n),o.length||(o=e._createPanel(a),o.insertAfter(e.panels[i-1]||e.tablist)),o.attr("aria-live","polite")),o.length&&(e.panels=e.panels.add(o)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":a,"aria-labelledby":r}),o.attr("aria-labelledby",r)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(e){return t("<div>").attr("id",e).data("ui-tabs-destroy",!0)},_setOptionDisabled:function(e){var i,s,n;for(t.isArray(e)&&(e.length?e.length===this.anchors.length&&(e=!0):e=!1),n=0;s=this.tabs[n];n++)i=t(s),e===!0||-1!==t.inArray(n,e)?(i.attr("aria-disabled","true"),this._addClass(i,null,"ui-state-disabled")):(i.removeAttr("aria-disabled"),this._removeClass(i,null,"ui-state-disabled"));this.options.disabled=e,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,e===!0)},_setupEvents:function(e){var i={};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(e){var i,s=this.element.parent();"fill"===e?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var e=t(this),s=e.css("position");"absolute"!==s&&"fixed"!==s&&(i-=e.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=t(this).outerHeight(!0)}),this.panels.each(function(){t(this).height(Math.max(0,i-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.panels.each(function(){i=Math.max(i,t(this).height("").height())}).height(i))},_eventHandler:function(e){var i=this.options,s=this.active,n=t(e.currentTarget),o=n.closest("li"),a=o[0]===s[0],r=a&&i.collapsible,h=r?t():this._getPanelForTab(o),l=s.length?this._getPanelForTab(s):t(),c={oldTab:s,oldPanel:l,newTab:r?t():o,newPanel:h};e.preventDefault(),o.hasClass("ui-state-disabled")||o.hasClass("ui-tabs-loading")||this.running||a&&!i.collapsible||this._trigger("beforeActivate",e,c)===!1||(i.active=r?!1:this.tabs.index(o),this.active=a?t():o,this.xhr&&this.xhr.abort(),l.length||h.length||t.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(o),e),this._toggle(e,c))},_toggle:function(e,i){function s(){o.running=!1,o._trigger("activate",e,i)}function n(){o._addClass(i.newTab.closest("li"),"ui-tabs-active","ui-state-active"),a.length&&o.options.show?o._show(a,o.options.show,s):(a.show(),s())}var o=this,a=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){o._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n()}):(this._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),a.length&&r.length?i.oldTab.attr("tabIndex",-1):a.length&&this.tabs.filter(function(){return 0===t(this).attr("tabIndex")}).attr("tabIndex",-1),a.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(e){var i,s=this._findActive(e);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return e===!1?t():this.tabs.eq(e)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+t.ui.escapeSelector(e)+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){t.data(this,"ui-tabs-destroy")?t(this).remove():t(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var e=t(this),i=e.data("ui-tabs-aria-controls");i?e.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):e.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(e){var i=this.options.disabled;i!==!1&&(void 0===e?i=!1:(e=this._getIndex(e),i=t.isArray(i)?t.map(i,function(t){return t!==e?t:null}):t.map(this.tabs,function(t,i){return i!==e?i:null})),this._setOptionDisabled(i))},disable:function(e){var i=this.options.disabled;if(i!==!0){if(void 0===e)i=!0;else{if(e=this._getIndex(e),-1!==t.inArray(e,i))return;i=t.isArray(i)?t.merge([e],i).sort():[e]}this._setOptionDisabled(i)}},load:function(e,i){e=this._getIndex(e);var s=this,n=this.tabs.eq(e),o=n.find(".ui-tabs-anchor"),a=this._getPanelForTab(n),r={tab:n,panel:a},h=function(t,e){"abort"===e&&s.panels.stop(!1,!0),s._removeClass(n,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===s.xhr&&delete s.xhr};this._isLocal(o[0])||(this.xhr=t.ajax(this._ajaxSettings(o,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(this._addClass(n,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,n){setTimeout(function(){a.html(t),s._trigger("load",i,r),h(n,e)},1)}).fail(function(t,e){setTimeout(function(){h(t,e)},1)})))},_ajaxSettings:function(e,i,s){var n=this;return{url:e.attr("href").replace(/#.*$/,""),beforeSend:function(e,o){return n._trigger("beforeLoad",i,t.extend({jqXHR:e,ajaxSettings:o},s))}}},_getPanelForTab:function(e){var i=t(e).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),t.uiBackCompat!==!1&&t.widget("ui.tabs",t.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}}),t.ui.tabs,t.widget("ui.tooltip",{version:"1.12.1",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var e=t(this).attr("title")||"";return t("<a>").text(e).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,track:!1,close:null,open:null},_addDescribedBy:function(e,i){var s=(e.attr("aria-describedby")||"").split(/\s+/);s.push(i),e.data("ui-tooltip-id",i).attr("aria-describedby",t.trim(s.join(" ")))},_removeDescribedBy:function(e){var i=e.data("ui-tooltip-id"),s=(e.attr("aria-describedby")||"").split(/\s+/),n=t.inArray(i,s);-1!==n&&s.splice(n,1),e.removeData("ui-tooltip-id"),s=t.trim(s.join(" ")),s?e.attr("aria-describedby",s):e.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=t("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=t([])},_setOption:function(e,i){var s=this;this._super(e,i),"content"===e&&t.each(this.tooltips,function(t,e){s._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur");n.target=n.currentTarget=s.element[0],e.close(n,!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var e=t(this);return e.is("[title]")?e.data("ui-tooltip-title",e.attr("title")).removeAttr("title"):void 0}))},_enable:function(){this.disabledTitles.each(function(){var e=t(this);e.data("ui-tooltip-title")&&e.attr("title",e.data("ui-tooltip-title"))}),this.disabledTitles=t([])},open:function(e){var i=this,s=t(e?e.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),e&&"mouseover"===e.type&&s.parents().each(function(){var e,s=t(this);s.data("ui-tooltip-open")&&(e=t.Event("blur"),e.target=e.currentTarget=this,i.close(e,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(e,s),this._updateContent(s,e))},_updateContent:function(t,e){var i,s=this.options.content,n=this,o=e?e.type:null;return"string"==typeof s||s.nodeType||s.jquery?this._open(e,t,s):(i=s.call(t[0],function(i){n._delay(function(){t.data("ui-tooltip-open")&&(e&&(e.type=o),this._open(e,t,i))})}),i&&this._open(e,t,i),void 0)},_open:function(e,i,s){function n(t){l.of=t,a.is(":hidden")||a.position(l)}var o,a,r,h,l=t.extend({},this.options.position);if(s){if(o=this._find(i))return o.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(e&&"mouseover"===e.type?i.attr("title",""):i.removeAttr("title")),o=this._tooltip(i),a=o.tooltip,this._addDescribedBy(i,a.attr("id")),a.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),h=t("<div>").html(a.find(".ui-tooltip-content").html()),h.removeAttr("name").find("[name]").removeAttr("name"),h.removeAttr("id").find("[id]").removeAttr("id"),h.appendTo(this.liveRegion),this.options.track&&e&&/^mouse/.test(e.type)?(this._on(this.document,{mousemove:n}),n(e)):a.position(t.extend({of:i},this.options.position)),a.hide(),this._show(a,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){a.is(":visible")&&(n(l.of),clearInterval(r))},t.fx.interval)),this._trigger("open",e,{tooltip:a})}},_registerCloseHandlers:function(e,i){var s={keyup:function(e){if(e.keyCode===t.ui.keyCode.ESCAPE){var s=t.Event(e);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),e&&"mouseover"!==e.type||(s.mouseleave="close"),e&&"focusin"!==e.type||(s.focusout="close"),this._on(!0,i,s)},close:function(e){var i,s=this,n=t(e?e.currentTarget:this.element),o=this._find(n);return o?(i=o.tooltip,o.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),o.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(t(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),e&&"mouseleave"===e.type&&t.each(this.parents,function(e,i){t(i.element).attr("title",i.title),delete s.parents[e]}),o.closing=!0,this._trigger("close",e,{tooltip:i}),o.hiding||(o.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(e){var i=t("<div>").attr("role","tooltip"),s=t("<div>").appendTo(i),n=i.uniqueId().attr("id");return this._addClass(s,"ui-tooltip-content"),this._addClass(i,"ui-tooltip","ui-widget ui-widget-content"),i.appendTo(this._appendTo(e)),this.tooltips[n]={element:e,tooltip:i}},_find:function(t){var e=t.data("ui-tooltip-id");return e?this.tooltips[e]:null},_removeTooltip:function(t){t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){var e=t.closest(".ui-front, dialog");return e.length||(e=this.document[0].body),e},_destroy:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur"),o=s.element;n.target=n.currentTarget=o[0],e.close(n,!0),t("#"+i).remove(),o.data("ui-tooltip-title")&&(o.attr("title")||o.attr("title",o.data("ui-tooltip-title")),o.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),t.uiBackCompat!==!1&&t.widget("ui.tooltip",t.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}}),t.ui.tooltip});;

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.CodeMirror = factory());
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {this.id = null;};
  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range$$1;
    try {range$$1 = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range$$1 || range$$1.parentElement() != te) { return false }
    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
      var this$1 = this;

    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
      var this$1 = this;

    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this$1.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map$$1[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range$$1 = doc.sel.ranges[i];
      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
      var collapsed = range$$1.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range$$1.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range$$1, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range$$1.from(), sTo = range$$1.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
        cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      onBlur(cm);
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;
    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
      var this$1 = this;

    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this$1.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
      var this$1 = this;

    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
      var this$1 = this;

    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
      var this$1 = this;

    for (var i = 0; i < this.ranges.length; i++)
      { if (!this$1.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
      var this$1 = this;

    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        var this$1 = this;

        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    var this$1 = this;

    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at)
        { if (op(this$1.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;

    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this$1;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      var this$1 = this;

      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;
          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      var this$1 = this;

      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }
            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    var this$1 = this;

    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this$1[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
      var this$1 = this;

    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
      var this$1 = this;

    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    var this$1 = this;

    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this$1; }
  };

  SharedTextMarker.prototype.clear = function () {
      var this$1 = this;

    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this$1.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range$$1 = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range$$1.head; }
      else if (start == "anchor") { pos = range$$1.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
      else { pos = range$$1.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                           clipPos(this$1, ranges[i].head)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var this$1 = this;

      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var this$1 = this;

      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var this$1 = this;

      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this$1, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
                span.from == null && lineNo$$1 != from.line ||
                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo$$1;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo$$1;
      });
      return clipPos(this, Pos(lineNo$$1, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      var this$1 = this;

      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this$1.linked[i];
        if (link.doc != other) { continue }
        this$1.linked.splice(i, 1);
        other.unlinkDoc(this$1);
        detachSharedMarkers(findSharedMarkers(this$1));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          { return }

        var reader = new FileReader;
        reader.onload = operation(cm, function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
        { return lookupKey(key, map$$1.fallthrough, handle, context) }
      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    delayBlurEvent(cm);
    setTimeout(function () { return display.input.focus(); }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
      else
        { ourRange = range$$1; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
    var order = getOrder(anchorLine);
    if (!order) { return range$$1 }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range$$1 }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(bind(onFocus, this), 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this$1, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(), to = range$$1.to();
      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];
      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
      var mode = cm.getModeAt(range$$1.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
          { indented = indentLine(cm, range$$1.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function(map$$1) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var this$1 = this;

        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var this$1 = this;

        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];
          if (!range$$1.empty()) {
            var from = range$$1.from(), to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this$1, j, how); }
            var newRanges = this$1.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;
            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var this$1 = this;

        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range$$1 = this.doc.sel.primary();
        if (start == null) { pos = range$$1.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range$$1.from() : range$$1.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var this$1 = this;

        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this$1.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range$$1.from() : range$$1.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range$$1) {
            var other = findPosH(doc, range$$1.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var this$1 = this;

        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this$1, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this$1, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse)
            { return dir < 0 ? range$$1.from() : range$$1.to() }
          var headPos = cursorCoords(this$1, range$$1.head, "div");
          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range$$1 == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range$$1 == "number") {
          range$$1 = {from: Pos(range$$1, 0), to: null};
        } else if (range$$1.from == null) {
          range$$1 = {from: range$$1, to: null};
        }
        if (!range$$1.to) { range$$1.to = range$$1.from; }
        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    function findNextLine() {
      var l = pos.line + dir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor())
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range$$1;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range$$1 = found[0].find(0)))
            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, …*/) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.49.0";

  return CodeMirror;

})));
;

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {hint: getHints};
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections()
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  CodeMirror.defineExtension("closeHint", function() {
    if (this.state.completionActive) this.state.completionActive.close()
  })

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1000/60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else this.cm.replaceRange(getText(completion), completion.from || data.from,
                                completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function() {self.update();});
        if (this.widget) this.widget.disable();
      }
    },

    update: function(first) {
      if (this.tick == null) return
      var self = this, myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function(data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();

      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor)
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options)
      if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };

    var mac = /Mac/.test(navigator.platform);

    if (mac) {
      baseMap["Ctrl-P"] = function() {handle.moveFocus(-1);};
      baseMap["Ctrl-N"] = function() {handle.moveFocus(1);};
    }

    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;

    var hints = this.hints = ownerDocument.createElement("ul");
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var container = completion.options.container || ownerDocument.body;
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    var offsetLeft = 0, offsetTop = 0;
    if (container !== ownerDocument.body) {
      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.
      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
      var offsetParent = isContainerPositioned ? container : container.offsetParent;
      var offsetParentPosition = offsetParent.getBoundingClientRect();
      var bodyPosition = ownerDocument.body.getBoundingClientRect();
      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);
      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);
    }
    hints.style.left = (left - offsetLeft) + "px";
    hints.style.top = (top - offsetTop) + "px";

    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    container.appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1
    var startScroll = cm.getScrollInfo();

    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height - offsetTop) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top - offsetTop) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left - offsetLeft) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px"

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {Enter: function() { widget.picked = true; }};
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words
    if (helpers.length) {
      var resolved = function(cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function(result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
    } else if (CodeMirror.hint.anyword) {
      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
    } else {
      return function() {}
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur)
    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur
    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start)
    } else {
      term = ""
      from = cur
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }

    if (found.length) return {list: found, from: from, to: to};
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
});
;

"use strict"
class Timer {
  constructor() {
    this._tickTime = Date.now() - (this.isNodeJs() ? 1000 * process.uptime() : 0)
    this._firstTickTime = this._tickTime
  }
  isNodeJs() {
    return typeof exports !== "undefined"
  }
  tick(msg) {
    const elapsed = Date.now() - this._tickTime
    if (msg) console.log(`${elapsed}ms ${msg}`)
    this._tickTime = Date.now()
    return elapsed
  }
  getTotalElapsedTime() {
    return Date.now() - this._firstTickTime
  }
}
class TreeUtils {
  static getFileExtension(filepath = "") {
    const match = filepath.match(/\.([^\.]+)$/)
    return (match && match[1]) || ""
  }
  static findProjectRoot(dirName, projectName) {
    const fs = require("fs")
    const getProjectName = dirName => {
      if (!dirName) throw new Error(`dirName undefined when attempting to findProjectRoot for project "${projectName}"`)
      const parts = dirName.split("/")
      const filename = parts.join("/") + "/" + "package.json"
      if (fs.existsSync(filename) && JSON.parse(fs.readFileSync(filename, "utf8")).name === projectName) return parts.join("/") + "/"
      parts.pop()
      return parts
    }
    let result = getProjectName(dirName)
    while (typeof result !== "string" && result.length > 0) {
      result = getProjectName(result.join("/"))
    }
    if (result.length === 0) throw new Error(`Project root "${projectName}" in folder ${dirName} not found.`)
    return result
  }
  static escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
  }
  static removeNonAscii(str) {
    // https://stackoverflow.com/questions/20856197/remove-non-ascii-character-in-string
    return str.replace(/[^\x00-\x7F]/g, "")
  }
  static getMethodFromDotPath(context, str) {
    const methodParts = str.split(".")
    while (methodParts.length > 1) {
      const methodName = methodParts.shift()
      if (!context[methodName]) throw new Error(`${methodName} is not a method on ${context}`)
      context = context[methodName]()
    }
    const final = methodParts.shift()
    return [context, final]
  }
  static requireAbsOrRelative(filePath, contextFilePath) {
    if (!filePath.startsWith(".")) return require(filePath)
    const path = require("path")
    const folder = this.getPathWithoutFileName(contextFilePath)
    const file = path.resolve(folder + "/" + filePath)
    return require(file)
  }
  // Removes last ".*" from this string
  static removeFileExtension(filename) {
    return filename ? filename.replace(/\.[^\.]+$/, "") : ""
  }
  static getFileName(path) {
    const parts = path.split("/") // todo: change for windows?
    return parts.pop()
  }
  static getPathWithoutFileName(path) {
    const parts = path.split("/") // todo: change for windows?
    parts.pop()
    return parts.join("/")
  }
  static shuffleInPlace(arr, seed = Date.now()) {
    // https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array
    const randFn = TreeUtils._getPseudoRandom0to1FloatGenerator(seed)
    for (let index = arr.length - 1; index > 0; index--) {
      const tempIndex = Math.floor(randFn() * (index + 1))
      ;[arr[index], arr[tempIndex]] = [arr[tempIndex], arr[index]]
    }
    return arr
  }
  // Only allows a-zA-Z0-9-_  (And optionally .)
  static _permalink(str, reg) {
    return str.length
      ? str
          .toLowerCase()
          .replace(reg, "")
          .replace(/ /g, "-")
      : ""
  }
  static stringToPermalink(str) {
    return this._permalink(str, /[^a-z0-9- _\.]/gi)
  }
  static getAvailablePermalink(permalink, doesFileExistSyncFn) {
    const extension = this.getFileExtension(permalink)
    permalink = this.removeFileExtension(permalink)
    const originalPermalink = permalink
    let num = 2
    let suffix = ""
    let filename = `${originalPermalink}${suffix}.${extension}`
    while (doesFileExistSyncFn(filename)) {
      filename = `${originalPermalink}${suffix}.${extension}`
      suffix = "-" + num
      num++
    }
    return filename
  }
  static getNextOrPrevious(arr) {
    const length = arr.length
    const index = arr.indexOf(this)
    if (length === 1) return undefined
    if (index === length - 1) return arr[index - 1]
    return arr[index + 1]
  }
  static toggle(currentValue, values) {
    const index = values.indexOf(currentValue)
    return index === -1 || index + 1 === values.length ? values[0] : values[index + 1]
  }
  static getClassNameFromFilePath(filepath) {
    return this.removeFileExtension(this.getFileName(filepath))
  }
  static joinArraysOn(joinOn, arrays, columns) {
    const rows = {}
    let index = 0
    if (!columns) columns = arrays.map(arr => Object.keys(arr[0]))
    arrays.forEach((arr, index) => {
      const cols = columns[index]
      arr.forEach(row => {
        const key = joinOn ? row[joinOn] : index++
        if (!rows[key]) rows[key] = {}
        const obj = rows[key]
        cols.forEach(col => (obj[col] = row[col]))
      })
    })
    return Object.values(rows)
  }
  static getParentFolder(path) {
    if (path.endsWith("/")) path = this._removeLastSlash(path)
    return path.replace(/\/[^\/]*$/, "") + "/"
  }
  static _removeLastSlash(path) {
    return path.replace(/\/$/, "")
  }
  static _listToEnglishText(list, limit = 5) {
    const len = list.length
    if (!len) return ""
    if (len === 1) return `'${list[0]}'`
    const clone = list.slice(0, limit).map(item => `'${item}'`)
    const last = clone.pop()
    if (len <= limit) return clone.join(", ") + ` and ${last}`
    return clone.join(", ") + ` and ${len - limit} more`
  }
  // todo: refactor so instead of str input takes an array of cells(strings) and scans each indepndently.
  static _chooseDelimiter(str) {
    const del = " ,|\t;^%$!#@~*&+-=_:?.{}[]()<>/".split("").find(idea => !str.includes(idea))
    if (!del) throw new Error("Could not find a delimiter")
    return del
  }
  static flatten(arr) {
    if (arr.flat) return arr.flat()
    return arr.reduce((acc, val) => acc.concat(val), [])
  }
  static escapeBackTicks(str) {
    return str.replace(/\`/g, "\\`").replace(/\$\{/g, "\\${")
  }
  static ucfirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }
  // Adapted from: https://github.com/dcporter/didyoumean.js/blob/master/didYouMean-1.2.1.js
  static didYouMean(str = "", options = [], caseSensitive = false, threshold = 0.4, thresholdAbsolute = 20) {
    if (!caseSensitive) str = str.toLowerCase()
    // Calculate the initial value (the threshold) if present.
    const thresholdRelative = threshold * str.length
    let maximumEditDistanceToBeBestMatch
    if (thresholdRelative !== null && thresholdAbsolute !== null) maximumEditDistanceToBeBestMatch = Math.min(thresholdRelative, thresholdAbsolute)
    else if (thresholdRelative !== null) maximumEditDistanceToBeBestMatch = thresholdRelative
    else if (thresholdAbsolute !== null) maximumEditDistanceToBeBestMatch = thresholdAbsolute
    // Get the edit distance to each option. If the closest one is less than 40% (by default) of str's length, then return it.
    let closestMatch
    const len = options.length
    for (let optionIndex = 0; optionIndex < len; optionIndex++) {
      const candidate = options[optionIndex]
      if (!candidate) continue
      const editDistance = TreeUtils._getEditDistance(str, caseSensitive ? candidate : candidate.toLowerCase(), maximumEditDistanceToBeBestMatch)
      if (editDistance < maximumEditDistanceToBeBestMatch) {
        maximumEditDistanceToBeBestMatch = editDistance
        closestMatch = candidate
      }
    }
    return closestMatch
  }
  // Adapted from: https://github.com/dcporter/didyoumean.js/blob/master/didYouMean-1.2.1.js
  static _getEditDistance(stringA, stringB, maxInt) {
    // Handle null or undefined max.
    maxInt = maxInt || maxInt === 0 ? maxInt : TreeUtils.MAX_INT
    const aLength = stringA.length
    const bLength = stringB.length
    // Fast path - no A or B.
    if (aLength === 0) return Math.min(maxInt + 1, bLength)
    if (bLength === 0) return Math.min(maxInt + 1, aLength)
    // Fast path - length diff larger than max.
    if (Math.abs(aLength - bLength) > maxInt) return maxInt + 1
    // Slow path.
    const matrix = []
    // Set up the first row ([0, 1, 2, 3, etc]).
    for (let bIndex = 0; bIndex <= bLength; bIndex++) {
      matrix[bIndex] = [bIndex]
    }
    // Set up the first column (same).
    for (let aIndex = 0; aIndex <= aLength; aIndex++) {
      matrix[0][aIndex] = aIndex
    }
    let colMin
    let minJ
    let maxJ
    // Loop over the rest of the columns.
    for (let bIndex = 1; bIndex <= bLength; bIndex++) {
      colMin = TreeUtils.MAX_INT
      minJ = 1
      if (bIndex > maxInt) minJ = bIndex - maxInt
      maxJ = bLength + 1
      if (maxJ > maxInt + bIndex) maxJ = maxInt + bIndex
      // Loop over the rest of the rows.
      for (let aIndex = 1; aIndex <= aLength; aIndex++) {
        // If j is out of bounds, just put a large value in the slot.
        if (aIndex < minJ || aIndex > maxJ) matrix[bIndex][aIndex] = maxInt + 1
        // Otherwise do the normal Levenshtein thing.
        else {
          // If the characters are the same, there's no change in edit distance.
          if (stringB.charAt(bIndex - 1) === stringA.charAt(aIndex - 1)) matrix[bIndex][aIndex] = matrix[bIndex - 1][aIndex - 1]
          // Otherwise, see if we're substituting, inserting or deleting.
          else
            matrix[bIndex][aIndex] = Math.min(
              matrix[bIndex - 1][aIndex - 1] + 1, // Substitute
              Math.min(
                matrix[bIndex][aIndex - 1] + 1, // Insert
                matrix[bIndex - 1][aIndex] + 1
              )
            ) // Delete
        }
        // Either way, update colMin.
        if (matrix[bIndex][aIndex] < colMin) colMin = matrix[bIndex][aIndex]
      }
      // If this column's minimum is greater than the allowed maximum, there's no point
      // in going on with life.
      if (colMin > maxInt) return maxInt + 1
    }
    // If we made it this far without running into the max, then return the final matrix value.
    return matrix[bLength][aLength]
  }
  static getLineIndexAtCharacterPosition(str, index) {
    const lines = str.split("\n")
    const len = lines.length
    let position = 0
    for (let lineNumber = 0; lineNumber < len; lineNumber++) {
      position += lines[lineNumber].length
      if (position >= index) return lineNumber
    }
  }
  static resolvePath(filePath, programFilepath) {
    // For use in Node.js only
    if (!filePath.startsWith(".")) return filePath
    const path = require("path")
    const folder = this.getPathWithoutFileName(programFilepath)
    return path.resolve(folder + "/" + filePath)
  }
  static resolveProperty(obj, path, separator = ".") {
    const properties = Array.isArray(path) ? path : path.split(separator)
    return properties.reduce((prev, curr) => prev && prev[curr], obj)
  }
  static formatStr(str, catchAllCellDelimiter = " ", parameterMap) {
    return str.replace(/{([^\}]+)}/g, (match, path) => {
      const val = parameterMap[path]
      if (!val) return ""
      return Array.isArray(val) ? val.join(catchAllCellDelimiter) : val
    })
  }
  static stripHtml(text) {
    return text && text.replace ? text.replace(/<(?:.|\n)*?>/gm, "") : text
  }
  static getUniqueWordsArray(allWords) {
    const words = allWords.replace(/\n/g, " ").split(" ")
    const index = {}
    words.forEach(word => {
      if (!index[word]) index[word] = 0
      index[word]++
    })
    return Object.keys(index).map(key => {
      return {
        word: key,
        count: index[key]
      }
    })
  }
  static getRandomString(length = 30, letters = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""), seed = Date.now()) {
    let str = ""
    const randFn = TreeUtils._getPseudoRandom0to1FloatGenerator(seed)
    while (length) {
      str += letters[Math.round(Math.min(randFn() * letters.length, letters.length - 1))]
      length--
    }
    return str
  }
  // todo: add seed!
  static makeRandomTree(lines = 1000, seed = Date.now()) {
    let str = ""
    let letters = " 123abc".split("")
    const randFn = TreeUtils._getPseudoRandom0to1FloatGenerator(seed)
    while (lines) {
      let indent = " ".repeat(Math.round(randFn() * 6))
      let bit = indent
      let rand = Math.floor(randFn() * 30)
      while (rand) {
        bit += letters[Math.round(Math.min(randFn() * letters.length, letters.length - 1))]
        rand--
      }
      bit += "\n"
      str += bit
      lines--
    }
    return str
  }
  // adapted from https://gist.github.com/blixt/f17b47c62508be59987b
  // 1993 Park-Miller LCG
  static _getPseudoRandom0to1FloatGenerator(seed) {
    return function() {
      seed = Math.imul(48271, seed) | 0 % 2147483647
      return (seed & 2147483647) / 2147483648
    }
  }
  static sampleWithoutReplacement(population = [], quantity, seed) {
    const prng = this._getPseudoRandom0to1FloatGenerator(seed)
    const sampled = {}
    const populationSize = population.length
    const picked = []
    if (quantity >= populationSize) quantity = populationSize
    while (picked.length < quantity) {
      const index = Math.floor(prng() * populationSize)
      if (sampled[index]) continue
      sampled[index] = true
      picked.push(population[index])
    }
    return picked
  }
  static arrayToMap(arr) {
    const map = {}
    arr.forEach(val => (map[val] = true))
    return map
  }
  static _replaceNonAlphaNumericCharactersWithCharCodes(str) {
    return str
      .replace(/[^a-zA-Z0-9]/g, sub => {
        return "_" + sub.charCodeAt(0).toString()
      })
      .replace(/^([0-9])/, "number$1")
  }
  static mapValues(object, fn) {
    const result = {}
    Object.keys(object).forEach(key => {
      result[key] = fn(key)
    })
    return result
  }
  static javascriptTableWithHeaderRowToObjects(dataTable) {
    dataTable = dataTable.slice()
    const header = dataTable.shift()
    return dataTable.map(row => {
      const obj = {}
      header.forEach((colName, index) => (obj[colName] = row[index]))
      return obj
    })
  }
  static interweave(arrayOfArrays) {
    const lineCount = Math.max(...arrayOfArrays.map(arr => arr.length))
    const totalArrays = arrayOfArrays.length
    const result = []
    arrayOfArrays.forEach((lineArray, arrayIndex) => {
      for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
        result[lineIndex * totalArrays + arrayIndex] = lineArray[lineIndex]
      }
    })
    return result
  }
  static makeSortByFn(accessorOrAccessors) {
    const arrayOfFns = Array.isArray(accessorOrAccessors) ? accessorOrAccessors : [accessorOrAccessors]
    return (objectA, objectB) => {
      const nodeAFirst = -1
      const nodeBFirst = 1
      const accessor = arrayOfFns[0] // todo: handle accessors
      const av = accessor(objectA)
      const bv = accessor(objectB)
      let result = av < bv ? nodeAFirst : av > bv ? nodeBFirst : 0
      if (av === undefined && bv !== undefined) result = nodeAFirst
      else if (bv === undefined && av !== undefined) result = nodeBFirst
      return result
    }
  }
  static _makeGraphSortFunctionFromGraph(idAccessor, graph) {
    return (nodeA, nodeB) => {
      const nodeAFirst = -1
      const nodeBFirst = 1
      const nodeAUniqueId = idAccessor(nodeA)
      const nodeBUniqueId = idAccessor(nodeB)
      const nodeAExtendsNodeB = graph[nodeAUniqueId].has(nodeBUniqueId)
      const nodeBExtendsNodeA = graph[nodeBUniqueId].has(nodeAUniqueId)
      if (nodeAExtendsNodeB) return nodeBFirst
      else if (nodeBExtendsNodeA) return nodeAFirst
      const nodeAExtendsSomething = graph[nodeAUniqueId].size > 1
      const nodeBExtendsSomething = graph[nodeBUniqueId].size > 1
      if (!nodeAExtendsSomething && nodeBExtendsSomething) return nodeAFirst
      else if (!nodeBExtendsSomething && nodeAExtendsSomething) return nodeBFirst
      if (nodeAUniqueId > nodeBUniqueId) return nodeBFirst
      else if (nodeAUniqueId < nodeBUniqueId) return nodeAFirst
      return 0
    }
  }
  static removeAll(str, needle) {
    return str.split(needle).join("")
  }
  static _makeGraphSortFunction(idAccessor, extendsIdAccessor) {
    return (nodeA, nodeB) => {
      // -1 === a before b
      const nodeAUniqueId = idAccessor(nodeA)
      const nodeAExtends = extendsIdAccessor(nodeA)
      const nodeBUniqueId = idAccessor(nodeB)
      const nodeBExtends = extendsIdAccessor(nodeB)
      const nodeAExtendsNodeB = nodeAExtends === nodeBUniqueId
      const nodeBExtendsNodeA = nodeBExtends === nodeAUniqueId
      const nodeAFirst = -1
      const nodeBFirst = 1
      if (!nodeAExtends && !nodeBExtends) {
        // If neither extends, sort by firstWord
        if (nodeAUniqueId > nodeBUniqueId) return nodeBFirst
        else if (nodeAUniqueId < nodeBUniqueId) return nodeAFirst
        return 0
      }
      // If only one extends, the other comes first
      else if (!nodeAExtends) return nodeAFirst
      else if (!nodeBExtends) return nodeBFirst
      // If A extends B, B should come first
      if (nodeAExtendsNodeB) return nodeBFirst
      else if (nodeBExtendsNodeA) return nodeAFirst
      // Sort by what they extend
      if (nodeAExtends > nodeBExtends) return nodeBFirst
      else if (nodeAExtends < nodeBExtends) return nodeAFirst
      // Finally sort by firstWord
      if (nodeAUniqueId > nodeBUniqueId) return nodeBFirst
      else if (nodeAUniqueId < nodeBUniqueId) return nodeAFirst
      // Should never hit this, unless we have a duplicate line.
      return 0
    }
  }
}
TreeUtils.Timer = Timer
//http://stackoverflow.com/questions/37684/how-to-replace-plain-urls-with-links#21925491
TreeUtils.linkify = text => {
  let replacedText
  let replacePattern1
  let replacePattern2
  let replacePattern3
  //URLs starting with http://, https://, or ftp://
  replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim
  replacedText = text.replace(replacePattern1, '<a href="$1" target="_blank">$1</a>')
  //URLs starting with "www." (without // before it, or it'd re-link the ones done above).
  replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim
  replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" target="_blank">$2</a>')
  //Change email addresses to mailto:: links.
  replacePattern3 = /(([a-zA-Z0-9\-\_\.])+@[a-zA-Z\_]+?(\.[a-zA-Z]{2,6})+)/gim
  replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>')
  return replacedText
}
// todo: switch algo to: http://indiegamr.com/generate-repeatable-random-numbers-in-js/?
TreeUtils.makeSemiRandomFn = (seed = Date.now()) => {
  return () => {
    const semiRand = Math.sin(seed++) * 10000
    return semiRand - Math.floor(semiRand)
  }
}
TreeUtils.randomUniformInt = (min, max, seed = Date.now()) => {
  return Math.floor(TreeUtils.randomUniformFloat(min, max, seed))
}
TreeUtils.randomUniformFloat = (min, max, seed = Date.now()) => {
  const randFn = TreeUtils.makeSemiRandomFn(seed)
  return min + (max - min) * randFn()
}
TreeUtils.getRange = (startIndex, endIndexExclusive, increment = 1) => {
  const range = []
  for (let index = startIndex; index < endIndexExclusive; index = index + increment) {
    range.push(index)
  }
  return range
}
TreeUtils.MAX_INT = Math.pow(2, 32) - 1
window.TreeUtils = TreeUtils
class TestRacerTestBlock {
  constructor(testFile, testName, fn) {
    this._parentFile = testFile
    this._testName = testName
    this._testFn = fn
  }
  _emitMessage(message) {
    this._parentFile.getRunner()._emitMessage(message)
    return message
  }
  async execute() {
    let passes = []
    let failures = []
    const assertEqual = (actual, expected, message = "") => {
      if (expected === actual) {
        passes.push(message)
      } else {
        failures.push([actual, expected, message])
      }
    }
    try {
      await this._testFn(assertEqual)
    } catch (err) {
      failures.push([
        "1",
        "0",
        `Should not have uncaught errors but in ${this._testName} got error:
 toString:
  ${new TreeNode(err.toString()).toString(2)}
 stack:
  ${new TreeNode(err.stack).toString(2)}`
      ])
    }
    failures.length ? this._emitBlockFailedMessage(failures) : this._emitBlockPassedMessage(passes)
    return {
      passes,
      failures
    }
  }
  _emitBlockPassedMessage(passes) {
    this._emitMessage(`ok block ${this._testName} - ${passes.length} passed`)
  }
  _emitBlockFailedMessage(failures) {
    // todo: should replace not replace last newline?
    // todo: do side by side.
    // todo: add diff.
    this._emitMessage(`failed block ${this._testName}`)
    this._emitMessage(
      failures
        .map(failure => {
          const actualVal = failure[0] === undefined ? "undefined" : failure[0].toString()
          const expectedVal = failure[1] === undefined ? "undefined" : failure[1].toString()
          const actual = new jtree.TreeNode(`actual\n${new jtree.TreeNode(actualVal).toString(1)}`)
          const expected = new jtree.TreeNode(`expected\n${new jtree.TreeNode(expectedVal.toString()).toString(1)}`)
          const comparison = actual.toComparison(expected)
          return new jtree.TreeNode(` assertion ${failure[2]}\n${comparison.toSideBySide([actual, expected]).toString(2)}`)
        })
        .join("\n")
    )
  }
}
class TestRacerFile {
  constructor(runner, testTree, fileName) {
    this._runner = runner
    this._testTree = {}
    this._fileName = fileName
    Object.keys(testTree).forEach(key => {
      this._testTree[key] = new TestRacerTestBlock(this, key, testTree[key])
    })
  }
  getRunner() {
    return this._runner
  }
  getFileName() {
    return this._fileName
  }
  get length() {
    return Object.values(this._testTree).length
  }
  get skippedLength() {
    return this.length - this._filterSkippedTests().length
  }
  _emitMessage(message) {
    this.getRunner()._emitMessage(message)
  }
  _filterSkippedTests() {
    const runOnlyTheseTestBlocks = Object.keys(this._testTree).filter(key => key.startsWith("_"))
    return runOnlyTheseTestBlocks.length ? runOnlyTheseTestBlocks : Object.keys(this._testTree)
  }
  async execute() {
    const tests = this._filterSkippedTests()
    this._emitStartFileMessage(tests.length)
    const fileTimer = new TreeUtils.Timer()
    const blockResults = {}
    const blockPromises = tests.map(async testName => {
      const results = await this._testTree[testName].execute()
      blockResults[testName] = results
    })
    await Promise.all(blockPromises)
    const fileStats = this._aggregateBlockResultsIntoFileResults(blockResults)
    const fileTimeElapsed = fileTimer.tick()
    fileStats.blocksFailed ? this._emitFileFailedMessage(fileStats, fileTimeElapsed, tests.length) : this._emitFilePassedMessage(fileStats, fileTimeElapsed, tests.length)
    return fileStats
  }
  _aggregateBlockResultsIntoFileResults(fileBlockResults) {
    const fileStats = {
      assertionsPassed: 0,
      assertionsFailed: 0,
      blocksPassed: 0,
      blocksFailed: 0,
      failedBlocks: []
    }
    Object.keys(fileBlockResults).forEach(blockName => {
      const results = fileBlockResults[blockName]
      fileStats.assertionsPassed += results.passes.length
      fileStats.assertionsFailed += results.failures.length
      if (results.failures.length) {
        fileStats.blocksFailed++
        fileStats.failedBlocks.push(blockName)
      } else fileStats.blocksPassed++
    })
    return fileStats
  }
  _emitStartFileMessage(blockCount) {
    this._emitMessage(`start file ${blockCount} test blocks in file ${this._fileName}`)
  }
  _emitFilePassedMessage(fileStats, fileTimeElapsed, blockCount) {
    this._emitMessage(`ok file ${this._fileName} in ${fileTimeElapsed}ms. ${blockCount} blocks and ${fileStats.assertionsPassed} assertions passed.`)
  }
  _emitFileFailedMessage(fileStats, fileTimeElapsed, blockCount) {
    this._emitMessage(
      `failed file ${this._fileName} over ${fileTimeElapsed}ms. ${fileStats.blocksFailed} blocks and ${fileStats.assertionsFailed} failed. ${blockCount - fileStats.blocksFailed} blocks and ${fileStats.assertionsPassed} assertions passed`
    )
  }
}
class TestRacer {
  constructor(fileTestTree) {
    this._logFunction = console.log
    this._timer = new TreeUtils.Timer()
    this._sessionFilesPassed = 0
    this._sessionFilesFailed = {}
    this._sessionBlocksFailed = 0
    this._sessionBlocksPassed = 0
    this._sessionAssertionsFailed = 0
    this._sessionAssertionsPassed = 0
    this._fileTestTree = {}
    Object.keys(fileTestTree).forEach(fileName => {
      this._fileTestTree[fileName] = new TestRacerFile(this, fileTestTree[fileName], fileName)
    })
  }
  setLogFunction(logFunction) {
    this._logFunction = logFunction
    return this
  }
  _addFileResultsToSessionResults(fileStats, fileName) {
    this._sessionAssertionsPassed += fileStats.assertionsPassed
    this._sessionAssertionsFailed += fileStats.assertionsFailed
    this._sessionBlocksPassed += fileStats.blocksPassed
    this._sessionBlocksFailed += fileStats.blocksFailed
    if (!fileStats.blocksFailed) this._sessionFilesPassed++
    else {
      this._sessionFilesFailed[fileName] = fileStats.failedBlocks
    }
  }
  async execute() {
    this._emitSessionPlanMessage()
    const proms = Object.values(this._fileTestTree).map(async testFile => {
      const results = await testFile.execute()
      this._addFileResultsToSessionResults(results, testFile.getFileName())
    })
    await Promise.all(proms)
    return this
  }
  finish() {
    return this._emitSessionFinishMessage()
  }
  _emitMessage(message) {
    this._logFunction(message)
    return message
  }
  get length() {
    return Object.values(this._fileTestTree).length
  }
  _emitSessionPlanMessage() {
    let blocks = 0
    let skippedLength = 0
    Object.values(this._fileTestTree).forEach(value => (blocks += value.length))
    Object.values(this._fileTestTree).forEach(value => (skippedLength += value.skippedLength))
    this._emitMessage(`${this.length} files and ${blocks} blocks to run. ${skippedLength} skipped blocks.`)
  }
  _getFailures() {
    if (!Object.keys(this._sessionFilesFailed).length) return ""
    return `
 failures
${new TreeNode(this._sessionFilesFailed).forEach(row => row.forEach(line => line.deleteWordAt(0))).toString(2)}`
  }
  _emitSessionFinishMessage() {
    return this._emitMessage(`finished in ${this._timer.getTotalElapsedTime()}ms
 passed
  ${this._sessionFilesPassed} files
  ${this._sessionBlocksPassed} blocks
  ${this._sessionAssertionsPassed} assertions
 failed
  ${Object.keys(this._sessionFilesFailed).length} files
  ${this._sessionBlocksFailed} blocks
  ${this._sessionAssertionsFailed} assertions${this._getFailures()}`)
  }
  static async testSingleFile(fileName, testTree) {
    const obj = {}
    obj[fileName] = testTree
    const session = new TestRacer(obj)
    await session.execute()
    session.finish()
  }
}
window.TestRacer = TestRacer
let _jtreeLatestTime = 0
let _jtreeMinTimeIncrement = 0.000000000001
class AbstractNode {
  _getProcessTimeInMilliseconds() {
    // We add this loop to restore monotonically increasing .now():
    // https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
    let time = performance.now()
    while (time <= _jtreeLatestTime) {
      if (time === time + _jtreeMinTimeIncrement)
        // Some browsers have different return values for perf.now()
        _jtreeMinTimeIncrement = 10 * _jtreeMinTimeIncrement
      time += _jtreeMinTimeIncrement
    }
    _jtreeLatestTime = time
    return time
  }
}
var FileFormat
;(function(FileFormat) {
  FileFormat["csv"] = "csv"
  FileFormat["tsv"] = "tsv"
  FileFormat["tree"] = "tree"
})(FileFormat || (FileFormat = {}))
class AbstractTreeEvent {
  constructor(targetNode) {
    this.targetNode = targetNode
  }
}
class ChildAddedTreeEvent extends AbstractTreeEvent {}
class ChildRemovedTreeEvent extends AbstractTreeEvent {}
class DescendantChangedTreeEvent extends AbstractTreeEvent {}
class LineChangedTreeEvent extends AbstractTreeEvent {}
class TreeWord {
  constructor(node, cellIndex) {
    this._node = node
    this._cellIndex = cellIndex
  }
  replace(newWord) {
    this._node.setWord(this._cellIndex, newWord)
  }
  get word() {
    return this._node.getWord(this._cellIndex)
  }
}
const TreeEvents = { ChildAddedTreeEvent, ChildRemovedTreeEvent, DescendantChangedTreeEvent, LineChangedTreeEvent }
var WhereOperators
;(function(WhereOperators) {
  WhereOperators["equal"] = "="
  WhereOperators["notEqual"] = "!="
  WhereOperators["lessThan"] = "<"
  WhereOperators["lessThanOrEqual"] = "<="
  WhereOperators["greaterThan"] = ">"
  WhereOperators["greaterThanOrEqual"] = ">="
  WhereOperators["includes"] = "includes"
  WhereOperators["doesNotInclude"] = "doesNotInclude"
  WhereOperators["in"] = "in"
  WhereOperators["notIn"] = "notIn"
  WhereOperators["empty"] = "empty"
  WhereOperators["notEmpty"] = "notEmpty"
})(WhereOperators || (WhereOperators = {}))
var TreeNotationConstants
;(function(TreeNotationConstants) {
  TreeNotationConstants["extends"] = "extends"
})(TreeNotationConstants || (TreeNotationConstants = {}))
class Parser {
  constructor(catchAllNodeConstructor, firstWordMap = {}, regexTests = undefined) {
    this._catchAllNodeConstructor = catchAllNodeConstructor
    this._firstWordMap = new Map(Object.entries(firstWordMap))
    this._regexTests = regexTests
  }
  getFirstWordOptions() {
    return Array.from(this._getFirstWordMap().keys())
  }
  // todo: remove
  _getFirstWordMap() {
    return this._firstWordMap
  }
  // todo: remove
  _getFirstWordMapAsObject() {
    let obj = {}
    const map = this._getFirstWordMap()
    for (let [key, val] of map.entries()) {
      obj[key] = val
    }
    return obj
  }
  _getNodeConstructor(line, contextNode, wordBreakSymbol = " ") {
    return this._getFirstWordMap().get(this._getFirstWord(line, wordBreakSymbol)) || this._getConstructorFromRegexTests(line) || this._getCatchAllNodeConstructor(contextNode)
  }
  _getCatchAllNodeConstructor(contextNode) {
    if (this._catchAllNodeConstructor) return this._catchAllNodeConstructor
    const parent = contextNode.getParent()
    if (parent) return parent._getParser()._getCatchAllNodeConstructor(parent)
    return contextNode.constructor
  }
  _getConstructorFromRegexTests(line) {
    if (!this._regexTests) return undefined
    const hit = this._regexTests.find(test => test.regex.test(line))
    if (hit) return hit.nodeConstructor
    return undefined
  }
  _getFirstWord(line, wordBreakSymbol) {
    const firstBreak = line.indexOf(wordBreakSymbol)
    return line.substr(0, firstBreak > -1 ? firstBreak : undefined)
  }
}
class TreeNode extends AbstractNode {
  constructor(children, line, parent) {
    super()
    // BEGIN MUTABLE METHODS BELOw
    this._nodeCreationTime = this._getProcessTimeInMilliseconds()
    this._parent = parent
    this._setLine(line)
    this._setChildren(children)
  }
  execute(context) {
    return Promise.all(this.map(child => child.execute(context)))
  }
  async loadRequirements(context) {
    await Promise.all(this.map(node => node.loadRequirements(context)))
  }
  getErrors() {
    return []
  }
  getLineCellTypes() {
    // todo: make this any a constant
    return "undefinedCellType ".repeat(this.getWords().length).trim()
  }
  executeSync(context) {
    return this.map(child => child.executeSync(context))
  }
  isNodeJs() {
    return typeof exports !== "undefined"
  }
  isBrowser() {
    return !this.isNodeJs()
  }
  getOlderSiblings() {
    if (this.isRoot()) return []
    return this.getParent().slice(0, this.getIndex())
  }
  _getClosestOlderSibling() {
    const olderSiblings = this.getOlderSiblings()
    return olderSiblings[olderSiblings.length - 1]
  }
  getYoungerSiblings() {
    if (this.isRoot()) return []
    return this.getParent().slice(this.getIndex() + 1)
  }
  getSiblings() {
    if (this.isRoot()) return []
    return this.getParent().filter(node => node !== this)
  }
  _getUid() {
    if (!this._uid) this._uid = TreeNode._makeUniqueId()
    return this._uid
  }
  // todo: rename getMother? grandMother et cetera?
  getParent() {
    return this._parent
  }
  getIndentLevel(relativeTo) {
    return this._getIndentLevel(relativeTo)
  }
  getIndentation(relativeTo) {
    return this.getEdgeSymbol().repeat(this._getIndentLevel(relativeTo) - 1)
  }
  _getTopDownArray(arr) {
    this.forEach(child => {
      arr.push(child)
      child._getTopDownArray(arr)
    })
  }
  getTopDownArray() {
    const arr = []
    this._getTopDownArray(arr)
    return arr
  }
  *getTopDownArrayIterator() {
    for (let child of this.getChildren()) {
      yield child
      yield* child.getTopDownArrayIterator()
    }
  }
  nodeAtLine(lineNumber) {
    let index = 0
    for (let node of this.getTopDownArrayIterator()) {
      if (lineNumber === index) return node
      index++
    }
  }
  getNumberOfLines() {
    let lineCount = 0
    for (let node of this.getTopDownArrayIterator()) {
      lineCount++
    }
    return lineCount
  }
  _getMaxUnitsOnALine() {
    let max = 0
    for (let node of this.getTopDownArrayIterator()) {
      const count = node.getWords().length + node.getIndentLevel()
      if (count > max) max = count
    }
    return max
  }
  getNumberOfWords() {
    let wordCount = 0
    for (let node of this.getTopDownArrayIterator()) {
      wordCount += node.getWords().length
    }
    return wordCount
  }
  getLineNumber() {
    return this._getLineNumberRelativeTo()
  }
  _getLineNumber(target = this) {
    if (this._cachedLineNumber) return this._cachedLineNumber
    let lineNumber = 1
    for (let node of this.getRootNode().getTopDownArrayIterator()) {
      if (node === target) return lineNumber
      lineNumber++
    }
    return lineNumber
  }
  isBlankLine() {
    return !this.length && !this.getLine()
  }
  hasDuplicateFirstWords() {
    return this.length ? new Set(this.getFirstWords()).size !== this.length : false
  }
  isEmpty() {
    return !this.length && !this.getContent()
  }
  _getLineNumberRelativeTo(relativeTo) {
    if (this.isRoot(relativeTo)) return 0
    const start = relativeTo || this.getRootNode()
    return start._getLineNumber(this)
  }
  isRoot(relativeTo) {
    return relativeTo === this || !this.getParent()
  }
  getRootNode() {
    return this._getRootNode()
  }
  _getRootNode(relativeTo) {
    if (this.isRoot(relativeTo)) return this
    return this.getParent()._getRootNode(relativeTo)
  }
  toString(indentCount = 0, language = this) {
    if (this.isRoot()) return this._childrenToString(indentCount, language)
    return language.getEdgeSymbol().repeat(indentCount) + this.getLine(language) + (this.length ? language.getNodeBreakSymbol() + this._childrenToString(indentCount + 1, language) : "")
  }
  printLinesFrom(start, quantity) {
    return this._printLinesFrom(start, quantity, false)
  }
  printLinesWithLineNumbersFrom(start, quantity) {
    return this._printLinesFrom(start, quantity, true)
  }
  _printLinesFrom(start, quantity, printLineNumbers) {
    // todo: use iterator for better perf?
    const end = start + quantity
    this.toString()
      .split("\n")
      .slice(start, end)
      .forEach((line, index) => {
        if (printLineNumbers) console.log(`${start + index} ${line}`)
        else console.log(line)
      })
    return this
  }
  getWord(index) {
    const words = this._getLine().split(this.getWordBreakSymbol())
    if (index < 0) index = words.length + index
    return words[index]
  }
  _toHtml(indentCount) {
    const path = this.getPathVector().join(" ")
    const classes = {
      nodeLine: "nodeLine",
      edgeSymbol: "edgeSymbol",
      nodeBreakSymbol: "nodeBreakSymbol",
      nodeChildren: "nodeChildren"
    }
    const edge = this.getEdgeSymbol().repeat(indentCount)
    // Set up the firstWord part of the node
    const edgeHtml = `<span class="${classes.nodeLine}" data-pathVector="${path}"><span class="${classes.edgeSymbol}">${edge}</span>`
    const lineHtml = this._getLineHtml()
    const childrenHtml = this.length ? `<span class="${classes.nodeBreakSymbol}">${this.getNodeBreakSymbol()}</span>` + `<span class="${classes.nodeChildren}">${this._childrenToHtml(indentCount + 1)}</span>` : ""
    return `${edgeHtml}${lineHtml}${childrenHtml}</span>`
  }
  _getWords(startFrom) {
    if (!this._words) this._words = this._getLine().split(this.getWordBreakSymbol())
    return startFrom ? this._words.slice(startFrom) : this._words
  }
  getWords() {
    return this._getWords(0)
  }
  doesExtend(nodeTypeId) {
    return false
  }
  require(moduleName, filePath) {
    if (!this.isNodeJs()) return window[moduleName]
    return require(filePath || moduleName)
  }
  getWordsFrom(startFrom) {
    return this._getWords(startFrom)
  }
  getFirstAncestor() {
    const parent = this.getParent()
    return parent.isRoot() ? this : parent.getFirstAncestor()
  }
  isLoaded() {
    return true
  }
  getRunTimePhaseErrors() {
    if (!this._runTimePhaseErrors) this._runTimePhaseErrors = {}
    return this._runTimePhaseErrors
  }
  setRunTimePhaseError(phase, errorObject) {
    if (errorObject === undefined) delete this.getRunTimePhaseErrors()[phase]
    else this.getRunTimePhaseErrors()[phase] = errorObject
    return this
  }
  _getJavascriptPrototypeChainUpTo(stopAtClassName = "TreeNode") {
    // todo: cross browser test this
    let constructor = this.constructor
    const chain = []
    while (constructor.name !== stopAtClassName) {
      chain.unshift(constructor.name)
      constructor = constructor.__proto__
    }
    chain.unshift(stopAtClassName)
    return chain
  }
  _getProjectRootDir() {
    return this.isRoot() ? "" : this.getRootNode()._getProjectRootDir()
  }
  getSparsity() {
    const nodes = this.getChildren()
    const fields = this._getUnionNames()
    let count = 0
    this.getChildren().forEach(node => {
      fields.forEach(field => {
        if (node.has(field)) count++
      })
    })
    return 1 - count / (nodes.length * fields.length)
  }
  // todo: rename. what is the proper term from set/cat theory?
  getBiDirectionalMaps(propertyNameOrFn, propertyNameOrFn2 = node => node.getWord(0)) {
    const oneToTwo = {}
    const twoToOne = {}
    const is1Str = typeof propertyNameOrFn === "string"
    const is2Str = typeof propertyNameOrFn2 === "string"
    const children = this.getChildren()
    this.forEach((node, index) => {
      const value1 = is1Str ? node.get(propertyNameOrFn) : propertyNameOrFn(node, index, children)
      const value2 = is2Str ? node.get(propertyNameOrFn2) : propertyNameOrFn2(node, index, children)
      if (value1 !== undefined) {
        if (!oneToTwo[value1]) oneToTwo[value1] = []
        oneToTwo[value1].push(value2)
      }
      if (value2 !== undefined) {
        if (!twoToOne[value2]) twoToOne[value2] = []
        twoToOne[value2].push(value1)
      }
    })
    return [oneToTwo, twoToOne]
  }
  _getWordIndexCharacterStartPosition(wordIndex) {
    const xiLength = this.getEdgeSymbol().length
    const numIndents = this._getIndentLevel(undefined) - 1
    const indentPosition = xiLength * numIndents
    if (wordIndex < 1) return xiLength * (numIndents + wordIndex)
    return (
      indentPosition +
      this.getWords()
        .slice(0, wordIndex)
        .join(this.getWordBreakSymbol()).length +
      this.getWordBreakSymbol().length
    )
  }
  getNodeInScopeAtCharIndex(charIndex) {
    if (this.isRoot()) return this
    let wordIndex = this.getWordIndexAtCharacterIndex(charIndex)
    if (wordIndex > 0) return this
    let node = this
    while (wordIndex < 1) {
      node = node.getParent()
      wordIndex++
    }
    return node
  }
  getWordProperties(wordIndex) {
    const start = this._getWordIndexCharacterStartPosition(wordIndex)
    const word = wordIndex < 0 ? "" : this.getWord(wordIndex)
    return {
      startCharIndex: start,
      endCharIndex: start + word.length,
      word: word
    }
  }
  fill(fill = "") {
    this.getTopDownArray().forEach(line => {
      line.getWords().forEach((word, index) => {
        line.setWord(index, fill)
      })
    })
    return this
  }
  getAllWordBoundaryCoordinates() {
    const coordinates = []
    let lineIndex = 0
    for (let node of this.getTopDownArrayIterator()) {
      node.getWordBoundaryCharIndices().forEach((charIndex, wordIndex) => {
        coordinates.push({
          lineIndex: lineIndex,
          charIndex: charIndex,
          wordIndex: wordIndex
        })
      })
      lineIndex++
    }
    return coordinates
  }
  getWordBoundaryCharIndices() {
    let indentLevel = this._getIndentLevel()
    const wordBreakSymbolLength = this.getWordBreakSymbol().length
    let elapsed = indentLevel
    return this.getWords().map((word, wordIndex) => {
      const boundary = elapsed
      elapsed += word.length + wordBreakSymbolLength
      return boundary
    })
  }
  getWordIndexAtCharacterIndex(charIndex) {
    // todo: is this correct thinking for handling root?
    if (this.isRoot()) return 0
    const numberOfIndents = this._getIndentLevel(undefined) - 1
    // todo: probably want to rewrite this in a performant way.
    const spots = []
    while (spots.length < numberOfIndents) {
      spots.push(-(numberOfIndents - spots.length))
    }
    this.getWords().forEach((word, wordIndex) => {
      word.split("").forEach(letter => {
        spots.push(wordIndex)
      })
      spots.push(wordIndex)
    })
    return spots[charIndex]
  }
  getAllErrors(lineStartsAt = 1) {
    const errors = []
    for (let node of this.getTopDownArray()) {
      node._cachedLineNumber = lineStartsAt // todo: cleanup
      const errs = node.getErrors()
      errs.forEach(err => errors.push(err))
      // delete node._cachedLineNumber
      lineStartsAt++
    }
    return errors
  }
  *getAllErrorsIterator() {
    let line = 1
    for (let node of this.getTopDownArrayIterator()) {
      node._cachedLineNumber = line
      const errs = node.getErrors()
      // delete node._cachedLineNumber
      if (errs.length) yield errs
      line++
    }
  }
  getFirstWord() {
    return this.getWords()[0]
  }
  getContent() {
    const words = this.getWordsFrom(1)
    return words.length ? words.join(this.getWordBreakSymbol()) : undefined
  }
  getContentWithChildren() {
    // todo: deprecate
    const content = this.getContent()
    return (content ? content : "") + (this.length ? this.getNodeBreakSymbol() + this._childrenToString() : "")
  }
  getFirstNode() {
    return this.nodeAt(0)
  }
  getStack() {
    return this._getStack()
  }
  _getStack(relativeTo) {
    if (this.isRoot(relativeTo)) return []
    const parent = this.getParent()
    if (parent.isRoot(relativeTo)) return [this]
    else return parent._getStack(relativeTo).concat([this])
  }
  getStackString() {
    return this._getStack()
      .map((node, index) => this.getEdgeSymbol().repeat(index) + node.getLine())
      .join(this.getNodeBreakSymbol())
  }
  getLine(language) {
    if (!this._words && !language) return this._getLine() // todo: how does this interact with "language" param?
    return this.getWords().join((language || this).getWordBreakSymbol())
  }
  getColumnNames() {
    return this._getUnionNames()
  }
  getOneHot(column) {
    const clone = this.clone()
    const cols = Array.from(new Set(clone.getColumn(column)))
    clone.forEach(node => {
      const val = node.get(column)
      node.delete(column)
      cols.forEach(col => {
        node.set(column + "_" + col, val === col ? "1" : "0")
      })
    })
    return clone
  }
  // todo: return array? getPathArray?
  _getFirstWordPath(relativeTo) {
    if (this.isRoot(relativeTo)) return ""
    else if (this.getParent().isRoot(relativeTo)) return this.getFirstWord()
    return this.getParent()._getFirstWordPath(relativeTo) + this.getEdgeSymbol() + this.getFirstWord()
  }
  getFirstWordPathRelativeTo(relativeTo) {
    return this._getFirstWordPath(relativeTo)
  }
  getFirstWordPath() {
    return this._getFirstWordPath()
  }
  getPathVector() {
    return this._getPathVector()
  }
  getPathVectorRelativeTo(relativeTo) {
    return this._getPathVector(relativeTo)
  }
  _getPathVector(relativeTo) {
    if (this.isRoot(relativeTo)) return []
    const path = this.getParent()._getPathVector(relativeTo)
    path.push(this.getIndex())
    return path
  }
  getIndex() {
    return this.getParent()._indexOfNode(this)
  }
  isTerminal() {
    return !this.length
  }
  _getLineHtml() {
    return this.getWords()
      .map((word, index) => `<span class="word${index}">${TreeUtils.stripHtml(word)}</span>`)
      .join(`<span class="zIncrement">${this.getWordBreakSymbol()}</span>`)
  }
  _getXmlContent(indentCount) {
    if (this.getContent() !== undefined) return this.getContentWithChildren()
    return this.length ? `${indentCount === -1 ? "" : "\n"}${this._childrenToXml(indentCount > -1 ? indentCount + 2 : -1)}${" ".repeat(indentCount)}` : ""
  }
  _toXml(indentCount) {
    const indent = " ".repeat(indentCount)
    const tag = this.getFirstWord()
    return `${indent}<${tag}>${this._getXmlContent(indentCount)}</${tag}>${indentCount === -1 ? "" : "\n"}`
  }
  _toObjectTuple() {
    const content = this.getContent()
    const length = this.length
    const hasChildrenNoContent = content === undefined && length
    const hasContentAndHasChildren = content !== undefined && length
    // If the node has a content and a subtree return it as a string, as
    // Javascript object values can't be both a leaf and a tree.
    const tupleValue = hasChildrenNoContent ? this.toObject() : hasContentAndHasChildren ? this.getContentWithChildren() : content
    return [this.getFirstWord(), tupleValue]
  }
  _indexOfNode(needleNode) {
    let result = -1
    this.find((node, index) => {
      if (node === needleNode) {
        result = index
        return true
      }
    })
    return result
  }
  getMaxLineWidth() {
    let maxWidth = 0
    for (let node of this.getTopDownArrayIterator()) {
      const lineWidth = node.getLine().length
      if (lineWidth > maxWidth) maxWidth = lineWidth
    }
    return maxWidth
  }
  toTreeNode() {
    return new TreeNode(this.toString())
  }
  _rightPad(newWidth, padCharacter) {
    const line = this.getLine()
    this.setLine(line + padCharacter.repeat(newWidth - line.length))
    return this
  }
  rightPad(padCharacter = " ") {
    const newWidth = this.getMaxLineWidth()
    this.getTopDownArray().forEach(node => node._rightPad(newWidth, padCharacter))
    return this
  }
  lengthen(numberOfLines) {
    let linesToAdd = numberOfLines - this.getNumberOfLines()
    while (linesToAdd > 0) {
      this.appendLine("")
      linesToAdd--
    }
    return this
  }
  toSideBySide(treesOrStrings, delimiter = " ") {
    treesOrStrings = treesOrStrings.map(tree => (tree instanceof TreeNode ? tree : new TreeNode(tree)))
    const clone = this.toTreeNode()
    const nodeBreakSymbol = "\n"
    let next
    while ((next = treesOrStrings.shift())) {
      clone.lengthen(next.getNumberOfLines())
      clone.rightPad()
      next
        .toString()
        .split(nodeBreakSymbol)
        .forEach((line, index) => {
          const node = clone.nodeAtLine(index)
          node.setLine(node.getLine() + delimiter + line)
        })
    }
    return clone
  }
  toComparison(treeNode) {
    const nodeBreakSymbol = "\n"
    const lines = treeNode.toString().split(nodeBreakSymbol)
    return new TreeNode(
      this.toString()
        .split(nodeBreakSymbol)
        .map((line, index) => (lines[index] === line ? "" : "x"))
        .join(nodeBreakSymbol)
    )
  }
  toBraid(treesOrStrings) {
    treesOrStrings.unshift(this)
    const nodeDelimiter = this.getNodeBreakSymbol()
    return new TreeNode(
      TreeUtils.interweave(treesOrStrings.map(tree => tree.toString().split(nodeDelimiter)))
        .map(line => (line === undefined ? "" : line))
        .join(nodeDelimiter)
    )
  }
  getSlice(startIndexInclusive, stopIndexExclusive) {
    return new TreeNode(
      this.slice(startIndexInclusive, stopIndexExclusive)
        .map(child => child.toString())
        .join("\n")
    )
  }
  _hasColumns(columns) {
    const words = this.getWords()
    return columns.every((searchTerm, index) => searchTerm === words[index])
  }
  hasWord(index, word) {
    return this.getWord(index) === word
  }
  getNodeByColumns(...columns) {
    return this.getTopDownArray().find(node => node._hasColumns(columns))
  }
  getNodeByColumn(index, name) {
    return this.find(node => node.getWord(index) === name)
  }
  _getNodesByColumn(index, name) {
    return this.filter(node => node.getWord(index) === name)
  }
  // todo: preserve subclasses!
  select(columnNames) {
    columnNames = Array.isArray(columnNames) ? columnNames : [columnNames]
    const result = new TreeNode()
    this.forEach(node => {
      const tree = result.appendLine(node.getLine())
      columnNames.forEach(name => {
        const valueNode = node.getNode(name)
        if (valueNode) tree.appendNode(valueNode)
      })
    })
    return result
  }
  selectionToString() {
    return this.getSelectedNodes()
      .map(node => node.toString())
      .join("\n")
  }
  getSelectedNodes() {
    return this.getTopDownArray().filter(node => node.isSelected())
  }
  clearSelection() {
    this.getSelectedNodes().forEach(node => node.unselectNode())
  }
  // Note: this is for debugging select chains
  print(message = "") {
    if (message) console.log(message)
    console.log(this.toString())
    return this
  }
  // todo: preserve subclasses!
  // todo: preserve links back to parent so you could edit as normal?
  where(columnName, operator, fixedValue) {
    const isArray = Array.isArray(fixedValue)
    const valueType = isArray ? typeof fixedValue[0] : typeof fixedValue
    let parser
    if (valueType === "number") parser = parseFloat
    const fn = node => {
      const cell = node.get(columnName)
      const typedCell = parser ? parser(cell) : cell
      if (operator === WhereOperators.equal) return fixedValue === typedCell
      else if (operator === WhereOperators.notEqual) return fixedValue !== typedCell
      else if (operator === WhereOperators.includes) return typedCell !== undefined && typedCell.includes(fixedValue)
      else if (operator === WhereOperators.doesNotInclude) return typedCell === undefined || !typedCell.includes(fixedValue)
      else if (operator === WhereOperators.greaterThan) return typedCell > fixedValue
      else if (operator === WhereOperators.lessThan) return typedCell < fixedValue
      else if (operator === WhereOperators.greaterThanOrEqual) return typedCell >= fixedValue
      else if (operator === WhereOperators.lessThanOrEqual) return typedCell <= fixedValue
      else if (operator === WhereOperators.empty) return !node.has(columnName)
      else if (operator === WhereOperators.notEmpty) return node.has(columnName)
      else if (operator === WhereOperators.in && isArray) return fixedValue.includes(typedCell)
      else if (operator === WhereOperators.notIn && isArray) return !fixedValue.includes(typedCell)
    }
    const result = new TreeNode()
    this.filter(fn).forEach(node => {
      result.appendNode(node)
    })
    return result
  }
  with(firstWord) {
    return this.filter(node => node.has(firstWord))
  }
  without(firstWord) {
    return this.filter(node => !node.has(firstWord))
  }
  first(quantity = 1) {
    return this.limit(quantity, 0)
  }
  last(quantity = 1) {
    return this.limit(quantity, this.length - quantity)
  }
  // todo: preserve subclasses!
  limit(quantity, offset = 0) {
    const result = new TreeNode()
    this.getChildren()
      .slice(offset, quantity + offset)
      .forEach(node => {
        result.appendNode(node)
      })
    return result
  }
  getChildrenFirstArray() {
    const arr = []
    this._getChildrenFirstArray(arr)
    return arr
  }
  _getChildrenFirstArray(arr) {
    this.forEach(child => {
      child._getChildrenFirstArray(arr)
      arr.push(child)
    })
  }
  _getIndentLevel(relativeTo) {
    return this._getStack(relativeTo).length
  }
  getParentFirstArray() {
    const levels = this._getLevels()
    const arr = []
    Object.values(levels).forEach(level => {
      level.forEach(item => arr.push(item))
    })
    return arr
  }
  _getLevels() {
    const levels = {}
    this.getTopDownArray().forEach(node => {
      const level = node._getIndentLevel()
      if (!levels[level]) levels[level] = []
      levels[level].push(node)
    })
    return levels
  }
  _getChildrenArray() {
    if (!this._children) this._children = []
    return this._children
  }
  getLines() {
    return this.map(node => node.getLine())
  }
  getChildren() {
    return this._getChildrenArray().slice(0)
  }
  get length() {
    return this._getChildrenArray().length
  }
  _nodeAt(index) {
    if (index < 0) index = this.length + index
    return this._getChildrenArray()[index]
  }
  nodeAt(indexOrIndexArray) {
    if (typeof indexOrIndexArray === "number") return this._nodeAt(indexOrIndexArray)
    if (indexOrIndexArray.length === 1) return this._nodeAt(indexOrIndexArray[0])
    const first = indexOrIndexArray[0]
    const node = this._nodeAt(first)
    if (!node) return undefined
    return node.nodeAt(indexOrIndexArray.slice(1))
  }
  _toObject() {
    const obj = {}
    this.forEach(node => {
      const tuple = node._toObjectTuple()
      obj[tuple[0]] = tuple[1]
    })
    return obj
  }
  toHtml() {
    return this._childrenToHtml(0)
  }
  _toHtmlCubeLine(indents = 0, lineIndex = 0, planeIndex = 0) {
    const getLine = (cellIndex, word = "") =>
      `<span class="htmlCubeSpan" style="top: calc(var(--topIncrement) * ${planeIndex} + var(--rowHeight) * ${lineIndex}); left:calc(var(--leftIncrement) * ${planeIndex} + var(--cellWidth) * ${cellIndex});">${word}</span>`
    let cells = []
    this.getWords().forEach((word, index) => (word ? cells.push(getLine(index + indents, word)) : ""))
    return cells.join("")
  }
  toHtmlCube() {
    return this.map((plane, planeIndex) =>
      plane
        .getTopDownArray()
        .map((line, lineIndex) => line._toHtmlCubeLine(line.getIndentLevel() - 2, lineIndex, planeIndex))
        .join("")
    ).join("")
  }
  _getHtmlJoinByCharacter() {
    return `<span class="nodeBreakSymbol">${this.getNodeBreakSymbol()}</span>`
  }
  _childrenToHtml(indentCount) {
    const joinBy = this._getHtmlJoinByCharacter()
    return this.map(node => node._toHtml(indentCount)).join(joinBy)
  }
  _childrenToString(indentCount, language = this) {
    return this.map(node => node.toString(indentCount, language)).join(language.getNodeBreakSymbol())
  }
  childrenToString(indentCount = 0) {
    return this._childrenToString(indentCount)
  }
  // todo: implement
  _getChildJoinCharacter() {
    return "\n"
  }
  format() {
    this.forEach(child => child.format())
    return this
  }
  compile() {
    return this.map(child => child.compile()).join(this._getChildJoinCharacter())
  }
  toXml() {
    return this._childrenToXml(0)
  }
  toDisk(path) {
    if (!this.isNodeJs()) throw new Error("This method only works in Node.js")
    const format = TreeNode._getFileFormat(path)
    const formats = {
      tree: tree => tree.toString(),
      csv: tree => tree.toCsv(),
      tsv: tree => tree.toTsv()
    }
    this.require("fs").writeFileSync(path, formats[format](this), "utf8")
    return this
  }
  _lineToYaml(indentLevel, listTag = "") {
    let prefix = " ".repeat(indentLevel)
    if (listTag && indentLevel > 1) prefix = " ".repeat(indentLevel - 2) + listTag + " "
    return prefix + `${this.getFirstWord()}:` + (this.getContent() ? " " + this.getContent() : "")
  }
  _isYamlList() {
    return this.hasDuplicateFirstWords()
  }
  toYaml() {
    return `%YAML 1.2
---\n${this._childrenToYaml(0).join("\n")}`
  }
  _childrenToYaml(indentLevel) {
    if (this._isYamlList()) return this._childrenToYamlList(indentLevel)
    else return this._childrenToYamlAssociativeArray(indentLevel)
  }
  // if your code-to-be-yaml has a list of associative arrays of type N and you don't
  // want the type N to print
  _collapseYamlLine() {
    return false
  }
  _toYamlListElement(indentLevel) {
    const children = this._childrenToYaml(indentLevel + 1)
    if (this._collapseYamlLine()) {
      if (indentLevel > 1) return children.join("\n").replace(" ".repeat(indentLevel), " ".repeat(indentLevel - 2) + "- ")
      return children.join("\n")
    } else {
      children.unshift(this._lineToYaml(indentLevel, "-"))
      return children.join("\n")
    }
  }
  _childrenToYamlList(indentLevel) {
    return this.map(node => node._toYamlListElement(indentLevel + 2))
  }
  _toYamlAssociativeArrayElement(indentLevel) {
    const children = this._childrenToYaml(indentLevel + 1)
    children.unshift(this._lineToYaml(indentLevel))
    return children.join("\n")
  }
  _childrenToYamlAssociativeArray(indentLevel) {
    return this.map(node => node._toYamlAssociativeArrayElement(indentLevel))
  }
  toJsonSubset() {
    return JSON.stringify(this.toObject(), null, " ")
  }
  findNodes(firstWordPath) {
    // todo: can easily speed this up
    const map = {}
    if (!Array.isArray(firstWordPath)) firstWordPath = [firstWordPath]
    firstWordPath.forEach(path => (map[path] = true))
    return this.getTopDownArray().filter(node => {
      if (map[node._getFirstWordPath(this)]) return true
      return false
    })
  }
  evalTemplateString(str) {
    const that = this
    return str.replace(/{([^\}]+)}/g, (match, path) => that.get(path) || "")
  }
  emitLogMessage(message) {
    console.log(message)
  }
  getColumn(path) {
    return this.map(node => node.get(path))
  }
  getFiltered(fn) {
    const clone = this.clone()
    clone
      .filter((node, index) => !fn(node, index))
      .forEach(node => {
        node.destroy()
      })
    return clone
  }
  getNode(firstWordPath) {
    return this._getNodeByPath(firstWordPath)
  }
  get(firstWordPath) {
    const node = this._getNodeByPath(firstWordPath)
    return node === undefined ? undefined : node.getContent()
  }
  getNodesByGlobPath(query) {
    return this._getNodesByGlobPath(query)
  }
  _getNodesByGlobPath(globPath) {
    const edgeSymbol = this.getEdgeSymbol()
    if (!globPath.includes(edgeSymbol)) {
      if (globPath === "*") return this.getChildren()
      return this.filter(node => node.getFirstWord() === globPath)
    }
    const parts = globPath.split(edgeSymbol)
    const current = parts.shift()
    const rest = parts.join(edgeSymbol)
    const matchingNodes = current === "*" ? this.getChildren() : this.filter(child => child.getFirstWord() === current)
    return [].concat.apply([], matchingNodes.map(node => node._getNodesByGlobPath(rest)))
  }
  _getNodeByPath(firstWordPath) {
    const edgeSymbol = this.getEdgeSymbol()
    if (!firstWordPath.includes(edgeSymbol)) {
      const index = this.indexOfLast(firstWordPath)
      return index === -1 ? undefined : this._nodeAt(index)
    }
    const parts = firstWordPath.split(edgeSymbol)
    const current = parts.shift()
    const currentNode = this._getChildrenArray()[this._getIndex()[current]]
    return currentNode ? currentNode._getNodeByPath(parts.join(edgeSymbol)) : undefined
  }
  getNext() {
    if (this.isRoot()) return this
    const index = this.getIndex()
    const parent = this.getParent()
    const length = parent.length
    const next = index + 1
    return next === length ? parent._getChildrenArray()[0] : parent._getChildrenArray()[next]
  }
  getPrevious() {
    if (this.isRoot()) return this
    const index = this.getIndex()
    const parent = this.getParent()
    const length = parent.length
    const prev = index - 1
    return prev === -1 ? parent._getChildrenArray()[length - 1] : parent._getChildrenArray()[prev]
  }
  _getUnionNames() {
    if (!this.length) return []
    const obj = {}
    this.forEach(node => {
      if (!node.length) return undefined
      node.forEach(node => {
        obj[node.getFirstWord()] = 1
      })
    })
    return Object.keys(obj)
  }
  getAncestorNodesByInheritanceViaExtendsKeyword(key) {
    const ancestorNodes = this._getAncestorNodes((node, id) => node._getNodesByColumn(0, id), node => node.get(key), this)
    ancestorNodes.push(this)
    return ancestorNodes
  }
  // Note: as you can probably tell by the name of this method, I don't recommend using this as it will likely be replaced by something better.
  getAncestorNodesByInheritanceViaColumnIndices(thisColumnNumber, extendsColumnNumber) {
    const ancestorNodes = this._getAncestorNodes((node, id) => node._getNodesByColumn(thisColumnNumber, id), node => node.getWord(extendsColumnNumber), this)
    ancestorNodes.push(this)
    return ancestorNodes
  }
  _getAncestorNodes(getPotentialParentNodesByIdFn, getParentIdFn, cannotContainNode) {
    const parentId = getParentIdFn(this)
    if (!parentId) return []
    const potentialParentNodes = getPotentialParentNodesByIdFn(this.getParent(), parentId)
    if (!potentialParentNodes.length) throw new Error(`"${this.getLine()} tried to extend "${parentId}" but "${parentId}" not found.`)
    if (potentialParentNodes.length > 1) throw new Error(`Invalid inheritance family tree. Multiple unique ids found for "${parentId}"`)
    const parentNode = potentialParentNodes[0]
    // todo: detect loops
    if (parentNode === cannotContainNode) throw new Error(`Loop detected between '${this.getLine()}' and '${parentNode.getLine()}'`)
    const ancestorNodes = parentNode._getAncestorNodes(getPotentialParentNodesByIdFn, getParentIdFn, cannotContainNode)
    ancestorNodes.push(parentNode)
    return ancestorNodes
  }
  pathVectorToFirstWordPath(pathVector) {
    const path = pathVector.slice() // copy array
    const names = []
    let node = this
    while (path.length) {
      if (!node) return names
      names.push(node.nodeAt(path[0]).getFirstWord())
      node = node.nodeAt(path.shift())
    }
    return names
  }
  toStringWithLineNumbers() {
    return this.toString()
      .split("\n")
      .map((line, index) => `${index + 1} ${line}`)
      .join("\n")
  }
  toCsv() {
    return this.toDelimited(",")
  }
  _getTypes(header) {
    const matrix = this._getMatrix(header)
    const types = header.map(i => "int")
    matrix.forEach(row => {
      row.forEach((value, index) => {
        const type = types[index]
        if (type === "string") return 1
        if (value === undefined || value === "") return 1
        if (type === "float") {
          if (value.match(/^\-?[0-9]*\.?[0-9]*$/)) return 1
          types[index] = "string"
        }
        if (value.match(/^\-?[0-9]+$/)) return 1
        types[index] = "string"
      })
    })
    return types
  }
  toDataTable(header = this._getUnionNames()) {
    const types = this._getTypes(header)
    const parsers = {
      string: str => str,
      float: parseFloat,
      int: parseInt
    }
    const cellFn = (cellValue, rowIndex, columnIndex) => (rowIndex ? parsers[types[columnIndex]](cellValue) : cellValue)
    const arrays = this._toArrays(header, cellFn)
    arrays.rows.unshift(arrays.header)
    return arrays.rows
  }
  toDelimited(delimiter, header = this._getUnionNames()) {
    const regex = new RegExp(`(\\n|\\"|\\${delimiter})`)
    const cellFn = (str, row, column) => (!str.toString().match(regex) ? str : `"` + str.replace(/\"/g, `""`) + `"`)
    return this._toDelimited(delimiter, header, cellFn)
  }
  _getMatrix(columns) {
    const matrix = []
    this.forEach(child => {
      const row = []
      columns.forEach(col => {
        row.push(child.get(col))
      })
      matrix.push(row)
    })
    return matrix
  }
  _toArrays(header, cellFn) {
    const skipHeaderRow = 1
    const headerArray = header.map((columnName, index) => cellFn(columnName, 0, index))
    const rows = this.map((node, rowNumber) =>
      header.map((columnName, columnIndex) => {
        const childNode = node.getNode(columnName)
        const content = childNode ? childNode.getContentWithChildren() : ""
        return cellFn(content, rowNumber + skipHeaderRow, columnIndex)
      })
    )
    return {
      rows: rows,
      header: headerArray
    }
  }
  _toDelimited(delimiter, header, cellFn) {
    const data = this._toArrays(header, cellFn)
    return data.header.join(delimiter) + "\n" + data.rows.map(row => row.join(delimiter)).join("\n")
  }
  toTable() {
    // Output a table for printing
    return this._toTable(100, false)
  }
  toFormattedTable(maxCharactersPerColumn, alignRight = false) {
    return this._toTable(maxCharactersPerColumn, alignRight)
  }
  _toTable(maxCharactersPerColumn, alignRight = false) {
    const header = this._getUnionNames()
    // Set initial column widths
    const widths = header.map(col => (col.length > maxCharactersPerColumn ? maxCharactersPerColumn : col.length))
    // Expand column widths if needed
    this.forEach(node => {
      if (!node.length) return true
      header.forEach((col, index) => {
        const cellValue = node.get(col)
        if (!cellValue) return true
        const length = cellValue.toString().length
        if (length > widths[index]) widths[index] = length > maxCharactersPerColumn ? maxCharactersPerColumn : length
      })
    })
    const cellFn = (cellText, row, col) => {
      const width = widths[col]
      // Strip newlines in fixedWidth output
      const cellValue = cellText.toString().replace(/\n/g, "\\n")
      const cellLength = cellValue.length
      if (cellLength > width) return cellValue.substr(0, width) + "..."
      const padding = " ".repeat(width - cellLength)
      return alignRight ? padding + cellValue : cellValue + padding
    }
    return this._toDelimited(" ", header, cellFn)
  }
  toSsv() {
    return this.toDelimited(" ")
  }
  toOutline() {
    return this._toOutline(node => node.getLine())
  }
  toMappedOutline(nodeFn) {
    return this._toOutline(nodeFn)
  }
  // Adapted from: https://github.com/notatestuser/treeify.js
  _toOutline(nodeFn) {
    const growBranch = (outlineTreeNode, last, lastStates, nodeFn, callback) => {
      let lastStatesCopy = lastStates.slice(0)
      const node = outlineTreeNode.node
      if (lastStatesCopy.push([outlineTreeNode, last]) && lastStates.length > 0) {
        let line = ""
        // firstWordd on the "was last element" states of whatever we're nested within,
        // we need to append either blankness or a branch to our line
        lastStates.forEach((lastState, idx) => {
          if (idx > 0) line += lastState[1] ? " " : "│"
        })
        // the prefix varies firstWordd on whether the key contains something to show and
        // whether we're dealing with the last element in this collection
        // the extra "-" just makes things stand out more.
        line += (last ? "└" : "├") + nodeFn(node)
        callback(line)
      }
      if (!node) return
      const length = node.length
      let index = 0
      node.forEach(node => {
        let lastKey = ++index === length
        growBranch({ node: node }, lastKey, lastStatesCopy, nodeFn, callback)
      })
    }
    let output = ""
    growBranch({ node: this }, false, [], nodeFn, line => (output += line + "\n"))
    return output
  }
  copyTo(node, index) {
    return node._insertLineAndChildren(this.getLine(), this.childrenToString(), index)
  }
  // Note: Splits using a positive lookahead
  // this.split("foo").join("\n") === this.toString()
  split(firstWord) {
    const constructor = this.constructor
    const NodeBreakSymbol = this.getNodeBreakSymbol()
    const WordBreakSymbol = this.getWordBreakSymbol()
    // todo: cleanup. the escaping is wierd.
    return this.toString()
      .split(new RegExp(`\\${NodeBreakSymbol}(?=${firstWord}(?:${WordBreakSymbol}|\\${NodeBreakSymbol}))`, "g"))
      .map(str => new constructor(str))
  }
  toMarkdownTable() {
    return this.toMarkdownTableAdvanced(this._getUnionNames(), val => val)
  }
  toMarkdownTableAdvanced(columns, formatFn) {
    const matrix = this._getMatrix(columns)
    const empty = columns.map(col => "-")
    matrix.unshift(empty)
    matrix.unshift(columns)
    const lines = matrix.map((row, rowIndex) => {
      const formattedValues = row.map((val, colIndex) => formatFn(val, rowIndex, colIndex))
      return `|${formattedValues.join("|")}|`
    })
    return lines.join("\n")
  }
  toTsv() {
    return this.toDelimited("\t")
  }
  getNodeBreakSymbol() {
    return "\n"
  }
  getWordBreakSymbol() {
    return " "
  }
  getNodeBreakSymbolRegex() {
    return new RegExp(this.getNodeBreakSymbol(), "g")
  }
  getEdgeSymbol() {
    return " "
  }
  _textToContentAndChildrenTuple(text) {
    const lines = text.split(this.getNodeBreakSymbolRegex())
    const firstLine = lines.shift()
    const children = !lines.length
      ? undefined
      : lines
          .map(line => (line.substr(0, 1) === this.getEdgeSymbol() ? line : this.getEdgeSymbol() + line))
          .map(line => line.substr(1))
          .join(this.getNodeBreakSymbol())
    return [firstLine, children]
  }
  _getLine() {
    return this._line
  }
  _setLine(line = "") {
    this._line = line
    if (this._words) delete this._words
    return this
  }
  _clearChildren() {
    this._deleteByIndexes(TreeUtils.getRange(0, this.length))
    delete this._children
    return this
  }
  _setChildren(content, circularCheckArray) {
    this._clearChildren()
    if (!content) return this
    // set from string
    if (typeof content === "string") {
      this._appendChildrenFromString(content)
      return this
    }
    // set from tree object
    if (content instanceof TreeNode) {
      content.forEach(node => this._insertLineAndChildren(node.getLine(), node.childrenToString()))
      return this
    }
    // If we set from object, create an array of inserted objects to avoid circular loops
    if (!circularCheckArray) circularCheckArray = [content]
    return this._setFromObject(content, circularCheckArray)
  }
  _setFromObject(content, circularCheckArray) {
    for (let firstWord in content) {
      if (!content.hasOwnProperty(firstWord)) continue
      // Branch the circularCheckArray, as we only have same branch circular arrays
      this._appendFromJavascriptObjectTuple(firstWord, content[firstWord], circularCheckArray.slice(0))
    }
    return this
  }
  // todo: refactor the below.
  _appendFromJavascriptObjectTuple(firstWord, content, circularCheckArray) {
    const type = typeof content
    let line
    let children
    if (content === null) line = firstWord + " " + null
    else if (content === undefined) line = firstWord
    else if (type === "string") {
      const tuple = this._textToContentAndChildrenTuple(content)
      line = firstWord + " " + tuple[0]
      children = tuple[1]
    } else if (type === "function") line = firstWord + " " + content.toString()
    else if (type !== "object") line = firstWord + " " + content
    else if (content instanceof Date) line = firstWord + " " + content.getTime().toString()
    else if (content instanceof TreeNode) {
      line = firstWord
      children = new TreeNode(content.childrenToString(), content.getLine())
    } else if (circularCheckArray.indexOf(content) === -1) {
      circularCheckArray.push(content)
      line = firstWord
      const length = content instanceof Array ? content.length : Object.keys(content).length
      if (length) children = new TreeNode()._setChildren(content, circularCheckArray)
    } else {
      // iirc this is return early from circular
      return
    }
    this._insertLineAndChildren(line, children)
  }
  _insertLineAndChildren(line, children, index = this.length) {
    const nodeConstructor = this._getParser()._getNodeConstructor(line, this)
    const newNode = new nodeConstructor(children, line, this)
    const adjustedIndex = index < 0 ? this.length + index : index
    this._getChildrenArray().splice(adjustedIndex, 0, newNode)
    if (this._index) this._makeIndex(adjustedIndex)
    return newNode
  }
  _appendChildrenFromString(str) {
    const lines = str.split(this.getNodeBreakSymbolRegex())
    const parentStack = []
    let currentIndentCount = -1
    let lastNode = this
    lines.forEach(line => {
      const indentCount = this._getIndentCount(line)
      if (indentCount > currentIndentCount) {
        currentIndentCount++
        parentStack.push(lastNode)
      } else if (indentCount < currentIndentCount) {
        // pop things off stack
        while (indentCount < currentIndentCount) {
          parentStack.pop()
          currentIndentCount--
        }
      }
      const lineContent = line.substr(currentIndentCount)
      const parent = parentStack[parentStack.length - 1]
      const nodeConstructor = parent._getParser()._getNodeConstructor(lineContent, parent)
      lastNode = new nodeConstructor(undefined, lineContent, parent)
      parent._getChildrenArray().push(lastNode)
    })
  }
  _getIndex() {
    // StringMap<int> {firstWord: index}
    // When there are multiple tails with the same firstWord, _index stores the last content.
    // todo: change the above behavior: when a collision occurs, create an array.
    return this._index || this._makeIndex()
  }
  getContentsArray() {
    return this.map(node => node.getContent())
  }
  // todo: rename to getChildrenByConstructor(?)
  getChildrenByNodeConstructor(constructor) {
    return this.filter(child => child instanceof constructor)
  }
  getAncestorByNodeConstructor(constructor) {
    if (this instanceof constructor) return this
    if (this.isRoot()) return undefined
    const parent = this.getParent()
    return parent instanceof constructor ? parent : parent.getAncestorByNodeConstructor(constructor)
  }
  // todo: rename to getNodeByConstructor(?)
  getNodeByType(constructor) {
    return this.find(child => child instanceof constructor)
  }
  indexOfLast(firstWord) {
    const result = this._getIndex()[firstWord]
    return result === undefined ? -1 : result
  }
  // todo: renmae to indexOfFirst?
  indexOf(firstWord) {
    if (!this.has(firstWord)) return -1
    const length = this.length
    const nodes = this._getChildrenArray()
    for (let index = 0; index < length; index++) {
      if (nodes[index].getFirstWord() === firstWord) return index
    }
  }
  toObject() {
    return this._toObject()
  }
  getFirstWords() {
    return this.map(node => node.getFirstWord())
  }
  _makeIndex(startAt = 0) {
    if (!this._index || !startAt) this._index = {}
    const nodes = this._getChildrenArray()
    const newIndex = this._index
    const length = nodes.length
    for (let index = startAt; index < length; index++) {
      newIndex[nodes[index].getFirstWord()] = index
    }
    return newIndex
  }
  _childrenToXml(indentCount) {
    return this.map(node => node._toXml(indentCount)).join("")
  }
  _getIndentCount(str) {
    let level = 0
    const edgeChar = this.getEdgeSymbol()
    while (str[level] === edgeChar) {
      level++
    }
    return level
  }
  clone() {
    return new this.constructor(this.childrenToString(), this.getLine())
  }
  // todo: rename to hasFirstWord
  has(firstWord) {
    return this._hasFirstWord(firstWord)
  }
  _hasFirstWord(firstWord) {
    return this._getIndex()[firstWord] !== undefined
  }
  map(fn) {
    return this.getChildren().map(fn)
  }
  filter(fn = item => item) {
    return this.getChildren().filter(fn)
  }
  find(fn) {
    return this.getChildren().find(fn)
  }
  every(fn) {
    let index = 0
    for (let node of this.getTopDownArrayIterator()) {
      if (!fn(node, index)) return false
      index++
    }
    return true
  }
  forEach(fn) {
    this.getChildren().forEach(fn)
    return this
  }
  // Recurse if predicate passes
  deepVisit(predicate) {
    this.forEach(node => {
      if (predicate(node) !== false) node.deepVisit(predicate)
    })
  }
  // todo: protected?
  _clearIndex() {
    delete this._index
  }
  slice(start, end) {
    return this.getChildren().slice(start, end)
  }
  // todo: make 0 and 1 a param
  getInheritanceTree() {
    const paths = {}
    const result = new TreeNode()
    this.forEach(node => {
      const key = node.getWord(0)
      const parentKey = node.getWord(1)
      const parentPath = paths[parentKey]
      paths[key] = parentPath ? [parentPath, key].join(" ") : key
      result.touchNode(paths[key])
    })
    return result
  }
  _getGrandParent() {
    return this.isRoot() || this.getParent().isRoot() ? undefined : this.getParent().getParent()
  }
  _getParser() {
    if (!TreeNode._parsers.has(this.constructor)) TreeNode._parsers.set(this.constructor, this.createParser())
    return TreeNode._parsers.get(this.constructor)
  }
  createParser() {
    return new Parser(this.constructor)
  }
  static _makeUniqueId() {
    if (this._uniqueId === undefined) this._uniqueId = 0
    this._uniqueId++
    return this._uniqueId
  }
  static _getFileFormat(path) {
    const format = path.split(".").pop()
    return FileFormat[format] ? format : FileFormat.tree
  }
  getLineModifiedTime() {
    return this._lineModifiedTime || this._nodeCreationTime
  }
  getChildArrayModifiedTime() {
    return this._childArrayModifiedTime || this._nodeCreationTime
  }
  _setChildArrayMofifiedTime(value) {
    this._childArrayModifiedTime = value
    return this
  }
  getLineOrChildrenModifiedTime() {
    return Math.max(this.getLineModifiedTime(), this.getChildArrayModifiedTime(), Math.max.apply(null, this.map(child => child.getLineOrChildrenModifiedTime())))
  }
  _setVirtualParentTree(tree) {
    this._virtualParentTree = tree
    return this
  }
  _getVirtualParentTreeNode() {
    return this._virtualParentTree
  }
  _setVirtualAncestorNodesByInheritanceViaColumnIndicesAndThenExpand(nodes, thisIdColumnNumber, extendsIdColumnNumber) {
    const map = {}
    for (let node of nodes) {
      const nodeId = node.getWord(thisIdColumnNumber)
      if (map[nodeId]) throw new Error(`Tried to define a node with id "${nodeId}" but one is already defined.`)
      map[nodeId] = {
        nodeId: nodeId,
        node: node,
        parentId: node.getWord(extendsIdColumnNumber)
      }
    }
    // Add parent Nodes
    Object.values(map).forEach(nodeInfo => {
      const parentId = nodeInfo.parentId
      const parentNode = map[parentId]
      if (parentId && !parentNode) throw new Error(`Node "${nodeInfo.nodeId}" tried to extend "${parentId}" but "${parentId}" not found.`)
      if (parentId) nodeInfo.node._setVirtualParentTree(parentNode.node)
    })
    nodes.forEach(node => node._expandFromVirtualParentTree())
    return this
  }
  _expandFromVirtualParentTree() {
    if (this._isVirtualExpanded) return this
    this._isExpanding = true
    let parentNode = this._getVirtualParentTreeNode()
    if (parentNode) {
      if (parentNode._isExpanding) throw new Error(`Loop detected: '${this.getLine()}' is the ancestor of one of its ancestors.`)
      parentNode._expandFromVirtualParentTree()
      const clone = this.clone()
      this._setChildren(parentNode.childrenToString())
      this.extend(clone)
    }
    this._isExpanding = false
    this._isVirtualExpanded = true
  }
  // todo: solve issue related to whether extend should overwrite or append.
  _expandChildren(thisIdColumnNumber, extendsIdColumnNumber, childrenThatNeedExpanding = this.getChildren()) {
    return this._setVirtualAncestorNodesByInheritanceViaColumnIndicesAndThenExpand(childrenThatNeedExpanding, thisIdColumnNumber, extendsIdColumnNumber)
  }
  // todo: add more testing.
  // todo: solve issue with where extend should overwrite or append
  // todo: should take a grammar? to decide whether to overwrite or append.
  // todo: this is slow.
  extend(nodeOrStr) {
    const node = nodeOrStr instanceof TreeNode ? nodeOrStr : new TreeNode(nodeOrStr)
    const usedFirstWords = new Set()
    node.forEach(sourceNode => {
      const firstWord = sourceNode.getFirstWord()
      let targetNode
      const isAnArrayNotMap = usedFirstWords.has(firstWord)
      if (!this.has(firstWord)) {
        usedFirstWords.add(firstWord)
        this.appendLineAndChildren(sourceNode.getLine(), sourceNode.childrenToString())
        return true
      }
      if (isAnArrayNotMap) targetNode = this.appendLine(sourceNode.getLine())
      else {
        targetNode = this.touchNode(firstWord).setContent(sourceNode.getContent())
        usedFirstWords.add(firstWord)
      }
      if (sourceNode.length) targetNode.extend(sourceNode)
    })
    return this
  }
  macroExpand(macroDefinitionWord, macroUsageWord) {
    const clone = this.clone()
    const defs = clone.findNodes(macroDefinitionWord)
    const allUses = clone.findNodes(macroUsageWord)
    const wordBreakSymbol = clone.getWordBreakSymbol()
    defs.forEach(def => {
      const macroName = def.getWord(1)
      const uses = allUses.filter(node => node.hasWord(1, macroName))
      const params = def.getWordsFrom(2)
      const replaceFn = str => {
        const paramValues = str.split(wordBreakSymbol).slice(2)
        let newTree = def.childrenToString()
        params.forEach((param, index) => {
          newTree = newTree.replace(new RegExp(param, "g"), paramValues[index])
        })
        return newTree
      }
      uses.forEach(node => {
        node.replaceNode(replaceFn)
      })
      def.destroy()
    })
    return clone
  }
  setChildren(children) {
    return this._setChildren(children)
  }
  _updateLineModifiedTimeAndTriggerEvent() {
    this._lineModifiedTime = this._getProcessTimeInMilliseconds()
  }
  insertWord(index, word) {
    const wi = this.getWordBreakSymbol()
    const words = this._getLine().split(wi)
    words.splice(index, 0, word)
    this.setLine(words.join(wi))
    return this
  }
  deleteDuplicates() {
    const set = new Set()
    this.getTopDownArray().forEach(node => {
      const str = node.toString()
      if (set.has(str)) node.destroy()
      else set.add(str)
    })
    return this
  }
  setWord(index, word) {
    const wi = this.getWordBreakSymbol()
    const words = this._getLine().split(wi)
    words[index] = word
    this.setLine(words.join(wi))
    return this
  }
  deleteChildren() {
    return this._clearChildren()
  }
  setContent(content) {
    if (content === this.getContent()) return this
    const newArray = [this.getFirstWord()]
    if (content !== undefined) {
      content = content.toString()
      if (content.match(this.getNodeBreakSymbol())) return this.setContentWithChildren(content)
      newArray.push(content)
    }
    this._setLine(newArray.join(this.getWordBreakSymbol()))
    this._updateLineModifiedTimeAndTriggerEvent()
    return this
  }
  prependSibling(line, children) {
    return this.getParent().insertLineAndChildren(line, children, this.getIndex())
  }
  appendSibling(line, children) {
    return this.getParent().insertLineAndChildren(line, children, this.getIndex() + 1)
  }
  setContentWithChildren(text) {
    // todo: deprecate
    if (!text.includes(this.getNodeBreakSymbol())) {
      this._clearChildren()
      return this.setContent(text)
    }
    const lines = text.split(this.getNodeBreakSymbolRegex())
    const firstLine = lines.shift()
    this.setContent(firstLine)
    // tood: cleanup.
    const remainingString = lines.join(this.getNodeBreakSymbol())
    const children = new TreeNode(remainingString)
    if (!remainingString) children.appendLine("")
    this.setChildren(children)
    return this
  }
  setFirstWord(firstWord) {
    return this.setWord(0, firstWord)
  }
  setLine(line) {
    if (line === this.getLine()) return this
    // todo: clear parent TMTimes
    this.getParent()._clearIndex()
    this._setLine(line)
    this._updateLineModifiedTimeAndTriggerEvent()
    return this
  }
  duplicate() {
    return this.getParent()._insertLineAndChildren(this.getLine(), this.childrenToString(), this.getIndex() + 1)
  }
  trim() {
    // todo: could do this so only the trimmed rows are deleted.
    this.setChildren(this.childrenToString().trim())
    return this
  }
  destroy() {
    this.getParent()._deleteNode(this)
  }
  set(firstWordPath, text) {
    return this.touchNode(firstWordPath).setContentWithChildren(text)
  }
  setFromText(text) {
    if (this.toString() === text) return this
    const tuple = this._textToContentAndChildrenTuple(text)
    this.setLine(tuple[0])
    return this._setChildren(tuple[1])
  }
  // todo: throw error if line contains a \n
  appendLine(line) {
    return this._insertLineAndChildren(line)
  }
  appendLineAndChildren(line, children) {
    return this._insertLineAndChildren(line, children)
  }
  getNodesByRegex(regex) {
    const matches = []
    regex = regex instanceof RegExp ? [regex] : regex
    this._getNodesByLineRegex(matches, regex)
    return matches
  }
  getNodesByLinePrefixes(columns) {
    const matches = []
    this._getNodesByLineRegex(matches, columns.map(str => new RegExp("^" + str)))
    return matches
  }
  _getNodesByLineRegex(matches, regs) {
    const rgs = regs.slice(0)
    const reg = rgs.shift()
    const candidates = this.filter(child => child.getLine().match(reg))
    if (!rgs.length) return candidates.forEach(cand => matches.push(cand))
    candidates.forEach(cand => cand._getNodesByLineRegex(matches, rgs))
  }
  concat(node) {
    if (typeof node === "string") node = new TreeNode(node)
    return node.map(node => this._insertLineAndChildren(node.getLine(), node.childrenToString()))
  }
  _deleteByIndexes(indexesToDelete) {
    if (!indexesToDelete.length) return this
    this._clearIndex()
    // note: assumes indexesToDelete is in ascending order
    const deletedNodes = indexesToDelete.reverse().map(index => this._getChildrenArray().splice(index, 1)[0])
    this._setChildArrayMofifiedTime(this._getProcessTimeInMilliseconds())
    return this
  }
  _deleteNode(node) {
    const index = this._indexOfNode(node)
    return index > -1 ? this._deleteByIndexes([index]) : 0
  }
  reverse() {
    this._clearIndex()
    this._getChildrenArray().reverse()
    return this
  }
  shift() {
    if (!this.length) return null
    const node = this._getChildrenArray().shift()
    return node.copyTo(new this.constructor(), 0)
  }
  sort(fn) {
    this._getChildrenArray().sort(fn)
    this._clearIndex()
    return this
  }
  invert() {
    this.forEach(node => node.getWords().reverse())
    return this
  }
  _rename(oldFirstWord, newFirstWord) {
    const index = this.indexOf(oldFirstWord)
    if (index === -1) return this
    const node = this._getChildrenArray()[index]
    node.setFirstWord(newFirstWord)
    this._clearIndex()
    return this
  }
  // Does not recurse.
  remap(map) {
    this.forEach(node => {
      const firstWord = node.getFirstWord()
      if (map[firstWord] !== undefined) node.setFirstWord(map[firstWord])
    })
    return this
  }
  rename(oldFirstWord, newFirstWord) {
    this._rename(oldFirstWord, newFirstWord)
    return this
  }
  renameAll(oldName, newName) {
    this.findNodes(oldName).forEach(node => node.setFirstWord(newName))
    return this
  }
  _deleteAllChildNodesWithFirstWord(firstWord) {
    if (!this.has(firstWord)) return this
    const allNodes = this._getChildrenArray()
    const indexesToDelete = []
    allNodes.forEach((node, index) => {
      if (node.getFirstWord() === firstWord) indexesToDelete.push(index)
    })
    return this._deleteByIndexes(indexesToDelete)
  }
  delete(path = "") {
    const edgeSymbol = this.getEdgeSymbol()
    if (!path.includes(edgeSymbol)) return this._deleteAllChildNodesWithFirstWord(path)
    const parts = path.split(edgeSymbol)
    const nextFirstWord = parts.pop()
    const targetNode = this.getNode(parts.join(edgeSymbol))
    return targetNode ? targetNode._deleteAllChildNodesWithFirstWord(nextFirstWord) : 0
  }
  deleteColumn(firstWord = "") {
    this.forEach(node => node.delete(firstWord))
    return this
  }
  _getNonMaps() {
    const results = this.getTopDownArray().filter(node => node.hasDuplicateFirstWords())
    if (this.hasDuplicateFirstWords()) results.unshift(this)
    return results
  }
  replaceNode(fn) {
    const parent = this.getParent()
    const index = this.getIndex()
    const newNodes = new TreeNode(fn(this.toString()))
    const returnedNodes = []
    newNodes.forEach((child, childIndex) => {
      const newNode = parent.insertLineAndChildren(child.getLine(), child.childrenToString(), index + childIndex)
      returnedNodes.push(newNode)
    })
    this.destroy()
    return returnedNodes
  }
  insertLineAndChildren(line, children, index) {
    return this._insertLineAndChildren(line, children, index)
  }
  insertLine(line, index) {
    return this._insertLineAndChildren(line, undefined, index)
  }
  prependLine(line) {
    return this.insertLine(line, 0)
  }
  pushContentAndChildren(content, children) {
    let index = this.length
    while (this.has(index.toString())) {
      index++
    }
    const line = index.toString() + (content === undefined ? "" : this.getWordBreakSymbol() + content)
    return this.appendLineAndChildren(line, children)
  }
  deleteBlanks() {
    this.getChildren()
      .filter(node => node.isBlankLine())
      .forEach(node => node.destroy())
    return this
  }
  // todo: add "globalReplace" method? Which runs a global regex or string replace on the Tree doc as a string?
  firstWordSort(firstWordOrder) {
    return this._firstWordSort(firstWordOrder)
  }
  deleteWordAt(wordIndex) {
    const words = this.getWords()
    words.splice(wordIndex, 1)
    return this.setWords(words)
  }
  trigger(event) {
    if (this._listeners && this._listeners.has(event.constructor)) {
      const listeners = this._listeners.get(event.constructor)
      const listenersToRemove = []
      for (let index = 0; index < listeners.length; index++) {
        const listener = listeners[index]
        if (listener(event) === true) listenersToRemove.push(index)
      }
      listenersToRemove.reverse().forEach(index => listenersToRemove.splice(index, 1))
    }
  }
  triggerAncestors(event) {
    if (this.isRoot()) return
    const parent = this.getParent()
    parent.trigger(event)
    parent.triggerAncestors(event)
  }
  onLineChanged(eventHandler) {
    return this._addEventListener(LineChangedTreeEvent, eventHandler)
  }
  onDescendantChanged(eventHandler) {
    return this._addEventListener(DescendantChangedTreeEvent, eventHandler)
  }
  onChildAdded(eventHandler) {
    return this._addEventListener(ChildAddedTreeEvent, eventHandler)
  }
  onChildRemoved(eventHandler) {
    return this._addEventListener(ChildRemovedTreeEvent, eventHandler)
  }
  _addEventListener(eventClass, eventHandler) {
    if (!this._listeners) this._listeners = new Map()
    if (!this._listeners.has(eventClass)) this._listeners.set(eventClass, [])
    this._listeners.get(eventClass).push(eventHandler)
    return this
  }
  setWords(words) {
    return this.setLine(words.join(this.getWordBreakSymbol()))
  }
  setWordsFrom(index, words) {
    this.setWords(
      this.getWords()
        .slice(0, index)
        .concat(words)
    )
    return this
  }
  appendWord(word) {
    const words = this.getWords()
    words.push(word)
    return this.setWords(words)
  }
  _firstWordSort(firstWordOrder, secondarySortFn) {
    const nodeAFirst = -1
    const nodeBFirst = 1
    const map = {}
    firstWordOrder.forEach((word, index) => {
      map[word] = index
    })
    this.sort((nodeA, nodeB) => {
      const valA = map[nodeA.getFirstWord()]
      const valB = map[nodeB.getFirstWord()]
      if (valA > valB) return nodeBFirst
      if (valA < valB) return nodeAFirst
      return secondarySortFn ? secondarySortFn(nodeA, nodeB) : 0
    })
    return this
  }
  _touchNode(firstWordPathArray) {
    let contextNode = this
    firstWordPathArray.forEach(firstWord => {
      contextNode = contextNode.getNode(firstWord) || contextNode.appendLine(firstWord)
    })
    return contextNode
  }
  _touchNodeByString(str) {
    str = str.replace(this.getNodeBreakSymbolRegex(), "") // todo: do we want to do this sanitization?
    return this._touchNode(str.split(this.getWordBreakSymbol()))
  }
  touchNode(str) {
    return this._touchNodeByString(str)
  }
  appendNode(node) {
    return this.appendLineAndChildren(node.getLine(), node.childrenToString())
  }
  hasLine(line) {
    return this.getChildren().some(node => node.getLine() === line)
  }
  getNodesByLine(line) {
    return this.filter(node => node.getLine() === line)
  }
  toggleLine(line) {
    const lines = this.getNodesByLine(line)
    if (lines.length) {
      lines.map(line => line.destroy())
      return this
    }
    return this.appendLine(line)
  }
  // todo: remove?
  sortByColumns(indexOrIndices) {
    const indices = indexOrIndices instanceof Array ? indexOrIndices : [indexOrIndices]
    const length = indices.length
    this.sort((nodeA, nodeB) => {
      const wordsA = nodeA.getWords()
      const wordsB = nodeB.getWords()
      for (let index = 0; index < length; index++) {
        const col = indices[index]
        const av = wordsA[col]
        const bv = wordsB[col]
        if (av === undefined) return -1
        if (bv === undefined) return 1
        if (av > bv) return 1
        else if (av < bv) return -1
      }
      return 0
    })
    return this
  }
  getWordsAsSet() {
    return new Set(this.getWordsFrom(1))
  }
  appendWordIfMissing(word) {
    if (this.getWordsAsSet().has(word)) return this
    return this.appendWord(word)
  }
  // todo: check to ensure identical objects
  addObjectsAsDelimited(arrayOfObjects, delimiter = TreeUtils._chooseDelimiter(new TreeNode(arrayOfObjects).toString())) {
    const header = Object.keys(arrayOfObjects[0])
      .join(delimiter)
      .replace(/[\n\r]/g, "")
    const rows = arrayOfObjects.map(item =>
      Object.values(item)
        .join(delimiter)
        .replace(/[\n\r]/g, "")
    )
    return this.addUniqueRowsToNestedDelimited(header, rows)
  }
  setChildrenAsDelimited(tree, delimiter = TreeUtils._chooseDelimiter(tree.toString())) {
    tree = tree instanceof TreeNode ? tree : new TreeNode(tree)
    return this.setChildren(tree.toDelimited(delimiter))
  }
  convertChildrenToDelimited(delimiter = TreeUtils._chooseDelimiter(this.childrenToString())) {
    // todo: handle newlines!!!
    return this.setChildren(this.toDelimited(delimiter))
  }
  addUniqueRowsToNestedDelimited(header, rowsAsStrings) {
    if (!this.length) this.appendLine(header)
    // todo: this looks brittle
    rowsAsStrings.forEach(row => {
      if (!this.toString().includes(row)) this.appendLine(row)
    })
    return this
  }
  shiftLeft() {
    const grandParent = this._getGrandParent()
    if (!grandParent) return this
    const parentIndex = this.getParent().getIndex()
    const newNode = grandParent.insertLineAndChildren(this.getLine(), this.length ? this.childrenToString() : undefined, parentIndex + 1)
    this.destroy()
    return newNode
  }
  pasteText(text) {
    const parent = this.getParent()
    const index = this.getIndex()
    const newNodes = new TreeNode(text)
    const firstNode = newNodes.nodeAt(0)
    if (firstNode) {
      this.setLine(firstNode.getLine())
      if (firstNode.length) this.setChildren(firstNode.childrenToString())
    } else {
      this.setLine("")
    }
    newNodes.forEach((child, childIndex) => {
      if (!childIndex)
        // skip first
        return true
      parent.insertLineAndChildren(child.getLine(), child.childrenToString(), index + childIndex)
    })
    return this
  }
  templateToString(obj) {
    // todo: compile/cache for perf?
    const tree = this.clone()
    tree.getTopDownArray().forEach(node => {
      const line = node.getLine().replace(/{([^\}]+)}/g, (match, path) => {
        const replacement = obj[path]
        if (replacement === undefined) throw new Error(`In string template no match found on line "${node.getLine()}"`)
        return replacement
      })
      node.pasteText(line)
    })
    return tree.toString()
  }
  shiftRight() {
    const olderSibling = this._getClosestOlderSibling()
    if (!olderSibling) return this
    const newNode = olderSibling.appendLineAndChildren(this.getLine(), this.length ? this.childrenToString() : undefined)
    this.destroy()
    return newNode
  }
  shiftYoungerSibsRight() {
    const nodes = this.getYoungerSiblings()
    nodes.forEach(node => node.shiftRight())
    return this
  }
  sortBy(nameOrNames) {
    const names = nameOrNames instanceof Array ? nameOrNames : [nameOrNames]
    const length = names.length
    this.sort((nodeA, nodeB) => {
      if (!nodeB.length && !nodeA.length) return 0
      else if (!nodeA.length) return -1
      else if (!nodeB.length) return 1
      for (let index = 0; index < length; index++) {
        const firstWord = names[index]
        const av = nodeA.get(firstWord)
        const bv = nodeB.get(firstWord)
        if (av > bv) return 1
        else if (av < bv) return -1
      }
      return 0
    })
    return this
  }
  selectNode() {
    this._selected = true
  }
  unselectNode() {
    delete this._selected
  }
  isSelected() {
    return !!this._selected
  }
  async saveVersion() {
    const newVersion = this.toString()
    const topUndoVersion = this._getTopUndoVersion()
    if (newVersion === topUndoVersion) return undefined
    this._recordChange(newVersion)
    this._setSavedVersion(this.toString())
    return this
  }
  hasUnsavedChanges() {
    return this.toString() !== this._getSavedVersion()
  }
  async redo() {
    const undoStack = this._getUndoStack()
    const redoStack = this._getRedoStack()
    if (!redoStack.length) return undefined
    undoStack.push(redoStack.pop())
    return this._reloadFromUndoTop()
  }
  async undo() {
    const undoStack = this._getUndoStack()
    const redoStack = this._getRedoStack()
    if (undoStack.length === 1) return undefined
    redoStack.push(undoStack.pop())
    return this._reloadFromUndoTop()
  }
  _getSavedVersion() {
    return this._savedVersion
  }
  _setSavedVersion(str) {
    this._savedVersion = str
    return this
  }
  _clearRedoStack() {
    const redoStack = this._getRedoStack()
    redoStack.splice(0, redoStack.length)
  }
  getChangeHistory() {
    return this._getUndoStack().slice(0)
  }
  _getUndoStack() {
    if (!this._undoStack) this._undoStack = []
    return this._undoStack
  }
  _getRedoStack() {
    if (!this._redoStack) this._redoStack = []
    return this._redoStack
  }
  _getTopUndoVersion() {
    const undoStack = this._getUndoStack()
    return undoStack[undoStack.length - 1]
  }
  async _reloadFromUndoTop() {
    this.setChildren(this._getTopUndoVersion())
  }
  _recordChange(newVersion) {
    this._clearRedoStack()
    this._getUndoStack().push(newVersion) // todo: use diffs?
  }
  static fromCsv(str) {
    return this.fromDelimited(str, ",", '"')
  }
  static fromJsonSubset(str) {
    return new TreeNode(JSON.parse(str))
  }
  static fromSsv(str) {
    return this.fromDelimited(str, " ", '"')
  }
  static fromTsv(str) {
    return this.fromDelimited(str, "\t", '"')
  }
  static fromDelimited(str, delimiter, quoteChar = '"') {
    const rows = this._getEscapedRows(str, delimiter, quoteChar)
    return this._rowsToTreeNode(rows, delimiter, true)
  }
  static _getEscapedRows(str, delimiter, quoteChar) {
    return str.includes(quoteChar) ? this._strToRows(str, delimiter, quoteChar) : str.split("\n").map(line => line.split(delimiter))
  }
  static fromDelimitedNoHeaders(str, delimiter, quoteChar) {
    const rows = this._getEscapedRows(str, delimiter, quoteChar)
    return this._rowsToTreeNode(rows, delimiter, false)
  }
  static _strToRows(str, delimiter, quoteChar, newLineChar = "\n") {
    const rows = [[]]
    const newLine = "\n"
    const length = str.length
    let currentCell = ""
    let inQuote = str.substr(0, 1) === quoteChar
    let currentPosition = inQuote ? 1 : 0
    let nextChar
    let isLastChar
    let currentRow = 0
    let char
    let isNextCharAQuote
    while (currentPosition < length) {
      char = str[currentPosition]
      isLastChar = currentPosition + 1 === length
      nextChar = str[currentPosition + 1]
      isNextCharAQuote = nextChar === quoteChar
      if (inQuote) {
        if (char !== quoteChar) currentCell += char
        else if (isNextCharAQuote) {
          // Both the current and next char are ", so the " is escaped
          currentCell += nextChar
          currentPosition++ // Jump 2
        } else {
          // If the current char is a " and the next char is not, it's the end of the quotes
          inQuote = false
          if (isLastChar) rows[currentRow].push(currentCell)
        }
      } else {
        if (char === delimiter) {
          rows[currentRow].push(currentCell)
          currentCell = ""
          if (isNextCharAQuote) {
            inQuote = true
            currentPosition++ // Jump 2
          }
        } else if (char === newLine) {
          rows[currentRow].push(currentCell)
          currentCell = ""
          currentRow++
          if (nextChar) rows[currentRow] = []
          if (isNextCharAQuote) {
            inQuote = true
            currentPosition++ // Jump 2
          }
        } else if (isLastChar) rows[currentRow].push(currentCell + char)
        else currentCell += char
      }
      currentPosition++
    }
    return rows
  }
  static multiply(nodeA, nodeB) {
    const productNode = nodeA.clone()
    productNode.forEach((node, index) => {
      node.setChildren(node.length ? this.multiply(node, nodeB) : nodeB.clone())
    })
    return productNode
  }
  // Given an array return a tree
  static _rowsToTreeNode(rows, delimiter, hasHeaders) {
    const numberOfColumns = rows[0].length
    const treeNode = new TreeNode()
    const names = this._getHeader(rows, hasHeaders)
    const rowCount = rows.length
    for (let rowIndex = hasHeaders ? 1 : 0; rowIndex < rowCount; rowIndex++) {
      let row = rows[rowIndex]
      // If the row contains too many columns, shift the extra columns onto the last one.
      // This allows you to not have to escape delimiter characters in the final column.
      if (row.length > numberOfColumns) {
        row[numberOfColumns - 1] = row.slice(numberOfColumns - 1).join(delimiter)
        row = row.slice(0, numberOfColumns)
      } else if (row.length < numberOfColumns) {
        // If the row is missing columns add empty columns until it is full.
        // This allows you to make including delimiters for empty ending columns in each row optional.
        while (row.length < numberOfColumns) {
          row.push("")
        }
      }
      const obj = {}
      row.forEach((cellValue, index) => {
        obj[names[index]] = cellValue
      })
      treeNode.pushContentAndChildren(undefined, obj)
    }
    return treeNode
  }
  static _initializeXmlParser() {
    if (this._xmlParser) return
    const windowObj = window
    if (typeof windowObj.DOMParser !== "undefined") this._xmlParser = xmlStr => new windowObj.DOMParser().parseFromString(xmlStr, "text/xml")
    else if (typeof windowObj.ActiveXObject !== "undefined" && new windowObj.ActiveXObject("Microsoft.XMLDOM")) {
      this._xmlParser = xmlStr => {
        const xmlDoc = new windowObj.ActiveXObject("Microsoft.XMLDOM")
        xmlDoc.async = "false"
        xmlDoc.loadXML(xmlStr)
        return xmlDoc
      }
    } else throw new Error("No XML parser found")
  }
  static fromXml(str) {
    this._initializeXmlParser()
    const xml = this._xmlParser(str)
    try {
      return this._treeNodeFromXml(xml).getNode("children")
    } catch (err) {
      return this._treeNodeFromXml(this._parseXml2(str)).getNode("children")
    }
  }
  static _zipObject(keys, values) {
    const obj = {}
    keys.forEach((key, index) => (obj[key] = values[index]))
    return obj
  }
  static fromShape(shapeArr, rootNode = new TreeNode()) {
    const part = shapeArr.shift()
    if (part !== undefined) {
      for (let index = 0; index < part; index++) {
        rootNode.appendLine(index.toString())
      }
    }
    if (shapeArr.length) rootNode.forEach(node => TreeNode.fromShape(shapeArr.slice(0), node))
    return rootNode
  }
  static fromDataTable(table) {
    const header = table.shift()
    return new TreeNode(table.map(row => this._zipObject(header, row)))
  }
  static _parseXml2(str) {
    const el = document.createElement("div")
    el.innerHTML = str
    return el
  }
  // todo: cleanup typings
  static _treeNodeFromXml(xml) {
    const result = new TreeNode()
    const children = new TreeNode()
    // Set attributes
    if (xml.attributes) {
      for (let index = 0; index < xml.attributes.length; index++) {
        result.set(xml.attributes[index].name, xml.attributes[index].value)
      }
    }
    if (xml.data) children.pushContentAndChildren(xml.data)
    // Set content
    if (xml.childNodes && xml.childNodes.length > 0) {
      for (let index = 0; index < xml.childNodes.length; index++) {
        const child = xml.childNodes[index]
        if (child.tagName && child.tagName.match(/parsererror/i)) throw new Error("Parse Error")
        if (child.childNodes.length > 0 && child.tagName) children.appendLineAndChildren(child.tagName, this._treeNodeFromXml(child))
        else if (child.tagName) children.appendLine(child.tagName)
        else if (child.data) {
          const data = child.data.trim()
          if (data) children.pushContentAndChildren(data)
        }
      }
    }
    if (children.length > 0) result.touchNode("children").setChildren(children)
    return result
  }
  static _getHeader(rows, hasHeaders) {
    const numberOfColumns = rows[0].length
    const headerRow = hasHeaders ? rows[0] : []
    const WordBreakSymbol = " "
    const ziRegex = new RegExp(WordBreakSymbol, "g")
    if (hasHeaders) {
      // Strip any WordBreakSymbols from column names in the header row.
      // This makes the mapping not quite 1 to 1 if there are any WordBreakSymbols in names.
      for (let index = 0; index < numberOfColumns; index++) {
        headerRow[index] = headerRow[index].replace(ziRegex, "")
      }
    } else {
      // If str has no headers, create them as 0,1,2,3
      for (let index = 0; index < numberOfColumns; index++) {
        headerRow.push(index.toString())
      }
    }
    return headerRow
  }
  static nest(str, xValue) {
    const NodeBreakSymbol = "\n"
    const WordBreakSymbol = " "
    const indent = NodeBreakSymbol + WordBreakSymbol.repeat(xValue)
    return str ? indent + str.replace(/\n/g, indent) : ""
  }
  static fromDisk(path) {
    const format = this._getFileFormat(path)
    const content = require("fs").readFileSync(path, "utf8")
    const methods = {
      tree: content => new TreeNode(content),
      csv: content => this.fromCsv(content),
      tsv: content => this.fromTsv(content)
    }
    return methods[format](content)
  }
}
TreeNode._parsers = new Map()
TreeNode.Parser = Parser
TreeNode.iris = `sepal_length,sepal_width,petal_length,petal_width,species
6.1,3,4.9,1.8,virginica
5.6,2.7,4.2,1.3,versicolor
5.6,2.8,4.9,2,virginica
6.2,2.8,4.8,1.8,virginica
7.7,3.8,6.7,2.2,virginica
5.3,3.7,1.5,0.2,setosa
6.2,3.4,5.4,2.3,virginica
4.9,2.5,4.5,1.7,virginica
5.1,3.5,1.4,0.2,setosa
5,3.4,1.5,0.2,setosa`
TreeNode.getVersion = () => "48.0.0"
class AbstractExtendibleTreeNode extends TreeNode {
  _getFromExtended(firstWordPath) {
    const hit = this._getNodeFromExtended(firstWordPath)
    return hit ? hit.get(firstWordPath) : undefined
  }
  _getFamilyTree() {
    const tree = new TreeNode()
    this.forEach(node => {
      const path = node._getAncestorsArray().map(node => node._getId())
      path.reverse()
      tree.touchNode(path.join(" "))
    })
    return tree
  }
  // todo: be more specific with the param
  _getChildrenByNodeConstructorInExtended(constructor) {
    return TreeUtils.flatten(this._getAncestorsArray().map(node => node.getChildrenByNodeConstructor(constructor)))
  }
  _getExtendedParent() {
    return this._getAncestorsArray()[1]
  }
  _hasFromExtended(firstWordPath) {
    return !!this._getNodeFromExtended(firstWordPath)
  }
  _getNodeFromExtended(firstWordPath) {
    return this._getAncestorsArray().find(node => node.has(firstWordPath))
  }
  _getConcatBlockStringFromExtended(firstWordPath) {
    return this._getAncestorsArray()
      .filter(node => node.has(firstWordPath))
      .map(node => node.getNode(firstWordPath).childrenToString())
      .reverse()
      .join("\n")
  }
  _doesExtend(nodeTypeId) {
    return this._getAncestorSet().has(nodeTypeId)
  }
  _getAncestorSet() {
    if (!this._cache_ancestorSet) this._cache_ancestorSet = new Set(this._getAncestorsArray().map(def => def._getId()))
    return this._cache_ancestorSet
  }
  // Note: the order is: [this, parent, grandParent, ...]
  _getAncestorsArray(cannotContainNodes) {
    this._initAncestorsArrayCache(cannotContainNodes)
    return this._cache_ancestorsArray
  }
  _getIdThatThisExtends() {
    return this.get(TreeNotationConstants.extends)
  }
  _initAncestorsArrayCache(cannotContainNodes) {
    if (this._cache_ancestorsArray) return undefined
    if (cannotContainNodes && cannotContainNodes.includes(this)) throw new Error(`Loop detected: '${this.getLine()}' is the ancestor of one of its ancestors.`)
    cannotContainNodes = cannotContainNodes || [this]
    let ancestors = [this]
    const extendedId = this._getIdThatThisExtends()
    if (extendedId) {
      const parentNode = this._getIdToNodeMap()[extendedId]
      if (!parentNode) throw new Error(`${extendedId} not found`)
      ancestors = ancestors.concat(parentNode._getAncestorsArray(cannotContainNodes))
    }
    this._cache_ancestorsArray = ancestors
  }
}
class ExtendibleTreeNode extends AbstractExtendibleTreeNode {
  _getIdToNodeMap() {
    if (!this.isRoot()) return this.getRootNode()._getIdToNodeMap()
    if (!this._nodeMapCache) {
      this._nodeMapCache = {}
      this.forEach(child => {
        this._nodeMapCache[child._getId()] = child
      })
    }
    return this._nodeMapCache
  }
  _getId() {
    return this.getWord(0)
  }
}
window.TreeNode = TreeNode
window.ExtendibleTreeNode = ExtendibleTreeNode
window.AbstractExtendibleTreeNode = AbstractExtendibleTreeNode
window.TreeEvents = TreeEvents
window.TreeWord = TreeWord
var GrammarConstantsCompiler
;(function(GrammarConstantsCompiler) {
  GrammarConstantsCompiler["stringTemplate"] = "stringTemplate"
  GrammarConstantsCompiler["indentCharacter"] = "indentCharacter"
  GrammarConstantsCompiler["catchAllCellDelimiter"] = "catchAllCellDelimiter"
  GrammarConstantsCompiler["openChildren"] = "openChildren"
  GrammarConstantsCompiler["joinChildrenWith"] = "joinChildrenWith"
  GrammarConstantsCompiler["closeChildren"] = "closeChildren"
})(GrammarConstantsCompiler || (GrammarConstantsCompiler = {}))
var PreludeCellTypeIds
;(function(PreludeCellTypeIds) {
  PreludeCellTypeIds["anyCell"] = "anyCell"
  PreludeCellTypeIds["keywordCell"] = "keywordCell"
  PreludeCellTypeIds["extraWordCell"] = "extraWordCell"
  PreludeCellTypeIds["floatCell"] = "floatCell"
  PreludeCellTypeIds["numberCell"] = "numberCell"
  PreludeCellTypeIds["bitCell"] = "bitCell"
  PreludeCellTypeIds["boolCell"] = "boolCell"
  PreludeCellTypeIds["intCell"] = "intCell"
})(PreludeCellTypeIds || (PreludeCellTypeIds = {}))
var GrammarConstantsConstantTypes
;(function(GrammarConstantsConstantTypes) {
  GrammarConstantsConstantTypes["boolean"] = "boolean"
  GrammarConstantsConstantTypes["string"] = "string"
  GrammarConstantsConstantTypes["int"] = "int"
  GrammarConstantsConstantTypes["float"] = "float"
})(GrammarConstantsConstantTypes || (GrammarConstantsConstantTypes = {}))
var GrammarBundleFiles
;(function(GrammarBundleFiles) {
  GrammarBundleFiles["package"] = "package.json"
  GrammarBundleFiles["readme"] = "readme.md"
  GrammarBundleFiles["indexHtml"] = "index.html"
  GrammarBundleFiles["indexJs"] = "index.js"
  GrammarBundleFiles["testJs"] = "test.js"
})(GrammarBundleFiles || (GrammarBundleFiles = {}))
var GrammarCellParser
;(function(GrammarCellParser) {
  GrammarCellParser["prefix"] = "prefix"
  GrammarCellParser["postfix"] = "postfix"
  GrammarCellParser["omnifix"] = "omnifix"
})(GrammarCellParser || (GrammarCellParser = {}))
var GrammarConstants
;(function(GrammarConstants) {
  // node types
  GrammarConstants["extensions"] = "extensions"
  GrammarConstants["toolingDirective"] = "tooling"
  GrammarConstants["todoComment"] = "todo"
  GrammarConstants["version"] = "version"
  GrammarConstants["nodeType"] = "nodeType"
  GrammarConstants["cellType"] = "cellType"
  GrammarConstants["grammarFileExtension"] = "grammar"
  GrammarConstants["nodeTypeSuffix"] = "Node"
  GrammarConstants["cellTypeSuffix"] = "Cell"
  // error check time
  GrammarConstants["regex"] = "regex"
  GrammarConstants["reservedWords"] = "reservedWords"
  GrammarConstants["enumFromCellTypes"] = "enumFromCellTypes"
  GrammarConstants["enum"] = "enum"
  GrammarConstants["examples"] = "examples"
  GrammarConstants["min"] = "min"
  GrammarConstants["max"] = "max"
  // baseNodeTypes
  GrammarConstants["baseNodeType"] = "baseNodeType"
  GrammarConstants["blobNode"] = "blobNode"
  GrammarConstants["errorNode"] = "errorNode"
  // parse time
  GrammarConstants["extends"] = "extends"
  GrammarConstants["abstract"] = "abstract"
  GrammarConstants["root"] = "root"
  GrammarConstants["crux"] = "crux"
  GrammarConstants["pattern"] = "pattern"
  GrammarConstants["inScope"] = "inScope"
  GrammarConstants["cells"] = "cells"
  GrammarConstants["catchAllCellType"] = "catchAllCellType"
  GrammarConstants["cellParser"] = "cellParser"
  GrammarConstants["catchAllNodeType"] = "catchAllNodeType"
  GrammarConstants["constants"] = "constants"
  GrammarConstants["required"] = "required"
  GrammarConstants["single"] = "single"
  GrammarConstants["tags"] = "tags"
  GrammarConstants["_extendsJsClass"] = "_extendsJsClass"
  GrammarConstants["_rootNodeJsHeader"] = "_rootNodeJsHeader"
  // default catchAll nodeType
  GrammarConstants["BlobNode"] = "BlobNode"
  GrammarConstants["defaultRootNode"] = "defaultRootNode"
  // code
  GrammarConstants["javascript"] = "javascript"
  // compile time
  GrammarConstants["compilerNodeType"] = "compiler"
  GrammarConstants["compilesTo"] = "compilesTo"
  // develop time
  GrammarConstants["description"] = "description"
  GrammarConstants["example"] = "example"
  GrammarConstants["frequency"] = "frequency"
  GrammarConstants["highlightScope"] = "highlightScope"
})(GrammarConstants || (GrammarConstants = {}))
class TypedWord extends TreeWord {
  constructor(node, cellIndex, type) {
    super(node, cellIndex)
    this._type = type
  }
  get type() {
    return this._type
  }
  toString() {
    return this.word + ":" + this.type
  }
}
// todo: can we merge these methods into base TreeNode and ditch this class?
class GrammarBackedNode extends TreeNode {
  getDefinition() {
    const grammarProgram = this.getGrammarProgram()
    return this.isRoot() ? grammarProgram : grammarProgram.getNodeTypeDefinitionByNodeTypeId(this.constructor.name)
  }
  getAutocompleteResults(partialWord, cellIndex) {
    return cellIndex === 0 ? this._getAutocompleteResultsForFirstWord(partialWord) : this._getAutocompleteResultsForCell(partialWord, cellIndex)
  }
  getChildInstancesOfNodeTypeId(nodeTypeId) {
    return this.filter(node => node.doesExtend(nodeTypeId))
  }
  doesExtend(nodeTypeId) {
    return this.getDefinition()._doesExtend(nodeTypeId)
  }
  _getErrorNodeErrors() {
    return [this.getFirstWord() ? new UnknownNodeTypeError(this) : new BlankLineError(this)]
  }
  _getBlobNodeCatchAllNodeType() {
    return BlobNode
  }
  _getAutocompleteResultsForFirstWord(partialWord) {
    const keywordMap = this.getDefinition().getFirstWordMapWithDefinitions()
    let keywords = Object.keys(keywordMap)
    if (partialWord) keywords = keywords.filter(keyword => keyword.includes(partialWord))
    return keywords.map(keyword => {
      const def = keywordMap[keyword]
      const description = def.getDescription()
      return {
        text: keyword,
        displayText: keyword + (description ? " " + description : "")
      }
    })
  }
  _getAutocompleteResultsForCell(partialWord, cellIndex) {
    // todo: root should be [] correct?
    const cell = this._getParsedCells()[cellIndex]
    return cell ? cell.getAutoCompleteWords(partialWord) : []
  }
  // note: this is overwritten by the root node of a runtime grammar program.
  // some of the magic that makes this all work. but maybe there's a better way.
  getGrammarProgram() {
    if (this.isRoot()) throw new Error(`Root node without getGrammarProgram defined.`)
    return this.getRootNode().getGrammarProgram()
  }
  getRunTimeEnumOptions(cell) {
    return undefined
  }
  _sortNodesByInScopeOrder() {
    const nodeTypeOrder = this.getDefinition()._getMyInScopeNodeTypeIds()
    if (!nodeTypeOrder.length) return this
    const orderMap = {}
    nodeTypeOrder.forEach((word, index) => {
      orderMap[word] = index
    })
    this.sort(
      TreeUtils.makeSortByFn(runtimeNode => {
        return orderMap[runtimeNode.getDefinition().getNodeTypeIdFromDefinition()]
      })
    )
    return this
  }
  _getRequiredNodeErrors(errors = []) {
    Object.values(this.getDefinition().getFirstWordMapWithDefinitions()).forEach(def => {
      if (def.isRequired()) {
        if (!this.getChildren().some(node => node.getDefinition() === def)) errors.push(new MissingRequiredNodeTypeError(this, def.getNodeTypeIdFromDefinition()))
      }
    })
    return errors
  }
  getProgramAsCells() {
    // todo: what is this?
    return this.getTopDownArray().map(node => {
      const cells = node._getParsedCells()
      let indents = node.getIndentLevel() - 1
      while (indents) {
        cells.unshift(undefined)
        indents--
      }
      return cells
    })
  }
  getProgramWidth() {
    return Math.max(...this.getProgramAsCells().map(line => line.length))
  }
  getAllTypedWords() {
    const words = []
    this.getTopDownArray().forEach(node => {
      node.getWordTypes().forEach((cell, index) => {
        words.push(new TypedWord(node, index, cell.getCellTypeId()))
      })
    })
    return words
  }
  findAllWordsWithCellType(cellTypeId) {
    return this.getAllTypedWords().filter(typedWord => typedWord.type === cellTypeId)
  }
  findAllNodesWithNodeType(nodeTypeId) {
    return this.getTopDownArray().filter(node => node.getDefinition().getNodeTypeIdFromDefinition() === nodeTypeId)
  }
  toCellTypeTree() {
    return this.getTopDownArray()
      .map(child => child.getIndentation() + child.getLineCellTypes())
      .join("\n")
  }
  getParseTable(maxColumnWidth = 40) {
    const tree = new TreeNode(this.toCellTypeTree())
    return new TreeNode(
      tree.getTopDownArray().map((node, lineNumber) => {
        const sourceNode = this.nodeAtLine(lineNumber)
        const errs = sourceNode.getErrors()
        const errorCount = errs.length
        const obj = {
          lineNumber: lineNumber,
          source: sourceNode.getIndentation() + sourceNode.getLine(),
          nodeType: sourceNode.constructor.name,
          cellTypes: node.getContent(),
          errorCount: errorCount
        }
        if (errorCount) obj.errorMessages = errs.map(err => err.getMessage()).join(";")
        return obj
      })
    ).toFormattedTable(maxColumnWidth)
  }
  // Helper method for selecting potential nodeTypes needed to update grammar file.
  getInvalidNodeTypes() {
    return Array.from(
      new Set(
        this.getAllErrors()
          .filter(err => err instanceof UnknownNodeTypeError)
          .map(err => err.getNode().getFirstWord())
      )
    )
  }
  _getAllAutoCompleteWords() {
    return this.getAllWordBoundaryCoordinates().map(coordinate => {
      const results = this.getAutocompleteResultsAt(coordinate.lineIndex, coordinate.charIndex)
      return {
        lineIndex: coordinate.lineIndex,
        charIndex: coordinate.charIndex,
        wordIndex: coordinate.wordIndex,
        word: results.word,
        suggestions: results.matches
      }
    })
  }
  toAutoCompleteCube(fillChar = "") {
    const trees = [this.clone()]
    const filled = this.clone().fill(fillChar)
    this._getAllAutoCompleteWords().forEach(hole => {
      hole.suggestions.forEach((suggestion, index) => {
        if (!trees[index + 1]) trees[index + 1] = filled.clone()
        trees[index + 1].nodeAtLine(hole.lineIndex).setWord(hole.wordIndex, suggestion.text)
      })
    })
    return new TreeNode(trees)
  }
  toAutoCompleteTable() {
    return new TreeNode(
      this._getAllAutoCompleteWords().map(result => {
        result.suggestions = result.suggestions.map(node => node.text).join(" ")
        return result
      })
    ).toTable()
  }
  getAutocompleteResultsAt(lineIndex, charIndex) {
    const lineNode = this.nodeAtLine(lineIndex) || this
    const nodeInScope = lineNode.getNodeInScopeAtCharIndex(charIndex)
    // todo: add more tests
    // todo: second param this.childrenToString()
    // todo: change to getAutocomplete definitions
    const wordIndex = lineNode.getWordIndexAtCharacterIndex(charIndex)
    const wordProperties = lineNode.getWordProperties(wordIndex)
    return {
      startCharIndex: wordProperties.startCharIndex,
      endCharIndex: wordProperties.endCharIndex,
      word: wordProperties.word,
      matches: nodeInScope.getAutocompleteResults(wordProperties.word, wordIndex)
    }
  }
  _sortWithParentNodeTypesUpTop() {
    const familyTree = new GrammarProgram(this.toString()).getNodeTypeFamilyTree()
    const rank = {}
    familyTree.getTopDownArray().forEach((node, index) => {
      rank[node.getWord(0)] = index
    })
    const nodeAFirst = -1
    const nodeBFirst = 1
    this.sort((nodeA, nodeB) => {
      const nodeARank = rank[nodeA.getWord(0)]
      const nodeBRank = rank[nodeB.getWord(0)]
      return nodeARank < nodeBRank ? nodeAFirst : nodeBFirst
    })
    return this
  }
  format() {
    if (this.isRoot()) {
      this._sortNodesByInScopeOrder()
      try {
        this._sortWithParentNodeTypesUpTop()
      } catch (err) {
        console.log(`Warning: ${err}`)
      }
    }
    this.getTopDownArray().forEach(child => {
      child.format()
    })
    return this
  }
  getNodeTypeUsage(filepath = "") {
    // returns a report on what nodeTypes from its language the program uses
    const usage = new TreeNode()
    const grammarProgram = this.getGrammarProgram()
    grammarProgram.getValidConcreteAndAbstractNodeTypeDefinitions().forEach(def => {
      const requiredCellTypeIds = def.getCellParser().getRequiredCellTypeIds()
      usage.appendLine([def.getNodeTypeIdFromDefinition(), "line-id", "nodeType", requiredCellTypeIds.join(" ")].join(" "))
    })
    this.getTopDownArray().forEach((node, lineNumber) => {
      const stats = usage.getNode(node.getNodeTypeId())
      stats.appendLine([filepath + "-" + lineNumber, node.getWords().join(" ")].join(" "))
    })
    return usage
  }
  toHighlightScopeTree() {
    return this.getTopDownArray()
      .map(child => child.getIndentation() + child.getLineHighlightScopes())
      .join("\n")
  }
  toDefinitionLineNumberTree() {
    return this.getTopDownArray()
      .map(child => child.getDefinition().getLineNumber() + " " + child.getIndentation() + child.getCellDefinitionLineNumbers().join(" "))
      .join("\n")
  }
  toCellTypeTreeWithNodeConstructorNames() {
    return this.getTopDownArray()
      .map(child => child.constructor.name + this.getWordBreakSymbol() + child.getIndentation() + child.getLineCellTypes())
      .join("\n")
  }
  toPreludeCellTypeTreeWithNodeConstructorNames() {
    return this.getTopDownArray()
      .map(child => child.constructor.name + this.getWordBreakSymbol() + child.getIndentation() + child.getLineCellPreludeTypes())
      .join("\n")
  }
  getTreeWithNodeTypes() {
    return this.getTopDownArray()
      .map(child => child.constructor.name + this.getWordBreakSymbol() + child.getIndentation() + child.getLine())
      .join("\n")
  }
  getCellHighlightScopeAtPosition(lineIndex, wordIndex) {
    this._initCellTypeCache()
    const typeNode = this._cache_highlightScopeTree.getTopDownArray()[lineIndex - 1]
    return typeNode ? typeNode.getWord(wordIndex - 1) : undefined
  }
  _initCellTypeCache() {
    const treeMTime = this.getLineOrChildrenModifiedTime()
    if (this._cache_programCellTypeStringMTime === treeMTime) return undefined
    this._cache_typeTree = new TreeNode(this.toCellTypeTree())
    this._cache_highlightScopeTree = new TreeNode(this.toHighlightScopeTree())
    this._cache_programCellTypeStringMTime = treeMTime
  }
  createParser() {
    return this.isRoot()
      ? new TreeNode.Parser(BlobNode)
      : new TreeNode.Parser(
          this.getParent()
            ._getParser()
            ._getCatchAllNodeConstructor(this.getParent()),
          {}
        )
  }
  getNodeTypeId() {
    return this.getDefinition().getNodeTypeIdFromDefinition()
  }
  getWordTypes() {
    return this._getParsedCells().filter(cell => cell.getWord() !== undefined)
  }
  getErrors() {
    const errors = this._getParsedCells()
      .map(check => check.getErrorIfAny())
      .filter(identity => identity)
    const firstWord = this.getFirstWord()
    if (this.getDefinition().has(GrammarConstants.single))
      this.getParent()
        .findNodes(firstWord)
        .forEach((node, index) => {
          if (index) errors.push(new NodeTypeUsedMultipleTimesError(node))
        })
    return this._getRequiredNodeErrors(errors)
  }
  _getParsedCells() {
    return this.getDefinition()
      .getCellParser()
      .getCellArray(this)
  }
  // todo: just make a fn that computes proper spacing and then is given a node to print
  getLineCellTypes() {
    return this._getParsedCells()
      .map(slot => slot.getCellTypeId())
      .join(" ")
  }
  getLineCellPreludeTypes() {
    return this._getParsedCells()
      .map(slot => {
        const def = slot._getCellTypeDefinition()
        //todo: cleanup
        return def ? def._getPreludeKindId() : PreludeCellTypeIds.anyCell
      })
      .join(" ")
  }
  getLineHighlightScopes(defaultScope = "source") {
    return this._getParsedCells()
      .map(slot => slot.getHighlightScope() || defaultScope)
      .join(" ")
  }
  getCellDefinitionLineNumbers() {
    return this._getParsedCells().map(cell => cell.getDefinitionLineNumber())
  }
  _getCompiledIndentation() {
    const indentCharacter = this.getDefinition()._getCompilerObject()[GrammarConstantsCompiler.indentCharacter]
    const indent = this.getIndentation()
    return indentCharacter !== undefined ? indentCharacter.repeat(indent.length) : indent
  }
  _getFields() {
    // fields are like cells
    const fields = {}
    this.forEach(node => {
      const def = node.getDefinition()
      if (def.isRequired() || def.has(GrammarConstants.single)) fields[node.getWord(0)] = node.getContent()
    })
    return fields
  }
  _getCompiledLine() {
    const compiler = this.getDefinition()._getCompilerObject()
    const catchAllCellDelimiter = compiler[GrammarConstantsCompiler.catchAllCellDelimiter]
    const str = compiler[GrammarConstantsCompiler.stringTemplate]
    return str !== undefined ? TreeUtils.formatStr(str, catchAllCellDelimiter, Object.assign(this._getFields(), this.cells)) : this.getLine()
  }
  compile() {
    if (this.isRoot()) return super.compile()
    const def = this.getDefinition()
    if (def.isTerminalNodeType()) return this._getCompiledIndentation() + this._getCompiledLine()
    const compiler = def._getCompilerObject()
    const openChildrenString = compiler[GrammarConstantsCompiler.openChildren] || ""
    const closeChildrenString = compiler[GrammarConstantsCompiler.closeChildren] || ""
    const childJoinCharacter = compiler[GrammarConstantsCompiler.joinChildrenWith] || "\n"
    const compiledLine = this._getCompiledLine()
    const indent = this._getCompiledIndentation()
    const compiledChildren = this.map(child => child.compile()).join(childJoinCharacter)
    return `${indent}${compiledLine}${openChildrenString}
${compiledChildren}
${indent}${closeChildrenString}`
  }
  // todo: remove
  get cells() {
    const cells = {}
    this._getParsedCells().forEach(cell => {
      const cellTypeId = cell.getCellTypeId()
      if (!cell.isCatchAll()) cells[cellTypeId] = cell.getParsed()
      else {
        if (!cells[cellTypeId]) cells[cellTypeId] = []
        cells[cellTypeId].push(cell.getParsed())
      }
    })
    return cells
  }
}
class BlobNode extends GrammarBackedNode {
  createParser() {
    return new TreeNode.Parser(BlobNode, {})
  }
  getErrors() {
    return []
  }
}
// todo: can we remove this? hard to extend.
class UnknownNodeTypeNode extends GrammarBackedNode {
  createParser() {
    return new TreeNode.Parser(UnknownNodeTypeNode, {})
  }
  getErrors() {
    return [new UnknownNodeTypeError(this)]
  }
}
/*
A cell contains a word but also the type information for that word.
*/
class AbstractGrammarBackedCell {
  constructor(node, index, typeDef, cellTypeId, isCatchAll, nodeTypeDef) {
    this._typeDef = typeDef
    this._node = node
    this._isCatchAll = isCatchAll
    this._index = index
    this._cellTypeId = cellTypeId
    this._nodeTypeDefinition = nodeTypeDef
  }
  getWord() {
    return this._node.getWord(this._index)
  }
  getDefinitionLineNumber() {
    return this._typeDef.getLineNumber()
  }
  getCellTypeId() {
    return this._cellTypeId
  }
  getNode() {
    return this._node
  }
  getCellIndex() {
    return this._index
  }
  isCatchAll() {
    return this._isCatchAll
  }
  get min() {
    return this._getCellTypeDefinition().get(GrammarConstants.min) || "0"
  }
  get max() {
    return this._getCellTypeDefinition().get(GrammarConstants.max) || "100"
  }
  get placeholder() {
    return this._getCellTypeDefinition().get(GrammarConstants.examples) || ""
  }
  getHighlightScope() {
    const definition = this._getCellTypeDefinition()
    if (definition) return definition.getHighlightScope() // todo: why the undefined?
  }
  getAutoCompleteWords(partialWord = "") {
    const cellDef = this._getCellTypeDefinition()
    let words = cellDef ? cellDef._getAutocompleteWordOptions(this.getNode().getRootNode()) : []
    const runTimeOptions = this.getNode().getRunTimeEnumOptions(this)
    if (runTimeOptions) words = runTimeOptions.concat(words)
    if (partialWord) words = words.filter(word => word.includes(partialWord))
    return words.map(word => {
      return {
        text: word,
        displayText: word
      }
    })
  }
  synthesizeCell(seed = Date.now()) {
    // todo: cleanup
    const cellDef = this._getCellTypeDefinition()
    const enumOptions = cellDef._getFromExtended(GrammarConstants.enum)
    if (enumOptions) return TreeUtils.getRandomString(1, enumOptions.split(" "))
    return this._synthesizeCell(seed)
  }
  _getStumpEnumInput(crux) {
    const cellDef = this._getCellTypeDefinition()
    const enumOptions = cellDef._getFromExtended(GrammarConstants.enum)
    if (!enumOptions) return undefined
    const options = new TreeNode(
      enumOptions
        .split(" ")
        .map(option => `option ${option}`)
        .join("\n")
    )
    return `select
 name ${crux}
${options.toString(1)}`
  }
  _toStumpInput(crux) {
    // todo: remove
    const enumInput = this._getStumpEnumInput(crux)
    if (enumInput) return enumInput
    // todo: cleanup. We shouldn't have these dual cellType classes.
    return `input
 name ${crux}
 placeholder ${this.placeholder}`
  }
  _getCellTypeDefinition() {
    return this._typeDef
  }
  _getFullLine() {
    return this.getNode().getLine()
  }
  _getErrorContext() {
    return this._getFullLine().split(" ")[0] // todo: WordBreakSymbol
  }
  isValid() {
    const runTimeOptions = this.getNode().getRunTimeEnumOptions(this)
    const word = this.getWord()
    if (runTimeOptions) return runTimeOptions.includes(word)
    return this._getCellTypeDefinition().isValid(word, this.getNode().getRootNode()) && this._isValid()
  }
  getErrorIfAny() {
    const word = this.getWord()
    if (word !== undefined && this.isValid()) return undefined
    // todo: refactor invalidwordError. We want better error messages.
    return word === undefined || word === "" ? new MissingWordError(this) : new InvalidWordError(this)
  }
}
AbstractGrammarBackedCell.parserFunctionName = ""
class GrammarBitCell extends AbstractGrammarBackedCell {
  _isValid() {
    const word = this.getWord()
    return word === "0" || word === "1"
  }
  _synthesizeCell() {
    return TreeUtils.getRandomString(1, "01".split(""))
  }
  getRegexString() {
    return "[01]"
  }
  getParsed() {
    const word = this.getWord()
    return !!parseInt(word)
  }
}
GrammarBitCell.defaultHighlightScope = "constant.numeric"
class GrammarNumericCell extends AbstractGrammarBackedCell {
  _toStumpInput(crux) {
    return `input
 name ${crux}
 type number
 placeholder ${this.placeholder}
 min ${this.min}
 max ${this.max}`
  }
}
class GrammarIntCell extends GrammarNumericCell {
  _isValid() {
    const word = this.getWord()
    const num = parseInt(word)
    if (isNaN(num)) return false
    return num.toString() === word
  }
  _synthesizeCell(seed) {
    return TreeUtils.randomUniformInt(parseInt(this.min), parseInt(this.max), seed).toString()
  }
  getRegexString() {
    return "-?[0-9]+"
  }
  getParsed() {
    const word = this.getWord()
    return parseInt(word)
  }
}
GrammarIntCell.defaultHighlightScope = "constant.numeric.integer"
GrammarIntCell.parserFunctionName = "parseInt"
class GrammarFloatCell extends GrammarNumericCell {
  _isValid() {
    const word = this.getWord()
    const num = parseFloat(word)
    return !isNaN(num) && /^-?\d*(\.\d+)?$/.test(word)
  }
  _synthesizeCell(seed) {
    return TreeUtils.randomUniformFloat(parseFloat(this.min), parseFloat(this.max), seed).toString()
  }
  getRegexString() {
    return "-?d*(.d+)?"
  }
  getParsed() {
    const word = this.getWord()
    return parseFloat(word)
  }
}
GrammarFloatCell.defaultHighlightScope = "constant.numeric.float"
GrammarFloatCell.parserFunctionName = "parseFloat"
// ErrorCellType => grammar asks for a '' cell type here but the grammar does not specify a '' cell type. (todo: bring in didyoumean?)
class GrammarBoolCell extends AbstractGrammarBackedCell {
  constructor() {
    super(...arguments)
    this._trues = new Set(["1", "true", "t", "yes"])
    this._falses = new Set(["0", "false", "f", "no"])
  }
  _isValid() {
    const word = this.getWord()
    const str = word.toLowerCase()
    return this._trues.has(str) || this._falses.has(str)
  }
  _synthesizeCell() {
    return TreeUtils.getRandomString(1, ["1", "true", "t", "yes", "0", "false", "f", "no"])
  }
  _getOptions() {
    return Array.from(this._trues).concat(Array.from(this._falses))
  }
  getRegexString() {
    return "(?:" + this._getOptions().join("|") + ")"
  }
  getParsed() {
    const word = this.getWord()
    return this._trues.has(word.toLowerCase())
  }
}
GrammarBoolCell.defaultHighlightScope = "constant.numeric"
class GrammarAnyCell extends AbstractGrammarBackedCell {
  _isValid() {
    return true
  }
  _synthesizeCell() {
    const examples = this._getCellTypeDefinition()._getFromExtended(GrammarConstants.examples)
    if (examples) return TreeUtils.getRandomString(1, examples.split(" "))
    return this._nodeTypeDefinition.getNodeTypeIdFromDefinition() + "-" + this.constructor.name
  }
  getRegexString() {
    return "[^ ]+"
  }
  getParsed() {
    return this.getWord()
  }
}
class GrammarKeywordCell extends GrammarAnyCell {
  _synthesizeCell() {
    return this._nodeTypeDefinition._getCruxIfAny()
  }
}
GrammarKeywordCell.defaultHighlightScope = "keyword"
class GrammarExtraWordCellTypeCell extends AbstractGrammarBackedCell {
  _isValid() {
    return false
  }
  synthesizeCell() {
    throw new Error(`Trying to synthesize a GrammarExtraWordCellTypeCell`)
    return this._synthesizeCell()
  }
  _synthesizeCell() {
    return "extraWord" // should never occur?
  }
  getParsed() {
    return this.getWord()
  }
  getErrorIfAny() {
    return new ExtraWordError(this)
  }
}
class GrammarUnknownCellTypeCell extends AbstractGrammarBackedCell {
  _isValid() {
    return false
  }
  synthesizeCell() {
    throw new Error(`Trying to synthesize an GrammarUnknownCellTypeCell`)
    return this._synthesizeCell()
  }
  _synthesizeCell() {
    return "extraWord" // should never occur?
  }
  getParsed() {
    return this.getWord()
  }
  getErrorIfAny() {
    return new UnknownCellTypeError(this)
  }
}
class AbstractTreeError {
  constructor(node) {
    this._node = node
  }
  getLineIndex() {
    return this.getLineNumber() - 1
  }
  getLineNumber() {
    return this.getNode()._getLineNumber() // todo: handle sourcemaps
  }
  isCursorOnWord(lineIndex, characterIndex) {
    return lineIndex === this.getLineIndex() && this._doesCharacterIndexFallOnWord(characterIndex)
  }
  _doesCharacterIndexFallOnWord(characterIndex) {
    return this.getCellIndex() === this.getNode().getWordIndexAtCharacterIndex(characterIndex)
  }
  // convenience method. may be removed.
  isBlankLineError() {
    return false
  }
  // convenience method. may be removed.
  isMissingWordError() {
    return false
  }
  getIndent() {
    return this.getNode().getIndentation()
  }
  getCodeMirrorLineWidgetElement(onApplySuggestionCallBack = () => {}) {
    const suggestion = this.getSuggestionMessage()
    if (this.isMissingWordError()) return this._getCodeMirrorLineWidgetElementCellTypeHints()
    if (suggestion) return this._getCodeMirrorLineWidgetElementWithSuggestion(onApplySuggestionCallBack, suggestion)
    return this._getCodeMirrorLineWidgetElementWithoutSuggestion()
  }
  getNodeTypeId() {
    return this.getNode()
      .getDefinition()
      .getNodeTypeIdFromDefinition()
  }
  _getCodeMirrorLineWidgetElementCellTypeHints() {
    const el = document.createElement("div")
    el.appendChild(
      document.createTextNode(
        this.getIndent() +
          this.getNode()
            .getDefinition()
            .getLineHints()
      )
    )
    el.className = "LintCellTypeHints"
    return el
  }
  _getCodeMirrorLineWidgetElementWithoutSuggestion() {
    const el = document.createElement("div")
    el.appendChild(document.createTextNode(this.getIndent() + this.getMessage()))
    el.className = "LintError"
    return el
  }
  _getCodeMirrorLineWidgetElementWithSuggestion(onApplySuggestionCallBack, suggestion) {
    const el = document.createElement("div")
    el.appendChild(document.createTextNode(this.getIndent() + `${this.getErrorTypeName()}. Suggestion: ${suggestion}`))
    el.className = "LintErrorWithSuggestion"
    el.onclick = () => {
      this.applySuggestion()
      onApplySuggestionCallBack()
    }
    return el
  }
  getLine() {
    return this.getNode().getLine()
  }
  getExtension() {
    return this.getNode()
      .getGrammarProgram()
      .getExtensionName()
  }
  getNode() {
    return this._node
  }
  getErrorTypeName() {
    return this.constructor.name.replace("Error", "")
  }
  getCellIndex() {
    return 0
  }
  toObject() {
    return {
      type: this.getErrorTypeName(),
      line: this.getLineNumber(),
      cell: this.getCellIndex(),
      suggestion: this.getSuggestionMessage(),
      path: this.getNode().getFirstWordPath(),
      message: this.getMessage()
    }
  }
  hasSuggestion() {
    return this.getSuggestionMessage() !== ""
  }
  getSuggestionMessage() {
    return ""
  }
  toString() {
    return this.getMessage()
  }
  applySuggestion() {}
  getMessage() {
    return `${this.getErrorTypeName()} at line ${this.getLineNumber()} cell ${this.getCellIndex()}.`
  }
}
class AbstractCellError extends AbstractTreeError {
  constructor(cell) {
    super(cell.getNode())
    this._cell = cell
  }
  getCell() {
    return this._cell
  }
  getCellIndex() {
    return this._cell.getCellIndex()
  }
  _getWordSuggestion() {
    return TreeUtils.didYouMean(
      this.getCell().getWord(),
      this.getCell()
        .getAutoCompleteWords()
        .map(option => option.text)
    )
  }
}
class UnknownNodeTypeError extends AbstractTreeError {
  getMessage() {
    const node = this.getNode()
    const parentNode = node.getParent()
    const options = parentNode._getParser().getFirstWordOptions()
    return super.getMessage() + ` Invalid nodeType "${node.getFirstWord()}". Valid nodeTypes are: ${TreeUtils._listToEnglishText(options, 7)}.`
  }
  _getWordSuggestion() {
    const node = this.getNode()
    const parentNode = node.getParent()
    return TreeUtils.didYouMean(node.getFirstWord(), parentNode.getAutocompleteResults("", 0).map(option => option.text))
  }
  getSuggestionMessage() {
    const suggestion = this._getWordSuggestion()
    const node = this.getNode()
    if (suggestion) return `Change "${node.getFirstWord()}" to "${suggestion}"`
    return ""
  }
  applySuggestion() {
    const suggestion = this._getWordSuggestion()
    if (suggestion) this.getNode().setWord(this.getCellIndex(), suggestion)
    return this
  }
}
class BlankLineError extends UnknownNodeTypeError {
  getMessage() {
    return super.getMessage() + ` Line: "${this.getNode().getLine()}". Blank lines are errors.`
  }
  // convenience method
  isBlankLineError() {
    return true
  }
  getSuggestionMessage() {
    return `Delete line ${this.getLineNumber()}`
  }
  applySuggestion() {
    this.getNode().destroy()
    return this
  }
}
class MissingRequiredNodeTypeError extends AbstractTreeError {
  constructor(node, missingNodeTypeId) {
    super(node)
    this._missingNodeTypeId = missingNodeTypeId
  }
  getMessage() {
    return super.getMessage() + ` A "${this._missingNodeTypeId}" is required.`
  }
}
class NodeTypeUsedMultipleTimesError extends AbstractTreeError {
  getMessage() {
    return super.getMessage() + ` Multiple "${this.getNode().getFirstWord()}" found.`
  }
  getSuggestionMessage() {
    return `Delete line ${this.getLineNumber()}`
  }
  applySuggestion() {
    return this.getNode().destroy()
  }
}
class UnknownCellTypeError extends AbstractCellError {
  getMessage() {
    return super.getMessage() + ` No cellType "${this.getCell().getCellTypeId()}" found. Language grammar for "${this.getExtension()}" may need to be fixed.`
  }
}
class InvalidWordError extends AbstractCellError {
  getMessage() {
    return super.getMessage() + ` "${this.getCell().getWord()}" does not fit in cellType "${this.getCell().getCellTypeId()}".`
  }
  getSuggestionMessage() {
    const suggestion = this._getWordSuggestion()
    if (suggestion) return `Change "${this.getCell().getWord()}" to "${suggestion}"`
    return ""
  }
  applySuggestion() {
    const suggestion = this._getWordSuggestion()
    if (suggestion) this.getNode().setWord(this.getCellIndex(), suggestion)
    return this
  }
}
class ExtraWordError extends AbstractCellError {
  getMessage() {
    return super.getMessage() + ` Extra word "${this.getCell().getWord()}" in ${this.getNodeTypeId()}.`
  }
  getSuggestionMessage() {
    return `Delete word "${this.getCell().getWord()}" at cell ${this.getCellIndex()}`
  }
  applySuggestion() {
    return this.getNode().deleteWordAt(this.getCellIndex())
  }
}
class MissingWordError extends AbstractCellError {
  // todo: autocomplete suggestion
  getMessage() {
    return super.getMessage() + ` Missing word for cell "${this.getCell().getCellTypeId()}".`
  }
  isMissingWordError() {
    return true
  }
}
// todo: add standard types, enum types, from disk types
class AbstractGrammarWordTestNode extends TreeNode {}
class GrammarRegexTestNode extends AbstractGrammarWordTestNode {
  isValid(str) {
    if (!this._regex) this._regex = new RegExp("^" + this.getContent() + "$")
    return !!str.match(this._regex)
  }
}
class GrammarReservedWordsTestNode extends AbstractGrammarWordTestNode {
  isValid(str) {
    if (!this._set) this._set = new Set(this.getContent().split(" "))
    return !this._set.has(str)
  }
}
// todo: remove in favor of custom word type constructors
class EnumFromCellTypesTestNode extends AbstractGrammarWordTestNode {
  _getEnumFromCellTypes(programRootNode) {
    const cellTypeIds = this.getWordsFrom(1)
    const enumGroup = cellTypeIds.join(" ")
    // note: hack where we store it on the program. otherwise has global effects.
    if (!programRootNode._enumMaps) programRootNode._enumMaps = {}
    if (programRootNode._enumMaps[enumGroup]) return programRootNode._enumMaps[enumGroup]
    const wordIndex = 1
    const map = {}
    const cellTypeMap = {}
    cellTypeIds.forEach(typeId => (cellTypeMap[typeId] = true))
    programRootNode
      .getAllTypedWords()
      .filter(typedWord => cellTypeMap[typedWord.type])
      .forEach(typedWord => {
        map[typedWord.word] = true
      })
    programRootNode._enumMaps[enumGroup] = map
    return map
  }
  // todo: remove
  isValid(str, programRootNode) {
    return this._getEnumFromCellTypes(programRootNode)[str] === true
  }
}
class GrammarEnumTestNode extends AbstractGrammarWordTestNode {
  isValid(str) {
    // enum c c++ java
    return !!this.getOptions()[str]
  }
  getOptions() {
    if (!this._map) this._map = TreeUtils.arrayToMap(this.getWordsFrom(1))
    return this._map
  }
}
class cellTypeDefinitionNode extends AbstractExtendibleTreeNode {
  createParser() {
    const types = {}
    types[GrammarConstants.regex] = GrammarRegexTestNode
    types[GrammarConstants.reservedWords] = GrammarReservedWordsTestNode
    types[GrammarConstants.enumFromCellTypes] = EnumFromCellTypesTestNode
    types[GrammarConstants.enum] = GrammarEnumTestNode
    types[GrammarConstants.highlightScope] = TreeNode
    types[GrammarConstants.todoComment] = TreeNode
    types[GrammarConstants.examples] = TreeNode
    types[GrammarConstants.min] = TreeNode
    types[GrammarConstants.max] = TreeNode
    types[GrammarConstants.description] = TreeNode
    types[GrammarConstants.extends] = TreeNode
    return new TreeNode.Parser(undefined, types)
  }
  _getId() {
    return this.getWord(0)
  }
  _getIdToNodeMap() {
    return this.getParent().getCellTypeDefinitions()
  }
  getGetter(wordIndex) {
    const wordToNativeJavascriptTypeParser = this.getCellConstructor().parserFunctionName
    return `get ${this.getCellTypeId()}() {
      return ${wordToNativeJavascriptTypeParser ? wordToNativeJavascriptTypeParser + `(this.getWord(${wordIndex}))` : `this.getWord(${wordIndex})`}
    }`
  }
  getCatchAllGetter(wordIndex) {
    const wordToNativeJavascriptTypeParser = this.getCellConstructor().parserFunctionName
    return `get ${this.getCellTypeId()}() {
      return ${wordToNativeJavascriptTypeParser ? `this.getWordsFrom(${wordIndex}).map(val => ${wordToNativeJavascriptTypeParser}(val))` : `this.getWordsFrom(${wordIndex})`}
    }`
  }
  // `this.getWordsFrom(${requireds.length + 1})`
  // todo: cleanup typings. todo: remove this hidden logic. have a "baseType" property?
  getCellConstructor() {
    return this._getPreludeKind() || GrammarAnyCell
  }
  _getPreludeKind() {
    return PreludeKinds[this.getWord(0)] || PreludeKinds[this._getExtendedCellTypeId()]
  }
  _getPreludeKindId() {
    if (PreludeKinds[this.getWord(0)]) return this.getWord(0)
    else if (PreludeKinds[this._getExtendedCellTypeId()]) return this._getExtendedCellTypeId()
    return PreludeCellTypeIds.anyCell
  }
  _getExtendedCellTypeId() {
    const arr = this._getAncestorsArray()
    return arr[arr.length - 1]._getId()
  }
  getHighlightScope() {
    const hs = this._getFromExtended(GrammarConstants.highlightScope)
    if (hs) return hs
    const preludeKind = this._getPreludeKind()
    if (preludeKind) return preludeKind.defaultHighlightScope
  }
  _getEnumOptions() {
    const enumNode = this._getNodeFromExtended(GrammarConstants.enum)
    if (!enumNode) return undefined
    // we sort by longest first to capture longest match first. todo: add test
    const options = Object.keys(enumNode.getNode(GrammarConstants.enum).getOptions())
    options.sort((a, b) => b.length - a.length)
    return options
  }
  _getEnumFromCellTypeOptions(program) {
    const node = this._getNodeFromExtended(GrammarConstants.enumFromCellTypes)
    return node ? Object.keys(node.getNode(GrammarConstants.enumFromCellTypes)._getEnumFromCellTypes(program)) : undefined
  }
  _getAutocompleteWordOptions(program) {
    return this._getEnumOptions() || this._getEnumFromCellTypeOptions(program) || []
  }
  getRegexString() {
    // todo: enum
    const enumOptions = this._getEnumOptions()
    return this._getFromExtended(GrammarConstants.regex) || (enumOptions ? "(?:" + enumOptions.join("|") + ")" : "[^ ]*")
  }
  isValid(str, programRootNode) {
    return this._getChildrenByNodeConstructorInExtended(AbstractGrammarWordTestNode).every(node => node.isValid(str, programRootNode))
  }
  getCellTypeId() {
    return this.getWord(0)
  }
}
class AbstractCellParser {
  constructor(definition) {
    this._definition = definition
  }
  getCatchAllCellTypeId() {
    return this._definition._getFromExtended(GrammarConstants.catchAllCellType)
  }
  // todo: improve layout (use bold?)
  getLineHints() {
    const catchAllCellTypeId = this.getCatchAllCellTypeId()
    const nodeTypeId = this._definition.get(GrammarConstants.crux) || this._definition._getId() // todo: cleanup
    return `${nodeTypeId}: ${this.getRequiredCellTypeIds().join(" ")}${catchAllCellTypeId ? ` ${catchAllCellTypeId}...` : ""}`
  }
  getRequiredCellTypeIds() {
    const parameters = this._definition._getFromExtended(GrammarConstants.cells)
    return parameters ? parameters.split(" ") : []
  }
  _getCellTypeId(cellIndex, requiredCellTypeIds, totalWordCount) {
    return requiredCellTypeIds[cellIndex]
  }
  _isCatchAllCell(cellIndex, numberOfRequiredCells, totalWordCount) {
    return cellIndex >= numberOfRequiredCells
  }
  getCellArray(node = undefined) {
    const wordCount = node ? node.getWords().length : 0
    const def = this._definition
    const grammarProgram = def.getLanguageDefinitionProgram()
    const requiredCellTypeIds = this.getRequiredCellTypeIds()
    const numberOfRequiredCells = requiredCellTypeIds.length
    const actualWordCountOrRequiredCellCount = Math.max(wordCount, numberOfRequiredCells)
    const cells = []
    // A for loop instead of map because "numberOfCellsToFill" can be longer than words.length
    for (let cellIndex = 0; cellIndex < actualWordCountOrRequiredCellCount; cellIndex++) {
      const isCatchAll = this._isCatchAllCell(cellIndex, numberOfRequiredCells, wordCount)
      let cellTypeId = isCatchAll ? this.getCatchAllCellTypeId() : this._getCellTypeId(cellIndex, requiredCellTypeIds, wordCount)
      let cellTypeDefinition = grammarProgram.getCellTypeDefinitionById(cellTypeId)
      let cellConstructor
      if (cellTypeDefinition) cellConstructor = cellTypeDefinition.getCellConstructor()
      else if (cellTypeId) cellConstructor = GrammarUnknownCellTypeCell
      else {
        cellConstructor = GrammarExtraWordCellTypeCell
        cellTypeId = PreludeCellTypeIds.extraWordCell
        cellTypeDefinition = grammarProgram.getCellTypeDefinitionById(cellTypeId)
      }
      cells[cellIndex] = new cellConstructor(node, cellIndex, cellTypeDefinition, cellTypeId, isCatchAll, def)
    }
    return cells
  }
}
class PrefixCellParser extends AbstractCellParser {}
class PostfixCellParser extends AbstractCellParser {
  _isCatchAllCell(cellIndex, numberOfRequiredCells, totalWordCount) {
    return cellIndex < totalWordCount - numberOfRequiredCells
  }
  _getCellTypeId(cellIndex, requiredCellTypeIds, totalWordCount) {
    const catchAllWordCount = Math.max(totalWordCount - requiredCellTypeIds.length, 0)
    return requiredCellTypeIds[cellIndex - catchAllWordCount]
  }
}
class OmnifixCellParser extends AbstractCellParser {
  getCellArray(node = undefined) {
    const cells = []
    const def = this._definition
    const program = node ? node.getRootNode() : undefined
    const grammarProgram = def.getLanguageDefinitionProgram()
    const words = node ? node.getWords() : []
    const requiredCellTypeDefs = this.getRequiredCellTypeIds().map(cellTypeId => grammarProgram.getCellTypeDefinitionById(cellTypeId))
    const catchAllCellTypeId = this.getCatchAllCellTypeId()
    const catchAllCellTypeDef = catchAllCellTypeId && grammarProgram.getCellTypeDefinitionById(catchAllCellTypeId)
    words.forEach((word, wordIndex) => {
      let cellConstructor
      for (let index = 0; index < requiredCellTypeDefs.length; index++) {
        const cellTypeDefinition = requiredCellTypeDefs[index]
        if (cellTypeDefinition.isValid(word, program)) {
          // todo: cleanup cellIndex/wordIndex stuff
          cellConstructor = cellTypeDefinition.getCellConstructor()
          cells.push(new cellConstructor(node, wordIndex, cellTypeDefinition, cellTypeDefinition._getId(), false, def))
          requiredCellTypeDefs.splice(index, 1)
          return true
        }
      }
      if (catchAllCellTypeDef && catchAllCellTypeDef.isValid(word, program)) {
        cellConstructor = catchAllCellTypeDef.getCellConstructor()
        cells.push(new cellConstructor(node, wordIndex, catchAllCellTypeDef, catchAllCellTypeId, true, def))
        return true
      }
      cells.push(new GrammarUnknownCellTypeCell(node, wordIndex, undefined, undefined, false, def))
    })
    const wordCount = words.length
    requiredCellTypeDefs.forEach((cellTypeDef, index) => {
      let cellConstructor = cellTypeDef.getCellConstructor()
      cells.push(new cellConstructor(node, wordCount + index, cellTypeDef, cellTypeDef._getId(), false, def))
    })
    return cells
  }
}
class GrammarExampleNode extends TreeNode {}
class GrammarCompilerNode extends TreeNode {
  createParser() {
    const types = [
      GrammarConstantsCompiler.stringTemplate,
      GrammarConstantsCompiler.indentCharacter,
      GrammarConstantsCompiler.catchAllCellDelimiter,
      GrammarConstantsCompiler.joinChildrenWith,
      GrammarConstantsCompiler.openChildren,
      GrammarConstantsCompiler.closeChildren
    ]
    const map = {}
    types.forEach(type => {
      map[type] = TreeNode
    })
    return new TreeNode.Parser(undefined, map)
  }
}
class GrammarNodeTypeConstant extends TreeNode {
  getGetter() {
    return `get ${this.getIdentifier()}() { return ${this.getConstantValueAsJsText()} }`
  }
  getIdentifier() {
    return this.getWord(1)
  }
  getConstantValueAsJsText() {
    const words = this.getWordsFrom(2)
    return words.length > 1 ? `[${words.join(",")}]` : words[0]
  }
  getConstantValue() {
    return JSON.parse(this.getConstantValueAsJsText())
  }
}
class GrammarNodeTypeConstantInt extends GrammarNodeTypeConstant {}
class GrammarNodeTypeConstantString extends GrammarNodeTypeConstant {
  getConstantValueAsJsText() {
    return "`" + TreeUtils.escapeBackTicks(this.getConstantValue()) + "`"
  }
  getConstantValue() {
    return this.length ? this.childrenToString() : this.getWordsFrom(2).join(" ")
  }
}
class GrammarNodeTypeConstantFloat extends GrammarNodeTypeConstant {}
class GrammarNodeTypeConstantBoolean extends GrammarNodeTypeConstant {}
class AbstractGrammarDefinitionNode extends AbstractExtendibleTreeNode {
  createParser() {
    // todo: some of these should just be on nonRootNodes
    const types = [
      GrammarConstants.frequency,
      GrammarConstants.inScope,
      GrammarConstants.cells,
      GrammarConstants.extends,
      GrammarConstants.description,
      GrammarConstants.catchAllNodeType,
      GrammarConstants.catchAllCellType,
      GrammarConstants.cellParser,
      GrammarConstants.extensions,
      GrammarConstants.version,
      GrammarConstants.tags,
      GrammarConstants.crux,
      GrammarConstants.pattern,
      GrammarConstants.baseNodeType,
      GrammarConstants.required,
      GrammarConstants.root,
      GrammarConstants._extendsJsClass,
      GrammarConstants._rootNodeJsHeader,
      GrammarConstants.javascript,
      GrammarConstants.compilesTo,
      GrammarConstants.abstract,
      GrammarConstants.javascript,
      GrammarConstants.single,
      GrammarConstants.todoComment
    ]
    const map = {}
    types.forEach(type => {
      map[type] = TreeNode
    })
    map[GrammarConstantsConstantTypes.boolean] = GrammarNodeTypeConstantBoolean
    map[GrammarConstantsConstantTypes.int] = GrammarNodeTypeConstantInt
    map[GrammarConstantsConstantTypes.string] = GrammarNodeTypeConstantString
    map[GrammarConstantsConstantTypes.float] = GrammarNodeTypeConstantFloat
    map[GrammarConstants.compilerNodeType] = GrammarCompilerNode
    map[GrammarConstants.example] = GrammarExampleNode
    return new TreeNode.Parser(undefined, map)
  }
  _getId() {
    return this.getWord(0)
  }
  getConstantsObject() {
    const obj = this._getUniqueConstantNodes()
    Object.keys(obj).forEach(key => {
      obj[key] = obj[key].getConstantValue()
    })
    return obj
  }
  _getUniqueConstantNodes(extended = true) {
    const obj = {}
    const items = extended ? this._getChildrenByNodeConstructorInExtended(GrammarNodeTypeConstant) : this.getChildrenByNodeConstructor(GrammarNodeTypeConstant)
    items.reverse() // Last definition wins.
    items.forEach(node => {
      obj[node.getIdentifier()] = node
    })
    return obj
  }
  getExamples() {
    return this._getChildrenByNodeConstructorInExtended(GrammarExampleNode)
  }
  getNodeTypeIdFromDefinition() {
    return this.getWord(0)
  }
  // todo: remove? just reused nodeTypeId
  _getGeneratedClassName() {
    return this.getNodeTypeIdFromDefinition()
  }
  _hasValidNodeTypeId() {
    return !!this._getGeneratedClassName()
  }
  _isAbstract() {
    return this.has(GrammarConstants.abstract)
  }
  _getConcreteDescendantDefinitions() {
    const defs = this._getProgramNodeTypeDefinitionCache()
    const id = this._getId()
    return Object.values(defs).filter(def => {
      return def._doesExtend(id) && !def._isAbstract()
    })
  }
  _getConstructorDefinedInGrammar() {
    if (!this._cache_definedNodeConstructor) this._cache_definedNodeConstructor = this.getLanguageDefinitionProgram()._getCompiledLoadedNodeTypes()[this.getNodeTypeIdFromDefinition()]
    return this._cache_definedNodeConstructor
  }
  _getCruxIfAny() {
    return this.get(GrammarConstants.crux)
  }
  _getRegexMatch() {
    return this.get(GrammarConstants.pattern)
  }
  _getFirstCellEnumOptions() {
    const firstCellDef = this._getCellTypeDefs()[0]
    return firstCellDef ? firstCellDef._getEnumOptions() : undefined
  }
  getLanguageDefinitionProgram() {
    return this.getParent()
  }
  _getCustomJavascriptMethods() {
    const hasJsCode = this.has(GrammarConstants.javascript)
    return hasJsCode ? this.getNode(GrammarConstants.javascript).childrenToString() : ""
  }
  getFirstWordMapWithDefinitions() {
    if (!this._cache_firstWordToNodeDefMap) this._cache_firstWordToNodeDefMap = this._createParserInfo(this._getInScopeNodeTypeIds()).firstWordMap
    return this._cache_firstWordToNodeDefMap
  }
  // todo: remove
  getRunTimeFirstWordsInScope() {
    return this._getParser().getFirstWordOptions()
  }
  _getCellTypeDefs() {
    const grammarProgram = this.getLanguageDefinitionProgram()
    const requiredCells = this.get(GrammarConstants.cells)
    if (!requiredCells) return []
    return requiredCells.split(" ").map(cellTypeId => {
      const cellTypeDef = grammarProgram.getCellTypeDefinitionById(cellTypeId)
      if (!cellTypeDef) throw new Error(`No cellType "${cellTypeId}" found`)
      return cellTypeDef
    })
  }
  // todo: what happens when you have a cell getter and constant with same name?
  _getCellGettersAndNodeTypeConstants() {
    // todo: add cellType parsings
    const grammarProgram = this.getLanguageDefinitionProgram()
    const getters = this._getCellTypeDefs().map((cellTypeDef, index) => cellTypeDef.getGetter(index))
    const catchAllCellTypeId = this.get(GrammarConstants.catchAllCellType)
    if (catchAllCellTypeId) getters.push(grammarProgram.getCellTypeDefinitionById(catchAllCellTypeId).getCatchAllGetter(getters.length))
    // Constants
    Object.values(this._getUniqueConstantNodes(false)).forEach(node => {
      getters.push(node.getGetter())
    })
    return getters.join("\n")
  }
  _createParserInfo(nodeTypeIdsInScope) {
    const result = {
      firstWordMap: {},
      regexTests: []
    }
    if (!nodeTypeIdsInScope.length) return result
    const allProgramNodeTypeDefinitionsMap = this._getProgramNodeTypeDefinitionCache()
    Object.keys(allProgramNodeTypeDefinitionsMap)
      .filter(nodeTypeId => allProgramNodeTypeDefinitionsMap[nodeTypeId].isOrExtendsANodeTypeInScope(nodeTypeIdsInScope))
      .filter(nodeTypeId => !allProgramNodeTypeDefinitionsMap[nodeTypeId]._isAbstract())
      .forEach(nodeTypeId => {
        const def = allProgramNodeTypeDefinitionsMap[nodeTypeId]
        const regex = def._getRegexMatch()
        const crux = def._getCruxIfAny()
        const enumOptions = def._getFirstCellEnumOptions()
        if (regex) result.regexTests.push({ regex: regex, nodeConstructor: def.getNodeTypeIdFromDefinition() })
        else if (crux) result.firstWordMap[crux] = def
        else if (enumOptions) {
          enumOptions.forEach(option => {
            result.firstWordMap[option] = def
          })
        }
      })
    return result
  }
  getTopNodeTypeDefinitions() {
    const arr = Object.values(this.getFirstWordMapWithDefinitions())
    arr.sort(TreeUtils.makeSortByFn(definition => definition.getFrequency()))
    arr.reverse()
    return arr
  }
  _getMyInScopeNodeTypeIds() {
    const nodeTypesNode = this.getNode(GrammarConstants.inScope)
    return nodeTypesNode ? nodeTypesNode.getWordsFrom(1) : []
  }
  _getInScopeNodeTypeIds() {
    // todo: allow multiple of these if we allow mixins?
    const ids = this._getMyInScopeNodeTypeIds()
    const parentDef = this._getExtendedParent()
    return parentDef ? ids.concat(parentDef._getInScopeNodeTypeIds()) : ids
  }
  isRequired() {
    return this._hasFromExtended(GrammarConstants.required)
  }
  getNodeTypeDefinitionByNodeTypeId(nodeTypeId) {
    // todo: return catch all?
    const def = this._getProgramNodeTypeDefinitionCache()[nodeTypeId]
    if (def) return def
    // todo: cleanup
    this.getLanguageDefinitionProgram()._addDefaultCatchAllBlobNode()
    return this._getProgramNodeTypeDefinitionCache()[nodeTypeId]
  }
  isDefined(nodeTypeId) {
    return !!this._getProgramNodeTypeDefinitionCache()[nodeTypeId]
  }
  _getIdToNodeMap() {
    return this._getProgramNodeTypeDefinitionCache()
  }
  _amIRoot() {
    if (this._cache_isRoot === undefined) this._cache_isRoot = this._getLanguageRootNode() === this
    return this._cache_isRoot
  }
  _getLanguageRootNode() {
    return this.getParent()._getRootNodeTypeDefinitionNode()
  }
  _isErrorNodeType() {
    return this.get(GrammarConstants.baseNodeType) === GrammarConstants.errorNode
  }
  _isBlobNodeType() {
    // Do not check extended classes. Only do once.
    return this.get(GrammarConstants.baseNodeType) === GrammarConstants.blobNode
  }
  _getErrorMethodToJavascript() {
    if (this._isBlobNodeType()) return "getErrors() { return [] }" // Skips parsing child nodes for perf gains.
    if (this._isErrorNodeType()) return "getErrors() { return this._getErrorNodeErrors() }"
    return ""
  }
  _getParserToJavascript() {
    if (this._isBlobNodeType())
      // todo: do we need this?
      return "createParser() { return new jtree.TreeNode.Parser(this._getBlobNodeCatchAllNodeType())}"
    const parserInfo = this._createParserInfo(this._getMyInScopeNodeTypeIds())
    const myFirstWordMap = parserInfo.firstWordMap
    const regexRules = parserInfo.regexTests
    // todo: use constants in first word maps?
    // todo: cache the super extending?
    const firstWords = Object.keys(myFirstWordMap)
    const hasFirstWords = firstWords.length
    const catchAllConstructor = this._getCatchAllNodeConstructorToJavascript()
    if (!hasFirstWords && !catchAllConstructor && !regexRules.length) return ""
    const firstWordsStr = hasFirstWords
      ? `Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {` + firstWords.map(firstWord => `"${firstWord}" : ${myFirstWordMap[firstWord].getNodeTypeIdFromDefinition()}`).join(",\n") + "})"
      : "undefined"
    const regexStr = regexRules.length
      ? `[${regexRules
          .map(rule => {
            return `{regex: /${rule.regex}/, nodeConstructor: ${rule.nodeConstructor}}`
          })
          .join(",")}]`
      : "undefined"
    const catchAllStr = catchAllConstructor ? catchAllConstructor : this._amIRoot() ? `this._getBlobNodeCatchAllNodeType()` : "undefined"
    return `createParser() {
  return new jtree.TreeNode.Parser(${catchAllStr}, ${firstWordsStr}, ${regexStr})
  }`
  }
  _getCatchAllNodeConstructorToJavascript() {
    if (this._isBlobNodeType()) return "this._getBlobNodeCatchAllNodeType()"
    const nodeTypeId = this.get(GrammarConstants.catchAllNodeType)
    if (!nodeTypeId) return ""
    const nodeDef = this.getNodeTypeDefinitionByNodeTypeId(nodeTypeId)
    if (!nodeDef) throw new Error(`No definition found for nodeType id "${nodeTypeId}"`)
    return nodeDef._getGeneratedClassName()
  }
  _nodeDefToJavascriptClass() {
    const components = [this._getParserToJavascript(), this._getErrorMethodToJavascript(), this._getCellGettersAndNodeTypeConstants(), this._getCustomJavascriptMethods()].filter(identity => identity)
    if (this._amIRoot()) {
      components.push(`getGrammarProgram() {
        if (!this._cachedGrammarProgramRoot)
          this._cachedGrammarProgramRoot = new jtree.GrammarProgram(\`${TreeUtils.escapeBackTicks(
            this.getParent()
              .toString()
              .replace(/\\/g, "\\\\")
          )}\`)
        return this._cachedGrammarProgramRoot
      }`)
      const nodeTypeMap = this.getLanguageDefinitionProgram()
        .getValidConcreteAndAbstractNodeTypeDefinitions()
        .map(def => {
          const id = def.getNodeTypeIdFromDefinition()
          return `"${id}": ${id}`
        })
        .join(",\n")
      components.push(`static getNodeTypeMap() { return {${nodeTypeMap} }}`)
    }
    return `class ${this._getGeneratedClassName()} extends ${this._getExtendsClassName()} {
      ${components.join("\n")}
    }`
  }
  _getExtendsClassName() {
    // todo: this is hopefully a temporary line in place for now for the case where you want your base class to extend something other than another treeclass
    const hardCodedExtend = this.get(GrammarConstants._extendsJsClass)
    if (hardCodedExtend) return hardCodedExtend
    const extendedDef = this._getExtendedParent()
    return extendedDef ? extendedDef._getGeneratedClassName() : "jtree.GrammarBackedNode"
  }
  _getCompilerObject() {
    let obj = {}
    const items = this._getChildrenByNodeConstructorInExtended(GrammarCompilerNode)
    items.reverse() // Last definition wins.
    items.forEach(node => {
      obj = Object.assign(obj, node.toObject()) // todo: what about multiline strings?
    })
    return obj
  }
  // todo: improve layout (use bold?)
  getLineHints() {
    return this.getCellParser().getLineHints()
  }
  isOrExtendsANodeTypeInScope(firstWordsInScope) {
    const chain = this._getNodeTypeInheritanceSet()
    return firstWordsInScope.some(firstWord => chain.has(firstWord))
  }
  isTerminalNodeType() {
    return !this._getFromExtended(GrammarConstants.inScope) && !this._getFromExtended(GrammarConstants.catchAllNodeType)
  }
  _getSublimeMatchLine() {
    const regexMatch = this._getRegexMatch()
    if (regexMatch) return `'${regexMatch}'`
    const cruxMatch = this._getCruxIfAny()
    if (cruxMatch) return `'^ *${TreeUtils.escapeRegExp(cruxMatch)}(?: |$)'`
    const enumOptions = this._getFirstCellEnumOptions()
    if (enumOptions) return `'^ *(${TreeUtils.escapeRegExp(enumOptions.join("|"))})(?: |$)'`
  }
  // todo: refactor. move some parts to cellParser?
  _toSublimeMatchBlock() {
    const defaultHighlightScope = "source"
    const program = this.getLanguageDefinitionProgram()
    const cellParser = this.getCellParser()
    const requiredCellTypeIds = cellParser.getRequiredCellTypeIds()
    const catchAllCellTypeId = cellParser.getCatchAllCellTypeId()
    const firstCellTypeDef = program.getCellTypeDefinitionById(requiredCellTypeIds[0])
    const firstWordHighlightScope = (firstCellTypeDef ? firstCellTypeDef.getHighlightScope() : defaultHighlightScope) + "." + this.getNodeTypeIdFromDefinition()
    const topHalf = ` '${this.getNodeTypeIdFromDefinition()}':
  - match: ${this._getSublimeMatchLine()}
    scope: ${firstWordHighlightScope}`
    if (catchAllCellTypeId) requiredCellTypeIds.push(catchAllCellTypeId)
    if (!requiredCellTypeIds.length) return topHalf
    const captures = requiredCellTypeIds
      .map((cellTypeId, index) => {
        const cellTypeDefinition = program.getCellTypeDefinitionById(cellTypeId) // todo: cleanup
        if (!cellTypeDefinition) throw new Error(`No ${GrammarConstants.cellType} ${cellTypeId} found`) // todo: standardize error/capture error at grammar time
        return `        ${index + 1}: ${(cellTypeDefinition.getHighlightScope() || defaultHighlightScope) + "." + cellTypeDefinition.getCellTypeId()}`
      })
      .join("\n")
    const cellTypesToRegex = cellTypeIds => cellTypeIds.map(cellTypeId => `({{${cellTypeId}}})?`).join(" ?")
    return `${topHalf}
    push:
     - match: ${cellTypesToRegex(requiredCellTypeIds)}
       captures:
${captures}
     - match: $
       pop: true`
  }
  _getNodeTypeInheritanceSet() {
    if (!this._cache_nodeTypeInheritanceSet) this._cache_nodeTypeInheritanceSet = new Set(this.getAncestorNodeTypeIdsArray())
    return this._cache_nodeTypeInheritanceSet
  }
  getAncestorNodeTypeIdsArray() {
    if (!this._cache_ancestorNodeTypeIdsArray) {
      this._cache_ancestorNodeTypeIdsArray = this._getAncestorsArray().map(def => def.getNodeTypeIdFromDefinition())
      this._cache_ancestorNodeTypeIdsArray.reverse()
    }
    return this._cache_ancestorNodeTypeIdsArray
  }
  _getProgramNodeTypeDefinitionCache() {
    return this.getLanguageDefinitionProgram()._getProgramNodeTypeDefinitionCache()
  }
  getDescription() {
    return this._getFromExtended(GrammarConstants.description) || ""
  }
  getFrequency() {
    const val = this._getFromExtended(GrammarConstants.frequency)
    return val ? parseFloat(val) : 0
  }
  _getExtendedNodeTypeId() {
    const ancestorIds = this.getAncestorNodeTypeIdsArray()
    if (ancestorIds.length > 1) return ancestorIds[ancestorIds.length - 2]
  }
  _toStumpString() {
    const crux = this._getCruxIfAny()
    const cellArray = this.getCellParser()
      .getCellArray()
      .filter((item, index) => index) // for now this only works for keyword langs
    if (!cellArray.length)
      // todo: remove this! just doing it for now until we refactor getCellArray to handle catchAlls better.
      return ""
    const cells = new TreeNode(cellArray.map((cell, index) => cell._toStumpInput(crux)).join("\n"))
    return `div
 label ${crux}
${cells.toString(1)}`
  }
  toStumpString() {
    const nodeBreakSymbol = "\n"
    return this._getConcreteNonErrorInScopeNodeDefinitions(this._getInScopeNodeTypeIds())
      .map(def => def._toStumpString())
      .filter(identity => identity)
      .join(nodeBreakSymbol)
  }
  _generateSimulatedLine(seed) {
    // todo: generate simulated data from catch all
    const crux = this._getCruxIfAny()
    return this.getCellParser()
      .getCellArray()
      .map((cell, index) => (!index && crux ? crux : cell.synthesizeCell(seed)))
      .join(" ")
  }
  _shouldSynthesize(def, nodeTypeChain) {
    if (def._isErrorNodeType() || def._isAbstract()) return false
    if (nodeTypeChain.includes(def._getId())) return false
    const tags = def.get(GrammarConstants.tags)
    if (tags && tags.includes("doNotSynthesize")) return false
    return true
  }
  _getConcreteNonErrorInScopeNodeDefinitions(nodeTypeIds) {
    const results = []
    nodeTypeIds.forEach(nodeTypeId => {
      const def = this.getNodeTypeDefinitionByNodeTypeId(nodeTypeId)
      if (def._isErrorNodeType()) return true
      else if (def._isAbstract()) {
        def._getConcreteDescendantDefinitions().forEach(def => results.push(def))
      } else {
        results.push(def)
      }
    })
    return results
  }
  // todo: refactor
  synthesizeNode(nodeCount = 1, indentCount = -1, nodeTypesAlreadySynthesized = [], seed = Date.now()) {
    let inScopeNodeTypeIds = this._getInScopeNodeTypeIds()
    const catchAllNodeTypeId = this._getFromExtended(GrammarConstants.catchAllNodeType)
    if (catchAllNodeTypeId) inScopeNodeTypeIds.push(catchAllNodeTypeId)
    const thisId = this._getId()
    if (!nodeTypesAlreadySynthesized.includes(thisId)) nodeTypesAlreadySynthesized.push(thisId)
    const lines = []
    while (nodeCount) {
      const line = this._generateSimulatedLine(seed)
      if (line) lines.push(" ".repeat(indentCount >= 0 ? indentCount : 0) + line)
      this._getConcreteNonErrorInScopeNodeDefinitions(inScopeNodeTypeIds.filter(nodeTypeId => !nodeTypesAlreadySynthesized.includes(nodeTypeId)))
        .filter(def => this._shouldSynthesize(def, nodeTypesAlreadySynthesized))
        .forEach(def => {
          const chain = nodeTypesAlreadySynthesized // .slice(0)
          chain.push(def._getId())
          def.synthesizeNode(1, indentCount + 1, chain, seed).forEach(line => {
            lines.push(line)
          })
        })
      nodeCount--
    }
    return lines
  }
  getCellParser() {
    if (!this._cellParser) {
      const cellParsingStrategy = this._getFromExtended(GrammarConstants.cellParser)
      if (cellParsingStrategy === GrammarCellParser.postfix) this._cellParser = new PostfixCellParser(this)
      else if (cellParsingStrategy === GrammarCellParser.omnifix) this._cellParser = new OmnifixCellParser(this)
      else this._cellParser = new PrefixCellParser(this)
    }
    return this._cellParser
  }
}
// todo: remove?
class nodeTypeDefinitionNode extends AbstractGrammarDefinitionNode {}
// GrammarProgram is a constructor that takes a grammar file, and builds a new
// constructor for new language that takes files in that language to execute, compile, etc.
class GrammarProgram extends AbstractGrammarDefinitionNode {
  createParser() {
    const map = {}
    map[GrammarConstants.toolingDirective] = TreeNode
    map[GrammarConstants.todoComment] = TreeNode
    return new TreeNode.Parser(UnknownNodeTypeNode, map, [{ regex: GrammarProgram.nodeTypeFullRegex, nodeConstructor: nodeTypeDefinitionNode }, { regex: GrammarProgram.cellTypeFullRegex, nodeConstructor: cellTypeDefinitionNode }])
  }
  _getCompiledLoadedNodeTypes() {
    if (!this._cache_compiledLoadedNodeTypes) {
      if (this.isNodeJs()) {
        const code = this.toNodeJsJavascript(__dirname + "/../index.js")
        try {
          const rootNode = this._importNodeJsRootNodeTypeConstructor(code)
          this._cache_compiledLoadedNodeTypes = rootNode.getNodeTypeMap()
          if (!this._cache_compiledLoadedNodeTypes) throw new Error(`Failed to getNodeTypeMap`)
        } catch (err) {
          // todo: figure out best error pattern here for debugging
          console.log(err)
          // console.log(`Error in code: `)
          // console.log(new TreeNode(code).toStringWithLineNumbers())
        }
      } else this._cache_compiledLoadedNodeTypes = this._importBrowserRootNodeTypeConstructor(this.toBrowserJavascript(), this.getRootNodeTypeId()).getNodeTypeMap()
    }
    return this._cache_compiledLoadedNodeTypes
  }
  _setDirName(name) {
    this._dirName = name
    return this
  }
  _importNodeJsRootNodeTypeConstructor(code) {
    const vm = require("vm")
    // todo: cleanup up
    try {
      global.jtree = require(__dirname + "/../index.js")
      global.require = require
      global.__dirname = this._dirName
      global.module = {}
      return vm.runInThisContext(code)
    } catch (err) {
      // todo: figure out best error pattern here for debugging
      console.log(`Error in compiled grammar code for language "${this.getGrammarName()}"`)
      // console.log(new TreeNode(code).toStringWithLineNumbers())
      console.log(err)
      throw err
    }
  }
  _importBrowserRootNodeTypeConstructor(code, name) {
    const script = document.createElement("script")
    script.innerHTML = code
    document.head.appendChild(script)
    return window[name]
  }
  // todo: better formalize the source maps pattern somewhat used here by getAllErrors
  // todo: move this to Grammar.grammar (or just get the bootstrapping done.)
  getErrorsInGrammarExamples() {
    const programConstructor = this.getRootConstructor()
    const errors = []
    this.getValidConcreteAndAbstractNodeTypeDefinitions().forEach(def =>
      def.getExamples().forEach(example => {
        const exampleProgram = new programConstructor(example.childrenToString())
        exampleProgram.getAllErrors(example._getLineNumber() + 1).forEach(err => {
          errors.push(err)
        })
      })
    )
    return errors
  }
  toReadMe() {
    const languageName = this.getExtensionName()
    const rootNodeDef = this._getRootNodeTypeDefinitionNode()
    const cellTypes = this.getCellTypeDefinitions()
    const nodeTypeFamilyTree = this.getNodeTypeFamilyTree()
    const exampleNode = rootNodeDef.getExamples()[0]
    return `title ${languageName} Readme

paragraph ${rootNodeDef.getDescription()}

subtitle Quick Example

code
${exampleNode ? exampleNode.childrenToString(1) : ""}

subtitle Quick facts about ${languageName}

list
 - ${languageName} has ${nodeTypeFamilyTree.getTopDownArray().length} node types.
 - ${languageName} has ${Object.keys(cellTypes).length} cell types
 - The source code for ${languageName} is ${this.getTopDownArray().length} lines long.

subtitle Installing

code
 npm install .

subtitle Testing

code
 node test.js

subtitle Node Types

code
${nodeTypeFamilyTree.toString(1)}

subtitle Cell Types

code
${new TreeNode(Object.keys(cellTypes).join("\n")).toString(1)}

subtitle Road Map

paragraph Here are the "todos" present in the source code for ${languageName}:

list
${this.getTopDownArray()
  .filter(node => node.getWord(0) === "todo")
  .map(node => ` - ${node.getLine()}`)
  .join("\n")}

paragraph This readme was auto-generated using the
 link https://github.com/treenotation/jtree JTree library.`
  }
  toBundle() {
    const files = {}
    const rootNodeDef = this._getRootNodeTypeDefinitionNode()
    const languageName = this.getExtensionName()
    const example = rootNodeDef.getExamples()[0]
    const sampleCode = example ? example.childrenToString() : ""
    files[GrammarBundleFiles.package] = JSON.stringify(
      {
        name: languageName,
        private: true,
        dependencies: {
          jtree: TreeNode.getVersion()
        }
      },
      null,
      2
    )
    files[GrammarBundleFiles.readme] = this.toReadMe()
    const testCode = `const program = new ${languageName}(sampleCode)
const errors = program.getAllErrors()
console.log("Sample program compiled with " + errors.length + " errors.")
if (errors.length)
 console.log(errors.map(error => error.getMessage()))`
    const nodePath = `${languageName}.node.js`
    files[nodePath] = this.toNodeJsJavascript()
    files[GrammarBundleFiles.indexJs] = `module.exports = require("./${nodePath}")`
    const browserPath = `${languageName}.browser.js`
    files[browserPath] = this.toBrowserJavascript()
    files[GrammarBundleFiles.indexHtml] = `<script src="node_modules/jtree/products/jtree.browser.js"></script>
<script src="${browserPath}"></script>
<script>
const sampleCode = \`${sampleCode.toString()}\`
${testCode}
</script>`
    const samplePath = "sample." + this.getExtensionName()
    files[samplePath] = sampleCode.toString()
    files[GrammarBundleFiles.testJs] = `const ${languageName} = require("./index.js")
/*keep-line*/ const sampleCode = require("fs").readFileSync("${samplePath}", "utf8")
${testCode}`
    return files
  }
  getTargetExtension() {
    return this._getRootNodeTypeDefinitionNode().get(GrammarConstants.compilesTo)
  }
  getCellTypeDefinitions() {
    if (!this._cache_cellTypes) this._cache_cellTypes = this._getCellTypeDefinitions()
    return this._cache_cellTypes
  }
  getCellTypeDefinitionById(cellTypeId) {
    // todo: return unknownCellTypeDefinition? or is that handled somewhere else?
    return this.getCellTypeDefinitions()[cellTypeId]
  }
  getNodeTypeFamilyTree() {
    const tree = new TreeNode()
    Object.values(this.getValidConcreteAndAbstractNodeTypeDefinitions()).forEach(node => {
      const path = node.getAncestorNodeTypeIdsArray().join(" ")
      tree.touchNode(path)
    })
    return tree
  }
  _getCellTypeDefinitions() {
    const types = {}
    // todo: add built in word types?
    this.getChildrenByNodeConstructor(cellTypeDefinitionNode).forEach(type => (types[type.getCellTypeId()] = type))
    return types
  }
  getLanguageDefinitionProgram() {
    return this
  }
  getValidConcreteAndAbstractNodeTypeDefinitions() {
    return this.getChildrenByNodeConstructor(nodeTypeDefinitionNode).filter(node => node._hasValidNodeTypeId())
  }
  _getRootNodeTypeDefinitionNode() {
    if (!this._cache_rootNodeTypeNode) {
      this.forEach(def => {
        if (def instanceof AbstractGrammarDefinitionNode && def.has(GrammarConstants.root) && def._hasValidNodeTypeId()) this._cache_rootNodeTypeNode = def
      })
    }
    // By default, have a very permissive basic root node.
    // todo: whats the best design pattern to use for this sort of thing?
    if (!this._cache_rootNodeTypeNode) {
      this._cache_rootNodeTypeNode = this.concat(`${GrammarConstants.defaultRootNode}
 ${GrammarConstants.root}
 ${GrammarConstants.catchAllNodeType} ${GrammarConstants.BlobNode}`)[0]
      this._addDefaultCatchAllBlobNode()
    }
    return this._cache_rootNodeTypeNode
  }
  // todo: whats the best design pattern to use for this sort of thing?
  _addDefaultCatchAllBlobNode() {
    delete this._cache_nodeTypeDefinitions
    this.concat(`${GrammarConstants.BlobNode}
 ${GrammarConstants.baseNodeType} ${GrammarConstants.blobNode}`)
  }
  getExtensionName() {
    return this.getGrammarName()
  }
  getRootNodeTypeId() {
    return this._getRootNodeTypeDefinitionNode().getNodeTypeIdFromDefinition()
  }
  getGrammarName() {
    return this.getRootNodeTypeId().replace(GrammarProgram.nodeTypeSuffixRegex, "")
  }
  _getMyInScopeNodeTypeIds() {
    const nodeTypesNode = this._getRootNodeTypeDefinitionNode().getNode(GrammarConstants.inScope)
    return nodeTypesNode ? nodeTypesNode.getWordsFrom(1) : []
  }
  _getInScopeNodeTypeIds() {
    const nodeTypesNode = this._getRootNodeTypeDefinitionNode().getNode(GrammarConstants.inScope)
    return nodeTypesNode ? nodeTypesNode.getWordsFrom(1) : []
  }
  _initProgramNodeTypeDefinitionCache() {
    if (this._cache_nodeTypeDefinitions) return undefined
    this._cache_nodeTypeDefinitions = {}
    this.getChildrenByNodeConstructor(nodeTypeDefinitionNode).forEach(nodeTypeDefinitionNode => {
      this._cache_nodeTypeDefinitions[nodeTypeDefinitionNode.getNodeTypeIdFromDefinition()] = nodeTypeDefinitionNode
    })
  }
  _getProgramNodeTypeDefinitionCache() {
    this._initProgramNodeTypeDefinitionCache()
    return this._cache_nodeTypeDefinitions
  }
  _getRootConstructor() {
    const def = this._getRootNodeTypeDefinitionNode()
    return def._getConstructorDefinedInGrammar()
  }
  getRootConstructor() {
    if (!this._cache_rootConstructorClass) this._cache_rootConstructorClass = this._getRootConstructor()
    return this._cache_rootConstructorClass
  }
  _getFileExtensions() {
    return this._getRootNodeTypeDefinitionNode().get(GrammarConstants.extensions)
      ? this._getRootNodeTypeDefinitionNode()
          .get(GrammarConstants.extensions)
          .split(" ")
          .join(",")
      : this.getExtensionName()
  }
  toNodeJsJavascript(jtreePath = "jtree") {
    return this._rootNodeDefToJavascriptClass(jtreePath, true).trim()
  }
  toBrowserJavascript() {
    return this._rootNodeDefToJavascriptClass("", false).trim()
  }
  _getProperName() {
    return TreeUtils.ucfirst(this.getExtensionName())
  }
  _rootNodeDefToJavascriptClass(jtreePath, forNodeJs = true) {
    const defs = this.getValidConcreteAndAbstractNodeTypeDefinitions()
    // todo: throw if there is no root node defined
    const nodeTypeClasses = defs.map(def => def._nodeDefToJavascriptClass()).join("\n\n")
    const rootDef = this._getRootNodeTypeDefinitionNode()
    const rootNodeJsHeader = forNodeJs && rootDef._getConcatBlockStringFromExtended(GrammarConstants._rootNodeJsHeader)
    const rootName = rootDef._getGeneratedClassName()
    if (!rootName) throw new Error(`Root Node Type Has No Name`)
    let exportScript = ""
    if (forNodeJs) {
      exportScript = `module.exports = ${rootName};
${rootName}`
    } else {
      exportScript = `window.${rootName} = ${rootName}`
    }
    // todo: we can expose the previous "constants" export, if needed, via the grammar, which we preserve.
    return `{
${forNodeJs ? `const {jtree} = require("${jtreePath}")` : ""}
${rootNodeJsHeader ? rootNodeJsHeader : ""}
${nodeTypeClasses}

${exportScript}
}
`
  }
  toSublimeSyntaxFile() {
    const cellTypeDefs = this.getCellTypeDefinitions()
    const variables = Object.keys(cellTypeDefs)
      .map(name => ` ${name}: '${cellTypeDefs[name].getRegexString()}'`)
      .join("\n")
    const defs = this.getValidConcreteAndAbstractNodeTypeDefinitions().filter(kw => !kw._isAbstract())
    const nodeTypeContexts = defs.map(def => def._toSublimeMatchBlock()).join("\n\n")
    const includes = defs.map(nodeTypeDef => `  - include: '${nodeTypeDef.getNodeTypeIdFromDefinition()}'`).join("\n")
    return `%YAML 1.2
---
name: ${this.getExtensionName()}
file_extensions: [${this._getFileExtensions()}]
scope: source.${this.getExtensionName()}

variables:
${variables}

contexts:
 main:
${includes}

${nodeTypeContexts}`
  }
}
GrammarProgram.makeNodeTypeId = str => TreeUtils._replaceNonAlphaNumericCharactersWithCharCodes(str).replace(GrammarProgram.nodeTypeSuffixRegex, "") + GrammarConstants.nodeTypeSuffix
GrammarProgram.makeCellTypeId = str => TreeUtils._replaceNonAlphaNumericCharactersWithCharCodes(str).replace(GrammarProgram.cellTypeSuffixRegex, "") + GrammarConstants.cellTypeSuffix
GrammarProgram.nodeTypeSuffixRegex = new RegExp(GrammarConstants.nodeTypeSuffix + "$")
GrammarProgram.nodeTypeFullRegex = new RegExp("^[a-zA-Z0-9_]+" + GrammarConstants.nodeTypeSuffix + "$")
GrammarProgram.cellTypeSuffixRegex = new RegExp(GrammarConstants.cellTypeSuffix + "$")
GrammarProgram.cellTypeFullRegex = new RegExp("^[a-zA-Z0-9_]+" + GrammarConstants.cellTypeSuffix + "$")
GrammarProgram._languages = {}
GrammarProgram._nodeTypes = {}
const PreludeKinds = {}
PreludeKinds[PreludeCellTypeIds.anyCell] = GrammarAnyCell
PreludeKinds[PreludeCellTypeIds.keywordCell] = GrammarKeywordCell
PreludeKinds[PreludeCellTypeIds.floatCell] = GrammarFloatCell
PreludeKinds[PreludeCellTypeIds.numberCell] = GrammarFloatCell
PreludeKinds[PreludeCellTypeIds.bitCell] = GrammarBitCell
PreludeKinds[PreludeCellTypeIds.boolCell] = GrammarBoolCell
PreludeKinds[PreludeCellTypeIds.intCell] = GrammarIntCell
window.GrammarConstants = GrammarConstants
window.PreludeCellTypeIds = PreludeCellTypeIds
window.GrammarProgram = GrammarProgram
window.GrammarBackedNode = GrammarBackedNode
window.UnknownNodeTypeError = UnknownNodeTypeError
class Upgrader extends TreeNode {
  upgradeManyInPlace(globPatterns, fromVersion, toVersion) {
    this._upgradeMany(globPatterns, fromVersion, toVersion).forEach(file => file.tree.toDisk(file.path))
    return this
  }
  upgradeManyPreview(globPatterns, fromVersion, toVersion) {
    return this._upgradeMany(globPatterns, fromVersion, toVersion)
  }
  _upgradeMany(globPatterns, fromVersion, toVersion) {
    const glob = this.require("glob")
    const files = TreeUtils.flatten(globPatterns.map(pattern => glob.sync(pattern)))
    console.log(`${files.length} files to upgrade`)
    return files.map(path => {
      console.log("Upgrading " + path)
      return {
        tree: this.upgrade(TreeNode.fromDisk(path), fromVersion, toVersion),
        path: path
      }
    })
  }
  upgrade(code, fromVersion, toVersion) {
    const updateFromMap = this.getUpgradeFromMap()
    const semver = this.require("semver")
    let fromMap
    while ((fromMap = updateFromMap[fromVersion])) {
      const toNextVersion = Object.keys(fromMap)[0] // todo: currently we just assume 1 step at a time
      if (semver.lt(toVersion, toNextVersion)) break
      const fn = Object.values(fromMap)[0]
      code = fn(code)
      fromVersion = toNextVersion
    }
    return code
  }
}
window.Upgrader = Upgrader
class UnknownGrammarProgram extends TreeNode {
  _inferRootNodeForAPrefixLanguage(grammarName) {
    grammarName = GrammarProgram.makeNodeTypeId(grammarName)
    const rootNode = new TreeNode(`${grammarName}
 ${GrammarConstants.root}`)
    // note: right now we assume 1 global cellTypeMap and nodeTypeMap per grammar. But we may have scopes in the future?
    const rootNodeNames = this.getFirstWords()
      .filter(identity => identity)
      .map(word => GrammarProgram.makeNodeTypeId(word))
    rootNode
      .nodeAt(0)
      .touchNode(GrammarConstants.inScope)
      .setWordsFrom(1, Array.from(new Set(rootNodeNames)))
    return rootNode
  }
  _renameIntegerKeywords(clone) {
    // todo: why are we doing this?
    for (let node of clone.getTopDownArrayIterator()) {
      const firstWordIsAnInteger = !!node.getFirstWord().match(/^\d+$/)
      const parentFirstWord = node.getParent().getFirstWord()
      if (firstWordIsAnInteger && parentFirstWord) node.setFirstWord(GrammarProgram.makeNodeTypeId(parentFirstWord + UnknownGrammarProgram._childSuffix))
    }
  }
  _getKeywordMaps(clone) {
    const keywordsToChildKeywords = {}
    const keywordsToNodeInstances = {}
    for (let node of clone.getTopDownArrayIterator()) {
      const firstWord = node.getFirstWord()
      if (!keywordsToChildKeywords[firstWord]) keywordsToChildKeywords[firstWord] = {}
      if (!keywordsToNodeInstances[firstWord]) keywordsToNodeInstances[firstWord] = []
      keywordsToNodeInstances[firstWord].push(node)
      node.forEach(child => {
        keywordsToChildKeywords[firstWord][child.getFirstWord()] = true
      })
    }
    return { keywordsToChildKeywords: keywordsToChildKeywords, keywordsToNodeInstances: keywordsToNodeInstances }
  }
  _inferNodeTypeDef(firstWord, globalCellTypeMap, childFirstWords, instances) {
    const edgeSymbol = this.getEdgeSymbol()
    const nodeTypeId = GrammarProgram.makeNodeTypeId(firstWord)
    const nodeDefNode = new TreeNode(nodeTypeId).nodeAt(0)
    const childNodeTypeIds = childFirstWords.map(word => GrammarProgram.makeNodeTypeId(word))
    if (childNodeTypeIds.length) nodeDefNode.touchNode(GrammarConstants.inScope).setWordsFrom(1, childNodeTypeIds)
    const cellsForAllInstances = instances
      .map(line => line.getContent())
      .filter(identity => identity)
      .map(line => line.split(edgeSymbol))
    const instanceCellCounts = new Set(cellsForAllInstances.map(cells => cells.length))
    const maxCellsOnLine = Math.max(...Array.from(instanceCellCounts))
    const minCellsOnLine = Math.min(...Array.from(instanceCellCounts))
    let catchAllCellType
    let cellTypeIds = []
    for (let cellIndex = 0; cellIndex < maxCellsOnLine; cellIndex++) {
      const cellType = this._getBestCellType(firstWord, instances.length, maxCellsOnLine, cellsForAllInstances.map(cells => cells[cellIndex]))
      if (!globalCellTypeMap.has(cellType.cellTypeId)) globalCellTypeMap.set(cellType.cellTypeId, cellType.cellTypeDefinition)
      cellTypeIds.push(cellType.cellTypeId)
    }
    if (maxCellsOnLine > minCellsOnLine) {
      //columns = columns.slice(0, min)
      catchAllCellType = cellTypeIds.pop()
      while (cellTypeIds[cellTypeIds.length - 1] === catchAllCellType) {
        cellTypeIds.pop()
      }
    }
    const needsCruxProperty = !firstWord.endsWith(UnknownGrammarProgram._childSuffix + "Node") // todo: cleanup
    if (needsCruxProperty) nodeDefNode.set(GrammarConstants.crux, firstWord)
    if (catchAllCellType) nodeDefNode.set(GrammarConstants.catchAllCellType, catchAllCellType)
    const cellLine = cellTypeIds.slice()
    cellLine.unshift(PreludeCellTypeIds.keywordCell)
    if (cellLine.length > 0) nodeDefNode.set(GrammarConstants.cells, cellLine.join(edgeSymbol))
    //if (!catchAllCellType && cellTypeIds.length === 1) nodeDefNode.set(GrammarConstants.cells, cellTypeIds[0])
    // Todo: add conditional frequencies
    return nodeDefNode.getParent().toString()
  }
  //  inferGrammarFileForAnSSVLanguage(grammarName: string): string {
  //     grammarName = GrammarProgram.makeNodeTypeId(grammarName)
  //    const rootNode = new TreeNode(`${grammarName}
  // ${GrammarConstants.root}`)
  //    // note: right now we assume 1 global cellTypeMap and nodeTypeMap per grammar. But we may have scopes in the future?
  //    const rootNodeNames = this.getFirstWords().map(word => GrammarProgram.makeNodeTypeId(word))
  //    rootNode
  //      .nodeAt(0)
  //      .touchNode(GrammarConstants.inScope)
  //      .setWordsFrom(1, Array.from(new Set(rootNodeNames)))
  //    return rootNode
  //  }
  inferGrammarFileForAKeywordLanguage(grammarName) {
    const clone = this.clone()
    this._renameIntegerKeywords(clone)
    const { keywordsToChildKeywords, keywordsToNodeInstances } = this._getKeywordMaps(clone)
    const globalCellTypeMap = new Map()
    globalCellTypeMap.set(PreludeCellTypeIds.keywordCell, undefined)
    const nodeTypeDefs = Object.keys(keywordsToChildKeywords)
      .filter(identity => identity)
      .map(firstWord => this._inferNodeTypeDef(firstWord, globalCellTypeMap, Object.keys(keywordsToChildKeywords[firstWord]), keywordsToNodeInstances[firstWord]))
    const cellTypeDefs = []
    globalCellTypeMap.forEach((def, id) => cellTypeDefs.push(def ? def : id))
    const nodeBreakSymbol = this.getNodeBreakSymbol()
    return this._formatCode([this._inferRootNodeForAPrefixLanguage(grammarName).toString(), cellTypeDefs.join(nodeBreakSymbol), nodeTypeDefs.join(nodeBreakSymbol)].filter(identity => identity).join("\n"))
  }
  _formatCode(code) {
    // todo: make this run in browser too
    if (!this.isNodeJs()) return code
    const grammarProgram = new GrammarProgram(TreeNode.fromDisk(__dirname + "/../langs/grammar/grammar.grammar"))
    const programConstructor = grammarProgram.getRootConstructor()
    const program = new programConstructor(code)
    return program.format().toString()
  }
  _getBestCellType(firstWord, instanceCount, maxCellsOnLine, allValues) {
    const asSet = new Set(allValues)
    const edgeSymbol = this.getEdgeSymbol()
    const values = Array.from(asSet).filter(identity => identity)
    const every = fn => {
      for (let index = 0; index < values.length; index++) {
        if (!fn(values[index])) return false
      }
      return true
    }
    if (every(str => str === "0" || str === "1")) return { cellTypeId: PreludeCellTypeIds.bitCell }
    if (
      every(str => {
        const num = parseInt(str)
        if (isNaN(num)) return false
        return num.toString() === str
      })
    ) {
      return { cellTypeId: PreludeCellTypeIds.intCell }
    }
    if (every(str => str.match(/^-?\d*.?\d+$/))) return { cellTypeId: PreludeCellTypeIds.floatCell }
    const bools = new Set(["1", "0", "true", "false", "t", "f", "yes", "no"])
    if (every(str => bools.has(str.toLowerCase()))) return { cellTypeId: PreludeCellTypeIds.boolCell }
    // todo: cleanup
    const enumLimit = 30
    if (instanceCount > 1 && maxCellsOnLine === 1 && allValues.length > asSet.size && asSet.size < enumLimit)
      return {
        cellTypeId: GrammarProgram.makeCellTypeId(firstWord),
        cellTypeDefinition: `${GrammarProgram.makeCellTypeId(firstWord)}
 enum ${values.join(edgeSymbol)}`
      }
    return { cellTypeId: PreludeCellTypeIds.anyCell }
  }
}
UnknownGrammarProgram._childSuffix = "Child"
window.UnknownGrammarProgram = UnknownGrammarProgram
// Adapted from https://github.com/NeekSandhu/codemirror-textmate/blob/master/src/tmToCm.ts
var CmToken
;(function(CmToken) {
  CmToken["Atom"] = "atom"
  CmToken["Attribute"] = "attribute"
  CmToken["Bracket"] = "bracket"
  CmToken["Builtin"] = "builtin"
  CmToken["Comment"] = "comment"
  CmToken["Def"] = "def"
  CmToken["Error"] = "error"
  CmToken["Header"] = "header"
  CmToken["HR"] = "hr"
  CmToken["Keyword"] = "keyword"
  CmToken["Link"] = "link"
  CmToken["Meta"] = "meta"
  CmToken["Number"] = "number"
  CmToken["Operator"] = "operator"
  CmToken["Property"] = "property"
  CmToken["Qualifier"] = "qualifier"
  CmToken["Quote"] = "quote"
  CmToken["String"] = "string"
  CmToken["String2"] = "string-2"
  CmToken["Tag"] = "tag"
  CmToken["Type"] = "type"
  CmToken["Variable"] = "variable"
  CmToken["Variable2"] = "variable-2"
  CmToken["Variable3"] = "variable-3"
})(CmToken || (CmToken = {}))
const tmToCm = {
  comment: {
    $: CmToken.Comment
  },
  constant: {
    // TODO: Revision
    $: CmToken.Def,
    character: {
      escape: {
        $: CmToken.String2
      }
    },
    language: {
      $: CmToken.Atom
    },
    numeric: {
      $: CmToken.Number
    },
    other: {
      email: {
        link: {
          $: CmToken.Link
        }
      },
      symbol: {
        // TODO: Revision
        $: CmToken.Def
      }
    }
  },
  entity: {
    name: {
      class: {
        $: CmToken.Def
      },
      function: {
        $: CmToken.Def
      },
      tag: {
        $: CmToken.Tag
      },
      type: {
        $: CmToken.Type,
        class: {
          $: CmToken.Variable
        }
      }
    },
    other: {
      "attribute-name": {
        $: CmToken.Attribute
      },
      "inherited-class": {
        // TODO: Revision
        $: CmToken.Def
      }
    },
    support: {
      function: {
        // TODO: Revision
        $: CmToken.Def
      }
    }
  },
  invalid: {
    $: CmToken.Error,
    illegal: { $: CmToken.Error },
    deprecated: {
      $: CmToken.Error
    }
  },
  keyword: {
    $: CmToken.Keyword,
    operator: {
      $: CmToken.Operator
    },
    other: {
      "special-method": CmToken.Def
    }
  },
  punctuation: {
    $: CmToken.Operator,
    definition: {
      comment: {
        $: CmToken.Comment
      },
      tag: {
        $: CmToken.Bracket
      }
      // 'template-expression': {
      //     $: CodeMirrorToken.Operator,
      // },
    }
    // terminator: {
    //     $: CodeMirrorToken.Operator,
    // },
  },
  storage: {
    $: CmToken.Keyword
  },
  string: {
    $: CmToken.String,
    regexp: {
      $: CmToken.String2
    }
  },
  support: {
    class: {
      $: CmToken.Def
    },
    constant: {
      $: CmToken.Variable2
    },
    function: {
      $: CmToken.Def
    },
    type: {
      $: CmToken.Type
    },
    variable: {
      $: CmToken.Variable2,
      property: {
        $: CmToken.Property
      }
    }
  },
  variable: {
    $: CmToken.Def,
    language: {
      // TODO: Revision
      $: CmToken.Variable3
    },
    other: {
      object: {
        $: CmToken.Variable,
        property: {
          $: CmToken.Property
        }
      },
      property: {
        $: CmToken.Property
      }
    },
    parameter: {
      $: CmToken.Def
    }
  }
}
const textMateScopeToCodeMirrorStyle = (scopeSegments, styleTree = tmToCm) => {
  const matchingBranch = styleTree[scopeSegments.shift()]
  return matchingBranch ? textMateScopeToCodeMirrorStyle(scopeSegments, matchingBranch) || matchingBranch.$ || null : null
}
class TreeNotationCodeMirrorMode {
  constructor(name, getProgramConstructorMethod, getProgramCodeMethod, codeMirrorLib = undefined) {
    this._name = name
    this._getProgramConstructorMethod = getProgramConstructorMethod
    this._getProgramCodeMethod = getProgramCodeMethod || (instance => (instance ? instance.getValue() : this._originalValue))
    this._codeMirrorLib = codeMirrorLib
  }
  _getParsedProgram() {
    const source = this._getProgramCodeMethod(this._cmInstance) || ""
    if (!this._cachedProgram || this._cachedSource !== source) {
      this._cachedSource = source
      this._cachedProgram = new (this._getProgramConstructorMethod())(source)
    }
    return this._cachedProgram
  }
  _getExcludedIntelliSenseTriggerKeys() {
    return {
      "8": "backspace",
      "9": "tab",
      "13": "enter",
      "16": "shift",
      "17": "ctrl",
      "18": "alt",
      "19": "pause",
      "20": "capslock",
      "27": "escape",
      "33": "pageup",
      "34": "pagedown",
      "35": "end",
      "36": "home",
      "37": "left",
      "38": "up",
      "39": "right",
      "40": "down",
      "45": "insert",
      "46": "delete",
      "91": "left window key",
      "92": "right window key",
      "93": "select",
      "112": "f1",
      "113": "f2",
      "114": "f3",
      "115": "f4",
      "116": "f5",
      "117": "f6",
      "118": "f7",
      "119": "f8",
      "120": "f9",
      "121": "f10",
      "122": "f11",
      "123": "f12",
      "144": "numlock",
      "145": "scrolllock"
    }
  }
  token(stream, state) {
    return this._advanceStreamAndReturnTokenType(stream, state)
  }
  fromTextAreaWithAutocomplete(area, options) {
    this._originalValue = area.value
    const defaultOptions = {
      lineNumbers: true,
      mode: this._name,
      tabSize: 1,
      indentUnit: 1,
      hintOptions: {
        hint: (cmInstance, options) => this.codeMirrorAutocomplete(cmInstance, options)
      }
    }
    Object.assign(defaultOptions, options)
    this._cmInstance = this._getCodeMirrorLib().fromTextArea(area, defaultOptions)
    this._enableAutoComplete(this._cmInstance)
    return this._cmInstance
  }
  _enableAutoComplete(cmInstance) {
    const excludedKeys = this._getExcludedIntelliSenseTriggerKeys()
    const codeMirrorLib = this._getCodeMirrorLib()
    cmInstance.on("keyup", (cm, event) => {
      // https://stackoverflow.com/questions/13744176/codemirror-autocomplete-after-any-keyup
      if (!cm.state.completionActive && !excludedKeys[event.keyCode.toString()])
        // Todo: get typings for CM autocomplete
        codeMirrorLib.commands.autocomplete(cm, null, { completeSingle: false })
    })
  }
  _getCodeMirrorLib() {
    return this._codeMirrorLib
  }
  async codeMirrorAutocomplete(cmInstance, options) {
    const cursor = cmInstance.getDoc().getCursor()
    const codeMirrorLib = this._getCodeMirrorLib()
    const result = await this._getParsedProgram().getAutocompleteResultsAt(cursor.line, cursor.ch)
    // It seems to be better UX if there's only 1 result, and its the word the user entered, to close autocomplete
    if (result.matches.length === 1 && result.matches[0].text === result.word) return null
    return result.matches.length
      ? {
          list: result.matches,
          from: codeMirrorLib.Pos(cursor.line, result.startCharIndex),
          to: codeMirrorLib.Pos(cursor.line, result.endCharIndex)
        }
      : null
  }
  register() {
    const codeMirrorLib = this._getCodeMirrorLib()
    codeMirrorLib.defineMode(this._name, () => this)
    codeMirrorLib.defineMIME("text/" + this._name, this._name)
    return this
  }
  _advanceStreamAndReturnTokenType(stream, state) {
    let nextCharacter = stream.next()
    const lineNumber = stream.lineOracle.line + 1 // state.lineIndex
    const WordBreakSymbol = " "
    const NodeBreakSymbol = "\n"
    while (typeof nextCharacter === "string") {
      const peek = stream.peek()
      if (nextCharacter === WordBreakSymbol) {
        if (peek === undefined || peek === NodeBreakSymbol) {
          stream.skipToEnd() // advance string to end
          this._incrementLine(state)
        }
        if (peek === WordBreakSymbol && state.cellIndex) {
          // If we are missing a cell.
          // TODO: this is broken for a blank 1st cell. We need to track WordBreakSymbol level.
          state.cellIndex++
        }
        return "bracket"
      }
      if (peek === WordBreakSymbol) {
        state.cellIndex++
        return this._getCellStyle(lineNumber, state.cellIndex)
      }
      nextCharacter = stream.next()
    }
    state.cellIndex++
    const style = this._getCellStyle(lineNumber, state.cellIndex)
    this._incrementLine(state)
    return style
  }
  _getCellStyle(lineIndex, cellIndex) {
    const program = this._getParsedProgram()
    // todo: if the current word is an error, don't show red?
    if (!program.getCellHighlightScopeAtPosition) console.log(program)
    const highlightScope = program.getCellHighlightScopeAtPosition(lineIndex, cellIndex)
    const style = highlightScope ? textMateScopeToCodeMirrorStyle(highlightScope.split(".")) : undefined
    return style || "noHighlightScopeDefinedInGrammar"
  }
  // todo: remove.
  startState() {
    return {
      cellIndex: 0
    }
  }
  _incrementLine(state) {
    state.cellIndex = 0
  }
}
window.TreeNotationCodeMirrorMode = TreeNotationCodeMirrorMode
class jtree {}
jtree.GrammarBackedNode = GrammarBackedNode
jtree.GrammarConstants = GrammarConstants
jtree.Utils = TreeUtils
jtree.UnknownNodeTypeError = UnknownNodeTypeError
jtree.TestRacer = TestRacer
jtree.TreeEvents = TreeEvents
jtree.TreeNode = TreeNode
jtree.ExtendibleTreeNode = ExtendibleTreeNode
jtree.GrammarProgram = GrammarProgram
jtree.UnknownGrammarProgram = UnknownGrammarProgram
jtree.TreeNotationCodeMirrorMode = TreeNotationCodeMirrorMode
jtree.getVersion = () => TreeNode.getVersion()
window.jtree = jtree
;

// todo: create a Tree Language for number formatting
// https://github.com/gentooboontoo/js-quantities
// https://github.com/moment/moment/issues/2469
// todo: ugly. how do we ditch this or test?
moment.createFromInputFallback = function(momentConfig) {
  momentConfig._d = new Date(momentConfig._i)
}
var VegaTypes
;(function(VegaTypes) {
  VegaTypes["nominal"] = "nominal"
  VegaTypes["ordinal"] = "ordinal"
  VegaTypes["geojson"] = "geojson"
  VegaTypes["quantitative"] = "quantitative"
  VegaTypes["temporal"] = "temporal"
})(VegaTypes || (VegaTypes = {}))
var JavascriptNativeTypeNames
;(function(JavascriptNativeTypeNames) {
  JavascriptNativeTypeNames["number"] = "number"
  JavascriptNativeTypeNames["string"] = "string"
  JavascriptNativeTypeNames["Date"] = "Date"
  JavascriptNativeTypeNames["boolean"] = "boolean"
})(JavascriptNativeTypeNames || (JavascriptNativeTypeNames = {}))
class AbstractPrimitiveType {
  constructor(typeName) {
    this._name = typeName
  }
  getPrimitiveTypeName() {
    return this._name
  }
  // Abstract methods:
  toDisplayString(value, format) {
    return value
  }
  getDefaultFormat(columnName, sample) {
    return ""
  }
  getProbForColumnSpecimen(value) {
    return 0
  }
  isInvalidValue(value) {
    if (value === undefined || value === "") return true
    return false
  }
}
class BooleanType extends AbstractPrimitiveType {
  getAsNativeJavascriptType(val) {
    // todo: handle false, etc
    return val ? 1 : 0
  }
  getJavascriptTypeName() {
    return JavascriptNativeTypeNames.boolean
  }
  fromStringToNumeric(val) {
    return val.toString() === "true" ? 1 : 0
  }
  getStringExamples() {
    return ["true"]
  }
  getVegaType() {
    return VegaTypes.nominal
  }
  isNumeric() {
    return false
  }
  isString() {
    return false
  }
  isTemporal() {
    return false
  }
}
class AbstractNumeric extends AbstractPrimitiveType {
  fromStringToNumeric(value) {
    return parseFloat(value)
  }
  getAsNativeJavascriptType(val) {
    if (val === undefined) return NaN
    const valType = typeof val
    if (valType === "string") return this.fromStringToNumeric(val)
    else if (val instanceof Date) return Math.round(val.getDate() / 1000)
    // Is a number
    return val
  }
  getJavascriptTypeName() {
    return JavascriptNativeTypeNames.number
  }
  getVegaType() {
    return VegaTypes.quantitative
  }
  isString() {
    return false
  }
  isTemporal() {
    return false
  }
  isNumeric() {
    return true
  }
  isInvalidValue(value) {
    return super.isInvalidValue(value) || isNaN(value)
  }
}
class IntType extends AbstractNumeric {
  fromStringToNumeric(val) {
    return parseInt(val)
  }
  getStringExamples() {
    return ["30"]
  }
  getVegaType() {
    return VegaTypes.quantitative
  }
  isNumeric() {
    return true
  }
  isString() {
    return false
  }
  isTemporal() {
    return false
  }
}
class Feet extends AbstractNumeric {
  getProbForColumnSpecimen(sample) {
    return isNaN(Feet.feetToInches(sample)) ? 0 : 1
  }
  fromStringToNumeric(val) {
    return Feet.feetToInches(val)
  }
  toDisplayString(value, format) {
    value = parseFloat(value)
    const inches = Math.round(value % 12)
    const feet = Math.floor(value / 12)
    return `${feet}'${inches}"`
  }
  getStringExamples() {
    return ["5'10\""]
  }
  // Return inches given formats like 6'1 6'2"
  static feetToInches(numStr) {
    let result = 0
    const indexOfDelimited = numStr.search(/[^0-9\.]/)
    if (indexOfDelimited < 1) {
      result = parseFloat(numStr.replace(/[^0-9\.]/g, ""))
      return isNaN(result) ? result : result * 12
    }
    const feetPart = parseFloat(numStr.substr(0, indexOfDelimited).replace(/[^0-9\.]/g, ""))
    const inchesPart = parseFloat(numStr.substr(indexOfDelimited).replace(/[^0-9\.]/g, ""))
    if (!isNaN(feetPart)) result += feetPart * 12
    if (!isNaN(inchesPart)) result += inchesPart
    return result
  }
}
class AbstractCurrency extends AbstractNumeric {}
class USD extends AbstractCurrency {
  toDisplayString(value, format) {
    return format ? d3format.format(format)(value) : value
  }
  fromStringToNumeric(value) {
    return parseFloat(value.toString().replace(/[\$\, \%]/g, ""))
  }
  getProbForColumnSpecimen(sample) {
    return sample && sample.match && !!sample.match(/^\$[0-9\.\,]+$/) ? 1 : 0
  }
  getDefaultFormat() {
    return "($.2f"
  }
  getStringExamples() {
    return ["$2.22"]
  }
}
class NumberCol extends AbstractNumeric {
  // https://github.com/d3/d3-format
  toDisplayString(value, format) {
    if (format === "percent") return d3format.format("(.2f")(parseFloat(value)) + "%"
    // Need the isNan bc numeral will throw otherwise
    if (format && !isNaN(value) && value !== Infinity) return d3format.format(format)(value)
    return value
  }
  getDefaultFormat(columnName, sample) {
    if (columnName.match(/^(mile|pound|inch|feet)s?$/i)) return "(.1f"
    if (columnName.match(/^(calorie|steps)s?$/i)) return ","
    if (sample && !sample.toString().includes(".")) return ","
  }
  getStringExamples() {
    return ["2.22"]
  }
}
class NumberString extends AbstractNumeric {
  toDisplayString(value, format) {
    return format ? d3format.format(format)(value) : value
  }
  getDefaultFormat() {
    return ","
  }
  fromStringToNumeric(str) {
    return parseFloat(str.toString().replace(/[\$\, \%]/g, ""))
  }
  getStringExamples() {
    return ["2,000"]
  }
}
class ObjectType extends AbstractPrimitiveType {
  getAsNativeJavascriptType(val) {
    return val === undefined ? "" : val.toString()
  }
  // todo: not sure about this.
  getStringExamples() {
    return ["{score: 10}"]
  }
  fromStringToNumeric() {
    return undefined
  }
  getJavascriptTypeName() {
    return JavascriptNativeTypeNames.string
  }
  getVegaType() {
    return VegaTypes.nominal
  }
  isNumeric() {
    return false
  }
  isString() {
    return false
  }
  isTemporal() {
    return false
  }
}
class AbstractStringCol extends AbstractPrimitiveType {
  isString() {
    return true
  }
  isNumeric() {
    return false
  }
  getStringExamples() {
    return ["Anything"]
  }
  getVegaType() {
    return VegaTypes.nominal
  }
  getJavascriptTypeName() {
    return JavascriptNativeTypeNames.string
  }
  fromStringToNumeric() {
    return undefined
  }
  isTemporal() {
    return false
  }
  getAsNativeJavascriptType(val) {
    return val === undefined ? "" : val.toString()
  }
}
class StringCol extends AbstractStringCol {}
class UrlCol extends AbstractStringCol {
  getStringExamples() {
    return ["www.foo.com"]
  }
}
class TextCol extends AbstractStringCol {}
class AbstractCodeCol extends AbstractStringCol {}
class CodeCol extends AbstractCodeCol {
  getStringExamples() {
    return ["i++"]
  }
}
class HTMLCol extends AbstractCodeCol {
  getStringExamples() {
    return ["<b>hi</b>"]
  }
}
class AbstractPathCol extends AbstractStringCol {}
// filepath
class PathCol extends AbstractPathCol {}
// Directory
class DirCol extends AbstractPathCol {}
class AbstractTemporal extends AbstractPrimitiveType {
  _fromStringToDate(value) {
    return moment(parseInt(value)).toDate()
  }
  getAsNativeJavascriptType(val) {
    if (val === undefined) return undefined
    const valType = typeof val
    if (valType === "string") return this._fromStringToDate(val)
    else if (val instanceof Date) return val
    return this._fromNumericToDate(val)
  }
  fromDateToNumeric(date) {
    return moment(date).unix()
  }
  getJavascriptTypeName() {
    return JavascriptNativeTypeNames.Date
  }
  isNumeric() {
    return true
  }
  isString() {
    return false
  }
  isTemporal() {
    return true
  }
  getVegaType() {
    return VegaTypes.temporal
  }
  getVegaTimeUnit() {
    return undefined
  }
  _fromNumericToDate(value) {
    return moment(value).toDate()
  }
}
class DateCol extends AbstractTemporal {
  toDisplayString(value, format) {
    if (!format) format = "MM/DD/YY"
    if (format === "fromNow") return moment(parseFloat(value)).fromNow()
    // todo: make sure we are working with numeric values?
    return moment(value).format(format)
  }
  fromStringToNumeric(value) {
    return DateCol.getDate(value).unix() * 1000
  }
  _fromStringToDate(value) {
    return DateCol.getDate(value).toDate()
  }
  getProbForColumnSpecimen(value) {
    const isValid = DateCol.getDate(value).isValid()
    return isValid
  }
  getStringExamples() {
    return ["01/01/01"]
  }
  static getDateAsUnixUtx(value) {
    return this.getDate(value, moment.utc).unix()
  }
  static getDate(value, momentFn = moment) {
    let result = momentFn(value)
    if (result.isValid()) return result
    if (typeof value === "string" && value.match(/^[0-9]{8}$/)) {
      const first2 = parseInt(value.substr(0, 2))
      const second2 = parseInt(value.substr(2, 2))
      const third2 = parseInt(value.substr(4, 2))
      const last2 = parseInt(value.substr(6, 2))
      const first4 = parseInt(value.substr(0, 4))
      const last4 = parseInt(value.substr(4, 4))
      const first2couldBeDay = first2 < 32
      const first2couldBeMonth = first2 < 13
      const second2couldBeDay = second2 < 32
      const second2couldBeMonth = second2 < 13
      const third2couldBeDay = third2 < 32
      const third2couldBeMonth = third2 < 13
      const last2couldBeDay = last2 < 32
      const last2couldBeMonth = last2 < 13
      const last4looksLikeAYear = last4 > 1000 && last4 < 2100
      const first4looksLikeAYear = first4 > 1000 && first4 < 2100
      // MMDDYYYY
      // YYYYMMDD
      // Prioritize the above 2 american versions
      // YYYYDDMM
      // DDMMYYYY
      if (first2couldBeMonth && second2couldBeDay && last4looksLikeAYear) result = momentFn(value, "MMDDYYYY")
      else if (first4looksLikeAYear && third2couldBeMonth && last2couldBeDay) result = momentFn(value, "YYYYMMDD")
      else if (first4looksLikeAYear && last2couldBeMonth) result = momentFn(value, "YYYYDDMM")
      else result = momentFn(value, "DDMMYYYY")
      return result
    } else if (typeof value === "string" && value.match(/^[0-9]{2}\/[0-9]{4}$/))
      // MM/YYYY
      return momentFn(value, "MM/YYYY")
    // Check if timestamp
    if (value.match && !value.match(/[^0-9]/)) {
      const num = parseFloat(value)
      if (!isNaN(num)) {
        if (value.length === 10) return momentFn(num * 1000)
        else return momentFn(num)
      }
    }
    // Okay to return an invalid result if we dont find a match
    // todo: why??? should we return "" instead ?
    return result
  }
}
// Beginning of day
class Day extends AbstractTemporal {
  toDisplayString(value, format) {
    return moment(value).format(format || "MM/DD/YYYY")
  }
  fromStringToNumeric(value) {
    return (
      DateCol.getDate(value)
        .startOf("day")
        .unix() * 1000
    )
  }
  getVegaTimeUnit() {
    return undefined
  }
  _fromStringToDate(value) {
    return DateCol.getDate(value)
      .startOf("day")
      .toDate()
  }
  fromDateToNumeric(date) {
    return (
      moment(date)
        .startOf("day")
        .unix() * 1000
    )
  }
  getStringExamples() {
    return ["01/01/01"]
  }
  getProbForColumnSpecimen(sample) {
    const format = moment.parseFormat ? moment.parseFormat(sample) : parseFormat
    return format === "MM/DD/YY" || format === "MM/DD/YYYY" || format === "M/D/YYYY" ? 1 : 0
  }
}
class HourMinute extends AbstractTemporal {
  // todo: is this correct? I dont think so.
  fromStringToNumeric(value) {
    return parseFloat(DateCol.getDate(value).format("H.m"))
  }
  getVegaTimeUnit() {
    return "hoursminutes"
  }
  // todo: is this correct? I dont think so.
  getStringExamples() {
    return ["2:30"]
  }
}
class Minute extends AbstractTemporal {
  toDisplayString(value, format) {
    return moment(value).format("m")
  }
  fromStringToNumeric(value) {
    return (
      DateCol.getDate(value)
        .startOf("minute")
        .unix() * 1000
    )
  }
  getVegaTimeUnit() {
    return "minutes"
  }
  getStringExamples() {
    return ["30"]
  }
}
class AbstractTemporalInt extends AbstractTemporal {
  fromStringToNumeric(val) {
    return parseInt(val)
  }
  // getAsNativeJavascriptType(val: any): number {
  //   const result = super.getAsNativeJavascriptType(val)
  //   return result === undefined ? undefined : this.fromDateToNumeric(result)
  // }
  getStringExamples() {
    return ["30"]
  }
  isNumeric() {
    return true
  }
  isString() {
    return false
  }
  fromDateToNumeric(date) {
    return moment(date).unix()
  }
  _fromStringToDate(val) {
    return moment(parseFloat(val)).toDate()
  }
  _fromNumericToDate(value) {
    return moment(value).toDate()
  }
  getVegaTimeUnit() {
    return "seconds"
  }
}
class Week extends AbstractTemporalInt {
  toDisplayString(value, format) {
    return moment(value).format("MM/DD/YYYY - WW")
  }
  fromDateToNumeric(date) {
    return (
      moment(date)
        .startOf("week")
        .unix() * 1000
    )
  }
  getVegaTimeUnit() {
    return "quartermonth"
  }
}
class Month extends AbstractTemporalInt {
  toDisplayString(value, format) {
    return moment(value).format(format || "MMMM")
  }
  fromDateToNumeric(date) {
    return (
      moment(date)
        .startOf("month")
        .unix() * 1000
    )
  }
  getVegaTimeUnit() {
    return "month"
  }
}
class MonthDay extends AbstractTemporalInt {
  toDisplayString(value, format) {
    return moment(value).format(format || "MMDD")
  }
  fromDateToNumeric(date) {
    return moment(date).unix() * 1000
  }
  getVegaTimeUnit() {
    return "monthdate"
  }
}
class Hour extends AbstractTemporalInt {
  fromDateToNumeric(date) {
    return parseInt(
      moment(date)
        .startOf("hour")
        .format("H")
    )
  }
  getVegaTimeUnit() {
    return "hours"
  }
}
class Year extends AbstractTemporalInt {
  fromDateToNumeric(date) {
    return parseInt(moment(date).format("YYYY"))
  }
  _fromStringToDate(val) {
    return moment(parseFloat(val), "YYYY").toDate()
  }
  toDisplayString(value, format) {
    return moment(value).format(format || "YYYY")
  }
  getVegaTimeUnit() {
    return "year"
  }
  _fromNumericToDate(value) {
    return moment(value, "YYYY").toDate()
  }
  isTemporal() {
    return true
  }
}
class AbstractMillisecond extends AbstractTemporalInt {
  toDisplayString(value, format) {
    if (format === "fromNow") return moment(parseFloat(value)).fromNow()
    return value
  }
  isTemporal() {
    return true
  }
  getDefaultFormat() {
    return "fromNow"
  }
}
class MilliSecond extends AbstractMillisecond {
  getVegaTimeUnit() {
    return "milliseconds"
  }
}
class Second extends AbstractMillisecond {
  fromStringToNumeric(value) {
    return parseInt(value) * 1000
  }
  getVegaTimeUnit() {
    return "seconds"
  }
  _fromNumericToDate(number) {
    return moment(number * 1000).toDate()
  }
  toDisplayString(value, format) {
    if (format === "fromNow") return moment(parseFloat(value) * 1000).fromNow()
    return value
  }
}
// todo: ADD TYPINGS
class Column {
  constructor(colDef = {}, rawAnyVector) {
    this._colDefObject = colDef
    this._rawAnyVectorFromSource = rawAnyVector
    this._sampleSet = jtree.Utils.sampleWithoutReplacement(rawAnyVector, 30, Date.now())
  }
  static _getPrimitiveTypesCollection() {
    if (!this._colTypes)
      this._colTypes = {
        millisecond: new MilliSecond("millisecond"),
        second: new Second("second"),
        date: new DateCol("date"),
        day: new Day("day"),
        week: new Week("week"),
        month: new Month("month"),
        monthDay: new MonthDay("monthDay"),
        hour: new Hour("hour"),
        hourMinute: new HourMinute("hourMinute"),
        minute: new Minute("minute"),
        year: new Year("year"),
        feet: new Feet("feet"),
        usd: new USD("usd"),
        number: new NumberCol("number"),
        numberString: new NumberString("numberString"),
        string: new StringCol("string"),
        text: new TextCol("text"),
        path: new PathCol("path"),
        dir: new DirCol("dir"),
        code: new CodeCol("code"),
        html: new HTMLCol("html"),
        url: new UrlCol("url"),
        object: new ObjectType("object"),
        boolean: new BooleanType("boolean"),
        int: new IntType("int")
      }
    return this._colTypes
  }
  static getPrimitiveTypeByName(name) {
    return this._getPrimitiveTypesCollection()[name]
  }
  getMathFn() {
    return this._colDefObject.mathFn
  }
  getColumnName() {
    return this._getColDefObject().name
  }
  getSourceColumnName() {
    return this._colDefObject.source
  }
  isInvalidValue(value) {
    return this.getPrimitiveTypeObj().isInvalidValue(value)
  }
  _getSample() {
    if (this._sample === undefined) {
      const sampleSet = this._getSampleSet()
      this._sample = sampleSet.length ? sampleSet[0] : ""
    }
    return this._sample
  }
  _getColDefObject() {
    return this._colDefObject
  }
  getPrimitiveTypeObj() {
    if (!this._type) this._type = this._inferType()
    return this._type
  }
  isTemporal() {
    return this.getPrimitiveTypeObj().isTemporal()
  }
  toDisplayString(value) {
    return this.getPrimitiveTypeObj().toDisplayString(value, this.getFormat())
  }
  isString() {
    return this.getPrimitiveTypeObj().isString()
  }
  isNumeric() {
    return this.getPrimitiveTypeObj().isNumeric()
  }
  isHash() {
    return this.isString() && false // todo: make this work. identify random hashes, et cetera.
  }
  // todo: isEnum/isSet
  // todo: isUniqueTimestamp
  getEntropy() {
    if (this._entropy !== undefined) return this._entropy
    const possibilities = {}
    let bits = 1
    const name = this.getColumnName()
    this._getSampleSet().forEach(val => {
      if (possibilities[val]) return
      bits++
      possibilities[val] = true
    })
    this._entropy = bits
    return this._entropy
  }
  isLink() {
    if (this._isLink !== undefined) return this._isLink
    const sample = this._getSample()
    if (!this.isString() || !sample || !sample.match) this._isLink = false
    else this._isLink = sample.match(/^(https?\:|\/)/) ? true : false
    return this._isLink
  }
  _getSampleSet() {
    return this._sampleSet
  }
  isUnique() {
    return this.getEntropy() - 1 === this._getSampleSet().length
  }
  getTitlePotential() {
    if (this._getColDefObject().title) return 1
    if (this._titlePotential !== undefined) return this._titlePotential
    const titleCols = {
      title: 0.99,
      name: 0.98,
      label: 0.97,
      category: 0.96
    }
    const lowerCaseName = this.getColumnName().toLowerCase()
    if (titleCols[lowerCaseName]) this._titlePotential = titleCols[lowerCaseName]
    else if (this.getEstimatedTextLength() > 150) this._titlePotential = 0.01
    else if (this.isString() && !this.isLink() && this.isUnique() && !this.isHash()) this._titlePotential = 0.75
    else this._titlePotential = 0
    return this._titlePotential
  }
  getVegaType() {
    return this.getPrimitiveTypeObj().getVegaType()
  }
  getVegaTimeUnit() {
    const type = this.getPrimitiveTypeObj()
    return type.getVegaTimeUnit ? type.getVegaTimeUnit() : undefined
  }
  getEstimatedTextLength() {
    if (!this.isString()) return 0
    if (this._estimatedTextLength !== undefined) return this._estimatedTextLength
    const name = this.getColumnName()
    const sampleSet = this._getSampleSet()
    const sum = sampleSet.map(val => val && val.length).reduce((rowLength, cumulative) => rowLength + cumulative, 0)
    this._estimatedTextLength = Math.floor(sum / sampleSet.length)
    return this._estimatedTextLength
  }
  getFormat() {
    if (this._getColDefObject().format) return this._getColDefObject().format
    return this.getPrimitiveTypeObj().getDefaultFormat(this.getColumnName(), this._getSample())
  }
  getBlankPercentage() {
    let blankCount = 0
    let mistypedCount = 0 // todo.
    const colName = this.getColumnName()
    const sampleSet = this._getSampleSet()
    sampleSet.forEach(value => {
      if (value === undefined || value === "") blankCount++
      // todo: add mistyped data
    })
    return blankCount / (sampleSet.length || 1)
  }
  getMap() {
    const map = this._map
    if (map) return map
    this._map = this._getSummaryVector().map
    return this._map
  }
  _getSummaryVector() {
    if (!this._summaryVector) this._summaryVector = this._createSummaryVector()
    return this._summaryVector
  }
  _getRawAnyVectorFromSource() {
    return this._rawAnyVectorFromSource
  }
  _createSummaryVector() {
    const values = []
    const map = new Map()
    let incompleteCount = 0
    let uniques = 0
    let index = 0
    let rawVector = this._getRawAnyVectorFromSource()
    // If needs conversion.
    // todo: add tests
    const primitiveType = this.getPrimitiveTypeObj()
    if (primitiveType.isNumeric() && typeof rawVector[0] === "string") rawVector = rawVector.map(primitiveType.fromStringToNumeric)
    rawVector.forEach(val => {
      if (this.isInvalidValue(val)) {
        incompleteCount++
        return true
      }
      if (!map.has(val)) {
        map.set(val, { count: 0, index: index })
        uniques++
      } else map.get(val).count++
      values.push(val)
    })
    return {
      map: map,
      values: values,
      incompleteCount: incompleteCount,
      uniqueValues: uniques
    }
  }
  getQuins() {
    const deciles = this.getReductions().deciles
    return [20, 40, 60, 80, 100].map(decile => {
      return {
        value: deciles[decile],
        percent: decile / 100
      }
    })
  }
  getPrimitiveTypeName() {
    return this.getPrimitiveTypeObj().getPrimitiveTypeName()
  }
  toObject() {
    return {
      name: this.getColumnName(),
      type: this.getPrimitiveTypeName(),
      vegaType: this.getVegaType(),
      vegaTimeUnit: this.getVegaTimeUnit(),
      reduction: this._getColDefObject().reduction,
      titlePotential: this.getTitlePotential(),
      isString: this.isString(),
      isTemporal: this.isTemporal(),
      isLink: this.isLink(),
      estimatedTextLength: this.getEstimatedTextLength()
    }
  }
  getReductions() {
    if (!this._reductions) this._reductions = this._getReductionResult(this._getSummaryVector(), this)
    return this._reductions
  }
  getMax() {
    return this.getReductions().max
  }
  getMean() {
    return this.getReductions().mean
  }
  _getReductionResult(valuesObj, col) {
    const values = valuesObj.values
    const count = values.length
    const reductionResult = {}
    reductionResult.incompleteCount = valuesObj.incompleteCount
    reductionResult.uniqueValues = valuesObj.uniqueValues
    if (!count) return reductionResult
    const numericCompare = (av, bv) => (av > bv ? 1 : av < bv ? -1 : 0)
    const arr = values.slice()
    col.isString() ? arr.sort() : arr.sort(numericCompare)
    let min = arr[0]
    let max = arr[0]
    let sum = 0
    let mode = undefined
    let modeSize = 0
    let currentBucketValue = undefined
    let currentBucketSize = 0
    for (let index = 0; index < count; index++) {
      let value = arr[index]
      sum += value
      if (value > max) max = value
      if (value < min) min = value
      if (value === currentBucketValue) currentBucketSize++
      else {
        currentBucketValue = value
        currentBucketSize = 1
      }
      if (currentBucketSize > modeSize) {
        modeSize = currentBucketSize
        mode = currentBucketValue
      }
    }
    const medianIndex = Math.floor(count / 2)
    reductionResult.count = count
    reductionResult.sum = sum
    reductionResult.median = arr[medianIndex]
    reductionResult.mean = sum / count
    reductionResult.min = min
    reductionResult.max = max
    reductionResult.range = max - min
    reductionResult.mode = mode
    reductionResult.modeSize = modeSize
    if (col.isString()) {
      reductionResult.sum = undefined
      reductionResult.mean = undefined
    } else if (col.isTemporal()) reductionResult.sum = undefined
    reductionResult.deciles = {}
    const deciles = [10, 20, 30, 40, 50, 60, 70, 80, 90, 99, 100]
    deciles.forEach(decile => {
      let index = Math.floor(count * (decile / 100))
      index = index === count ? index - 1 : index
      reductionResult.deciles[decile] = arr[index]
    })
    return reductionResult
  }
  static _getColumnProbabilities(name, sample) {
    // Assume data is trimmed.
    const sampleType = typeof sample
    const sampleStringLength = sample !== undefined ? sample.toString().length : 0
    const guesses = {}
    guesses.number = 0.5
    guesses.date = 0.25
    guesses.string = 0.75
    guesses.feet = 0.01 // 5'11"
    guesses.object = 0.1
    guesses.boolean = 0.02
    const isDate = sample instanceof Date
    const isNumber = !isNaN(parseFloat(sample)) || Column.getPrimitiveTypeByName("usd").getProbForColumnSpecimen(sample)
    if (sampleType === "object") guesses.object = 0.9
    if (sample === true || sample === false) guesses.boolean = 0.96
    if (name.match(/(team|name|link|image|description|permalink|title|label|status|thumb|ip|useragent)/i)) guesses.string = 0.95
    if (name.match(/(gender|region|category|group|section|sector|field)/i)) guesses.string = 0.95
    if (name.match(/(height|length)/i)) {
      if (sample.toString().match(/[0-9]+(\'|\-)[0-9\.]+/) && Column.getPrimitiveTypeByName("feet").getProbForColumnSpecimen(sample)) guesses.feet = 0.97
    }
    if (isNumber) guesses.number = 0.8
    else guesses.number = 0.1
    const usdGuess = Column.getPrimitiveTypeByName("usd").getProbForColumnSpecimen(sample)
    if (usdGuess || (!isNaN(sample) && name.match(/^(price|income|cost|revenue|budget|profit|amount|balance)$/i))) guesses.usd = 0.99
    if (isNumber && name.match(/(year|born)/i) && sampleStringLength === 4) guesses.year = 0.99
    if (isDate && name.match(/(year|born)/i)) guesses.year = 0.99
    if (isNumber && name.match(/(time|second|created|edited)/i) && sampleStringLength === 10) guesses.second = 0.99
    if (isNumber && name.match(/(time|second)/i) && sampleStringLength === 13) guesses.millisecond = 0.99
    const isValidDate = Column.getPrimitiveTypeByName("date").getProbForColumnSpecimen(sample)
    if (name.match(/(year|date|dob|birthday|day|month|time|birthdate|utc)/i) && isValidDate) guesses.date = 0.98
    else if (isValidDate && sampleType === "string" && sample.includes("/")) guesses.date = 0.81
    if (sampleType === "string" && sampleStringLength > 100) guesses.string = 0.98
    return guesses
  }
  _inferType() {
    const columnObj = this._getColDefObject()
    const sample = this._getSample()
    if (columnObj && columnObj.type && Column.getPrimitiveTypeByName(columnObj.type)) return Column.getPrimitiveTypeByName(columnObj.type)
    const guesses = Column._getColumnProbabilities(this.getColumnName(), this._getSample())
    let max = 0
    let bestGuess = null
    for (let typeScore in guesses) {
      if (guesses[typeScore] > max) {
        max = guesses[typeScore]
        bestGuess = typeScore
      }
    }
    if (bestGuess === "number" && typeof sample === "string") {
      if (sample.match(",")) bestGuess = "numberString"
    }
    if (bestGuess === "date" && typeof sample === "string") {
      if (Column.getPrimitiveTypeByName("day").getProbForColumnSpecimen(sample)) bestGuess = "day"
    }
    return Column.getPrimitiveTypeByName(bestGuess)
  }
  // Note: If it returns a string removes spaces
  static convertValueToNumeric(value, sourceType, destinationType, mathFn) {
    const destType = this.getPrimitiveTypeByName(destinationType)
    if (value === undefined || !destType || value === "") return ""
    const conversionFn = this._getConversionFn(sourceType, destinationType, value)
    const res = conversionFn(value)
    if (mathFn) return mathFn(res)
    return res
  }
  static _getConversionFn(sourceType, destinationType, value) {
    const sourceCol = this.getPrimitiveTypeByName(sourceType)
    const destinationCol = this.getPrimitiveTypeByName(destinationType)
    if (!sourceCol || !destinationCol) return destinationCol.fromStringToNumeric
    if (destinationCol.isTemporal() && sourceCol.isTemporal()) return val => destinationCol.fromDateToNumeric(sourceCol._fromStringToDate(val))
    return destinationCol.fromStringToNumeric
  }
}
const PrimitiveTypes = {
  AbstractPrimitiveType,
  BooleanType,
  ObjectType,
  USD,
  NumberCol,
  NumberString,
  Feet,
  IntType,
  UrlCol,
  HTMLCol,
  DirCol,
  PathCol,
  TextCol,
  StringCol,
  AbstractTemporal,
  MilliSecond,
  Second,
  DateCol,
  Day,
  Month,
  MonthDay,
  Week,
  Hour,
  Minute,
  Year,
  HourMinute,
  CodeCol
}
window.Column = Column
window.PrimitiveTypes = PrimitiveTypes
class Row {
  constructor(sourceObject = {}, table) {
    this._puid = this._getUniqueId()
    this._sourceObject = sourceObject
    this._table = table
  }
  _getUniqueId() {
    Row._uniqueId++
    return Row._uniqueId
  }
  destroy() {}
  _getRowTable() {
    return this._table
  }
  async destroyRow() {}
  getAsArray(headerRow) {
    const obj = this.rowToObjectWithOnlyNativeJavascriptTypes()
    return headerRow.map(col => obj[col])
  }
  getRowSourceObject() {
    return this._sourceObject
  }
  // todo: rowToObjectWithOnlyNativeJavascriptTypes method? Its numerics where we need and strings where we need.
  _parseIntoObjectWithOnlyNativeJavascriptTypes() {
    const columns = this._getRowTable().getColumnsMap()
    const typedNode = {}
    Object.keys(columns).forEach(colName => {
      typedNode[colName] = this._getRowValueFromSourceColOrOriginalCol(colName)
    })
    return typedNode
  }
  // why from source col? if we always copy, we shouldnt need that, correct? perhaps have an audit array of all operations on a row?
  _getRowValueFromSourceColOrOriginalCol(colName) {
    const columns = this._getRowTable().getColumnsMap()
    const destColumn = columns[colName]
    const sourceColName = destColumn.getSourceColumnName()
    const sourceCol = columns[sourceColName]
    // only use source if we still have access to it
    const val = sourceColName && sourceCol ? this._getRowValueFromOriginalOrSource(sourceColName, sourceCol.getPrimitiveTypeName(), destColumn.getPrimitiveTypeName()) : this.getRowOriginalValue(colName)
    const res = destColumn.getPrimitiveTypeObj().getAsNativeJavascriptType(val)
    const mathFn = destColumn.getMathFn()
    if (mathFn) return mathFn(res)
    return res
  }
  _getRowValueFromOriginalOrSource(sourceColName, sourceColType, destType) {
    return Column.convertValueToNumeric(this.getRowOriginalValue(sourceColName), sourceColType, destType)
  }
  rowToObjectWithOnlyNativeJavascriptTypes() {
    if (!this._objectWithOnlyNativeJavascriptTypes) this._objectWithOnlyNativeJavascriptTypes = this._parseIntoObjectWithOnlyNativeJavascriptTypes()
    return this._objectWithOnlyNativeJavascriptTypes
  }
  getRowKeys() {
    return Object.keys(this.getRowSourceObject())
  }
  getFirstValue() {
    return this.getRowOriginalValue(this.getRowKeys()[0])
  }
  // todo: get values from source/virtual columns
  getRowOriginalValue(column) {
    const value = this.getRowSourceObject()[column]
    return value === null ? "" : value
  }
  getRowHtmlSafeValue(columnName) {
    const val = this.getRowOriginalValue(columnName)
    return val === undefined ? "" : jtree.Utils.stripHtml(val.toString()).toString() // todo: cache this?
  }
  getHoverTitle() {
    return encodeURIComponent(this.rowToString().replace(/\n/g, " "))
  }
  getPuid() {
    return this._puid
  }
  rowToString() {
    return JSON.stringify(this.getRowSourceObject(), null, 2)
  }
}
Row._uniqueId = 0
window.Row = Row
var TableParserIds
;(function(TableParserIds) {
  TableParserIds["csv"] = "csv"
  TableParserIds["ssv"] = "ssv"
  TableParserIds["psv"] = "psv"
  TableParserIds["tsv"] = "tsv"
  TableParserIds["xml"] = "xml"
  TableParserIds["html"] = "html"
  TableParserIds["spaced"] = "spaced"
  TableParserIds["tree"] = "tree"
  TableParserIds["treeRows"] = "treeRows"
  TableParserIds["sections"] = "sections"
  TableParserIds["txt"] = "txt"
  TableParserIds["list"] = "list"
  TableParserIds["text"] = "text"
  TableParserIds["jsonVector"] = "jsonVector"
  TableParserIds["json"] = "json"
  TableParserIds["jsonDataTableWithHeader"] = "jsonDataTableWithHeader"
  TableParserIds["jsonMap"] = "jsonMap"
  TableParserIds["jsonCounts"] = "jsonCounts"
})(TableParserIds || (TableParserIds = {}))
// todo: detect mixed format, like a csv file with a header. and then suggest ignore that part, or splitting it out?
// maybe we could split a string into sections, and say "we've detected 3 sections, which one do you want to use"?
// todo: split csv into normal csv and advanced delimited.
// todo: allow for metadata like filename and filetype header
class RowStringSpecimen {
  constructor(str) {
    const trimmedStr = str.trim()
    const lines = trimmedStr.split(/\n/g)
    const firstLine = lines[0]
    const strCount = (str, reg) => (str.match(reg) || []).length
    // todo: do these things lazily.
    this.trimmedStr = trimmedStr
    this.lines = lines
    this.firstLine = firstLine
    this.lineCount = lines.length
    this.indentedLineCount = strCount(trimmedStr, /\n /g)
    this.blankLineCount = strCount(trimmedStr, /\n\n/g)
    this.commaCount = strCount(trimmedStr, /\,/g)
    this.tabCount = strCount(trimmedStr, /\t/g)
    this.verticalBarCount = strCount(trimmedStr, /\|/g)
    this.firstLineCommaCount = strCount(firstLine, /\,/g)
    this.firstLineTabCount = strCount(firstLine, /\t/g)
    this.firstLineSpaceCount = strCount(firstLine, / /g)
    this.firstLineVerticalBarCount = strCount(firstLine, /\|/g)
  }
  getParsedJsonAttemptResult() {
    if (this._parsedJsonObject) return this._parsedJsonObject
    try {
      this._parsedJsonObject = { ok: true, result: JSON.parse(this.trimmedStr) }
    } catch (err) {
      this._parsedJsonObject = { ok: false }
    }
    return this._parsedJsonObject
  }
}
class AbstractTableParser {
  isNodeJs() {
    return typeof exports !== "undefined"
  }
}
class AbstractJsonParser extends AbstractTableParser {
  getParserId() {
    return TableParserIds.json
  }
  getProbForRowSpecimen(specimen) {
    return 0
  }
  getExample() {
    return JSON.stringify([{ name: "joe", age: 2 }, { name: "mike", age: 4 }])
  }
  _parseTableInputsFromString(str) {
    const obj = JSON.parse(str)
    return { rows: obj instanceof Array ? obj : [obj] }
  }
}
class JsonParser extends AbstractJsonParser {}
class AbstractJsonArrayParser extends AbstractJsonParser {
  getExample() {
    return JSON.stringify([{ name: "jane", age: 33 }, { name: "bill", age: 25 }])
  }
  getProbForRowSpecimen(specimen) {
    const str = specimen.trimmedStr
    if (str.match(/^\s*\[/) && str.match(/\]\s*$/)) return 0.98
    return 0
  }
}
class JsonArrayParser extends AbstractJsonArrayParser {}
class JsonDataTableWithHeaderParser extends AbstractJsonArrayParser {
  getExample() {
    return JSON.stringify([["country", "income", "health", "population"], ["Afghanistan", 1925, "57.63", 32526562], ["Albania", 10620, "76", 2896679]])
  }
  _parseTableInputsFromString(str) {
    return { rows: jtree.Utils.javascriptTableWithHeaderRowToObjects(JSON.parse(str)) }
  }
  getParserId() {
    return TableParserIds.jsonDataTableWithHeader
  }
  getProbForRowSpecimen(specimen) {
    const result = specimen.getParsedJsonAttemptResult()
    if (!result.ok) return 0
    if (JsonDataTableWithHeaderParser.isJavaScriptDataTable(result.result)) return 0.99
    return 0.001
  }
  static isJavaScriptDataTable(obj) {
    const isAnArray = obj instanceof Array
    if (!isAnArray) return false
    const isAnArrayOfArrays = obj.every(row => row instanceof Array)
    if (!isAnArrayOfArrays) return false
    if (obj.length < 3) return false
    const firstRowTypes = obj[0].map(item => typeof item === "string").join(" ")
    const secondRowTypes = obj[1].map(item => typeof item === "string").join(" ")
    const thirdRowTypes = obj[2].map(item => typeof item === "string").join(" ")
    const firstRowIsJustStrings = !firstRowTypes.replace(/true/g, "").trim()
    if (secondRowTypes === thirdRowTypes && secondRowTypes !== firstRowTypes && firstRowIsJustStrings) return true
    return false
  }
}
class AbstractJsonObjectParser extends AbstractJsonParser {
  getProbForRowSpecimen(specimen) {
    const str = specimen.trimmedStr
    if (str.match(/^\s*\{/) && str.match(/\}\s*$/)) return 0.99
    return 0
  }
}
class JsonObjectParser extends AbstractJsonObjectParser {}
// formerley flatobject
class JsonMapParser extends AbstractJsonObjectParser {
  getExample() {
    return JSON.stringify({ person1: { name: "joe", age: 2 }, person2: { name: "mike", age: 4 } })
  }
  getParserId() {
    return TableParserIds.jsonMap
  }
  _parseTableInputsFromString(str) {
    // todo: should we preserve keys?
    return { rows: Object.values(JSON.parse(str)) }
  }
}
// formerly flatarray
class JsonVectorParser extends AbstractJsonArrayParser {
  getExample() {
    return JSON.stringify([23, 32, 41])
  }
  getParserId() {
    return TableParserIds.jsonVector
  }
  getProbForRowSpecimen(specimen) {
    const result = specimen.getParsedJsonAttemptResult()
    if (!result.ok) return 0
    if (!(result.result instanceof Array)) return 0
    return result.result.filter(item => item && typeof item === "object" && item.hasOwnProperty).length === 0 ? 1 : 0
    return 0
  }
  _parseTableInputsFromString(str) {
    return {
      rows: JSON.parse(str).map(num => {
        return { value: num }
      })
    }
  }
}
class JsonCountMapParser extends AbstractJsonObjectParser {
  getParserId() {
    return TableParserIds.jsonCounts
  }
  getProbForRowSpecimen(specimen) {
    const result = specimen.getParsedJsonAttemptResult()
    if (!result.ok) return 0
    const keys = Object.keys(result.result)
    if (keys.length < 2) return 0
    return !keys.some(key => typeof result.result[key] !== "number") ? 1 : 0
    return 0
  }
  getExample() {
    return JSON.stringify({ h1: 10, h2: 5, h3: 2 })
  }
  _parseTableInputsFromString(str) {
    const obj = JSON.parse(str)
    return {
      rows: Object.keys(obj).map(key => {
        return {
          name: key,
          count: obj[key]
        }
      })
    }
  }
}
// todo: remove?
class AbstractJTreeTableParser extends AbstractTableParser {
  _parseTableInputsFromString(str) {
    return {
      rows: this._parseTrees(str)
        .filter(node => node.length)
        .map(node => node.toObject())
    }
  }
  _parseTrees(str) {
    return []
  }
}
class CsvParser extends AbstractJTreeTableParser {
  getExample() {
    return `name,age,height
john,12,50`
  }
  _parseTrees(str) {
    return jtree.TreeNode.fromCsv(str)
  }
  getProbForRowSpecimen(specimen) {
    if (!specimen.firstLineCommaCount) return 0
    if (specimen.blankLineCount) return 0.05
    return 0.49
  }
  getParserId() {
    return TableParserIds.csv
  }
}
class TsvParser extends AbstractJTreeTableParser {
  getExample() {
    return `name\tage\theight
john\t12\t50`
  }
  _parseTrees(str) {
    return jtree.TreeNode.fromTsv(str)
  }
  getProbForRowSpecimen(specimen) {
    if (!specimen.firstLineTabCount) return 0
    else if (specimen.tabCount > 5) return 0.9
    return 0.25
  }
  getParserId() {
    return TableParserIds.tsv
  }
}
class PsvParser extends AbstractJTreeTableParser {
  getParserId() {
    return TableParserIds.psv
  }
  getExample() {
    return `name|age
mike|33`
  }
  _parseTrees(str) {
    return jtree.TreeNode.fromDelimited(str, "|", '"')
  }
  getProbForRowSpecimen(specimen) {
    // vertical bar separated file
    if (!specimen.firstLineVerticalBarCount) return 0
    else if (specimen.verticalBarCount >= specimen.lineCount) return 0.8
    return 0.01
  }
}
class SsvParser extends AbstractJTreeTableParser {
  getExample() {
    return `name age height
john 12 50`
  }
  getParserId() {
    return TableParserIds.ssv
  }
  _parseTrees(str) {
    return jtree.TreeNode.fromSsv(str)
  }
  getProbForRowSpecimen(specimen) {
    if (!specimen.firstLineSpaceCount) return 0
    if (specimen.blankLineCount) return 0.05
    return 0.11
  }
}
class XmlParser extends AbstractJTreeTableParser {
  getProbForRowSpecimen(specimen) {
    return specimen.trimmedStr.match(/^ *\</) ? 1 : 0
  }
  getExample() {
    return `<person>
 <name>bob</name><age>32</age></person>`
  }
  getParserId() {
    return TableParserIds.xml
  }
  _parseTrees(str) {
    // todo: fix this! Create an XML Tree Language
    if (this.isNodeJs()) return new jtree.TreeNode(str)
    return jtree.TreeNode.fromXml(str)
  }
}
class HtmlParser extends AbstractJTreeTableParser {
  getProbForRowSpecimen(specimen) {
    return specimen.trimmedStr.match(/^(\<\!doctype html\>|\<html|\<div)/i) ? 1 : 0
  }
  getExample() {
    return `<!doctype html>
<html>
 <head>bam</head></html>`
  }
  getParserId() {
    return TableParserIds.html
  }
  _parseTrees(str) {
    if (this.isNodeJs()) return new jtree.TreeNode(str)
    return jtree.TreeNode.fromXml(str)
  }
}
class TreeRowsParser extends AbstractJTreeTableParser {
  getExample() {
    return `person
 name john
 age 12
 height 50`
  }
  _parseTableInputsFromString(str) {
    // todo: get columns on first pass.
    const rows = new jtree.TreeNode(str)
    return {
      rows: rows.map(node => node.toObject()),
      columnDefinitions: rows.getColumnNames().map(name => {
        return { name: name }
      })
    }
  }
  getProbForRowSpecimen(specimen) {
    if (specimen.indentedLineCount < 1) return 0
    return 0.1
  }
  getParserId() {
    return TableParserIds.treeRows
  }
}
class TreeParser extends AbstractJTreeTableParser {
  getExample() {
    return `country
 name USA
 state
  name MA
  city
   name Brockton`
  }
  _parseTrees(str) {
    // todo: add tests. Detected value(s) or undefined subtrees, treating as object.
    const newTree = new jtree.TreeNode()
    newTree.pushContentAndChildren(undefined, str instanceof jtree.TreeNode ? str : new jtree.TreeNode(str))
    return newTree
  }
  getProbForRowSpecimen(specimen) {
    return 0
  }
  getParserId() {
    return TableParserIds.tree
  }
}
class SpacedParser extends AbstractTableParser {
  getExample() {
    return `name john
age 12

name mary
age 20`
  }
  getParserId() {
    return TableParserIds.spaced
  }
  getProbForRowSpecimen(specimen) {
    if (specimen.blankLineCount > 10) return 0.95
    return 0.05
  }
  _parseTableInputsFromString(str) {
    // todo: clean this up. it looks like this is just trees, but not indented, with a newline as a delimiter.
    const headerBreak = str.indexOf("\n\n")
    const header = str.substr(0, headerBreak)
    let names = header.split(/\n/g)
    const rest = str
      .substr(headerBreak + 2)
      .replace(/\n\n/g, "\n")
      .trim()
      .split("\n")
    const nodeCount = names.length
    const lineCount = rest.length
    const rows = []
    // todo: should we do this here?
    names = names.map(name => name.replace(/ /g, ""))
    for (let lineNumber = 0; lineNumber < lineCount; lineNumber = lineNumber + nodeCount) {
      const obj = {}
      names.forEach((col, index) => {
        obj[col] = rest[lineNumber + index].trim()
      })
      rows.push(obj)
    }
    return { rows: rows }
  }
}
class SectionsParser extends AbstractTableParser {
  getExample() {
    return `name
age

john
12

mary
20`
  }
  getProbForRowSpecimen() {
    return 0
  }
  getParserId() {
    return TableParserIds.sections
  }
  _parseTableInputsFromString(str) {
    const firstDoubleNewline = str.indexOf("\n\n")
    const tiles = [str.slice(0, firstDoubleNewline), str.slice(firstDoubleNewline + 1)]
    const header = tiles.shift()
    const names = header.split(/\n/g)
    const length = names.length
    const lines = tiles[0].trim().split(/\n/g)
    const lineCount = lines.length
    const rowCount = lineCount / length
    const rows = []
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
      const startLine = rowIndex * length
      const values = lines.slice(startLine, startLine + length)
      const obj = {}
      names.forEach((name, colIndex) => (obj[name] = values[colIndex]))
      rows.push(obj)
    }
    return { rows: rows }
  }
}
class ListParser extends AbstractTableParser {
  getExample() {
    return `john doe
frank jones`
  }
  getProbForRowSpecimen() {
    return 0
  }
  getParserId() {
    return TableParserIds.list
  }
  _parseTableInputsFromString(str) {
    return {
      rows: str.split(/\n/g).map((line, index) => {
        return {
          index: index,
          name: line
        }
      })
    }
  }
}
class TextListParser extends ListParser {
  getParserId() {
    return TableParserIds.txt
  }
}
class TextParser extends AbstractTableParser {
  getParserId() {
    return TableParserIds.text
  }
  getExample() {
    return "hello world"
  }
  getProbForRowSpecimen(specimen) {
    if (specimen.blankLineCount) return 0.12
    return 0.05
  }
  _parseTableInputsFromString(str) {
    return { rows: [{ text: str }] }
  }
}
class TableParser {
  constructor() {
    this._parsers = [
      new CsvParser(),
      new TsvParser(),
      new SsvParser(),
      new PsvParser(),
      new TreeRowsParser(),
      new TreeParser(),
      new XmlParser(),
      new HtmlParser(),
      new TextParser(),
      new SectionsParser(),
      new SpacedParser(),
      new ListParser(),
      new TextListParser(),
      new JsonParser(),
      new JsonArrayParser(),
      new JsonDataTableWithHeaderParser(),
      new JsonVectorParser(),
      new JsonMapParser(),
      new JsonCountMapParser()
    ]
    this._parserMap = {}
    this._parsers.forEach(parser => {
      const name = parser.getParserId()
      if (!name) return // only allow leafs to be used as names?
      this._parserMap[name] = parser
    })
  }
  getAllParsers() {
    return this._getParsersArray()
  }
  getAllTableParserIds() {
    return Object.keys(this._getParserMap())
  }
  getExample(parserId) {
    return this._getParser(parserId).getExample()
  }
  _getParser(parserId) {
    const options = this._getParserMap()
    return options[parserId] || options.text // todo: surface an error.
  }
  _getParserMap() {
    return this._parserMap
  }
  _getParsersArray() {
    return this._parsers
  }
  // todo: remove this?
  parseTableInputsFromObject(data, parserId) {
    if (data instanceof Array) {
      if (JsonDataTableWithHeaderParser.isJavaScriptDataTable(data)) return { rows: jtree.Utils.javascriptTableWithHeaderRowToObjects(data) }
      // test to see if it's primitives
      if (typeof data[0] === "object") return { rows: data }
      return { rows: data.map(row => (typeof row === "object" ? row : { value: row })) }
    } else if (parserId === TableParserIds.jsonMap) return { rows: Object.values(data) }
    return { rows: [data] }
  }
  // todo: should this be inferAndParse? or 2 methods? parse and inferAndParse?
  parseTableInputsFromString(str = "", parserId) {
    str = str.trim() // Remove empty lines at end of string, which seem to be common.
    if (!str) return { rows: [] }
    parserId = parserId || this.guessTableParserId(str)
    try {
      return this._getParser(parserId)._parseTableInputsFromString(str)
    } catch (err) {
      console.error(err)
      const snippet = str.substr(0, 30).replace(/[\n\r]/g, " ")
      throw new Error(`Failed parsing string '${snippet}...' using parser '${parserId}'`)
    }
  }
  guessProbabilitiesForAllTableParsers(str) {
    const parsers = this._getParsersArray()
    const length = parsers.length
    const probabilities = {}
    const specimen = new RowStringSpecimen(str)
    for (let index = 0; index < parsers.length; index++) {
      const parser = parsers[index]
      const probability = parser.getProbForRowSpecimen(specimen)
      const name = parser.getParserId()
      if (probability === 1) {
        const exact = {}
        exact[name] = 1
        return exact
      }
      probabilities[name] = probability
    }
    return probabilities
  }
  guessTableParserId(str) {
    const probabilities = this.guessProbabilitiesForAllTableParsers(str)
    let maxScore = 0
    let bestGuess = null
    for (let option in probabilities) {
      if (probabilities[option] > maxScore) {
        maxScore = probabilities[option]
        bestGuess = option
      }
    }
    return bestGuess
  }
}
window.TableParser = TableParser
const DummyDataSets = {
  flowPrograms: [
    ["filename", "bytes", "link"],
    [
      "hello.flow",
      `samples.iris
 tables.basic`,
      ""
    ]
  ],
  amazonPurchases: [
    ["OrderDate", "Title", "Category", "ItemTotal"],
    [1329386400000, "3D Math Primer for Graphics and Game Development (Wordware Game Math Library)", "Paperback", "26.2"],
    [1261735200000, "A Mathematician Reads the Newspaper", "Paperback", "1.19"],
    [1447840800000, "A Most Incomprehensible Thing: Notes Towards a Very Gentle Introduction to the Mathematics of Relativity", "Paperback", "14.63"],
    [1464429600000, "From Mathematics to Generic Programming", "Paperback", "34.37"],
    [1268215200000, "Innumeracy: Mathematical Illiteracy and Its Consequences", "Paperback", "9.89"],
    [1268215200000, "Irreligion: A Mathematician Explains Why the Arguments for God Just Don't Add Up", "Paperback", "9.89"],
    [1379844000000, "Mathematics and the Imagination", "Paperback", "5.3"],
    [1410688800000, "Medical Math (Laminated Reference Guide; Quick Study Academic)", "Pamphlet", "3.78"],
    [1268215200000, "Once Upon A Number: The Hidden Mathematical Logic Of Stories", "Paperback", "14.35"],
    [1408528800000, "The Language of Mathematics: Making the Invisible Visible", "Paperback", "18.37"]
  ],
  waterBill: [
    ["Amount", "PaidOn", "Gallons"],
    ["$64.86", "1/10/2018", 2087],
    ["$73.32", "1/28/2018", 2451],
    ["$62.65", "2/26/2018", 1968],
    ["$71.51", "3/25/2018", 2365],
    ["$65.03", "4/23/2018", 2075],
    ["$81.39", "5/15/2018", 2757],
    ["$65.01", "6/15/2018", 2047],
    ["$93.09", "7/10/2018", 3051],
    ["$196.58", "8/25/2018", 7309],
    ["$130.68", "9/10/2018", 4597],
    ["$55.03", "10/14/2018", 1484],
    ["$63.44", "11/7/2018", 1967],
    ["$71.88", "12/12/2018", 2335],
    ["$53.18", "2/3/2019", 1483],
    ["$52.05", "3/8/2019", 1429],
    ["$54.73", "4/28/2019", 1544]
  ],
  gapMinder: [
    ["country", "income", "health", "population"],
    ["Afghanistan", 1925, "57.63", 32526562],
    ["Albania", 10620, "76", 2896679],
    ["Algeria", 13434, "76.5", 39666519],
    ["Andorra", 46577, "84.1", 70473],
    ["Angola", 7615, "61", 25021974],
    ["Antigua and Barbuda", 21049, "75.2", 91818],
    ["Argentina", 17344, "76.2", 43416755],
    ["Armenia", 7763, "74.4", 3017712],
    ["Australia", 44056, "81.8", 23968973],
    ["Austria", 44401, "81", 8544586],
    ["Azerbaijan", 16986, "72.9", 9753968],
    ["Bahamas", 22818, "72.3", 388019],
    ["Bahrain", 44138, "79.2", 1377237],
    ["Bangladesh", 3161, "70.1", 160995642],
    ["Barbados", 12984, "75.8", 284215],
    ["Belarus", 17415, "70.4", 9495826],
    ["Belgium", 41240, "80.4", 11299192],
    ["Belize", 8501, "70", 359287],
    ["Benin", 1830, "65.5", 10879829],
    ["Bhutan", 7983, "70.2", 774830],
    ["Bolivia", 6295, "72.3", 10724705],
    ["Bosnia and Herzegovina", 9833, "77.9", 3810416],
    ["Botswana", 17196, "66.4", 2262485],
    ["Brazil", 15441, "75.6", 207847528],
    ["Brunei", 73003, "78.7", 423188],
    ["Bulgaria", 16371, "74.9", 7149787],
    ["Burkina Faso", 1654, "62.8", 18105570],
    ["Burundi", 777, "60.4", 11178921],
    ["Cambodia", 3267, "68.4", 15577899],
    ["Cameroon", 2897, "59.5", 23344179],
    ["Canada", 43294, "81.7", 35939927],
    ["Cape Verde", 6514, "74.6", 520502],
    ["Central African Republic", 599, "53.8", 4900274],
    ["Chad", 2191, "57.7", 14037472],
    ["Chile", 22465, "79.3", 17948141],
    ["China", 13334, "76.9", 1376048943],
    ["Colombia", 12761, "75.8", 48228704],
    ["Comoros", 1472, "64.1", 788474],
    ["Congo, Dem. Rep.", 809, "58.3", 77266814],
    ["Congo, Rep.", 6220, "61.9", 4620330],
    ["Costa Rica", 14132, "80", 4807850],
    ["Cote d'Ivoire", 3491, "60.33", 22701556],
    ["Croatia", 20260, "78", 4240317],
    ["Cuba", 21291, "78.5", 11389562],
    ["Cyprus", 29797, "82.6", 1165300],
    ["Czech Republic", 29437, "78.6", 10543186],
    ["Denmark", 43495, "80.1", 5669081],
    ["Djibouti", 3139, "64.63", 887861],
    ["Dominica", 10503, "74.6", 72680],
    ["Dominican Republic", 12837, "73.8", 10528391],
    ["Ecuador", 10996, "75.2", 16144363],
    ["Egypt", 11031, "71.3", 91508084],
    ["El Salvador", 7776, "74.1", 6126583],
    ["Equatorial Guinea", 31087, "60.63", 845060],
    ["Eritrea", 1129, "62.9", 5227791],
    ["Estonia", 26812, "76.8", 1312558],
    ["Ethiopia", 1520, "63.6", 99390750],
    ["Fiji", 7925, "66.3", 892145],
    ["Finland", 38923, "80.8", 5503457],
    ["France", 37599, "81.9", 64395345],
    ["Gabon", 18627, "60.53", 1725292],
    ["Gambia", 1644, "65.1", 1990924],
    ["Georgia", 7474, "73.3", 3999812],
    ["Germany", 44053, "81.1", 80688545],
    ["Ghana", 4099, "65.5", 27409893],
    ["Greece", 25430, "79.8", 10954617],
    ["Grenada", 11593, "71.7", 106825],
    ["Guatemala", 7279, "73.1", 16342897],
    ["Guinea", 1225, "60.8", 12608590],
    ["Guinea-Bissau", 1386, "53.4", 1844325],
    ["Guyana", 6816, "64.4", 767085],
    ["Haiti", 1710, "65.3", 10711067],
    ["Honduras", 4270, "72.4", 8075060],
    ["Hungary", 24200, "76.2", 9855023],
    ["Iceland", 42182, "82.8", 329425],
    ["India", 5903, "66.8", 1311050527],
    ["Indonesia", 10504, "70.9", 257563815],
    ["Iran", 15573, "78.5", 79109272],
    ["Iraq", 14646, "72.1", 36423395],
    ["Ireland", 47758, "80.4", 4688465],
    ["Israel", 31590, "82.4", 8064036],
    ["Italy", 33297, "82.1", 59797685],
    ["Jamaica", 8606, "75.5", 2793335],
    ["Japan", 36162, "83.5", 126573481],
    ["Jordan", 11752, "78.3", 7594547],
    ["Kazakhstan", 23468, "68.2", 17625226],
    ["Kenya", 2898, "66.63", 46050302],
    ["Kiribati", 1824, "62.4", 112423],
    ["Kuwait", 82633, "80.7", 3892115],
    ["Kyrgyz Republic", 3245, "69", 5939962],
    ["Lao", 5212, "66.4", 6802023],
    ["Latvia", 23282, "75.7", 1970503],
    ["Lebanon", 17050, "78.5", 5850743],
    ["Lesotho", 2598, "48.5", 2135022],
    ["Liberia", 958, "63.9", 4503438],
    ["Libya", 17261, "76.2", 6278438],
    ["Lithuania", 26665, "75.4", 2878405],
    ["Luxembourg", 88314, "81.1", 567110],
    ["Macedonia, FYR", 12547, "77", 2078453],
    ["Madagascar", 1400, "64.7", 24235390],
    ["Malawi", 799, "60.22", 17215232],
    ["Malaysia", 24320, "75.1", 30331007],
    ["Maldives", 14408, "79.5", 363657],
    ["Mali", 1684, "57.6", 17599694],
    ["Malta", 30265, "82.1", 418670],
    ["Marshall Islands", 3661, "65.1", 52993],
    ["Mauritania", 3877, "65.7", 4067564],
    ["Mauritius", 18350, "73.9", 1273212],
    ["Mexico", 16850, "74.5", 127017224],
    ["Micronesia, Fed. Sts.", 3510, "67", 104460],
    ["Moldova", 4896, "72.7", 4068897],
    ["Mongolia", 11819, "65.3", 2959134],
    ["Montenegro", 14833, "75.8", 625781],
    ["Morocco", 7319, "74.7", 34377511],
    ["Mozambique", 1176, "56.4", 27977863],
    ["Myanmar", 4012, "67.9", 53897154],
    ["Namibia", 10040, "61", 2458830],
    ["Nepal", 2352, "71.2", 28513700],
    ["Netherlands", 45784, "80.6", 16924929],
    ["New Zealand", 34186, "80.6", 4528526],
    ["Nicaragua", 4712, "76.8", 6082032],
    ["Niger", 943, "62.2", 19899120],
    ["Nigeria", 5727, "61.33", 182201962],
    ["North Korea", 1390, "71.4", 25155317],
    ["Norway", 64304, "81.6", 5210967],
    ["Oman", 48226, "75.7", 4490541],
    ["Pakistan", 4743, "66.5", 188924874],
    ["Panama", 20485, "78.2", 3929141],
    ["Papua New Guinea", 2529, "60.6", 7619321],
    ["Paraguay", 8219, "73.9", 6639123],
    ["Peru", 11903, "77.5", 31376670],
    ["Philippines", 6876, "70.2", 100699395],
    ["Poland", 24787, "77.3", 38611794],
    ["Portugal", 26437, "79.8", 10349803],
    ["Qatar", 132877, "82", 2235355],
    ["Romania", 19203, "76.8", 19511324],
    ["Russia", 23038, "73.13", 143456918],
    ["Rwanda", 1549, "66.53", 11609666],
    ["Samoa", 5558, "72.2", 193228],
    ["Sao Tome and Principe", 3003, "68.8", 190344],
    ["Saudi Arabia", 52469, "78.1", 31540372],
    ["Senegal", 2251, "66.1", 15129273],
    ["Serbia", 12908, "78.1", 8850975],
    ["Seychelles", 25684, "73.7", 96471],
    ["Sierra Leone", 2085, "58.5", 6453184],
    ["Singapore", 80794, "82.1", 5603740],
    ["Slovak Republic", 27204, "76.4", 5426258],
    ["Slovenia", 28550, "80.2", 2067526],
    ["Solomon Islands", 2047, "64.1", 583591],
    ["Somalia", 624, "58.7", 10787104],
    ["South Africa", 12509, "63.72", 54490406],
    ["South Korea", 34644, "80.7", 50293439],
    ["South Sudan", 3047, "58", 12339812],
    ["Spain", 32979, "81.7", 46121699],
    ["Sri Lanka", 10624, "76.5", 20715010],
    ["St. Lucia", 9997, "74.5", 184999],
    ["St. Vincent and the Grenadines", 10435, "72.9", 109462],
    ["Sudan", 3975, "69.5", 40234882],
    ["Suriname", 17125, "70.5", 542975],
    ["Swaziland", 6095, "51.5", 1286970],
    ["Sweden", 44892, "82", 9779426],
    ["Switzerland", 56118, "82.9", 8298663],
    ["Syria", 4637, "70.26", 18502413],
    ["Tajikistan", 2582, "71", 8481855],
    ["Tanzania", 2571, "63.43", 53470420],
    ["Thailand", 14512, "75.1", 67959359],
    ["Timor-Leste", 2086, "72.4", 1184765],
    ["Togo", 1433, "64.23", 7304578],
    ["Tonga", 5069, "70.5", 106170],
    ["Trinidad and Tobago", 30113, "71.4", 1360088],
    ["Tunisia", 11126, "77.3", 11253554],
    ["Turkey", 19360, "76.5", 78665830],
    ["Turkmenistan", 15865, "67.9", 5373502],
    ["Uganda", 1680, "60.8", 39032383],
    ["Ukraine", 8449, "72.1", 44823765],
    ["United Arab Emirates", 60749, "76.6", 9156963],
    ["United Kingdom", 38225, "81.4", 64715810],
    ["United States", 53354, "79.1", 321773631],
    ["Uruguay", 20438, "77.3", 3431555],
    ["Uzbekistan", 5598, "70.1", 29893488],
    ["Vanuatu", 2912, "65", 264652],
    ["Venezuela", 15753, "75.8", 31108083],
    ["Vietnam", 5623, "76.5", 93447601],
    ["West Bank and Gaza", 4319, "75.2", 4668466],
    ["Yemen", 3887, "67.6", 26832215],
    ["Zambia", 4034, "58.96", 16211767],
    ["Zimbabwe", 1801, "60.01", 15602751]
  ],
  emojis: [["animal", "count"], ["🐄", 9], ["🐖", 12], ["🐏", 3]],
  telescopes: [
    ["Name", "Type", "Url", "Location", "OperatedBy", "FundedBy"],
    ["Hubble Space Telescope", "Space Telescope", "https://en.wikipedia.org/wiki/Hubble_Space_Telescope", "Space", "NASA", "NASA"],
    ["LIGO Hanford", "Gravity Wave Observatory", "https://www.ligo.caltech.edu/WA", "Richland, WA, USA", "Caltech", "National Science Foundation"],
    ["LIGO Livingston", "Gravity Wave Observatory", "https://www.ligo.caltech.edu/LA", "Livingston, LA, USA", "MIT", "National Science Foundation"],
    [
      "Gran Telescopio Canarias (GTC)",
      "Astronomical Observatory",
      "http://www.gtc.iac.es/gtc/gtc.php",
      "La Palma, Garafía, Spain ",
      "IAC",
      "Observatorio Astronómico de Canarias, National Autonomous University of Mexico, University of Florida Edit this on Wikidata"
    ],
    [
      "Hobby–Eberly Telescope",
      "Astronomical Observatory",
      "http://mcdonaldobservatory.org/research/telescopes/HET",
      "Davis Mountains, Texas, US",
      "Stanford University & Ludwig Maximilians University of Munich and Georg August University of Göttingen",
      "YarCom Inc. and the Lott family "
    ]
  ],
  markdown: [
    ["text"],
    [
      `# My header
## My subheader
Hello world`
    ]
  ],
  webPages: [["name", "url"]],
  outerSpace: [
    ["text"],
    [
      `universe
 galaxies
  milkyWay
   solarSystems
    solarSystem
     stars
      sun
     planets
      mercury
      venus
      earth
       moons
        moon
      mars
      jupiter
      saturn
      uranus
      neptune
      pluto`
    ]
  ],
  wordCounts: [
    ["word", "count"],
    ["Two", 2],
    ["roads", 2],
    ["diverged", 2],
    ["in", 3],
    ["a", 3],
    ["yellow", 1],
    ["wood", 2],
    ["And", 6],
    ["sorry", 1],
    ["I", 9],
    ["could", 2],
    ["not", 1],
    ["travel", 1],
    ["both", 2],
    ["be", 2],
    ["one", 3],
    ["traveler", 1],
    ["long", 1],
    ["stood", 1],
    ["looked", 1]
  ],
  treeProgram: [
    ["source"],
    [
      `samples.iris
 group.by Species
  tables.basic
 columns.first 3`
    ]
  ],
  poem: [
    ["text"],
    [
      `Two roads diverged in a yellow wood,
And sorry I could not travel both
And be one traveler, long I stood
And looked down one as far as I could
To where it bent in the undergrowth;

Then took the other, as just as fair,
And having perhaps the better claim,
Because it was grassy and wanted wear;
Though as for that the passing there
Had worn them really about the same,

And both that morning equally lay
In leaves no step had trodden black.
Oh, I kept the first for another day!
Yet knowing how way leads on to way,
I doubted if I should ever come back.

I shall be telling this with a sigh
Somewhere ages and ages hence:
Two roads diverged in a wood, and I—
I took the one less traveled by,
And that has made all the difference.`
    ]
  ],
  playerGoals: [["PlayerGoals", "Goals"], ["Player1", 11], ["Player2", 2], ["Player3", 2], ["Player4", 2], ["Player5", 7]],
  patients: [["Patient", "Gender", "Weight"], ["Patient1", "Girl", "3.31"], ["Patient2", "Male", "2.8"], ["Patient3", "Male", "3.7"], ["Patient4", "Girl", "2.5"], ["Patient5", "Girl", "2.8"]],
  regionalMarkets: [
    ["Location", "Parent", "Market trade volume (size)", "Market increase/decrease (color)"],
    ["Global", null, 0, 0],
    ["America", "Global", 0, 0],
    ["Europe", "Global", 0, 0],
    ["Asia", "Global", 0, 0],
    ["Australia", "Global", 0, 0],
    ["Africa", "Global", 0, 0],
    ["Brazil", "America", 11, 10],
    ["USA", "America", 52, 31],
    ["Mexico", "America", 24, 12],
    ["Canada", "America", 16, -23],
    ["France", "Europe", 42, -11],
    ["Germany", "Europe", 31, -2],
    ["Sweden", "Europe", 22, -13],
    ["Italy", "Europe", 17, 4],
    ["UK", "Europe", 21, -5],
    ["China", "Asia", 36, 4],
    ["Japan", "Asia", 20, -12],
    ["India", "Asia", 40, 63],
    ["Laos", "Asia", 4, 34],
    ["Mongolia", "Asia", 1, -5],
    ["Israel", "Asia", 12, 24],
    ["Iran", "Asia", 18, 13],
    ["Pakistan", "Asia", 11, -52],
    ["Egypt", "Africa", 21, 0],
    ["S. Africa", "Africa", 30, 43],
    ["Sudan", "Africa", 12, 2],
    ["Congo", "Africa", 10, 12],
    ["Zaire", "Africa", 8, 10]
  ],
  stockPrice: [
    ["Step", "Price"],
    [0, 0],
    [1, 10],
    [2, 23],
    [3, 17],
    [4, 18],
    [5, 9],
    [6, 11],
    [7, 27],
    [8, 33],
    [9, 40],
    [10, 32],
    [11, 35],
    [12, 30],
    [13, 40],
    [14, 42],
    [15, 47],
    [16, 44],
    [17, 48],
    [18, 52],
    [19, 54],
    [20, 42],
    [21, 55],
    [22, 56],
    [23, 57],
    [24, 60],
    [25, 50],
    [26, 52],
    [27, 51],
    [28, 49],
    [29, 53],
    [30, 55],
    [31, 60],
    [32, 61],
    [33, 59],
    [34, 62],
    [35, 65],
    [36, 62],
    [37, 58],
    [38, 55],
    [39, 61],
    [40, 64],
    [41, 65],
    [42, 63],
    [43, 66],
    [44, 67],
    [45, 69],
    [46, 69],
    [47, 70],
    [48, 72],
    [49, 68],
    [50, 66],
    [51, 65],
    [52, 67],
    [53, 70],
    [54, 71],
    [55, 72],
    [56, 73],
    [57, 75],
    [58, 70],
    [59, 68],
    [60, 64],
    [61, 60],
    [62, 65],
    [63, 67],
    [64, 68],
    [65, 69],
    [66, 70],
    [67, 72],
    [68, 75],
    [69, 80]
  ]
}
window.DummyDataSets = DummyDataSets
class PivotTable {
  constructor(rows, inputColumns, outputColumns) {
    this._columns = {}
    this._rows = rows
    inputColumns.forEach(col => (this._columns[col.name] = col))
    outputColumns.forEach(col => (this._columns[col.name] = col))
  }
  _getGroups(allRows, groupByColNames) {
    const rowsInGroups = new Map()
    allRows.forEach(row => {
      const groupKey = groupByColNames.map(col => row[col].toString().replace(/ /g, "")).join(" ")
      if (!rowsInGroups.has(groupKey)) rowsInGroups.set(groupKey, [])
      rowsInGroups.get(groupKey).push(row)
    })
    return rowsInGroups
  }
  getNewRows(groupByCols) {
    // make new trees
    const rowsInGroups = this._getGroups(this._rows, groupByCols)
    // Any column in the group should be reused by the children
    const columns = [
      {
        name: "count",
        type: "number",
        min: 0
      }
    ]
    groupByCols.forEach(colName => columns.push(this._columns[colName]))
    const colsToReduce = Object.values(this._columns).filter(col => !!col.reduction)
    colsToReduce.forEach(col => columns.push(col))
    // for each group
    const newRows = []
    const totalGroups = rowsInGroups.size
    for (let [groupId, group] of rowsInGroups) {
      const firstRow = group[0]
      const newRow = {}
      groupByCols.forEach(col => {
        newRow[col] = firstRow ? firstRow[col] : 0
      })
      newRow.count = group.length
      // todo: add more reductions? count, stddev, median, variance.
      colsToReduce.forEach(col => {
        const sourceColName = col.source
        const values = group.map(row => row[sourceColName]).filter(val => typeof val === "number" && !isNaN(val))
        const reduction = col.reduction
        let reducedValue = firstRow[sourceColName]
        if (reduction === "sum") reducedValue = values.reduce((prev, current) => prev + current, 0)
        if (reduction === "max") reducedValue = Math.max(...values)
        if (reduction === "min") reducedValue = Math.min(...values)
        if (reduction === "mean") reducedValue = values.reduce((prev, current) => prev + current, 0) / values.length
        newRow[col.name] = reducedValue
      })
      newRows.push(newRow)
    }
    return {
      rows: newRows,
      columns: columns
    }
  }
}
var ComparisonOperators
;(function(ComparisonOperators) {
  ComparisonOperators["lessThan"] = "<"
  ComparisonOperators["greaterThan"] = ">"
  ComparisonOperators["lessThanOrEqual"] = "<="
  ComparisonOperators["greaterThanOrEqual"] = ">="
  ComparisonOperators["equal"] = "="
  ComparisonOperators["notEqual"] = "!="
})(ComparisonOperators || (ComparisonOperators = {}))
// todo: remove detectAndAddParam?
// todo: remove rowclass param?
class Table {
  constructor(rowsArray = [], columnsArrayOrMap = [], rowClass = Row, detectAndAddColumns = true) {
    this._columnsMap = {}
    this._ctime = new jtree.TreeNode()._getProcessTimeInMilliseconds()
    this._tableId = this._getUniqueId()
    // if this is ALREADY CARDS, should we be a view?
    this._rows = rowsArray.map(source => (source instanceof Row ? source : new rowClass(source, this)))
    // Add detected columns first, so they can be overwritten
    if (detectAndAddColumns) this._getDetectedColumnNames().forEach(col => this._registerColumn({ name: col }))
    if (Array.isArray(columnsArrayOrMap)) columnsArrayOrMap.forEach(col => this._registerColumn(col))
    else if (columnsArrayOrMap) this._columnsMap = columnsArrayOrMap
  }
  _getUniqueId() {
    Table._uniqueId++
    return Table._uniqueId
  }
  _registerColumn(col) {
    this._columnsMap[col.name] = new Column(col, this._getColumnValuesFromSourceAsAnyVector(col.source || col.name))
    return this
  }
  _getColumnValuesFromSourceAsAnyVector(columnName) {
    return this.getRows().map(row => row.getRowOriginalValue(columnName))
  }
  // todo: ADD TYPINGS
  _predictColumns(predictionHints, propertyNameToColumnNameMap = {}) {
    // todo: use the available input table column names, coupled with column setting we are trying to predict.
    // ie: "gender" should use "gender" col, if available
    // check all the columns for one that matches all tests. if found, return it.
    const columnsArray = this.getColumnsArray()
    const tests = predictionHints.split(",")
    const filterTests = tests.filter(test => test.includes("=")).map(test => test.split("="))
    const filterFn = col => filterTests.every(test => col[test[0]] !== undefined && col[test[0]]().toString() === test[1])
    let colsThatPassed = columnsArray.filter(col => filterFn(col))
    const notIn = {}
    const notEqualTests = tests
      .filter(test => test.startsWith("!"))
      .map(test => propertyNameToColumnNameMap[test.substr(1)])
      .filter(identity => identity)
      .forEach(name => {
        notIn[name] = true
      })
    colsThatPassed = colsThatPassed.filter(col => !notIn[col.getColumnName()])
    // for now just 1 prop ranking.
    const rankColumn = tests.find(test => !test.includes("=") && !test.includes("!"))
    let potentialCols = colsThatPassed
    if (rankColumn) potentialCols = potentialCols.sort(jtree.Utils.makeSortByFn(col => col[rankColumn]())).reverse()
    return potentialCols
  }
  getRows() {
    return this._rows
  }
  getFirstColumnAsString() {
    return this.getRows()
      .map(row => row.getFirstValue())
      .join("")
  }
  isBlankTable() {
    return this.getRowCount() === 0 && this.getColumnCount() === 0
  }
  getRowCount() {
    return this.getRows().length
  }
  getColumnCount() {
    return this.getColumnNames().length
  }
  getColumnNames() {
    return Object.keys(this.getColumnsMap())
  }
  getColumnsMap() {
    return this._columnsMap
  }
  getColumnByName(name) {
    return this.getColumnsMap()[name]
  }
  _getLowerCaseColumnsMap() {
    const map = {}
    Object.keys(this._columnsMap).forEach(key => (map[key.toLowerCase()] = key))
    return map
  }
  getTableCTime() {
    return this._ctime
  }
  filterClonedRowsByScalar(columnName, comparisonOperator, scalarValueAsString) {
    const column = this.getColumnByName(columnName)
    let typedScalarValue = column.getPrimitiveTypeObj().getAsNativeJavascriptType(scalarValueAsString)
    if (typedScalarValue instanceof Date) typedScalarValue = typedScalarValue.getTime() // todo: do I need this?
    return new Table(
      this.cloneNativeJavascriptTypedRows().filter(row => {
        let rowTypedValue = row[columnName]
        if (rowTypedValue instanceof Date) rowTypedValue = rowTypedValue.getTime() // todo: do I need this?
        if (comparisonOperator === ComparisonOperators.equal) return rowTypedValue == typedScalarValue
        if (comparisonOperator === ComparisonOperators.notEqual) return rowTypedValue != typedScalarValue
        if (comparisonOperator === ComparisonOperators.greaterThan) return rowTypedValue > typedScalarValue
        if (comparisonOperator === ComparisonOperators.lessThan) return rowTypedValue < typedScalarValue
        if (comparisonOperator === ComparisonOperators.lessThanOrEqual) return rowTypedValue <= typedScalarValue
        if (comparisonOperator === ComparisonOperators.greaterThanOrEqual) return rowTypedValue >= typedScalarValue
      }),
      this.getColumnsArrayOfObjects(),
      undefined,
      false
    )
  }
  getColumnsArray() {
    return Object.values(this.getColumnsMap())
  }
  getColumnsArrayOfObjects() {
    return this.getColumnsArray().map(col => col.toObject())
  }
  getJavascriptNativeTypedValues() {
    return this.getRows().map(row => row.rowToObjectWithOnlyNativeJavascriptTypes())
  }
  clone() {
    return new Table(this.cloneNativeJavascriptTypedRows())
  }
  cloneNativeJavascriptTypedRows() {
    return this.getRows()
      .map(row => row.rowToObjectWithOnlyNativeJavascriptTypes())
      .map(obj => Object.assign({}, obj))
  }
  getTableColumnByName(name) {
    return this.getColumnsMap()[name]
  }
  _getUnionSample(sampleSet) {
    const sample = {}
    sampleSet.forEach(row => {
      row.getRowKeys().forEach(key => {
        if (!key) return
        const currentVal = sample[key]
        if (currentVal !== undefined && currentVal !== "") return
        sample[key] = row.getRowOriginalValue(key)
      })
    })
    return sample
  }
  _getSampleSet() {
    const SAMPLE_SET_SIZE = 30 // todo: fix.
    if (!this._sampleSet) this._sampleSet = jtree.Utils.sampleWithoutReplacement(this.getRows(), SAMPLE_SET_SIZE, Date.now())
    return this._sampleSet
  }
  _getDetectedColumnNames() {
    const columns = this.getColumnsMap()
    // This is run AFTER we have all user definied columns, and AFTER we have all data.
    // detect columns that appear in records
    // todo: this is broken. if you only pull 30, and its a tree or other type with varying columsn, you
    // will often miss columns.
    return Object.keys(this._getUnionSample(this._getSampleSet()))
      .map(columnName => columnName.trim()) // todo: why do we filter empties?
      .filter(identity => identity)
      .filter(col => !columns[col]) // do not overwrite any custom columns
  }
  toTypeScriptInterface() {
    const cols = this.getColumnsArray()
      .map(col => `  ${col.getColumnName()}: ${col.getPrimitiveTypeName()};`)
      .join("\n")
    return `interface Row {
${cols}
}`
  }
  getColumnNamesAndTypes() {
    return this._getColumnNamesAndTypes()
  }
  getColumnNamesAndTypesAndReductions() {
    return this._getColumnNamesAndTypes(true)
  }
  _getColumnNamesAndTypes(withReductions = false) {
    const columns = this.getColumnsMap()
    return this.getColumnNames().map(name => {
      const column = columns[name]
      const obj = {
        Column: name,
        JTableType: column.getPrimitiveTypeName(),
        JavascriptType: column.getPrimitiveTypeObj().getJavascriptTypeName()
      }
      if (withReductions) Object.assign(obj, column.getReductions())
      return obj
    })
  }
  getPredictionsForAPropertyNameToColumnNameMapGivenHintsNode(hintsNode, propertyNameToColumnNameMap) {
    const results = {}
    hintsNode
      .map(columnHintNode => this.getColumnNamePredictionsForProperty(columnHintNode.getFirstWord(), columnHintNode.getContent(), propertyNameToColumnNameMap))
      .filter(pred => pred.length)
      .forEach(predictions => {
        const topPrediction = predictions[0]
        results[topPrediction.propertyName] = topPrediction.columnName
      })
    return results
  }
  getColumnNamePredictionsForProperty(propertyName, predictionHints, propertyNameToColumnNameMap) {
    const userDefinedColumnName = propertyNameToColumnNameMap[propertyName]
    if (this.getColumnsMap()[userDefinedColumnName]) return [{ propertyName: propertyName, columnName: userDefinedColumnName }] // Table has a column named this, return okay.
    // Table has a lowercase column named this. Return okay. Todo: do we want to do this?
    if (userDefinedColumnName && this._getLowerCaseColumnsMap()[userDefinedColumnName.toLowerCase()]) return [this._getLowerCaseColumnsMap()[userDefinedColumnName.toLowerCase()]]
    if (predictionHints) {
      const potentialCols = this._predictColumns(predictionHints, propertyNameToColumnNameMap)
      if (potentialCols.length) return [{ propertyName: propertyName, columnName: potentialCols[0].getColumnName() }]
    }
    const cols = this.getColumnsByImportance()
    const name = cols.length && cols[0].getColumnName()
    if (name) return [{ propertyName: propertyName, columnName: name }]
    return []
  }
  toTree() {
    return new jtree.TreeNode(this.getRows().map(row => row.getRowSourceObject()))
  }
  filterRowsByFn(fn) {
    return new Table(this.cloneNativeJavascriptTypedRows().filter((inputRow, index) => fn(inputRow, index)))
  }
  // todo: make more efficient?
  // todo: preserve columns
  addColumns(columnsToAdd) {
    const inputColDefs = this.getColumnsMap()
    return new Table(
      this.cloneNativeJavascriptTypedRows().map(inputRow => {
        columnsToAdd.forEach(newCol => {
          let newValue
          if (newCol.accessorFn) newValue = newCol.accessorFn(inputRow)
          else newValue = Column.convertValueToNumeric(inputRow[newCol.source], inputColDefs[newCol.source].getPrimitiveTypeName(), newCol.type, newCol.mathFn)
          inputRow[newCol.name] = newValue
        })
        return inputRow
      })
    )
  }
  // todo: can be made more effcicent
  changeColumnType(columnName, newType) {
    const cols = this.getColumnsArrayOfObjects()
    cols.forEach(col => {
      if (col.name === columnName) col.type = newType
    })
    return new Table(this.cloneNativeJavascriptTypedRows(), cols, undefined, false)
  }
  // todo: can be made more effcicent
  dropAllColumnsExcept(columnsToKeep) {
    return new Table(
      this.cloneNativeJavascriptTypedRows().map((inputRow, rowIndex) => {
        const result = {}
        columnsToKeep.forEach(name => {
          result[name] = inputRow[name]
        })
        return result
      }),
      columnsToKeep.map(colName => this.getColumnByName(colName).toObject())
    )
  }
  // todo: we don't need any cloning here--just create a new row, new rows array, new and add the pointers
  // to same rows
  addRow(rowWords) {
    const rows = this.cloneNativeJavascriptTypedRows()
    const newRow = {}
    Object.keys(rows[0] || {}).forEach((key, index) => {
      // todo: handle typings
      newRow[key] = rowWords[index]
    })
    rows.push(newRow)
    return new Table(rows, this.getColumnsMap())
  }
  // todo: we don't need any cloning here--here create a new sorted array with poitners
  // to same rows
  shuffleRows() {
    // todo: add seed!
    // cellType randomSeed int
    //  description An integer to seed the random number generator with.
    return new Table(jtree.Utils.shuffleInPlace(this.getRows().slice(0)), this.getColumnsMap())
  }
  reverseRows() {
    const rows = this.getRows().slice(0)
    rows.reverse()
    return new Table(rows, this.getColumnsMap())
  }
  // Pivot is shorthand for group and reduce?
  makePivotTable(groupByColumnNames, newCols) {
    const inputColumns = this.getColumnsArrayOfObjects()
    const colMap = {}
    inputColumns.forEach(col => (colMap[col.name] = true))
    const groupByCols = groupByColumnNames.filter(col => colMap[col])
    const pivotTable = new PivotTable(this.getJavascriptNativeTypedValues(), inputColumns, newCols).getNewRows(groupByCols)
    return new Table(pivotTable.rows, pivotTable.columns)
  }
  sortBy(colNames) {
    const colAccessorFns = colNames.map(colName => row => row.rowToObjectWithOnlyNativeJavascriptTypes()[colName])
    const rows = this.getRows().sort(jtree.Utils.makeSortByFn(colAccessorFns))
    return new Table(rows, this.getColumnsMap())
  }
  toDelimited(delimiter) {
    return this.toTree().toDelimited(delimiter, this.getColumnNames())
  }
  // guess which are the more important/informative/interesting columns
  getColumnsByImportance() {
    const columnsMap = this.getColumnsMap()
    const aIsMoreImportant = -1
    const bIsMoreImportant = 1
    const cols = Object.keys(columnsMap).map(columnName => columnsMap[columnName])
    cols.sort((colA, colB) => {
      if (colA.getTitlePotential() > colB.getTitlePotential()) return aIsMoreImportant
      if (colB.getTitlePotential() > colA.getTitlePotential()) return bIsMoreImportant
      if (colA.getBlankPercentage() > 0.5 || colB.getBlankPercentage() > 0.5) {
        if (colA.getBlankPercentage() > colB.getBlankPercentage()) return bIsMoreImportant
        else if (colB.getBlankPercentage() > colA.getBlankPercentage()) return aIsMoreImportant
      }
      if (colA.isTemporal() && !colB.isTemporal()) return aIsMoreImportant
      if (!colA.isTemporal() && colB.isTemporal()) return bIsMoreImportant
      if (colA.isLink() && !colB.isLink()) return bIsMoreImportant
      else if (!colA.isLink() && colB.isLink()) return aIsMoreImportant
      if (colA.isString() && !colB.isString()) return bIsMoreImportant
      else if (!colA.isString() && colB.isString()) return aIsMoreImportant
      if (colA.isString() && colB.isString()) {
        if (colA.getEntropy() > 4 && colA.getEntropy() < 8 && colA.getEntropy() > colB.getEntropy()) return aIsMoreImportant
        if (colA.getEstimatedTextLength() > colB.getEstimatedTextLength()) return bIsMoreImportant
        else return aIsMoreImportant
      }
      return 0
    })
    return cols
  }
}
Table._uniqueId = 0
window.Table = Table
window.ComparisonOperators = ComparisonOperators
;

{
  class stumpNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        errorNode,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          blockquote: htmlTagNode,
          colgroup: htmlTagNode,
          datalist: htmlTagNode,
          fieldset: htmlTagNode,
          menuitem: htmlTagNode,
          noscript: htmlTagNode,
          optgroup: htmlTagNode,
          progress: htmlTagNode,
          styleTag: htmlTagNode,
          template: htmlTagNode,
          textarea: htmlTagNode,
          titleTag: htmlTagNode,
          address: htmlTagNode,
          article: htmlTagNode,
          caption: htmlTagNode,
          details: htmlTagNode,
          section: htmlTagNode,
          summary: htmlTagNode,
          button: htmlTagNode,
          canvas: htmlTagNode,
          dialog: htmlTagNode,
          figure: htmlTagNode,
          footer: htmlTagNode,
          header: htmlTagNode,
          hgroup: htmlTagNode,
          iframe: htmlTagNode,
          keygen: htmlTagNode,
          legend: htmlTagNode,
          object: htmlTagNode,
          option: htmlTagNode,
          output: htmlTagNode,
          script: htmlTagNode,
          select: htmlTagNode,
          source: htmlTagNode,
          strong: htmlTagNode,
          aside: htmlTagNode,
          embed: htmlTagNode,
          input: htmlTagNode,
          label: htmlTagNode,
          meter: htmlTagNode,
          param: htmlTagNode,
          small: htmlTagNode,
          table: htmlTagNode,
          tbody: htmlTagNode,
          tfoot: htmlTagNode,
          thead: htmlTagNode,
          track: htmlTagNode,
          video: htmlTagNode,
          abbr: htmlTagNode,
          area: htmlTagNode,
          base: htmlTagNode,
          body: htmlTagNode,
          code: htmlTagNode,
          form: htmlTagNode,
          head: htmlTagNode,
          html: htmlTagNode,
          link: htmlTagNode,
          main: htmlTagNode,
          mark: htmlTagNode,
          menu: htmlTagNode,
          meta: htmlTagNode,
          ruby: htmlTagNode,
          samp: htmlTagNode,
          span: htmlTagNode,
          time: htmlTagNode,
          bdi: htmlTagNode,
          bdo: htmlTagNode,
          col: htmlTagNode,
          del: htmlTagNode,
          dfn: htmlTagNode,
          div: htmlTagNode,
          img: htmlTagNode,
          ins: htmlTagNode,
          kbd: htmlTagNode,
          map: htmlTagNode,
          nav: htmlTagNode,
          pre: htmlTagNode,
          rtc: htmlTagNode,
          sub: htmlTagNode,
          sup: htmlTagNode,
          var: htmlTagNode,
          wbr: htmlTagNode,
          br: htmlTagNode,
          dd: htmlTagNode,
          dl: htmlTagNode,
          dt: htmlTagNode,
          em: htmlTagNode,
          h1: htmlTagNode,
          h2: htmlTagNode,
          h3: htmlTagNode,
          h4: htmlTagNode,
          h5: htmlTagNode,
          h6: htmlTagNode,
          hr: htmlTagNode,
          li: htmlTagNode,
          ol: htmlTagNode,
          rb: htmlTagNode,
          rp: htmlTagNode,
          rt: htmlTagNode,
          td: htmlTagNode,
          th: htmlTagNode,
          tr: htmlTagNode,
          ul: htmlTagNode,
          a: htmlTagNode,
          b: htmlTagNode,
          i: htmlTagNode,
          p: htmlTagNode,
          q: htmlTagNode,
          s: htmlTagNode,
          u: htmlTagNode
        }),
        [{ regex: /^$/, nodeConstructor: blankLineNode }]
      )
    }
    compile() {
      return this.toHtml()
    }
    _getHtmlJoinByCharacter() {
      return ""
    }
    getGrammarProgram() {
      if (!this._cachedGrammarProgramRoot)
        this._cachedGrammarProgramRoot = new jtree.GrammarProgram(`anyCell
keywordCell
emptyCell
extraCell
 highlightScope invalid
anyHtmlContentCell
 highlightScope string
attributeValueCell
 highlightScope constant.language
htmlTagNameCell
 highlightScope variable.function
 extends keywordCell
 enum a abbr address area article aside b base bdi bdo blockquote body br button canvas caption code col colgroup datalist dd del details dfn dialog div dl dt em embed fieldset figure footer form h1 h2 h3 h4 h5 h6 head header hgroup hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rb rp rt rtc ruby s samp script section select small source span strong styleTag sub summary sup table tbody td template textarea tfoot th thead time titleTag tr track u ul var video wbr
htmlAttributeNameCell
 highlightScope entity.name.type
 extends keywordCell
 enum accept accept-charset accesskey action align alt async autocomplete autofocus autoplay bgcolor border charset checked class color cols colspan content contenteditable controls coords datetime default defer dir dirname disabled download draggable dropzone enctype for formaction headers height hidden high href hreflang http-equiv id ismap kind lang list loop low max maxlength media method min multiple muted name novalidate onabort onafterprint onbeforeprint onbeforeunload onblur oncanplay oncanplaythrough onchange onclick oncontextmenu oncopy oncuechange oncut ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended onerror onfocus onhashchange oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart onmousedown onmousemove onmouseout onmouseover onmouseup onmousewheel onoffline ononline onpagehide onpageshow onpaste onpause onplay onplaying onpopstate onprogress onratechange onreset onresize onscroll onsearch onseeked onseeking onselect onstalled onstorage onsubmit onsuspend ontimeupdate ontoggle onunload onvolumechange onwaiting onwheel open optimum pattern placeholder poster preload readonly rel required reversed rows rowspan sandbox scope selected shape size sizes spellcheck src srcdoc srclang srcset start step style tabindex target title translate type usemap value width wrap
bernKeywordCell
 enum bern
 extends keywordCell
stumpNode
 root
 description A prefix Tree Language that compiles to HTML.
 catchAllNodeType errorNode
 inScope htmlTagNode blankLineNode
 example
  div
   h1 hello world
 compilesTo html
 javascript
  compile() {
   return this.toHtml()
  }
  _getHtmlJoinByCharacter() {
    return ""
  }
blankLineNode
 pattern ^$
 tags doNotSynthesize
 cells emptyCell
 javascript
  _toHtml() {
   return ""
  }
  getTextContent() {return ""}
htmlTagNode
 inScope bernNode htmlTagNode htmlAttributeNode blankLineNode
 catchAllCellType anyHtmlContentCell
 cells htmlTagNameCell
 javascript
  getTag() {
   // we need to remove the "Tag" bit to handle the style and title attribute/tag conflict.
   const firstWord = this.getFirstWord()
   const map = {
    titleTag: "title",
    styleTag: "style"
   }
   return map[firstWord] || firstWord
  }
  _getHtmlJoinByCharacter() {
   return ""
  }
  toHtmlWithSuids() {
   return this._toHtml(undefined, true)
  }
  _getOneLiner() {
   const oneLinerWords = this.getWordsFrom(1)
   return oneLinerWords.length ? oneLinerWords.join(" ") : ""
  }
  getTextContent() {
    return this._getOneLiner()
  }
  shouldCollapse() {
   return this.has("collapse")
  }
  _toHtml(indentCount, withSuid) {
   const tag = this.getTag()
   const children = this.map(child => child._toHtml(indentCount + 1, withSuid)).join("")
   const attributesStr = this.filter(node => node.isAttributeNode)
    .map(child => child.getAttribute())
    .join("")
   const indent = " ".repeat(indentCount)
   const collapse = this.shouldCollapse()
   const indentForChildNodes = !collapse && this.getChildInstancesOfNodeTypeId("htmlTagNode").length > 0
   const suid = withSuid ? \` stumpUid="\${this._getUid()}"\` : ""
   const oneLiner = this._getOneLiner()
   return \`\${!collapse ? indent : ""}<\${tag}\${attributesStr}\${suid}>\${oneLiner}\${indentForChildNodes ? "\\n" : ""}\${children}</\${tag}>\${collapse ? "" : "\\n"}\`
  }
  removeCssStumpNode() {
   return this.removeStumpNode()
  }
  removeStumpNode() {
   this.getShadow().removeShadow()
   return this.destroy()
  }
  getNodeByGuid(guid) {
   return this.getTopDownArray().find(node => node._getUid() === guid)
  }
  addClassToStumpNode(className) {
   const classNode = this.touchNode("class")
   const words = classNode.getWordsFrom(1)
   // note: we call add on shadow regardless, because at the moment stump may have gotten out of
   // sync with shadow, if things modified the dom. todo: cleanup.
   this.getShadow().addClassToShadow(className)
   if (words.includes(className)) return this
   words.push(className)
   classNode.setContent(words.join(this.getWordBreakSymbol()))
   return this
  }
  removeClassFromStumpNode(className) {
   const classNode = this.getNode("class")
   if (!classNode) return this
   const newClasses = classNode.getWords().filter(word => word !== className)
   if (!newClasses.length) classNode.destroy()
   else classNode.setContent(newClasses.join(" "))
   this.getShadow().removeClassFromShadow(className)
   return this
  }
  stumpNodeHasClass(className) {
   const classNode = this.getNode("class")
   return classNode && classNode.getWords().includes(className) ? true : false
  }
  isStumpNodeCheckbox() {
   return this.get("type") === "checkbox"
  }
  getShadow() {
   if (!this._shadow) {
    const shadowClass = this.getShadowClass()
    this._shadow = new shadowClass(this)
   }
   return this._shadow
  }
  insertCssChildNode(text, index) {
   return this.insertChildNode(text, index)
  }
  insertChildNode(text, index) {
   const singleNode = new jtree.TreeNode(text).getChildren()[0]
   const newNode = this.insertLineAndChildren(singleNode.getLine(), singleNode.childrenToString(), index)
   const stumpNodeIndex = this.getChildInstancesOfNodeTypeId("htmlTagNode").indexOf(newNode)
   this.getShadow().insertHtmlNode(newNode, stumpNodeIndex)
   return newNode
  }
  isInputType() {
   return ["input", "textarea"].includes(this.getTag()) || this.get("contenteditable") === "true"
  }
  findStumpNodeByChild(line) {
   return this.findStumpNodesByChild(line)[0]
  }
  findStumpNodeByChildString(line) {
   return this.getTopDownArray().find(node =>
    node
     .map(child => child.getLine())
     .join("\\n")
     .includes(line)
   )
  }
  findStumpNodeByFirstWord(firstWord) {
   return this._findStumpNodesByBase(firstWord)[0]
  }
  _findStumpNodesByBase(firstWord) {
   return this.getTopDownArray().filter(node => node.doesExtend("htmlTagNode") && node.getFirstWord() === firstWord)
  }
  hasLine(line) {
   return this.getChildren().some(node => node.getLine() === line)
  }
  findStumpNodesByChild(line) {
   return this.getTopDownArray().filter(node => node.doesExtend("htmlTagNode") && node.hasLine(line))
  }
  findStumpNodesWithClass(className) {
   return this.getTopDownArray().filter(
    node =>
     node.doesExtend("htmlTagNode") &&
     node.has("class") &&
     node
      .getNode("class")
      .getWords()
      .includes(className)
   )
  }
  getShadowClass() {
   return this.getParent().getShadowClass()
  }
  // todo: should not be here
  getStumpNodeTreeComponent() {
   return this._treeComponent || this.getParent().getStumpNodeTreeComponent()
  }
  // todo: should not be here
  setStumpNodeTreeComponent(treeComponent) {
   this._treeComponent = treeComponent
   return this
  }
  setStumpNodeCss(css) {
   this.getShadow().setShadowCss(css)
   return this
  }
  getStumpNodeCss(prop) {
   return this.getShadow().getShadowCss(prop)
  }
  getStumpNodeAttr(key) {
   return this.get(key)
  }
  setStumpNodeAttr(key, value) {
   // todo
   return this
  }
  toHtml() {
   return this._toHtml()
  }
errorNode
 baseNodeType errorNode
htmlAttributeNode
 javascript
  _toHtml() {
   return ""
  }
  getTextContent() {return ""}
  getAttribute() {
   return \` \${this.getFirstWord()}="\${this.getContent()}"\`
  }
 boolean isAttributeNode true
 boolean isTileAttribute true
 catchAllNodeType errorNode
 catchAllCellType attributeValueCell
 cells htmlAttributeNameCell
stumpExtendedAttributeNameCell
 extends htmlAttributeNameCell
 enum collapse blurCommand changeCommand clickCommand contextMenuCommand doubleClickCommand lineClickCommand lineShiftClickCommand shiftClickCommand
stumpExtendedAttributeNode
 description Node types not present in HTML but included in stump.
 extends htmlAttributeNode
 cells stumpExtendedAttributeNameCell
lineOfHtmlContentNode
 boolean isTileAttribute true
 catchAllNodeType lineOfHtmlContentNode
 catchAllCellType anyHtmlContentCell
 javascript
  getTextContent() {return this.getLine()}
bernNode
 boolean isTileAttribute true
 todo Rename this node type
 description This is a node where you can put any HTML content. It is called "bern" until someone comes up with a better name.
 catchAllNodeType lineOfHtmlContentNode
 javascript
  _toHtml() {
   return this.childrenToString()
  }
  getTextContent() {return ""}
 cells bernKeywordCell`)
      return this._cachedGrammarProgramRoot
    }
    static getNodeTypeMap() {
      return {
        stumpNode: stumpNode,
        blankLineNode: blankLineNode,
        htmlTagNode: htmlTagNode,
        errorNode: errorNode,
        htmlAttributeNode: htmlAttributeNode,
        stumpExtendedAttributeNode: stumpExtendedAttributeNode,
        lineOfHtmlContentNode: lineOfHtmlContentNode,
        bernNode: bernNode
      }
    }
  }

  class blankLineNode extends jtree.GrammarBackedNode {
    get emptyCell() {
      return this.getWord(0)
    }
    _toHtml() {
      return ""
    }
    getTextContent() {
      return ""
    }
  }

  class htmlTagNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          blockquote: htmlTagNode,
          colgroup: htmlTagNode,
          datalist: htmlTagNode,
          fieldset: htmlTagNode,
          menuitem: htmlTagNode,
          noscript: htmlTagNode,
          optgroup: htmlTagNode,
          progress: htmlTagNode,
          styleTag: htmlTagNode,
          template: htmlTagNode,
          textarea: htmlTagNode,
          titleTag: htmlTagNode,
          address: htmlTagNode,
          article: htmlTagNode,
          caption: htmlTagNode,
          details: htmlTagNode,
          section: htmlTagNode,
          summary: htmlTagNode,
          button: htmlTagNode,
          canvas: htmlTagNode,
          dialog: htmlTagNode,
          figure: htmlTagNode,
          footer: htmlTagNode,
          header: htmlTagNode,
          hgroup: htmlTagNode,
          iframe: htmlTagNode,
          keygen: htmlTagNode,
          legend: htmlTagNode,
          object: htmlTagNode,
          option: htmlTagNode,
          output: htmlTagNode,
          script: htmlTagNode,
          select: htmlTagNode,
          source: htmlTagNode,
          strong: htmlTagNode,
          aside: htmlTagNode,
          embed: htmlTagNode,
          input: htmlTagNode,
          label: htmlTagNode,
          meter: htmlTagNode,
          param: htmlTagNode,
          small: htmlTagNode,
          table: htmlTagNode,
          tbody: htmlTagNode,
          tfoot: htmlTagNode,
          thead: htmlTagNode,
          track: htmlTagNode,
          video: htmlTagNode,
          abbr: htmlTagNode,
          area: htmlTagNode,
          base: htmlTagNode,
          body: htmlTagNode,
          code: htmlTagNode,
          form: htmlTagNode,
          head: htmlTagNode,
          html: htmlTagNode,
          link: htmlTagNode,
          main: htmlTagNode,
          mark: htmlTagNode,
          menu: htmlTagNode,
          meta: htmlTagNode,
          ruby: htmlTagNode,
          samp: htmlTagNode,
          span: htmlTagNode,
          time: htmlTagNode,
          bdi: htmlTagNode,
          bdo: htmlTagNode,
          col: htmlTagNode,
          del: htmlTagNode,
          dfn: htmlTagNode,
          div: htmlTagNode,
          img: htmlTagNode,
          ins: htmlTagNode,
          kbd: htmlTagNode,
          map: htmlTagNode,
          nav: htmlTagNode,
          pre: htmlTagNode,
          rtc: htmlTagNode,
          sub: htmlTagNode,
          sup: htmlTagNode,
          var: htmlTagNode,
          wbr: htmlTagNode,
          br: htmlTagNode,
          dd: htmlTagNode,
          dl: htmlTagNode,
          dt: htmlTagNode,
          em: htmlTagNode,
          h1: htmlTagNode,
          h2: htmlTagNode,
          h3: htmlTagNode,
          h4: htmlTagNode,
          h5: htmlTagNode,
          h6: htmlTagNode,
          hr: htmlTagNode,
          li: htmlTagNode,
          ol: htmlTagNode,
          rb: htmlTagNode,
          rp: htmlTagNode,
          rt: htmlTagNode,
          td: htmlTagNode,
          th: htmlTagNode,
          tr: htmlTagNode,
          ul: htmlTagNode,
          a: htmlTagNode,
          b: htmlTagNode,
          i: htmlTagNode,
          p: htmlTagNode,
          q: htmlTagNode,
          s: htmlTagNode,
          u: htmlTagNode,
          oncanplaythrough: htmlAttributeNode,
          ondurationchange: htmlAttributeNode,
          onloadedmetadata: htmlAttributeNode,
          contenteditable: htmlAttributeNode,
          "accept-charset": htmlAttributeNode,
          onbeforeunload: htmlAttributeNode,
          onvolumechange: htmlAttributeNode,
          onbeforeprint: htmlAttributeNode,
          oncontextmenu: htmlAttributeNode,
          autocomplete: htmlAttributeNode,
          onafterprint: htmlAttributeNode,
          onhashchange: htmlAttributeNode,
          onloadeddata: htmlAttributeNode,
          onmousewheel: htmlAttributeNode,
          onratechange: htmlAttributeNode,
          ontimeupdate: htmlAttributeNode,
          oncuechange: htmlAttributeNode,
          ondragenter: htmlAttributeNode,
          ondragleave: htmlAttributeNode,
          ondragstart: htmlAttributeNode,
          onloadstart: htmlAttributeNode,
          onmousedown: htmlAttributeNode,
          onmousemove: htmlAttributeNode,
          onmouseover: htmlAttributeNode,
          placeholder: htmlAttributeNode,
          formaction: htmlAttributeNode,
          "http-equiv": htmlAttributeNode,
          novalidate: htmlAttributeNode,
          ondblclick: htmlAttributeNode,
          ondragover: htmlAttributeNode,
          onkeypress: htmlAttributeNode,
          onmouseout: htmlAttributeNode,
          onpagehide: htmlAttributeNode,
          onpageshow: htmlAttributeNode,
          onpopstate: htmlAttributeNode,
          onprogress: htmlAttributeNode,
          spellcheck: htmlAttributeNode,
          accesskey: htmlAttributeNode,
          autofocus: htmlAttributeNode,
          draggable: htmlAttributeNode,
          maxlength: htmlAttributeNode,
          oncanplay: htmlAttributeNode,
          ondragend: htmlAttributeNode,
          onemptied: htmlAttributeNode,
          oninvalid: htmlAttributeNode,
          onkeydown: htmlAttributeNode,
          onmouseup: htmlAttributeNode,
          onoffline: htmlAttributeNode,
          onplaying: htmlAttributeNode,
          onseeking: htmlAttributeNode,
          onstalled: htmlAttributeNode,
          onstorage: htmlAttributeNode,
          onsuspend: htmlAttributeNode,
          onwaiting: htmlAttributeNode,
          translate: htmlAttributeNode,
          autoplay: htmlAttributeNode,
          controls: htmlAttributeNode,
          datetime: htmlAttributeNode,
          disabled: htmlAttributeNode,
          download: htmlAttributeNode,
          dropzone: htmlAttributeNode,
          hreflang: htmlAttributeNode,
          multiple: htmlAttributeNode,
          onchange: htmlAttributeNode,
          ononline: htmlAttributeNode,
          onresize: htmlAttributeNode,
          onscroll: htmlAttributeNode,
          onsearch: htmlAttributeNode,
          onseeked: htmlAttributeNode,
          onselect: htmlAttributeNode,
          onsubmit: htmlAttributeNode,
          ontoggle: htmlAttributeNode,
          onunload: htmlAttributeNode,
          readonly: htmlAttributeNode,
          required: htmlAttributeNode,
          reversed: htmlAttributeNode,
          selected: htmlAttributeNode,
          tabindex: htmlAttributeNode,
          bgcolor: htmlAttributeNode,
          charset: htmlAttributeNode,
          checked: htmlAttributeNode,
          colspan: htmlAttributeNode,
          content: htmlAttributeNode,
          default: htmlAttributeNode,
          dirname: htmlAttributeNode,
          enctype: htmlAttributeNode,
          headers: htmlAttributeNode,
          onabort: htmlAttributeNode,
          onclick: htmlAttributeNode,
          onended: htmlAttributeNode,
          onerror: htmlAttributeNode,
          onfocus: htmlAttributeNode,
          oninput: htmlAttributeNode,
          onkeyup: htmlAttributeNode,
          onpaste: htmlAttributeNode,
          onpause: htmlAttributeNode,
          onreset: htmlAttributeNode,
          onwheel: htmlAttributeNode,
          optimum: htmlAttributeNode,
          pattern: htmlAttributeNode,
          preload: htmlAttributeNode,
          rowspan: htmlAttributeNode,
          sandbox: htmlAttributeNode,
          srclang: htmlAttributeNode,
          accept: htmlAttributeNode,
          action: htmlAttributeNode,
          border: htmlAttributeNode,
          coords: htmlAttributeNode,
          height: htmlAttributeNode,
          hidden: htmlAttributeNode,
          method: htmlAttributeNode,
          onblur: htmlAttributeNode,
          oncopy: htmlAttributeNode,
          ondrag: htmlAttributeNode,
          ondrop: htmlAttributeNode,
          onload: htmlAttributeNode,
          onplay: htmlAttributeNode,
          poster: htmlAttributeNode,
          srcdoc: htmlAttributeNode,
          srcset: htmlAttributeNode,
          target: htmlAttributeNode,
          usemap: htmlAttributeNode,
          align: htmlAttributeNode,
          async: htmlAttributeNode,
          class: htmlAttributeNode,
          color: htmlAttributeNode,
          defer: htmlAttributeNode,
          ismap: htmlAttributeNode,
          media: htmlAttributeNode,
          muted: htmlAttributeNode,
          oncut: htmlAttributeNode,
          scope: htmlAttributeNode,
          shape: htmlAttributeNode,
          sizes: htmlAttributeNode,
          start: htmlAttributeNode,
          style: htmlAttributeNode,
          title: htmlAttributeNode,
          value: htmlAttributeNode,
          width: htmlAttributeNode,
          cols: htmlAttributeNode,
          high: htmlAttributeNode,
          href: htmlAttributeNode,
          kind: htmlAttributeNode,
          lang: htmlAttributeNode,
          list: htmlAttributeNode,
          loop: htmlAttributeNode,
          name: htmlAttributeNode,
          open: htmlAttributeNode,
          rows: htmlAttributeNode,
          size: htmlAttributeNode,
          step: htmlAttributeNode,
          type: htmlAttributeNode,
          wrap: htmlAttributeNode,
          alt: htmlAttributeNode,
          dir: htmlAttributeNode,
          for: htmlAttributeNode,
          low: htmlAttributeNode,
          max: htmlAttributeNode,
          min: htmlAttributeNode,
          rel: htmlAttributeNode,
          src: htmlAttributeNode,
          id: htmlAttributeNode,
          lineShiftClickCommand: stumpExtendedAttributeNode,
          contextMenuCommand: stumpExtendedAttributeNode,
          doubleClickCommand: stumpExtendedAttributeNode,
          shiftClickCommand: stumpExtendedAttributeNode,
          lineClickCommand: stumpExtendedAttributeNode,
          changeCommand: stumpExtendedAttributeNode,
          clickCommand: stumpExtendedAttributeNode,
          blurCommand: stumpExtendedAttributeNode,
          collapse: stumpExtendedAttributeNode,
          bern: bernNode
        }),
        [{ regex: /^$/, nodeConstructor: blankLineNode }]
      )
    }
    get htmlTagNameCell() {
      return this.getWord(0)
    }
    get anyHtmlContentCell() {
      return this.getWordsFrom(1)
    }
    getTag() {
      // we need to remove the "Tag" bit to handle the style and title attribute/tag conflict.
      const firstWord = this.getFirstWord()
      const map = {
        titleTag: "title",
        styleTag: "style"
      }
      return map[firstWord] || firstWord
    }
    _getHtmlJoinByCharacter() {
      return ""
    }
    toHtmlWithSuids() {
      return this._toHtml(undefined, true)
    }
    _getOneLiner() {
      const oneLinerWords = this.getWordsFrom(1)
      return oneLinerWords.length ? oneLinerWords.join(" ") : ""
    }
    getTextContent() {
      return this._getOneLiner()
    }
    shouldCollapse() {
      return this.has("collapse")
    }
    _toHtml(indentCount, withSuid) {
      const tag = this.getTag()
      const children = this.map(child => child._toHtml(indentCount + 1, withSuid)).join("")
      const attributesStr = this.filter(node => node.isAttributeNode)
        .map(child => child.getAttribute())
        .join("")
      const indent = " ".repeat(indentCount)
      const collapse = this.shouldCollapse()
      const indentForChildNodes = !collapse && this.getChildInstancesOfNodeTypeId("htmlTagNode").length > 0
      const suid = withSuid ? ` stumpUid="${this._getUid()}"` : ""
      const oneLiner = this._getOneLiner()
      return `${!collapse ? indent : ""}<${tag}${attributesStr}${suid}>${oneLiner}${indentForChildNodes ? "\n" : ""}${children}</${tag}>${collapse ? "" : "\n"}`
    }
    removeCssStumpNode() {
      return this.removeStumpNode()
    }
    removeStumpNode() {
      this.getShadow().removeShadow()
      return this.destroy()
    }
    getNodeByGuid(guid) {
      return this.getTopDownArray().find(node => node._getUid() === guid)
    }
    addClassToStumpNode(className) {
      const classNode = this.touchNode("class")
      const words = classNode.getWordsFrom(1)
      // note: we call add on shadow regardless, because at the moment stump may have gotten out of
      // sync with shadow, if things modified the dom. todo: cleanup.
      this.getShadow().addClassToShadow(className)
      if (words.includes(className)) return this
      words.push(className)
      classNode.setContent(words.join(this.getWordBreakSymbol()))
      return this
    }
    removeClassFromStumpNode(className) {
      const classNode = this.getNode("class")
      if (!classNode) return this
      const newClasses = classNode.getWords().filter(word => word !== className)
      if (!newClasses.length) classNode.destroy()
      else classNode.setContent(newClasses.join(" "))
      this.getShadow().removeClassFromShadow(className)
      return this
    }
    stumpNodeHasClass(className) {
      const classNode = this.getNode("class")
      return classNode && classNode.getWords().includes(className) ? true : false
    }
    isStumpNodeCheckbox() {
      return this.get("type") === "checkbox"
    }
    getShadow() {
      if (!this._shadow) {
        const shadowClass = this.getShadowClass()
        this._shadow = new shadowClass(this)
      }
      return this._shadow
    }
    insertCssChildNode(text, index) {
      return this.insertChildNode(text, index)
    }
    insertChildNode(text, index) {
      const singleNode = new jtree.TreeNode(text).getChildren()[0]
      const newNode = this.insertLineAndChildren(singleNode.getLine(), singleNode.childrenToString(), index)
      const stumpNodeIndex = this.getChildInstancesOfNodeTypeId("htmlTagNode").indexOf(newNode)
      this.getShadow().insertHtmlNode(newNode, stumpNodeIndex)
      return newNode
    }
    isInputType() {
      return ["input", "textarea"].includes(this.getTag()) || this.get("contenteditable") === "true"
    }
    findStumpNodeByChild(line) {
      return this.findStumpNodesByChild(line)[0]
    }
    findStumpNodeByChildString(line) {
      return this.getTopDownArray().find(node =>
        node
          .map(child => child.getLine())
          .join("\n")
          .includes(line)
      )
    }
    findStumpNodeByFirstWord(firstWord) {
      return this._findStumpNodesByBase(firstWord)[0]
    }
    _findStumpNodesByBase(firstWord) {
      return this.getTopDownArray().filter(node => node.doesExtend("htmlTagNode") && node.getFirstWord() === firstWord)
    }
    hasLine(line) {
      return this.getChildren().some(node => node.getLine() === line)
    }
    findStumpNodesByChild(line) {
      return this.getTopDownArray().filter(node => node.doesExtend("htmlTagNode") && node.hasLine(line))
    }
    findStumpNodesWithClass(className) {
      return this.getTopDownArray().filter(
        node =>
          node.doesExtend("htmlTagNode") &&
          node.has("class") &&
          node
            .getNode("class")
            .getWords()
            .includes(className)
      )
    }
    getShadowClass() {
      return this.getParent().getShadowClass()
    }
    // todo: should not be here
    getStumpNodeTreeComponent() {
      return this._treeComponent || this.getParent().getStumpNodeTreeComponent()
    }
    // todo: should not be here
    setStumpNodeTreeComponent(treeComponent) {
      this._treeComponent = treeComponent
      return this
    }
    setStumpNodeCss(css) {
      this.getShadow().setShadowCss(css)
      return this
    }
    getStumpNodeCss(prop) {
      return this.getShadow().getShadowCss(prop)
    }
    getStumpNodeAttr(key) {
      return this.get(key)
    }
    setStumpNodeAttr(key, value) {
      // todo
      return this
    }
    toHtml() {
      return this._toHtml()
    }
  }

  class errorNode extends jtree.GrammarBackedNode {
    getErrors() {
      return this._getErrorNodeErrors()
    }
  }

  class htmlAttributeNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(errorNode, undefined, undefined)
    }
    get htmlAttributeNameCell() {
      return this.getWord(0)
    }
    get attributeValueCell() {
      return this.getWordsFrom(1)
    }
    get isTileAttribute() {
      return true
    }
    get isAttributeNode() {
      return true
    }
    _toHtml() {
      return ""
    }
    getTextContent() {
      return ""
    }
    getAttribute() {
      return ` ${this.getFirstWord()}="${this.getContent()}"`
    }
  }

  class stumpExtendedAttributeNode extends htmlAttributeNode {
    get stumpExtendedAttributeNameCell() {
      return this.getWord(0)
    }
  }

  class lineOfHtmlContentNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(lineOfHtmlContentNode, undefined, undefined)
    }
    get anyHtmlContentCell() {
      return this.getWordsFrom(0)
    }
    get isTileAttribute() {
      return true
    }
    getTextContent() {
      return this.getLine()
    }
  }

  class bernNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(lineOfHtmlContentNode, undefined, undefined)
    }
    get bernKeywordCell() {
      return this.getWord(0)
    }
    get isTileAttribute() {
      return true
    }
    _toHtml() {
      return this.childrenToString()
    }
    getTextContent() {
      return ""
    }
  }

  window.stumpNode = stumpNode
}
;

{
  class fireNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        errorNode,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          block: blockNode,
          function: functionNode,
          if: ifNode,
          while: whileNode,
          divide: divideNode,
          modulo: moduloNode,
          multiply: multiplyNode,
          substract: substractNode,
          add: addNode,
          greaterThan: greaterThanNode,
          greaterThanOrEqual: greaterThanOrEqualNode,
          lessThan: lessThanNode,
          lessThanOrEqual: lessThanOrEqualNode,
          sum: sumNode,
          boolean: booleanNode,
          callFunctionAndSet: callFunctionAndSetNode,
          callMethodAndSet: callMethodAndSetNode,
          join: joinNode,
          mutableNumber: mutableNumberNode,
          number: numberNode,
          numbers: numbersNode,
          string: stringNode,
          callFunction: callFunctionNode,
          decrement: decrementNode,
          dumpIdentifier: dumpIdentifierNode,
          export: exportNode,
          increment: incrementNode,
          printNumber: printNumberNode,
          printString: printStringNode,
          require: requireNode,
          return: returnNode,
          "#!": hashbangNode
        }),
        undefined
      )
    }
    async execute() {
      return this.executeSync()
    }
    executeSync() {
      let outputLines = []
      const _originalConsoleLog = console.log
      const tempConsoleLog = (...params) => outputLines.push(params)
      console.log = tempConsoleLog
      const compiled = this.compile("js")
      eval(compiled)
      console.log = _originalConsoleLog
      console.log(outputLines.join("\n"))
      return outputLines
    }
    getGrammarProgram() {
      if (!this._cachedGrammarProgramRoot)
        this._cachedGrammarProgramRoot = new jtree.GrammarProgram(`todo Explore best ways to add polymorphism
anyCell
booleanCell
 enum false true
filepathCell
identifierCell
 regex [$A-Za-z_][0-9a-zA-Z_$]*
 highlightScope variable
 examples myVarA someVarB
numberCell
 regex \\-?[0-9]*\\.?[0-9]*
 highlightScope constant.numeric
numberIdentifierCell
 extends identifierCell
hashBangCell
 highlightScope comment
hashBangKeywordCell
 highlightScope comment
stringCell
 highlightScope string
booleanIdentifierCell
 extends identifierCell
functionIdentifierCell
 extends identifierCell
identifiersCell
 extends identifierCell
instanceIdentifierCell
 extends identifierCell
methodIdentifierCell
 extends identifierCell
resultIdentifierCell
 extends identifierCell
keywordCell
 highlightScope keyword
stringIdentifierCell
 extends identifierCell
stringCellsCell
 extends stringCell
leftNumberCell
 extends numberCell
leftAnyCell
 extends anyCell
fireNode
 root
 description A useless prefix Tree Language that compiles to Javascript for testing Tree Notation features.
 compilesTo js
 inScope hashbangNode abstractTerminalNode abstractNonTerminalNode
 catchAllNodeType errorNode
 javascript
  async execute() {
   return this.executeSync()
  }
  executeSync() {
   let outputLines = []
   const _originalConsoleLog = console.log
   const tempConsoleLog = (...params) => outputLines.push(params)
   console.log = tempConsoleLog
   const compiled = this.compile("js")
   eval(compiled)
   console.log = _originalConsoleLog
   console.log(outputLines.join("\\n"))
   return outputLines
  }
abstractNonTerminalNode
 inScope abstractTerminalNode abstractNonTerminalNode
 abstract
 cells keywordCell
abstractJsblockNode
 compiler
  openChildren  {
  closeChildren }
 extends abstractNonTerminalNode
 abstract
blockNode
 description block of code
 frequency .2
 compiler
  stringTemplate /* {identifierCell} */
 extends abstractJsblockNode
 crux block
functionNode
 crux function
 description Function Assignment
 cells keywordCell functionIdentifierCell
 catchAllCellType anyCell
 compiler
  stringTemplate const {functionIdentifierCell} = ({anyCell}) =>
  catchAllCellDelimiter , 
 frequency .1
 extends abstractJsblockNode
ifNode
 crux if
 description If tile
 cells keywordCell identifierCell
 frequency .2
 compiler
  stringTemplate if ({identifierCell})
 extends abstractJsblockNode
whileNode
 crux while
 description While tile
 cells keywordCell identifierCell
 frequency .1
 compiler
  stringTemplate while ({identifierCell})
 extends abstractJsblockNode
abstractTerminalNode
 abstract
 cells keywordCell
abstractAssignmentNode
 extends abstractTerminalNode
 abstract
abstractArithmeticNode
 cells keywordCell identifierCell
 catchAllCellType anyCell
 compiler
  stringTemplate const {identifierCell} = {anyCell}
 frequency .2
 extends abstractAssignmentNode
 abstract
divideNode
 description Divide Numbers
 compiler
  catchAllCellDelimiter  / 
 extends abstractArithmeticNode
 crux divide
moduloNode
 description Modulo Numbers
 compiler
  catchAllCellDelimiter %
 extends abstractArithmeticNode
 crux modulo
multiplyNode
 description Multiply Numbers
 compiler
  catchAllCellDelimiter  * 
 extends abstractArithmeticNode
 crux multiply
substractNode
 description Subtract Numbers
 compiler
  catchAllCellDelimiter  - 
 extends abstractArithmeticNode
 crux substract
addNode
 crux add
 description Add numbers and store result
 compiler
  catchAllCellDelimiter  + 
 extends abstractArithmeticNode
abstractBooleanOperatorNode
 description Runs a boolean test and saves result.
 extends abstractAssignmentNode
 abstract
greaterThanNode
 description Greater than test
 cells keywordCell identifierCell leftNumberCell numberCell
 compiler
  stringTemplate const {identifierCell} = {leftNumberCell} > {numberCell}
 frequency .1
 extends abstractBooleanOperatorNode
 crux greaterThan
greaterThanOrEqualNode
 description Greater than or equal to test
 cells keywordCell identifierCell leftNumberCell numberCell
 compiler
  stringTemplate const {identifierCell} = {leftNumberCell} >= {numberCell}
 frequency .1
 extends abstractBooleanOperatorNode
 crux greaterThanOrEqual
lessThanNode
 description Less than test
 cells keywordCell identifierCell leftAnyCell anyCell
 compiler
  stringTemplate const {identifierCell} = {leftAnyCell} < {anyCell}
 frequency .1
 extends abstractBooleanOperatorNode
 crux lessThan
lessThanOrEqualNode
 crux lessThanOrEqual
 description Less than or equal to test
 cells keywordCell identifierCell leftAnyCell anyCell
 compiler
  stringTemplate const {identifierCell} = {leftAnyCell} <= {anyCell}
 frequency .1
 extends abstractBooleanOperatorNode
sumNode
 crux sum
 description Add numbers and store result
 cells keywordCell numberIdentifierCell
 catchAllCellType numberCell
 compiler
  stringTemplate const {numberIdentifierCell} = [{numberCell}].reduce((sum, num) => sum + num)
  catchAllCellDelimiter , 
 frequency .1
 extends abstractAssignmentNode
booleanNode
 crux boolean
 description Boolean Assignment
 cells keywordCell booleanIdentifierCell booleanCell
 compiler
  stringTemplate const {booleanIdentifierCell} = {booleanCell}
 extends abstractAssignmentNode
callFunctionAndSetNode
 crux callFunctionAndSet
 description Function Call
 frequency .5
 cells keywordCell resultIdentifierCell functionIdentifierCell
 catchAllCellType anyCell
 compiler
  stringTemplate const {resultIdentifierCell} = {functionIdentifierCell}({anyCell})
  catchAllCellDelimiter , 
 extends abstractAssignmentNode
callMethodAndSetNode
 crux callMethodAndSet
 description Method Call
 frequency .5
 cells keywordCell resultIdentifierCell instanceIdentifierCell methodIdentifierCell
 catchAllCellType anyCell
 compiler
  stringTemplate const {resultIdentifierCell} = {instanceIdentifierCell}.{methodIdentifierCell}({anyCell})
  catchAllCellDelimiter , 
 extends abstractAssignmentNode
joinNode
 crux join
 description Join strings to form new string
 cells keywordCell identifierCell
 catchAllCellType identifiersCell
 compiler
  stringTemplate const {identifierCell} = [{identifiersCell}].join("")
  catchAllCellDelimiter , 
 frequency .2
 extends abstractAssignmentNode
mutableNumberNode
 crux mutableNumber
 description Mutable Number Assignment
 cells keywordCell identifierCell numberCell
 compiler
  stringTemplate let {identifierCell} = {numberCell}
 extends abstractAssignmentNode
numberNode
 crux number
 description Number Assignment
 cells keywordCell identifierCell numberCell
 compiler
  stringTemplate const {identifierCell} = {numberCell}
 frequency .3
 extends abstractAssignmentNode
numbersNode
 crux numbers
 description Number Array Assignment
 cells keywordCell identifierCell
 catchAllCellType numberCell
 frequency .4
 compiler
  stringTemplate const {identifierCell} = [{numberCell}]
  catchAllCellDelimiter , 
 extends abstractAssignmentNode
stringNode
 crux string
 description String Assignment
 cells keywordCell stringIdentifierCell
 catchAllCellType anyCell
 compiler
  stringTemplate const {stringIdentifierCell} = "{anyCell}"
 frequency .2
 extends abstractAssignmentNode
callFunctionNode
 crux callFunction
 description Function call ignore result.
 frequency .1
 cells keywordCell functionIdentifierCell
 catchAllCellType anyCell
 compiler
  stringTemplate {functionIdentifierCell}({anyCell})
  catchAllCellDelimiter , 
 extends abstractTerminalNode
decrementNode
 crux decrement
 description Decrement
 cells keywordCell numberIdentifierCell
 compiler
  stringTemplate {numberIdentifierCell}--
 frequency .1
 extends abstractTerminalNode
dumpIdentifierNode
 crux dumpIdentifier
 description Dump variable(s) to console
 catchAllCellType identifierCell
 compiler
  stringTemplate console.log({identifierCell})
  catchAllCellDelimiter , 
 frequency .5
 extends abstractTerminalNode
exportNode
 crux export
 description Export This
 cells keywordCell identifierCell
 compiler
  stringTemplate module.exports = {identifierCell}
 frequency .1
 extends abstractTerminalNode
incrementNode
 crux increment
 description Increment
 frequency .3
 cells keywordCell numberIdentifierCell
 compiler
  stringTemplate {numberIdentifierCell}++
 extends abstractTerminalNode
printNumberNode
 crux printNumber
 extends abstractTerminalNode
 catchAllCellType numberIdentifierCell
 compiler
  stringTemplate console.log({numberIdentifierCell})
printStringNode
 crux printString
 todo Allow printing of multiline strings
 extends abstractTerminalNode
 catchAllCellType stringCellsCell
 compiler
  stringTemplate console.log("{stringCells}")
requireNode
 crux require
 description Require Something
 cells keywordCell identifierCell filepathCell
 compiler
  stringTemplate const {identifierCell} = require("{filepathCell}")
 frequency .1
 extends abstractTerminalNode
returnNode
 crux return
 cells keywordCell anyCell
 compiler
  stringTemplate return {anyCell}
 frequency .1
 extends abstractTerminalNode
hashbangNode
 crux #!
 description Standard bash hashbang line.
 catchAllCellType hashBangCell
 compiler
  stringTemplate // #! {hashBangCell}
 cells hashBangKeywordCell
errorNode
 baseNodeType errorNode
 compiler
  stringTemplate // error`)
      return this._cachedGrammarProgramRoot
    }
    static getNodeTypeMap() {
      return {
        fireNode: fireNode,
        abstractNonTerminalNode: abstractNonTerminalNode,
        abstractJsblockNode: abstractJsblockNode,
        blockNode: blockNode,
        functionNode: functionNode,
        ifNode: ifNode,
        whileNode: whileNode,
        abstractTerminalNode: abstractTerminalNode,
        abstractAssignmentNode: abstractAssignmentNode,
        abstractArithmeticNode: abstractArithmeticNode,
        divideNode: divideNode,
        moduloNode: moduloNode,
        multiplyNode: multiplyNode,
        substractNode: substractNode,
        addNode: addNode,
        abstractBooleanOperatorNode: abstractBooleanOperatorNode,
        greaterThanNode: greaterThanNode,
        greaterThanOrEqualNode: greaterThanOrEqualNode,
        lessThanNode: lessThanNode,
        lessThanOrEqualNode: lessThanOrEqualNode,
        sumNode: sumNode,
        booleanNode: booleanNode,
        callFunctionAndSetNode: callFunctionAndSetNode,
        callMethodAndSetNode: callMethodAndSetNode,
        joinNode: joinNode,
        mutableNumberNode: mutableNumberNode,
        numberNode: numberNode,
        numbersNode: numbersNode,
        stringNode: stringNode,
        callFunctionNode: callFunctionNode,
        decrementNode: decrementNode,
        dumpIdentifierNode: dumpIdentifierNode,
        exportNode: exportNode,
        incrementNode: incrementNode,
        printNumberNode: printNumberNode,
        printStringNode: printStringNode,
        requireNode: requireNode,
        returnNode: returnNode,
        hashbangNode: hashbangNode,
        errorNode: errorNode
      }
    }
  }

  class abstractNonTerminalNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          block: blockNode,
          function: functionNode,
          if: ifNode,
          while: whileNode,
          divide: divideNode,
          modulo: moduloNode,
          multiply: multiplyNode,
          substract: substractNode,
          add: addNode,
          greaterThan: greaterThanNode,
          greaterThanOrEqual: greaterThanOrEqualNode,
          lessThan: lessThanNode,
          lessThanOrEqual: lessThanOrEqualNode,
          sum: sumNode,
          boolean: booleanNode,
          callFunctionAndSet: callFunctionAndSetNode,
          callMethodAndSet: callMethodAndSetNode,
          join: joinNode,
          mutableNumber: mutableNumberNode,
          number: numberNode,
          numbers: numbersNode,
          string: stringNode,
          callFunction: callFunctionNode,
          decrement: decrementNode,
          dumpIdentifier: dumpIdentifierNode,
          export: exportNode,
          increment: incrementNode,
          printNumber: printNumberNode,
          printString: printStringNode,
          require: requireNode,
          return: returnNode
        }),
        undefined
      )
    }
    get keywordCell() {
      return this.getWord(0)
    }
  }

  class abstractJsblockNode extends abstractNonTerminalNode {}

  class blockNode extends abstractJsblockNode {}

  class functionNode extends abstractJsblockNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get functionIdentifierCell() {
      return this.getWord(1)
    }
    get anyCell() {
      return this.getWordsFrom(2)
    }
  }

  class ifNode extends abstractJsblockNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
  }

  class whileNode extends abstractJsblockNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
  }

  class abstractTerminalNode extends jtree.GrammarBackedNode {
    get keywordCell() {
      return this.getWord(0)
    }
  }

  class abstractAssignmentNode extends abstractTerminalNode {}

  class abstractArithmeticNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get anyCell() {
      return this.getWordsFrom(2)
    }
  }

  class divideNode extends abstractArithmeticNode {}

  class moduloNode extends abstractArithmeticNode {}

  class multiplyNode extends abstractArithmeticNode {}

  class substractNode extends abstractArithmeticNode {}

  class addNode extends abstractArithmeticNode {}

  class abstractBooleanOperatorNode extends abstractAssignmentNode {}

  class greaterThanNode extends abstractBooleanOperatorNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get leftNumberCell() {
      return parseFloat(this.getWord(2))
    }
    get numberCell() {
      return parseFloat(this.getWord(3))
    }
  }

  class greaterThanOrEqualNode extends abstractBooleanOperatorNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get leftNumberCell() {
      return parseFloat(this.getWord(2))
    }
    get numberCell() {
      return parseFloat(this.getWord(3))
    }
  }

  class lessThanNode extends abstractBooleanOperatorNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get leftAnyCell() {
      return this.getWord(2)
    }
    get anyCell() {
      return this.getWord(3)
    }
  }

  class lessThanOrEqualNode extends abstractBooleanOperatorNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get leftAnyCell() {
      return this.getWord(2)
    }
    get anyCell() {
      return this.getWord(3)
    }
  }

  class sumNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get numberIdentifierCell() {
      return this.getWord(1)
    }
    get numberCell() {
      return this.getWordsFrom(2).map(val => parseFloat(val))
    }
  }

  class booleanNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get booleanIdentifierCell() {
      return this.getWord(1)
    }
    get booleanCell() {
      return this.getWord(2)
    }
  }

  class callFunctionAndSetNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get resultIdentifierCell() {
      return this.getWord(1)
    }
    get functionIdentifierCell() {
      return this.getWord(2)
    }
    get anyCell() {
      return this.getWordsFrom(3)
    }
  }

  class callMethodAndSetNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get resultIdentifierCell() {
      return this.getWord(1)
    }
    get instanceIdentifierCell() {
      return this.getWord(2)
    }
    get methodIdentifierCell() {
      return this.getWord(3)
    }
    get anyCell() {
      return this.getWordsFrom(4)
    }
  }

  class joinNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get identifiersCell() {
      return this.getWordsFrom(2)
    }
  }

  class mutableNumberNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get numberCell() {
      return parseFloat(this.getWord(2))
    }
  }

  class numberNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get numberCell() {
      return parseFloat(this.getWord(2))
    }
  }

  class numbersNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get numberCell() {
      return this.getWordsFrom(2).map(val => parseFloat(val))
    }
  }

  class stringNode extends abstractAssignmentNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get stringIdentifierCell() {
      return this.getWord(1)
    }
    get anyCell() {
      return this.getWordsFrom(2)
    }
  }

  class callFunctionNode extends abstractTerminalNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get functionIdentifierCell() {
      return this.getWord(1)
    }
    get anyCell() {
      return this.getWordsFrom(2)
    }
  }

  class decrementNode extends abstractTerminalNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get numberIdentifierCell() {
      return this.getWord(1)
    }
  }

  class dumpIdentifierNode extends abstractTerminalNode {
    get identifierCell() {
      return this.getWordsFrom(0)
    }
  }

  class exportNode extends abstractTerminalNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
  }

  class incrementNode extends abstractTerminalNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get numberIdentifierCell() {
      return this.getWord(1)
    }
  }

  class printNumberNode extends abstractTerminalNode {
    get numberIdentifierCell() {
      return this.getWordsFrom(0)
    }
  }

  class printStringNode extends abstractTerminalNode {
    get stringCellsCell() {
      return this.getWordsFrom(0)
    }
  }

  class requireNode extends abstractTerminalNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get identifierCell() {
      return this.getWord(1)
    }
    get filepathCell() {
      return this.getWord(2)
    }
  }

  class returnNode extends abstractTerminalNode {
    get keywordCell() {
      return this.getWord(0)
    }
    get anyCell() {
      return this.getWord(1)
    }
  }

  class hashbangNode extends jtree.GrammarBackedNode {
    get hashBangKeywordCell() {
      return this.getWord(0)
    }
    get hashBangCell() {
      return this.getWordsFrom(1)
    }
  }

  class errorNode extends jtree.GrammarBackedNode {
    getErrors() {
      return this._getErrorNodeErrors()
    }
  }

  window.fireNode = fireNode
}
;

{
  class hakonNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        selectorNode,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { comment: commentNode }),
        undefined
      )
    }
    getSelector() {
      return ""
    }
    compile() {
      return this.getTopDownArray()
        .filter(node => node.isSelectorNode)
        .map(child => child.compile())
        .join("")
    }
    getGrammarProgram() {
      if (!this._cachedGrammarProgramRoot)
        this._cachedGrammarProgramRoot = new jtree.GrammarProgram(`anyCell
keywordCell
commentKeywordCell
 extends keywordCell
 highlightScope comment
 enum comment
extraCell
 highlightScope invalid
cssValueCell
 highlightScope constant.numeric
selectorCell
 highlightScope keyword.control
 examples body h1
 todo add html tags, css and ids selector regexes, etc
propertyKeywordCell
 highlightScope variable.function
 extends keywordCell
 enum align-content align-items align-self all animation animation-delay animation-direction animation-duration animation-fill-mode animation-iteration-count animation-name animation-play-state animation-timing-function backface-visibility background background-attachment background-blend-mode background-clip background-color background-image background-origin background-position background-repeat background-size border border-bottom border-bottom-color border-bottom-left-radius border-bottom-right-radius border-bottom-style border-bottom-width border-collapse border-color border-image border-image-outset border-image-repeat border-image-slice border-image-source border-image-width border-left border-left-color border-left-style border-left-width border-radius border-right border-right-color border-right-style border-right-width border-spacing border-style border-top border-top-color border-top-left-radius border-top-right-radius border-top-style border-top-width border-width bottom box-shadow box-sizing caption-side clear clip color column-count column-fill column-gap column-rule column-rule-color column-rule-style column-rule-width column-span column-width columns content counter-increment counter-reset cursor direction display empty-cells fill filter flex flex-basis flex-direction flex-flow flex-grow flex-shrink flex-wrap float font @font-face font-family font-size font-size-adjust font-stretch font-style font-variant font-weight hanging-punctuation height justify-content @keyframes left letter-spacing line-height list-style list-style-image list-style-position list-style-type margin margin-bottom margin-left margin-right margin-top max-height max-width @media min-height min-width nav-down nav-index nav-left nav-right nav-up opacity order outline outline-color outline-offset outline-style outline-width overflow overflow-x overflow-y padding padding-bottom padding-left padding-right padding-top page-break-after page-break-before page-break-inside perspective perspective-origin position quotes resize right tab-size table-layout text-align text-align-last text-decoration text-decoration-color text-decoration-line text-decoration-style text-indent text-justify text-overflow text-shadow text-transform top transform transform-origin transform-style transition transition-delay transition-duration transition-property transition-timing-function unicode-bidi vertical-align visibility white-space width word-break word-spacing word-wrap z-index overscroll-behavior-x user-select -ms-touch-action -webkit-user-select -webkit-touch-callout -moz-user-select touch-action -ms-user-select -khtml-user-select
errorCell
 highlightScope invalid
commentCell
 highlightScope comment
hakonNode
 root
 todo Add variables?
 description A prefix Tree Language that compiles to CSS
 compilesTo css
 inScope commentNode
 catchAllNodeType selectorNode
 javascript
  getSelector() {
   return ""
  }
  compile() {
   return this.getTopDownArray()
    .filter(node => node.isSelectorNode)
    .map(child => child.compile())
    .join("")
  }
 example A basic example
  body
   font-size 12px
   h1,h2
    color red
  a
   &:hover
    color blue
    font-size 17px
propertyNode
 catchAllCellType cssValueCell
 catchAllNodeType errorNode
 javascript
  compile(spaces) {
   return \`\${spaces}\${this.getFirstWord()}: \${this.getContent()};\`
  }
 cells propertyKeywordCell
variableNode
 extends propertyNode
 pattern --
errorNode
 catchAllNodeType errorNode
 catchAllCellType errorCell
 baseNodeType errorNode
commentNode
 cells commentKeywordCell
 catchAllCellType commentCell
 catchAllNodeType commentNode
selectorNode
 inScope propertyNode variableNode commentNode
 catchAllNodeType selectorNode
 boolean isSelectorNode true
 javascript
  getSelector() {
   const parentSelector = this.getParent().getSelector()
   return this.getFirstWord()
    .split(",")
    .map(part => {
     if (part.startsWith("&")) return parentSelector + part.substr(1)
     return parentSelector ? parentSelector + " " + part : part
    })
    .join(",")
  }
  compile() {
   const propertyNodes = this.getChildren().filter(node => node.doesExtend("propertyNode"))
   if (!propertyNodes.length) return ""
   const spaces = "  "
   return \`\${this.getSelector()} {
  \${propertyNodes.map(child => child.compile(spaces)).join("\\n")}
  }\\n\`
  }
 cells selectorCell`)
      return this._cachedGrammarProgramRoot
    }
    static getNodeTypeMap() {
      return {
        hakonNode: hakonNode,
        propertyNode: propertyNode,
        variableNode: variableNode,
        errorNode: errorNode,
        commentNode: commentNode,
        selectorNode: selectorNode
      }
    }
  }

  class propertyNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(errorNode, undefined, undefined)
    }
    get propertyKeywordCell() {
      return this.getWord(0)
    }
    get cssValueCell() {
      return this.getWordsFrom(1)
    }
    compile(spaces) {
      return `${spaces}${this.getFirstWord()}: ${this.getContent()};`
    }
  }

  class variableNode extends propertyNode {}

  class errorNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(errorNode, undefined, undefined)
    }
    getErrors() {
      return this._getErrorNodeErrors()
    }
    get errorCell() {
      return this.getWordsFrom(0)
    }
  }

  class commentNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(commentNode, undefined, undefined)
    }
    get commentKeywordCell() {
      return this.getWord(0)
    }
    get commentCell() {
      return this.getWordsFrom(1)
    }
  }

  class selectorNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        selectorNode,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          "border-bottom-right-radius": propertyNode,
          "transition-timing-function": propertyNode,
          "animation-iteration-count": propertyNode,
          "animation-timing-function": propertyNode,
          "border-bottom-left-radius": propertyNode,
          "border-top-right-radius": propertyNode,
          "border-top-left-radius": propertyNode,
          "background-attachment": propertyNode,
          "background-blend-mode": propertyNode,
          "text-decoration-color": propertyNode,
          "text-decoration-style": propertyNode,
          "overscroll-behavior-x": propertyNode,
          "-webkit-touch-callout": propertyNode,
          "animation-play-state": propertyNode,
          "text-decoration-line": propertyNode,
          "animation-direction": propertyNode,
          "animation-fill-mode": propertyNode,
          "backface-visibility": propertyNode,
          "background-position": propertyNode,
          "border-bottom-color": propertyNode,
          "border-bottom-style": propertyNode,
          "border-bottom-width": propertyNode,
          "border-image-outset": propertyNode,
          "border-image-repeat": propertyNode,
          "border-image-source": propertyNode,
          "hanging-punctuation": propertyNode,
          "list-style-position": propertyNode,
          "transition-duration": propertyNode,
          "transition-property": propertyNode,
          "-webkit-user-select": propertyNode,
          "animation-duration": propertyNode,
          "border-image-slice": propertyNode,
          "border-image-width": propertyNode,
          "border-right-color": propertyNode,
          "border-right-style": propertyNode,
          "border-right-width": propertyNode,
          "perspective-origin": propertyNode,
          "-khtml-user-select": propertyNode,
          "background-origin": propertyNode,
          "background-repeat": propertyNode,
          "border-left-color": propertyNode,
          "border-left-style": propertyNode,
          "border-left-width": propertyNode,
          "column-rule-color": propertyNode,
          "column-rule-style": propertyNode,
          "column-rule-width": propertyNode,
          "counter-increment": propertyNode,
          "page-break-before": propertyNode,
          "page-break-inside": propertyNode,
          "background-color": propertyNode,
          "background-image": propertyNode,
          "border-top-color": propertyNode,
          "border-top-style": propertyNode,
          "border-top-width": propertyNode,
          "font-size-adjust": propertyNode,
          "list-style-image": propertyNode,
          "page-break-after": propertyNode,
          "transform-origin": propertyNode,
          "transition-delay": propertyNode,
          "-ms-touch-action": propertyNode,
          "-moz-user-select": propertyNode,
          "animation-delay": propertyNode,
          "background-clip": propertyNode,
          "background-size": propertyNode,
          "border-collapse": propertyNode,
          "justify-content": propertyNode,
          "list-style-type": propertyNode,
          "text-align-last": propertyNode,
          "text-decoration": propertyNode,
          "transform-style": propertyNode,
          "-ms-user-select": propertyNode,
          "animation-name": propertyNode,
          "border-spacing": propertyNode,
          "flex-direction": propertyNode,
          "letter-spacing": propertyNode,
          "outline-offset": propertyNode,
          "padding-bottom": propertyNode,
          "text-transform": propertyNode,
          "vertical-align": propertyNode,
          "align-content": propertyNode,
          "border-bottom": propertyNode,
          "border-radius": propertyNode,
          "counter-reset": propertyNode,
          "margin-bottom": propertyNode,
          "outline-color": propertyNode,
          "outline-style": propertyNode,
          "outline-width": propertyNode,
          "padding-right": propertyNode,
          "text-overflow": propertyNode,
          "border-color": propertyNode,
          "border-image": propertyNode,
          "border-right": propertyNode,
          "border-style": propertyNode,
          "border-width": propertyNode,
          "caption-side": propertyNode,
          "column-count": propertyNode,
          "column-width": propertyNode,
          "font-stretch": propertyNode,
          "font-variant": propertyNode,
          "margin-right": propertyNode,
          "padding-left": propertyNode,
          "table-layout": propertyNode,
          "text-justify": propertyNode,
          "unicode-bidi": propertyNode,
          "word-spacing": propertyNode,
          "touch-action": propertyNode,
          "align-items": propertyNode,
          "border-left": propertyNode,
          "column-fill": propertyNode,
          "column-rule": propertyNode,
          "column-span": propertyNode,
          "empty-cells": propertyNode,
          "flex-shrink": propertyNode,
          "font-family": propertyNode,
          "font-weight": propertyNode,
          "line-height": propertyNode,
          "margin-left": propertyNode,
          "padding-top": propertyNode,
          perspective: propertyNode,
          "text-indent": propertyNode,
          "text-shadow": propertyNode,
          "white-space": propertyNode,
          "user-select": propertyNode,
          "align-self": propertyNode,
          background: propertyNode,
          "border-top": propertyNode,
          "box-shadow": propertyNode,
          "box-sizing": propertyNode,
          "column-gap": propertyNode,
          "flex-basis": propertyNode,
          "@font-face": propertyNode,
          "font-style": propertyNode,
          "@keyframes": propertyNode,
          "list-style": propertyNode,
          "margin-top": propertyNode,
          "max-height": propertyNode,
          "min-height": propertyNode,
          "overflow-x": propertyNode,
          "overflow-y": propertyNode,
          "text-align": propertyNode,
          transition: propertyNode,
          visibility: propertyNode,
          "word-break": propertyNode,
          animation: propertyNode,
          direction: propertyNode,
          "flex-flow": propertyNode,
          "flex-grow": propertyNode,
          "flex-wrap": propertyNode,
          "font-size": propertyNode,
          "max-width": propertyNode,
          "min-width": propertyNode,
          "nav-index": propertyNode,
          "nav-right": propertyNode,
          transform: propertyNode,
          "word-wrap": propertyNode,
          "nav-down": propertyNode,
          "nav-left": propertyNode,
          overflow: propertyNode,
          position: propertyNode,
          "tab-size": propertyNode,
          columns: propertyNode,
          content: propertyNode,
          display: propertyNode,
          opacity: propertyNode,
          outline: propertyNode,
          padding: propertyNode,
          "z-index": propertyNode,
          border: propertyNode,
          bottom: propertyNode,
          cursor: propertyNode,
          filter: propertyNode,
          height: propertyNode,
          margin: propertyNode,
          "@media": propertyNode,
          "nav-up": propertyNode,
          quotes: propertyNode,
          resize: propertyNode,
          clear: propertyNode,
          color: propertyNode,
          float: propertyNode,
          order: propertyNode,
          right: propertyNode,
          width: propertyNode,
          clip: propertyNode,
          fill: propertyNode,
          flex: propertyNode,
          font: propertyNode,
          left: propertyNode,
          all: propertyNode,
          top: propertyNode,
          comment: commentNode
        }),
        [{ regex: /--/, nodeConstructor: variableNode }]
      )
    }
    get selectorCell() {
      return this.getWord(0)
    }
    get isSelectorNode() {
      return true
    }
    getSelector() {
      const parentSelector = this.getParent().getSelector()
      return this.getFirstWord()
        .split(",")
        .map(part => {
          if (part.startsWith("&")) return parentSelector + part.substr(1)
          return parentSelector ? parentSelector + " " + part : part
        })
        .join(",")
    }
    compile() {
      const propertyNodes = this.getChildren().filter(node => node.doesExtend("propertyNode"))
      if (!propertyNodes.length) return ""
      const spaces = "  "
      return `${this.getSelector()} {
${propertyNodes.map(child => child.compile(spaces)).join("\n")}
}\n`
    }
  }

  window.hakonNode = hakonNode
}
;

const BrowserEvents = {}
BrowserEvents.click = "click"
BrowserEvents.change = "change"
BrowserEvents.mouseover = "mouseover"
BrowserEvents.mouseout = "mouseout"
BrowserEvents.mousedown = "mousedown"
BrowserEvents.contextmenu = "contextmenu"
BrowserEvents.keypress = "keypress"
BrowserEvents.keyup = "keyup"
BrowserEvents.focus = "focus"
BrowserEvents.mousemove = "mousemove"
BrowserEvents.dblclick = "dblclick"
BrowserEvents.submit = "submit"
BrowserEvents.blur = "blur"
BrowserEvents.paste = "paste"
BrowserEvents.copy = "copy"
BrowserEvents.resize = "resize"
BrowserEvents.cut = "cut"
BrowserEvents.drop = "drop"
BrowserEvents.dragover = "dragover"
BrowserEvents.dragenter = "dragenter"
BrowserEvents.dragleave = "dragleave"
BrowserEvents.ready = "ready"
const WillowConstants = {}
// todo: cleanup
WillowConstants.clickCommand = "clickCommand"
WillowConstants.shiftClickCommand = "shiftClickCommand"
WillowConstants.blurCommand = "blurCommand"
WillowConstants.contextMenuCommand = "contextMenuCommand"
WillowConstants.changeCommand = "changeCommand"
WillowConstants.doubleClickCommand = "doubleClickCommand"
// todo: cleanup
WillowConstants.titleTag = "titleTag"
WillowConstants.styleTag = "styleTag"
WillowConstants.tagMap = {}
WillowConstants.tagMap[WillowConstants.styleTag] = "style"
WillowConstants.tagMap[WillowConstants.titleTag] = "title"
WillowConstants.tags = {}
WillowConstants.tags.html = "html"
WillowConstants.tags.head = "head"
WillowConstants.tags.body = "body"
WillowConstants.collapse = "collapse"
WillowConstants.uidAttribute = "stumpUid"
WillowConstants.class = "class"
WillowConstants.type = "type"
WillowConstants.value = "value"
WillowConstants.name = "name"
WillowConstants.checkbox = "checkbox"
WillowConstants.checkedSelector = ":checked"
WillowConstants.contenteditable = "contenteditable"
WillowConstants.inputTypes = ["input", "textarea"]
var CacheType
;(function(CacheType) {
  CacheType["inBrowserMemory"] = "inBrowserMemory"
})(CacheType || (CacheType = {}))
class WillowHTTPResponse {
  constructor(superAgentResponse) {
    this._cacheType = CacheType.inBrowserMemory
    this._fromCache = false
    this._cacheTime = Date.now()
    this._superAgentResponse = superAgentResponse
    this._mimeType = superAgentResponse && superAgentResponse.type
  }
  // todo: ServerMemoryCacheTime and ServerMemoryDiskCacheTime
  get cacheTime() {
    return this._cacheTime
  }
  get cacheType() {
    return this._cacheType
  }
  get body() {
    return this._superAgentResponse && this._superAgentResponse.body
  }
  get text() {
    if (this._text === undefined) this._text = this._superAgentResponse && this._superAgentResponse.text ? this._superAgentResponse.text : this.body ? JSON.stringify(this.body, null, 2) : ""
    return this._text
  }
  get asJson() {
    return this.body ? this.body : JSON.parse(this.text)
  }
  get fromCache() {
    return this._fromCache
  }
  setFromCache(val) {
    this._fromCache = val
    return this
  }
  getParsedDataOrText() {
    if (this._mimeType === "text/csv") return this.text
    return this.body || this.text
  }
}
class WillowHTTPProxyCacheResponse extends WillowHTTPResponse {
  constructor(proxyServerResponse) {
    super()
    this._proxyServerResponse = proxyServerResponse
    this._cacheType = proxyServerResponse.body.cacheType
    this._cacheTime = proxyServerResponse.body.cacheTime
    this._text = proxyServerResponse.body.text
  }
}
class AbstractWillowShadow {
  constructor(stumpNode) {
    this._stumpNode = stumpNode
  }
  getShadowStumpNode() {
    return this._stumpNode
  }
  getShadowValue() {
    return this._val
  }
  removeShadow() {
    return this
  }
  setInputOrTextAreaValue(value) {
    this._val = value
    return this
  }
  getShadowParent() {
    return this.getShadowStumpNode()
      .getParent()
      .getShadow()
  }
  getPositionAndDimensions(gridSize = 1) {
    const offset = this.getShadowOffset()
    const parentOffset = this.getShadowParent().getShadowOffset()
    return {
      left: Math.floor((offset.left - parentOffset.left) / gridSize),
      top: Math.floor((offset.top - parentOffset.top) / gridSize),
      width: Math.floor(this.getShadowWidth() / gridSize),
      height: Math.floor(this.getShadowHeight() / gridSize)
    }
  }
  shadowHasClass(name) {
    return false
  }
  getShadowAttr(name) {
    return ""
  }
  makeResizable(options) {
    return this
  }
  makeDraggable(options) {
    return this
  }
  makeSelectable(options) {
    return this
  }
  isShadowChecked() {
    return false
  }
  getShadowHtml() {
    return ""
  }
  getShadowOffset() {
    return { left: 111, top: 111 }
  }
  getShadowWidth() {
    return 111
  }
  getShadowHeight() {
    return 111
  }
  isShadowResizable() {
    return false
  }
  setShadowAttr(name, value) {
    return this
  }
  isShadowDraggable() {
    return this.shadowHasClass("draggable")
  }
  toggleShadow() {}
  addClassToShadow(className) {}
  removeClassFromShadow(className) {
    return this
  }
  onShadowEvent(event, selector, fn) {
    // todo:
    return this
  }
  offShadowEvent(event, fn) {
    // todo:
    return this
  }
  triggerShadowEvent(name) {
    return this
  }
  getShadowPosition() {
    return {
      left: 111,
      top: 111
    }
  }
  getShadowOuterHeight() {
    return 11
  }
  getShadowOuterWidth() {
    return 11
  }
  getShadowCss(property) {
    return ""
  }
  setShadowCss(css) {
    return this
  }
  insertHtmlNode(childNode, index) {}
  getShadowElement() {}
}
class WillowShadow extends AbstractWillowShadow {}
class WillowStore {
  constructor() {
    this._values = {}
  }
  get(key) {
    return this._values[key]
  }
  set(key, value) {
    this._values[key] = value
    return this
  }
  remove(key) {
    delete this._values[key]
  }
  each(fn) {
    Object.keys(this._values).forEach(key => {
      fn(this._values[key], key)
    })
  }
  clearAll() {
    this._values = {}
  }
}
class WillowMousetrap {
  constructor() {
    this.prototype = {}
  }
  bind() {}
}
// this one should have no document, window, $, et cetera.
class AbstractWillowBrowser extends stumpNode {
  constructor(fullHtmlPageUrlIncludingProtocolAndFileName) {
    super(`${WillowConstants.tags.html}
 ${WillowConstants.tags.head}
 ${WillowConstants.tags.body}`)
    this._offlineMode = false
    this._httpGetResponseCache = {}
    this.location = {}
    this._htmlStumpNode = this.nodeAt(0)
    this._headStumpNode = this.nodeAt(0).nodeAt(0)
    this._bodyStumpNode = this.nodeAt(0).nodeAt(1)
    this.addSuidsToHtmlHeadAndBodyShadows()
    this._fullHtmlPageUrlIncludingProtocolAndFileName = fullHtmlPageUrlIncludingProtocolAndFileName
    const url = new URL(fullHtmlPageUrlIncludingProtocolAndFileName)
    this.location.port = url.port
    this.location.protocol = url.protocol
    this.location.hostname = url.hostname
    this.location.host = url.host
  }
  _getPort() {
    return this.location.port ? ":" + this.location.port : ""
  }
  getHash() {
    return this.location.hash || ""
  }
  setHash(value) {
    this.location.hash = value
  }
  queryObjectToQueryString(obj) {
    const params = new URLSearchParams()
    for (const [key, value] of Object.entries(obj)) {
      params.set(key, String(value))
    }
    return params.toString()
  }
  toPrettyDeepLink(treeCode, queryObject) {
    // todo: move things to a constant.
    const nodeBreakSymbol = "~"
    const edgeSymbol = "_"
    const obj = Object.assign({}, queryObject)
    if (!treeCode.includes(nodeBreakSymbol) && !treeCode.includes(edgeSymbol)) {
      obj.nodeBreakSymbol = nodeBreakSymbol
      obj.edgeSymbol = edgeSymbol
      obj.data = encodeURIComponent(treeCode.replace(/ /g, edgeSymbol).replace(/\n/g, nodeBreakSymbol))
    } else obj.data = encodeURIComponent(treeCode)
    return this.getAppWebPageUrl() + "?" + this.queryObjectToQueryString(obj)
  }
  getHost() {
    return this.location.host
  }
  reload() {}
  toggleOfflineMode() {
    this._offlineMode = !this._offlineMode
  }
  addSuidsToHtmlHeadAndBodyShadows() {}
  getShadowClass() {
    return WillowShadow
  }
  getMockMouseEvent() {
    return {
      clientX: 0,
      clientY: 0,
      offsetX: 0,
      offsetY: 0
    }
  }
  toggleFullScreen() {}
  getMousetrap() {
    if (!this._mousetrap) this._mousetrap = new WillowMousetrap()
    return this._mousetrap
  }
  _getFocusedShadow() {
    return this._focusedShadow || this.getBodyStumpNode().getShadow()
  }
  getHeadStumpNode() {
    return this._headStumpNode
  }
  getBodyStumpNode() {
    return this._bodyStumpNode
  }
  getHtmlStumpNode() {
    return this._htmlStumpNode
  }
  getStore() {
    if (!this._store) this._store = new WillowStore()
    return this._store
  }
  someInputHasFocus() {
    const focusedShadow = this._getFocusedShadow()
    if (!focusedShadow) return false
    const stumpNode = focusedShadow.getShadowStumpNode()
    return stumpNode && stumpNode.isInputType()
  }
  copyTextToClipboard(text) {}
  setCopyData(evt, str) {}
  getAppWebPageUrl() {
    return this._fullHtmlPageUrlIncludingProtocolAndFileName
  }
  getAppWebPageParentFolderWithoutTrailingSlash() {
    return jtree.Utils.getPathWithoutFileName(this._fullHtmlPageUrlIncludingProtocolAndFileName)
  }
  _makeRelativeUrlAbsolute(url) {
    if (url.startsWith("http://") || url.startsWith("https://")) return url
    return this.getAppWebPageParentFolderWithoutTrailingSlash() + "/" + url.replace(/^\//, "")
  }
  async makeUrlAbsoluteAndHttpGetUrl(url, queryStringObject, responseClass = WillowHTTPResponse) {
    return this.httpGetUrl(this._makeRelativeUrlAbsolute(url), queryStringObject, responseClass)
  }
  async httpGetUrl(url, queryStringObject, responseClass = WillowHTTPResponse) {
    if (this._offlineMode) return new WillowHTTPResponse()
    const superAgentResponse = await superagent
      .get(url)
      .query(queryStringObject)
      .set(this._headers || {})
    return new responseClass(superAgentResponse)
  }
  _getFromResponseCache(cacheKey) {
    const hit = this._httpGetResponseCache[cacheKey]
    if (hit) hit.setFromCache(true)
    return hit
  }
  _setInResponseCache(url, res) {
    this._httpGetResponseCache[url] = res
    return this
  }
  async httpGetUrlFromCache(url, queryStringMap = {}, responseClass = WillowHTTPResponse) {
    const cacheKey = url + JSON.stringify(queryStringMap)
    const cacheHit = this._getFromResponseCache(cacheKey)
    if (!cacheHit) {
      const res = await this.httpGetUrl(url, queryStringMap, responseClass)
      this._setInResponseCache(cacheKey, res)
      return res
    }
    return cacheHit
  }
  async httpGetUrlFromProxyCache(url) {
    const queryStringMap = {}
    queryStringMap.url = url
    queryStringMap.cacheOnServer = "true"
    return await this.httpGetUrlFromCache("/proxy", queryStringMap, WillowHTTPProxyCacheResponse)
  }
  async httpPostUrl(url, data) {
    if (this._offlineMode) return new WillowHTTPResponse()
    const superAgentResponse = await superagent
      .post(this._makeRelativeUrlAbsolute(url))
      .set(this._headers || {})
      .send(data)
    return new WillowHTTPResponse(superAgentResponse)
  }
  encodeURIComponent(str) {
    return encodeURIComponent(str)
  }
  downloadFile(data, filename, filetype) {
    // noop
  }
  async appendScript(url) {}
  getWindowTitle() {
    // todo: deep getNodeByBase/withBase/type/word or something?
    const nodes = this.getTopDownArray()
    const titleNode = nodes.find(node => node.getFirstWord() === WillowConstants.titleTag)
    return titleNode ? titleNode.getContent() : ""
  }
  setWindowTitle(value) {
    const nodes = this.getTopDownArray()
    const headNode = nodes.find(node => node.getFirstWord() === WillowConstants.tags.head)
    headNode.touchNode(WillowConstants.titleTag).setContent(value)
    return this
  }
  _getHostname() {
    return this.location.hostname || ""
  }
  openUrl(link) {
    // noop in willow
  }
  getPageHtml() {
    return this.getHtmlStumpNode().toHtmlWithSuids()
  }
  getStumpNodeFromElement(el) {}
  setPasteHandler(fn) {
    return this
  }
  setErrorHandler(fn) {
    return this
  }
  setCopyHandler(fn) {
    return this
  }
  setCutHandler(fn) {
    return this
  }
  setResizeEndHandler(fn) {
    return this
  }
  async confirmThen(message) {
    return true
  }
  async promptThen(message, value) {
    return value
  }
  setLoadedDroppedFileHandler(callback, helpText = "") {}
  getWindowSize() {
    return {
      width: 1111,
      height: 1111
    }
  }
  getDocumentSize() {
    return this.getWindowSize()
  }
  isExternalLink(link) {
    if (link && link.substr(0, 1) === "/") return false
    if (!link.includes("//")) return false
    const hostname = this._getHostname()
    const url = new URL(link)
    return url.hostname && hostname !== url.hostname
  }
  forceRepaint() {}
  blurFocusedInput() {}
}
class WillowBrowser extends AbstractWillowBrowser {
  constructor(fullHtmlPageUrlIncludingProtocolAndFileName) {
    super(fullHtmlPageUrlIncludingProtocolAndFileName)
    this._offlineMode = true
  }
}
WillowBrowser._stumpsOnPage = 0
class WillowBrowserShadow extends AbstractWillowShadow {
  _getJQElement() {
    // todo: speedup?
    if (!this._cachedEl) this._cachedEl = jQuery(`[${WillowConstants.uidAttribute}="${this.getShadowStumpNode()._getUid()}"]`)
    return this._cachedEl
  }
  getShadowElement() {
    return this._getJQElement()[0]
  }
  getShadowPosition() {
    return this._getJQElement().position()
  }
  shadowHasClass(name) {
    return this._getJQElement().hasClass(name)
  }
  getShadowHtml() {
    return this._getJQElement().html()
  }
  getShadowValue() {
    // todo: cleanup, add tests
    if (this.getShadowStumpNode().isInputType()) return this._getJQElement().val()
    return this._getJQElement().val() || this.getShadowValueFromAttr()
  }
  getShadowValueFromAttr() {
    return this._getJQElement().attr(WillowConstants.value)
  }
  getShadowOuterHeight() {
    return this._getJQElement().outerHeight()
  }
  getShadowOuterWidth() {
    return this._getJQElement().outerWidth()
  }
  isShadowChecked() {
    return this._getJQElement().is(WillowConstants.checkedSelector)
  }
  getShadowWidth() {
    return this._getJQElement().width()
  }
  getShadowHeight() {
    return this._getJQElement().height()
  }
  getShadowOffset() {
    return this._getJQElement().offset()
  }
  getShadowAttr(name) {
    return this._getJQElement().attr(name)
  }
  _logMessage(type) {
    if (true) return true
    WillowBrowserShadow._shadowUpdateNumber++
    console.log(`DOM Update ${WillowBrowserShadow._shadowUpdateNumber}: ${type}`)
  }
  getShadowCss(prop) {
    return this._getJQElement().css(prop)
  }
  isShadowResizable() {
    return this._getJQElement().find(".ui-resizable-handle").length > 0
  }
  triggerShadowEvent(event) {
    this._getJQElement().trigger(event)
    this._logMessage("trigger")
    return this
  }
  // BEGIN MUTABLE METHODS:
  // todo: add tests
  // todo: idea, don't "paint" wall (dont append it to parent, until done.)
  insertHtmlNode(childStumpNode, index) {
    const newChildJqElement = jQuery(childStumpNode.toHtmlWithSuids())
    newChildJqElement.data("stumpNode", childStumpNode) // todo: what do we use this for?
    const jqEl = this._getJQElement()
    // todo: can we virtualize this?
    // would it be a "virtual shadow?"
    if (index === undefined) jqEl.append(newChildJqElement)
    else if (index === 0) jqEl.prepend(newChildJqElement)
    else jQuery(jqEl.children().get(index - 1)).after(newChildJqElement)
    WillowBrowser._stumpsOnPage++
    this._logMessage("insert")
  }
  addClassToShadow(className) {
    this._getJQElement().addClass(className)
    this._logMessage("addClass")
    return this
  }
  removeClassFromShadow(className) {
    this._getJQElement().removeClass(className)
    this._logMessage("removeClass")
    return this
  }
  onShadowEvent(event, two, three) {
    this._getJQElement().on(event, two, three)
    this._logMessage("bind on")
    return this
  }
  offShadowEvent(event, fn) {
    this._getJQElement().off(event, fn)
    this._logMessage("bind off")
    return this
  }
  toggleShadow() {
    this._getJQElement().toggle()
    this._logMessage("toggle")
    return this
  }
  makeResizable(options) {
    this._getJQElement().resizable(options)
    this._logMessage("resizable")
    return this
  }
  removeShadow() {
    this._getJQElement().remove()
    WillowBrowser._stumpsOnPage--
    this._logMessage("remove")
    return this
  }
  setInputOrTextAreaValue(value) {
    this._getJQElement().val(value)
    this._logMessage("val")
    return this
  }
  setShadowAttr(name, value) {
    this._getJQElement().attr(name, value)
    this._logMessage("attr")
    return this
  }
  makeDraggable(options) {
    this._logMessage("draggable")
    this._getJQElement().draggable(options)
    return this
  }
  setShadowCss(css) {
    this._getJQElement().css(css)
    this._logMessage("css")
    return this
  }
  makeSelectable(options) {
    this._getJQElement().selectable(options)
    this._logMessage("selectable")
    return this
  }
}
WillowBrowserShadow._shadowUpdateNumber = 0 // todo: what is this for, debugging perf?
// same thing, except with side effects.
class RealWillowBrowser extends AbstractWillowBrowser {
  findStumpNodesByShadowClass(className) {
    const stumpNodes = []
    const that = this
    jQuery("." + className).each(function() {
      stumpNodes.push(that.getStumpNodeFromElement(this))
    })
    return stumpNodes
  }
  addSuidsToHtmlHeadAndBodyShadows() {
    jQuery(WillowConstants.tags.html).attr(WillowConstants.uidAttribute, this.getHtmlStumpNode()._getUid())
    jQuery(WillowConstants.tags.head).attr(WillowConstants.uidAttribute, this.getHeadStumpNode()._getUid())
    jQuery(WillowConstants.tags.body).attr(WillowConstants.uidAttribute, this.getBodyStumpNode()._getUid())
  }
  getShadowClass() {
    return WillowBrowserShadow
  }
  setCopyHandler(fn) {
    jQuery(document).on(BrowserEvents.copy, fn)
    return this
  }
  setCutHandler(fn) {
    jQuery(document).on(BrowserEvents.cut, fn)
    return this
  }
  setPasteHandler(fn) {
    window.addEventListener(BrowserEvents.paste, fn, false)
    return this
  }
  setErrorHandler(fn) {
    window.addEventListener("error", fn)
    window.addEventListener("unhandledrejection", fn)
    return this
  }
  toggleFullScreen() {
    const doc = document
    if ((doc.fullScreenElement && doc.fullScreenElement !== null) || (!doc.mozFullScreen && !doc.webkitIsFullScreen)) {
      if (doc.documentElement.requestFullScreen) doc.documentElement.requestFullScreen()
      else if (doc.documentElement.mozRequestFullScreen) doc.documentElement.mozRequestFullScreen()
      else if (doc.documentElement.webkitRequestFullScreen) doc.documentElement.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)
    } else {
      if (doc.cancelFullScreen) doc.cancelFullScreen()
      else if (doc.mozCancelFullScreen) doc.mozCancelFullScreen()
      else if (doc.webkitCancelFullScreen) doc.webkitCancelFullScreen()
    }
  }
  setCopyData(evt, str) {
    const originalEvent = evt.originalEvent
    originalEvent.preventDefault()
    originalEvent.clipboardData.setData("text/plain", str)
    originalEvent.clipboardData.setData("text/html", str)
  }
  getMousetrap() {
    return window.Mousetrap
  }
  copyTextToClipboard(text) {
    // http://stackoverflow.com/questions/400212/how-do-i-copy-to-the-clipboard-in-javascript
    const textArea = document.createElement("textarea")
    textArea.style.position = "fixed"
    textArea.style.top = "0"
    textArea.style.left = "0"
    textArea.style.width = "2em"
    textArea.style.height = "2em"
    textArea.style.padding = "0"
    textArea.style.border = "none"
    textArea.style.outline = "none"
    textArea.style.boxShadow = "none"
    textArea.style.background = "transparent"
    textArea.value = text
    document.body.appendChild(textArea)
    textArea.select()
    try {
      const successful = document.execCommand("copy")
    } catch (err) {}
    document.body.removeChild(textArea)
  }
  getStore() {
    return window.store
  }
  getHash() {
    return location.hash || ""
  }
  setHash(value) {
    location.hash = value
  }
  getHost() {
    return location.host
  }
  _getHostname() {
    return location.hostname
  }
  async appendScript(url) {
    if (!url) return undefined
    if (!this._loadingPromises) this._loadingPromises = {}
    if (this._loadingPromises[url]) return this._loadingPromises[url]
    if (this.isNodeJs()) return undefined
    this._loadingPromises[url] = this._appendScript(url)
    return this._loadingPromises[url]
  }
  _appendScript(url) {
    //https://bradb.net/blog/promise-based-js-script-loader/
    return new Promise(function(resolve, reject) {
      let resolved = false
      const scriptEl = document.createElement("script")
      scriptEl.type = "text/javascript"
      scriptEl.src = url
      scriptEl.async = true
      scriptEl.onload = scriptEl.onreadystatechange = function() {
        if (!resolved && (!this.readyState || this.readyState == "complete")) {
          resolved = true
          resolve(this)
        }
      }
      scriptEl.onerror = scriptEl.onabort = reject
      document.head.appendChild(scriptEl)
    })
  }
  downloadFile(data, filename, filetype) {
    const downloadLink = document.createElement("a")
    downloadLink.setAttribute("href", `data:${filetype},` + encodeURIComponent(data))
    downloadLink.setAttribute("download", filename)
    downloadLink.click()
  }
  reload() {
    window.location.reload()
  }
  openUrl(link) {
    window.open(link)
  }
  setResizeEndHandler(fn) {
    let resizeTimer
    jQuery(window).on(BrowserEvents.resize, evt => {
      const target = jQuery(evt.target)
      if (target.is("div")) return // dont resize on div resizes
      clearTimeout(resizeTimer)
      resizeTimer = setTimeout(() => {
        fn({ width: target.width(), height: target.height() })
      }, 100)
    })
    return this
  }
  getStumpNodeFromElement(el) {
    const jqEl = jQuery(el)
    return this.getHtmlStumpNode().getNodeByGuid(parseInt(jqEl.attr(WillowConstants.uidAttribute)))
  }
  forceRepaint() {
    jQuery(window).width()
  }
  getBrowserHtml() {
    return document.documentElement.outerHTML
  }
  async confirmThen(message) {
    return confirm(message)
  }
  async promptThen(message, value) {
    return prompt(message, value)
  }
  getWindowSize() {
    const windowStumpNode = jQuery(window)
    return {
      width: windowStumpNode.width(),
      height: windowStumpNode.height()
    }
  }
  getDocumentSize() {
    const documentStumpNode = jQuery(document)
    return {
      width: documentStumpNode.width(),
      height: documentStumpNode.height()
    }
  }
  // todo: denote the side effect
  blurFocusedInput() {
    // todo: test against browser.
    document.activeElement.blur()
  }
  setLoadedDroppedFileHandler(callback, helpText = "") {
    const bodyStumpNode = this.getBodyStumpNode()
    const bodyShadow = bodyStumpNode.getShadow()
    // Added the below to ensure dragging from the chrome downloads bar works
    // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
    const handleChromeBug = event => {
      const originalEvent = event.originalEvent
      const effect = originalEvent.dataTransfer.effectAllowed
      originalEvent.dataTransfer.dropEffect = effect === "move" || effect === "linkMove" ? "move" : "copy"
    }
    const dragoverHandler = event => {
      handleChromeBug(event)
      event.preventDefault()
      event.stopPropagation()
      if (!bodyStumpNode.stumpNodeHasClass("dragOver")) {
        bodyStumpNode.insertChildNode(`div ${helpText}
 id dragOverHelp`)
        bodyStumpNode.addClassToStumpNode("dragOver")
        // Add the help, and then hopefull we'll get a dragover event on the dragOverHelp, then
        // 50ms later, add the dragleave handler, and from now on drag leave will only happen on the help
        // div
        setTimeout(function() {
          bodyShadow.onShadowEvent(BrowserEvents.dragleave, dragleaveHandler)
        }, 50)
      }
    }
    const dragleaveHandler = event => {
      event.preventDefault()
      event.stopPropagation()
      bodyStumpNode.removeClassFromStumpNode("dragOver")
      bodyStumpNode.findStumpNodeByChild("id dragOverHelp").removeStumpNode()
      bodyShadow.offShadowEvent(BrowserEvents.dragleave, dragleaveHandler)
    }
    const dropHandler = async event => {
      event.preventDefault()
      event.stopPropagation()
      bodyStumpNode.removeClassFromStumpNode("dragOver")
      bodyStumpNode.findStumpNodeByChild("id dragOverHelp").removeStumpNode()
      const droppedItems = event.originalEvent.dataTransfer.items
      // NOTE: YOU NEED TO STAY IN THE "DROP" EVENT, OTHERWISE THE DATATRANSFERITEMS MUTATE
      // (BY DESIGN) https://bugs.chromium.org/p/chromium/issues/detail?id=137231
      // DO NOT ADD AN AWAIT IN THIS LOOP. IT WILL BREAK.
      const items = []
      for (let droppedItem of droppedItems) {
        const entry = droppedItem.webkitGetAsEntry()
        items.push(this._handleDroppedEntry(entry))
      }
      const results = await Promise.all(items)
      callback(results)
    }
    bodyShadow.onShadowEvent(BrowserEvents.dragover, dragoverHandler)
    bodyShadow.onShadowEvent(BrowserEvents.drop, dropHandler)
    // todo: why do we do this?
    bodyShadow.onShadowEvent(BrowserEvents.dragenter, function(event) {
      event.preventDefault()
      event.stopPropagation()
    })
  }
  _handleDroppedEntry(item, path = "") {
    // http://stackoverflow.com/questions/3590058/does-html5-allow-drag-drop-upload-of-folders-or-a-folder-tree
    // http://stackoverflow.com/questions/6756583/prevent-browser-from-loading-a-drag-and-dropped-file
    return item.isFile ? this._handleDroppedFile(item) : this._handleDroppedDirectory(item, path)
  }
  _handleDroppedDirectory(item, path) {
    return new Promise((resolve, reject) => {
      item.createReader().readEntries(async entries => {
        const promises = []
        for (let i = 0; i < entries.length; i++) {
          promises.push(this._handleDroppedEntry(entries[i], path + item.name + "/"))
        }
        const res = await Promise.all(promises)
        resolve(res)
      })
    })
  }
  _handleDroppedFile(file) {
    // https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications
    // http://www.sitepoint.com/html5-javascript-open-dropped-files/
    return new Promise((resolve, reject) => {
      file.file(data => {
        const reader = new FileReader()
        reader.onload = evt => {
          resolve({ data: evt.target.result, filename: data.name })
        }
        reader.onerror = err => reject(err)
        reader.readAsText(data)
      })
    })
  }
  _getFocusedShadow() {
    const stumpNode = this.getStumpNodeFromElement(document.activeElement)
    return stumpNode && stumpNode.getShadow()
  }
}
class AbstractTheme {
  hakonToCss(str) {
    const hakonProgram = new hakonNode(str)
    // console.log(hakonProgram.getAllErrors())
    return hakonProgram.compile()
  }
}
class DefaultTheme extends AbstractTheme {}
class AbstractTreeComponent extends jtree.GrammarBackedNode {
  async startWhenReady() {
    if (this.isNodeJs()) return this.start()
    document.addEventListener(
      "DOMContentLoaded",
      async () => {
        this.start()
      },
      false
    )
  }
  start() {
    this._bindTreeComponentFrameworkCommandListenersOnBody()
    this.renderAndGetRenderReport(this.getWillowBrowser().getBodyStumpNode())
  }
  getWillowBrowser() {
    if (!this._willowBrowser) {
      if (this.isNodeJs()) {
        this._willowBrowser = new WillowBrowser("http://localhost:8000/index.html")
      } else {
        this._willowBrowser = new RealWillowBrowser(window.location.href)
      }
    }
    return this._willowBrowser
  }
  onCommandError(err) {
    throw err
  }
  _setMouseEvent(evt) {
    this._mouseEvent = evt
    return this
  }
  getMouseEvent() {
    return this._mouseEvent || this.getWillowBrowser().getMockMouseEvent()
  }
  _onCommandWillRun() {
    // todo: remove. currently used by ohayo
  }
  _getCommandArgumentsFromStumpNode(stumpNode, commandMethod) {
    if (commandMethod.includes(" ")) {
      // todo: cleanup and document
      // It seems the command arguments can from the method string or from form values.
      const parts = commandMethod.split(" ")
      return {
        uno: parts[1],
        dos: parts[2]
      }
    }
    const shadow = stumpNode.getShadow()
    let valueParam
    if (stumpNode.isStumpNodeCheckbox()) valueParam = shadow.isShadowChecked() ? true : false
    // todo: fix bug if nothing is entered.
    else if (shadow.getShadowValue() !== undefined) valueParam = shadow.getShadowValue()
    else valueParam = stumpNode.getStumpNodeAttr("value")
    const nameParam = stumpNode.getStumpNodeAttr("name")
    return {
      uno: valueParam,
      dos: nameParam
    }
  }
  getStumpNodeString() {
    return this.getWillowBrowser()
      .getHtmlStumpNode()
      .toString()
  }
  _getHtmlOnlyNodes() {
    const nodes = []
    this.getWillowBrowser()
      .getHtmlStumpNode()
      .deepVisit(node => {
        if (node.getFirstWord() === "styleTag" || (node.getContent() || "").startsWith("<svg ")) return false
        nodes.push(node)
      })
    return nodes
  }
  getStumpNodeStringWithoutCssAndSvg() {
    // todo: cleanup. feels hacky.
    const clone = new jtree.TreeNode(
      this.getWillowBrowser()
        .getHtmlStumpNode()
        .toString()
    )
    clone.getTopDownArray().forEach(node => {
      if (node.getFirstWord() === "styleTag" || (node.getContent() || "").startsWith("<svg ")) node.destroy()
    })
    return clone.toString()
  }
  getTextContent() {
    return this._getHtmlOnlyNodes()
      .map(node => node.getTextContent())
      .filter(text => text)
      .join("\n")
  }
  getCommandNames() {
    return Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(word => word.endsWith("Command"))
  }
  async _executeCommandOnStumpNode(stumpNode, commandMethod) {
    const params = this._getCommandArgumentsFromStumpNode(stumpNode, commandMethod)
    if (commandMethod.includes(" "))
      // todo: cleanup
      commandMethod = commandMethod.split(" ")[0]
    this.addToCommandLog([commandMethod, params.uno, params.dos].filter(identity => identity).join(" "))
    this._onCommandWillRun() // todo: remove. currently used by ohayo
    let treeComponent = stumpNode.getStumpNodeTreeComponent()
    while (!treeComponent[commandMethod]) {
      const parent = treeComponent.getParent()
      if (parent === treeComponent) throw new Error(`Unknown command "${commandMethod}"`)
      if (!parent) debugger
      treeComponent = parent
    }
    try {
      await treeComponent[commandMethod](params.uno, params.dos)
    } catch (err) {
      this.onCommandError(err)
    }
  }
  _bindTreeComponentFrameworkCommandListenersOnBody() {
    const willowBrowser = this.getWillowBrowser()
    const bodyShadow = willowBrowser.getBodyStumpNode().getShadow()
    const app = this
    const checkAndExecute = (el, attr, evt) => {
      const stumpNode = willowBrowser.getStumpNodeFromElement(el)
      evt.preventDefault()
      evt.stopImmediatePropagation()
      this._executeCommandOnStumpNode(stumpNode, stumpNode.getStumpNodeAttr(attr))
      return false
    }
    bodyShadow.onShadowEvent(BrowserEvents.contextmenu, `[${WillowConstants.contextMenuCommand}]`, function(evt) {
      if (evt.ctrlKey) return true
      app._setMouseEvent(evt) // todo: remove?
      return checkAndExecute(this, WillowConstants.contextMenuCommand, evt)
    })
    bodyShadow.onShadowEvent(BrowserEvents.click, `[${WillowConstants.clickCommand}]`, function(evt) {
      if (evt.shiftKey) return checkAndExecute(this, WillowConstants.shiftClickCommand, evt)
      return checkAndExecute(this, WillowConstants.clickCommand, evt)
    })
    bodyShadow.onShadowEvent(BrowserEvents.dblclick, `[${WillowConstants.doubleClickCommand}]`, function(evt) {
      if (evt.target !== evt.currentTarget) return true // direct dblclicks only
      app._setMouseEvent(evt) // todo: remove?
      return checkAndExecute(this, WillowConstants.doubleClickCommand, evt)
    })
    bodyShadow.onShadowEvent(BrowserEvents.blur, `[${WillowConstants.blurCommand}]`, function(evt) {
      return checkAndExecute(this, WillowConstants.blurCommand, evt)
    })
    bodyShadow.onShadowEvent(BrowserEvents.change, `[${WillowConstants.changeCommand}]`, function(evt) {
      return checkAndExecute(this, WillowConstants.changeCommand, evt)
    })
  }
  stopPropagationCommand() {
    // todo: remove?
    // intentional noop
  }
  // todo: remove?
  async clearMessageBufferCommand() {
    delete this._messageBuffer
  }
  // todo: remove?
  async unmountAndDestroyCommand() {
    this.unmountAndDestroy()
  }
  toggleTreeComponentFrameworkDebuggerCommand() {
    // todo: move somewhere else?
    // todo: cleanup
    const app = this.getRootNode()
    const node = app.getNode("TreeComponentFrameworkDebuggerComponent")
    if (node) {
      node.unmountAndDestroy()
    } else {
      app.appendLine("TreeComponentFrameworkDebuggerComponent")
      app.renderAndGetRenderReport()
    }
  }
  getStumpNode() {
    return this._htmlStumpNode
  }
  toHakonCode() {
    return ""
  }
  getTheme() {
    if (!this.isRoot()) return this.getRootNode().getTheme()
    if (!this._theme) this._theme = new DefaultTheme()
    return this._theme
  }
  getCommandsBuffer() {
    if (!this._commandsBuffer) this._commandsBuffer = []
    return this._commandsBuffer
  }
  addToCommandLog(command) {
    this.getCommandsBuffer().push({
      command: command,
      time: this._getProcessTimeInMilliseconds()
    })
  }
  getMessageBuffer() {
    if (!this._messageBuffer) this._messageBuffer = new jtree.TreeNode()
    return this._messageBuffer
  }
  // todo: move this to tree class? or other higher level class?
  addStumpCodeMessageToLog(message) {
    // note: we have 1 parameter, and are going to do type inference first.
    // Todo: add actions that can be taken from a message?
    // todo: add tests
    this.getMessageBuffer().appendLineAndChildren("message", message)
  }
  addStumpErrorMessageToLog(errorMessage) {
    return this.addStumpCodeMessageToLog(`div
 class OhayoError
 bern${jtree.TreeNode.nest(errorMessage, 2)}`)
  }
  logMessageText(message = "") {
    const pre = `pre
 bern${jtree.TreeNode.nest(message, 2)}`
    return this.addStumpCodeMessageToLog(pre)
  }
  unmount() {
    if (
      !this.isMounted() // todo: why do we need this check?
    )
      return undefined
    this._getChildTreeComponents().forEach(child => child.unmount())
    this.treeComponentWillUnmount()
    this._removeCss()
    this._removeHtml()
    delete this._lastRenderedTime
    this.treeComponentDidUnmount()
  }
  _removeHtml() {
    this._htmlStumpNode.removeStumpNode()
    delete this._htmlStumpNode
  }
  toStumpCode() {
    return `div
 class ${this.getCssClassNames().join(" ")}`
  }
  getCssClassNames() {
    return this._getJavascriptPrototypeChainUpTo("AbstractTreeComponent")
  }
  treeComponentWillMount() {}
  async treeComponentDidMount() {
    AbstractTreeComponent._mountedTreeComponents++
  }
  treeComponentDidUnmount() {
    AbstractTreeComponent._mountedTreeComponents--
  }
  treeComponentWillUnmount() {}
  getNewestTimeToRender() {
    return this._lastTimeToRender
  }
  _setLastRenderedTime(time) {
    this._lastRenderedTime = time
    return this
  }
  async treeComponentDidUpdate() {}
  _getChildTreeComponents() {
    return this.getChildrenByNodeConstructor(AbstractTreeComponent)
  }
  _hasChildrenTreeComponents() {
    return this._getChildTreeComponents().length > 0
  }
  // todo: this is hacky. we do it so we can just mount all tiles to wall.
  getStumpNodeForChildren() {
    return this.getStumpNode()
  }
  _getLastRenderedTime() {
    return this._lastRenderedTime
  }
  _getCss() {
    return this.getTheme().hakonToCss(this.toHakonCode())
  }
  toPlainHtml(containerId) {
    return `<div id="${containerId}">
 <style>${this.getTheme().hakonToCss(this.toHakonCode())}</style>
${new stumpNode(this.toStumpCode()).compile()}
</div>`
  }
  _getCssStumpCode() {
    return `styleTag
 for ${this.constructor.name}
 bern${jtree.TreeNode.nest(this._getCss(), 2)}`
  }
  _updateAndGetUpdateReport() {
    const reasonForUpdatingOrNot = this.getWhetherToUpdateAndReason()
    if (!reasonForUpdatingOrNot.shouldUpdate) return reasonForUpdatingOrNot
    this._setLastRenderedTime(this._getProcessTimeInMilliseconds())
    this._removeCss()
    this._mountCss()
    // todo: fucking switch to react? looks like we don't update parent because we dont want to nuke children.
    // okay. i see why we might do that for non tile treeComponents. but for Tile treeComponents, seems like we arent nesting, so why not?
    // for now
    if (this._hasChildrenTreeComponents()) return { shouldUpdate: false, reason: "did not update because is a parent" }
    this._updateHtml()
    this._lastTimeToRender = this._getProcessTimeInMilliseconds() - this._getLastRenderedTime()
    return reasonForUpdatingOrNot
  }
  _updateHtml() {
    const stumpNodeToMountOn = this._htmlStumpNode.getParent()
    const currentIndex = this._htmlStumpNode.getIndex()
    this._removeHtml()
    this._mountHtml(stumpNodeToMountOn, this._toLoadedOrLoadingStumpCode(), currentIndex)
  }
  unmountAndDestroy() {
    this.unmount()
    return this.destroy()
  }
  // todo: move to keyword node class?
  toggle(firstWord, contentOptions) {
    const currentNode = this.getNode(firstWord)
    if (!contentOptions) return currentNode ? currentNode.unmountAndDestroy() : this.appendLine(firstWord)
    const currentContent = currentNode === undefined ? undefined : currentNode.getContent()
    const index = contentOptions.indexOf(currentContent)
    const newContent = index === -1 || index + 1 === contentOptions.length ? contentOptions[0] : contentOptions[index + 1]
    this.delete(firstWord)
    if (newContent) this.touchNode(firstWord).setContent(newContent)
    return newContent
  }
  isMounted() {
    return !!this._htmlStumpNode
  }
  toggleAndRender(firstWord, contentOptions) {
    this.toggle(firstWord, contentOptions)
    this.getRootNode().renderAndGetRenderReport()
  }
  _getFirstOutdatedDependency(lastRenderedTime = this._getLastRenderedTime() || 0) {
    return this.getDependencies().find(dep => dep.getLineModifiedTime() > lastRenderedTime)
  }
  getWhetherToUpdateAndReason() {
    const mTime = this.getLineModifiedTime()
    const lastRenderedTime = this._getLastRenderedTime() || 0
    const staleTime = mTime - lastRenderedTime
    if (lastRenderedTime === 0)
      return {
        shouldUpdate: true,
        reason: "shouldUpdate because this TreeComponent hasn't been rendered yet",
        staleTime: staleTime
      }
    if (staleTime > 0)
      return {
        shouldUpdate: true,
        reason: "shouldUpdate because this TreeComponent changed",
        staleTime: staleTime
      }
    const outdatedDependency = this._getFirstOutdatedDependency(lastRenderedTime)
    if (outdatedDependency)
      return {
        shouldUpdate: true,
        reason: "Should update because a dependency updated",
        dependency: outdatedDependency,
        staleTime: outdatedDependency.getLineModifiedTime() - lastRenderedTime
      }
    return {
      shouldUpdate: false,
      reason: "Should NOT update because no dependency changed",
      lastRenderedTime: lastRenderedTime,
      mTime: mTime
    }
  }
  getDependencies() {
    return []
  }
  _getTreeComponentsThatNeedRendering(arr) {
    this._getChildTreeComponents().forEach(child => {
      const reasonForUpdatingOrNot = child.getWhetherToUpdateAndReason()
      if (!child.isMounted() || reasonForUpdatingOrNot.shouldUpdate) arr.push({ child: child, childUpdateBecause: reasonForUpdatingOrNot })
      child._getTreeComponentsThatNeedRendering(arr)
    })
  }
  toStumpLoadingCode() {
    return `div Loading ${this.getFirstWord()}...
 class ${this.getCssClassNames().join(" ")}
 id ${this.getTreeComponentId()}`
  }
  getTreeComponentId() {
    // html ids can't begin with a number
    return "treeComponent" + this._getUid()
  }
  _toLoadedOrLoadingStumpCode() {
    if (!this.isLoaded()) return this.toStumpLoadingCode()
    this.setRunTimePhaseError("renderPhase")
    try {
      return this.toStumpCode()
    } catch (err) {
      console.error(err)
      this.setRunTimePhaseError("renderPhase", err)
      return this.toStumpErrorStateCode(err)
    }
  }
  toStumpErrorStateCode(err) {
    return `div ${err}
 class ${this.getCssClassNames().join(" ")}
 id ${this.getTreeComponentId()}`
  }
  _mount(stumpNodeToMountOn, index) {
    this._setLastRenderedTime(this._getProcessTimeInMilliseconds())
    this.treeComponentWillMount()
    this._mountCss()
    this._mountHtml(stumpNodeToMountOn, this._toLoadedOrLoadingStumpCode(), index) // todo: add index back?
    this._lastTimeToRender = this._getProcessTimeInMilliseconds() - this._getLastRenderedTime()
    return this
  }
  // todo: we might be able to squeeze virtual dom in here on the mountCss and mountHtml methods.
  _mountCss() {
    // todo: only insert css once per class? have a set?
    this._cssStumpNode = this._getPageHeadStump().insertCssChildNode(this._getCssStumpCode())
  }
  _getPageHeadStump() {
    return this.getRootNode()
      .getWillowBrowser()
      .getHeadStumpNode()
  }
  _removeCss() {
    this._cssStumpNode.removeCssStumpNode()
    delete this._cssStumpNode
  }
  _mountHtml(stumpNodeToMountOn, htmlCode, index) {
    this._htmlStumpNode = stumpNodeToMountOn.insertChildNode(htmlCode, index)
    this._htmlStumpNode.setStumpNodeTreeComponent(this)
  }
  renderAndGetRenderReport(stumpNode, index) {
    const isUpdateOp = this.isMounted()
    let treeComponentUpdateReport = {
      shouldUpdate: false,
      reason: ""
    }
    if (isUpdateOp) treeComponentUpdateReport = this._updateAndGetUpdateReport()
    else this._mount(stumpNode, index)
    const stumpNodeForChildren = this.getStumpNodeForChildren()
    // Todo: insert delayed rendering?
    const childResults = this._getChildTreeComponents().map((child, index) => child.renderAndGetRenderReport(stumpNodeForChildren, index))
    if (isUpdateOp) {
      if (treeComponentUpdateReport.shouldUpdate) {
        try {
          if (this.isLoaded()) this.treeComponentDidUpdate()
        } catch (err) {
          console.error(err)
        }
      }
    } else {
      try {
        if (this.isLoaded()) this.treeComponentDidMount()
      } catch (err) {
        console.error(err)
      }
    }
    let str = `${this.getWord(0) || this.constructor.name} ${isUpdateOp ? "update" : "mount"} ${treeComponentUpdateReport.shouldUpdate} ${treeComponentUpdateReport.reason}`
    childResults.forEach(child => (str += "\n" + child.toString(1)))
    return new jtree.TreeNode(str)
  }
}
AbstractTreeComponent._mountedTreeComponents = 0
class TreeComponentFrameworkDebuggerComponent extends AbstractTreeComponent {
  toHakonCode() {
    return `.TreeComponentFrameworkDebuggerComponent
 position fixed
 top 5px
 left 5px
 z-index 1000
 background rgba(254,255,156, .95)
 box-shadow 1px 1px 1px rgba(0,0,0,.5)
 padding 12px
 overflow scroll
 max-height 500px
.TreeComponentFrameworkDebuggerComponentCloseButton
 position absolute
 cursor pointer
 opacity .9
 top 2px
 right 2px
 &:hover
  opacity 1`
  }
  toStumpCode() {
    const app = this.getRootNode()
    return `div
 class TreeComponentFrameworkDebuggerComponent
 div x
  class TreeComponentFrameworkDebuggerComponentCloseButton
  clickCommand toggleTreeComponentFrameworkDebuggerCommand
 div
  span This app is powered by the
  a Tree Component Framework
   href https://github.com/treenotation/jtree/tree/master/treeComponentFramework
 p ${app.getNumberOfLines()} components loaded. ${WillowBrowser._stumpsOnPage} stumps on page.
 pre
  bern
${app.toString(3)}`
  }
}
class AbstractGithubTriangleComponent extends AbstractTreeComponent {
  constructor() {
    super(...arguments)
    this.githubLink = `https://github.com/treenotation/jtree`
  }
  toHakonCode() {
    return `.AbstractGithubTriangleComponent
 display block
 position absolute
 top 0
 right 0`
  }
  toStumpCode() {
    return `a
 class AbstractGithubTriangleComponent
 href ${this.githubLink}
 img
  src /github-fork.svg`
  }
}
window.AbstractGithubTriangleComponent = AbstractGithubTriangleComponent
window.AbstractTreeComponent = AbstractTreeComponent
window.WillowBrowser = WillowBrowser
window.TreeComponentFrameworkDebuggerComponent = TreeComponentFrameworkDebuggerComponent
;

{
  class abstractTileTreeComponentNode extends AbstractTreeComponent {
    createParser() {
      return new jtree.TreeNode.Parser(
        catchAllErrorNode,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          hidden: hiddenNode,
          visible: visibleNode,
          maximized: maximizedNode,
          left: leftNode,
          top: topNode,
          width: widthNode,
          height: heightNode
        }),
        [{ regex: /^$/, nodeConstructor: tileBlankLineNode }]
      )
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get tileStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div {header}
  class TileHeader
 div
  style {bodyStyle}
  class TileBody
  {body}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get errorStateStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div ERROR
  class TileHeader
 div
  class TileBody
  {content}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get inspectionStumpTemplate() {
      return `div TileConstructor: {constructorName} ParentConstructor: {parentConstructorName}
div Messages:
ol
 {messages}
div Tree:
pre
 bern
  {sourceCode}
div All Tile Settings:
pre
 bern
  {settings}`
    }
    get pencilStumpTemplate() {
      return `span {icon}
 class TilePencilButton
 clickCommand toggleToolbarCommand`
    }
    get visibleKey() {
      return `visible`
    }
    get hiddenKey() {
      return `hidden`
    }
    get footerHeight() {
      return 30
    }
    get headerHeight() {
      return 30
    }
    getProgramTemplate(id) {}
    getSnippetTemplate(id) {}
    getExampleTemplate(index) {
      // todo: right now we only have 1 example per tile.
      const exampleNode = this.getDefinition().getNode(jtree.GrammarConstants.example)
      return exampleNode ? exampleNode.childrenToString() : ""
    }
    emitLogMessage(message) {
      const tab = this.getTab()
      if (tab) tab.addStumpCodeMessageToLog(message)
      else if (this.isNodeJs()) console.log(message)
    }
    getTheme() {
      return this.getTab().getTheme()
    }
    qFormat(str, obj) {
      return new jtree.TreeNode(str).templateToString(obj)
    }
    scrollIntoView() {
      const el = this.getStumpNode()
        .getShadow()
        .getShadowElement()
      if (el) el.scrollIntoView()
    }
    async loadRequirements() {
      const loadingMap = this.getTab()
        .getRootNode()
        .getDefinitionLoadingPromiseMap()
      if (!loadingMap.has(this.constructor)) loadingMap.set(this.constructor, this._makeLoadRequirementsPromise(loadingMap))
      await loadingMap.get(this.constructor)
    }
    async _makeLoadRequirementsPromise(loadingMap) {
      const app = this.getWebApp()
      const cssScript = this[TilesConstants.tileCssScript]
      if (cssScript) this._loadTileCss(cssScript)
      const scriptPath = this[TilesConstants.tileScript]
      if (scriptPath) await app.getWillowBrowser().appendScript(scriptPath)
      loadingMap.set(this.constructor, true)
    }
    _loadTileCss(css) {
      const app = this.getWebApp()
      app
        .getWillowBrowser()
        .getBodyStumpNode()
        .insertChildNode(
          css
            .split(" ")
            .map(
              url => `link
 rel stylesheet
 media screen
 href ${url}`
            )
            .join("\n")
        )
    }
    _hasRequirements() {
      return this.tileScript
    }
    _areRequirementsLoaded() {
      const loadingMap = this.getTab()
        .getRootNode()
        .getDefinitionLoadingPromiseMap()
      return !this._hasRequirements() || loadingMap.get(this.constructor) === true
    }
    isLoaded() {
      return this._areRequirementsLoaded()
    }
    getErrorMessageHtml() {
      const errors = Object.values(this.getRunTimePhaseErrors())
      return errors.length ? ` <span style="color: ${this.getTheme().errorColor};">${errors.join(" ")}</span>` : "" //todo: cleanup
    }
    toStumpErrorStateCode(err) {
      return this.qFormat(this.errorStateStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        id: this.getTreeComponentId(),
        content: `div ` + err,
        footer: this.getTileToolbarButtonStumpCode()
      })
    }
    // todo: delete this
    makeDirty() {
      delete this._cache_settingsObject
      delete this._bodyStumpCodeCache // todo: cleanup
      this._setLastRenderedTime(0)
    }
    toggleToolbar() {
      if (!this._tileToolbar) {
        const TileToolbarTreeComponent = this.require(
          "TileToolbarTreeComponent",
          this._getProjectRootDir() + "ohayoWebApp/treeComponents/TileToolbarTreeComponent.js"
        )
        this._tileToolbar = new TileToolbarTreeComponent("", undefined, this)
        this._tileToolbar.renderAndGetRenderReport(this.getStumpNode())
      } else this._tileToolbar = this._tileToolbar.unmount()
    }
    getAllTileSettingsDefinitions() {
      const def = this.getDefinition()
      return Object.values(def.getFirstWordMapWithDefinitions()).filter(def => def.isOrExtendsANodeTypeInScope([TilesConstants.abstractTileSetting]))
    }
    getTab() {
      return this.getRootNode().getTab()
    }
    getChildTiles() {
      return this.getChildInstancesOfNodeTypeId("abstractTileTreeComponentNode")
    }
    selectTile() {
      this.selectNode()
      if (this.isMounted()) this.getStumpNode().addClassToStumpNode(TilesConstants.selectedClass)
    }
    unselectNode() {
      super.unselectNode()
      if (this.isMounted()) this.getStumpNode().removeClassFromStumpNode(TilesConstants.selectedClass)
    }
    getCssClassNames() {
      const classNames = super.getCssClassNames()
      if (this._isMaximized()) classNames.push("TileMaximized")
      return classNames
    }
    toStumpCode() {
      return this.qFormat(this.tileStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        id: this.getTreeComponentId(),
        header: this.getTileHeaderBern(),
        bodyStyle: this.customBodyStyle || "",
        body: this._getBodyStumpCodeCache() || "",
        footer: this.getTileFooterStumpCode()
      })
    }
    _getBodyStumpCodeCache() {
      if (!this._bodyStumpCodeCache) this._bodyStumpCodeCache = this.getTileBodyStumpCode()
      return this._bodyStumpCodeCache
    }
    getTileHeaderBern() {
      return `${this.getFirstWord()}`
    }
    cloneAndOffset() {
      const clone = this.duplicate()
      const left = this.getLeft()
      const _top = this.getTop()
      if (left) clone.touchNode(TilesConstants.left).setContent(parseInt(left) + 1)
      if (_top) clone.touchNode(TilesConstants.top).setContent(parseInt(_top) + 1)
      return clone
    }
    getTileBodyStumpCode() {
      return ``
    }
    _getCss() {
      const selector = "#" + this.getTreeComponentId()
      const theme = this.getTheme()
      const visibleCss = this.isVisible() ? "" : "display: none"
      const dimensions = this.getTileDimensionIfAny()
      const dimensionCss = dimensions ? dimensions.toCss() : ""
      const hakonCode = this.hakonTemplate ? new jtree.TreeNode(theme).evalTemplateString(this.hakonTemplate) : this.toHakonCode()
      return `${selector} { ${visibleCss} ${dimensionCss} }
      ${theme.hakonToCss(hakonCode)}`
    }
    getContextMenuStumpCode() {
      return ""
    }
    handleTileError(err) {
      if (!this._errorCount) this._errorCount = 0
      this._errorCount++
      this.getRootNode().goRed(err)
    }
    getWall() {
      return this.getWebApp().getAppWall()
    }
    getWebApp() {
      return this.getTab().getRootNode()
    }
    getTileDimensionIfAny() {
      const dimensions = this.getWall().getWallViewPortDimensions()
      return this.getRootNode()
        .getTileDimensionMap(dimensions.width, dimensions.height)
        .get(this)
    }
    getTileBodyDimension() {
      const dimension = this.getTileDimensionIfAny()
      dimension.height = dimension.height - this.headerHeight - this.footerHeight
      return dimension
    }
    getDependencies() {
      return []
    }
    async runAndrenderAndGetRenderReport() {
      await this.execute()
      return this.renderAndGetRenderReport()
    }
    getTimeToLoad() {
      return this._timeToLoad || 0
    }
    toHakonCode() {
      return ""
    }
    getTileFooterStumpCode() {
      return this.getTileToolbarButtonStumpCode()
    }
    getTileToolbarButtonStumpCode() {
      return this.qFormat(this.pencilStumpTemplate, { icon: Icons("pencil", 16) })
    }
    getDefinedOrSuggestedSize() {
      const size = this.getSuggestedSize()
      const width = this.getWidth()
      const height = this.getHeight()
      return {
        width: width ? width * 20 : size.width,
        height: height ? height * 20 : size.height
      }
    }
    getSuggestedSize() {
      const tileSize = this.tileSize || "280 220"
      const parts = tileSize.split(" ").map(tileSize => parseInt(tileSize))
      return {
        width: parts[0],
        height: parts[1]
      }
    }
    getRequiredDimensionsForTreeLayout(padding = 0) {
      const size = {
        width: 0,
        height: 0
      }
      const children = this.getChildTiles()
      const suggestedSize = this.getDefinedOrSuggestedSize()
      children.forEach(child => {
        const childSize = child.getRequiredDimensionsForTreeLayout(padding)
        size.width += childSize.width
        size.height = childSize.height > size.height ? childSize.height : size.height
      })
      size.width += children.length * padding
      size.width = Math.max(size.width, suggestedSize.width)
      size.height = suggestedSize.height + (children.length ? padding + size.height : 0)
      return size
    }
    getLeft() {
      return this.get(TilesConstants.left)
    }
    getTop() {
      return this.get(TilesConstants.top)
    }
    getWidth() {
      return this.get(TilesConstants.width)
    }
    getHeight() {
      return this.get(TilesConstants.height)
    }
    // Tile child rendering is done at the wall flex level.
    _getChildTreeComponents() {
      return []
    }
    getStumpNodeForChildren() {
      // We render all Tiles on the Wall.
      return this.getStumpNode().getParent()
    }
    async treeComponentDidMount() {
      super.treeComponentDidMount()
      if (this._tileToolbar) this._tileToolbar.renderAndGetRenderReport()
    }
    toInspectionStumpCode() {
      const messages = this.getMessageBuffer().map(message => `li ${moment(message.getLineModifiedTime()).fromNow()} - ${message.childrenToString()}`)
      const settingsDefinitions = this.getAllTileSettingsDefinitions()
        .map(setting => `${setting.getFirstWord()} ${setting.getDescription()}`)
        .join("\n")
      const parentConstructorName = this.getParent().constructor.name
      const constructorName = this.constructor.name
      const sourceCode = this.toString()
      const settings = settingsDefinitions
      return this.qFormat(this.inspectionStumpTemplate, {
        constructorName,
        parentConstructorName,
        sourceCode,
        messages,
        settings
      })
    }
    isVisible() {
      if (this.visible === false) return false
      return this.has(this.visibleKey) || (this.getRootNode().tilesAreVisible() && !this.has(this.hiddenKey))
    }
    _isMaximized() {
      return this.has(TilesConstants.maximized)
    }
    async _executeChildNodes() {
      await this._runChildTiles()
    }
    async _runChildTiles() {
      await Promise.all(this.getChildTiles().map(tile => tile.execute()))
    }
    async execute() {
      try {
        this.setRunTimePhaseError("execute")
        await this._executeChildNodes()
      } catch (err) {
        this.setRunTimePhaseError("execute", err)
        console.error(err)
        const theme = this.getTheme()
        this.emitLogMessage(`div
   bern
    Error occurred. See console.
   style color: ${theme.errorColor};`)
      }
      return this
    }
    cloneTileCommand() {
      this.cloneAndOffset()
      return this.getTab().autosaveAndRender()
    }
    async toggleTileMaximizeCommand() {
      if (this.has(TilesConstants.maximized)) this.delete(TilesConstants.maximized)
      else this.touchNode(TilesConstants.maximized)
      await this._runAfterTileUpdate(this)
    }
    async triggerTileMethodCommand(value, methodName) {
      await this[methodName](value)
      await this._runAfterTileUpdate(tile)
    }
    // todo: refactor.
    async changeTileTypeCommand(newValue) {
      this.setFirstWord(newValue)
      const newNode = this.duplicate()
      // todo: destroy or something? how do we reparse.
      this.unmountAndDestroy()
      const app = this.getTab().getRootNode()
      await this.getRootNode().loadRequirements()
      await this.getTab().autosaveAndRender()
      newNode.runAndrenderAndGetRenderReport()
    }
    changeParentCommand(pathVector) {
      // if (tile.getFirstWordPath() === value) return; // todo: do we need this line?
      const program = this.getRootNode()
      const indexPath = pathVector ? pathVector.split(" ").map(num => parseInt(num)) : ""
      const destinationTree = indexPath ? program.nodeAt(indexPath) : program
      // todo: on jtree should we make copyTo second param optional?
      this.copyTo(destinationTree, destinationTree.length)
      this.unmountAndDestroy()
      return this.getTab().autosaveAndRender()
    }
    async openTileContextMenuCommand() {
      this.getTab()
        .getRootNode()
        .setTargetNode(this)
        .toggleAndRender(OhayoConstants.tileContextMenu)
    }
    destroyTileCommand() {
      this.unmountAndDestroy()
      return this.getTab().autosaveAndRender()
    }
    getNewDataCommand() {
      // todo: have some type of paging system to fetch new data.
    }
    async changeTileSettingAndRenderCommand(value, settingName) {
      // note the unusual ordering of params.
      this.touchNode(settingName).setContent(value.toString())
      // todo: sometimes size needs to be redone (maximize, for example)
      await this._runAfterTileUpdate(this)
    }
    // todo: remove
    async changeTileSettingMultilineCommand(val, settingName) {
      this.touchNode(settingName).setChildren(val)
      await this._runAfterTileUpdate(this)
    }
    async changeTileSettingCommand(settingName, value) {
      this.touchNode(settingName).setContent(value)
    }
    async changeWordAndRenderCommand(value, index) {
      this.setWord(parseInt(index), value)
      await this._runAfterTileUpdate(this)
    }
    async changeWordsAndRenderCommand(value, index) {
      index = parseInt(index)
      const edgeSymbol = this.getEdgeSymbol()
      const words = this.getWords().slice(0, index)
      this.setLine(words.concat(value.split(edgeSymbol)).join(edgeSymbol))
      await this._runAfterTileUpdate(this)
    }
    async updateChildrenCommand(val) {
      this.setChildren(val)
      // reload the whole doc for now.
      await this._runAfterTileUpdate(this)
    }
    async _runAfterTileUpdate(tile) {
      tile.makeDirty() // ugly!
      tile.getChildTiles().forEach(tile => {
        tile.makeDirty() // todo: ugly!
      })
      // todo: what if you have a tile that has a contextare that allows editing of its children/
      // if you edit a child, then that parent tile needs to update to...should we allow that or ban that?
      await tile.getTab().autosaveTab()
      await tile.runAndrenderAndGetRenderReport()
      tile
        .getTab()
        .getRootNode()
        .renderApp() // Need to render full app because of code editor
    }
    // todo: downstream data changes?
    async changeTileContentAndRenderCommand(value) {
      this.setContent(value)
      await this._runAfterTileUpdate(this)
    }
    async copyTileCommand() {
      // todo: remove cousin tiles?
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(this.getFirstAncestor().toString())
    }
    async createProgramFromTileExampleCommand(index) {
      const template = this.getExampleTemplate(index)
      if (!template) return undefined
      const fileExtension = "maia" // todo: generalize
      const tab = await this.getTab()
        .getRootNode()
        ._createAndOpen(template, `help-for-${this.getFirstWord()}.${fileExtension}`)
      tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
    }
    async inspectTileCommand() {
      if (!this.isNodeJs()) {
        console.log("Tile available at window.tile")
        window.tile = this
        console.log(this)
      }
      this.getTab().addStumpCodeMessageToLog(this.toInspectionStumpCode())
      this.getTab()
        .getRootNode()
        .renderApp()
    }
    async toggleToolbarCommand() {
      this.toggleToolbar()
    }
    async createProgramFromTemplateCommand(id) {
      const programTemplate = this.getProgramTemplate(id)
      if (!programTemplate) return undefined
      const tab = await this.getTab()
        .getRootNode()
        ._createAndOpen(programTemplate.template, programTemplate.name)
      tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
    }
    async appendSnippetTemplateCommand(id) {
      const snippet = this.getSnippetTemplate(id)
      if (!snippet) return undefined
      const tab = this.getTab()
      const tabProgram = tab.getTabProgram()
      const newNodes = tabProgram.concat(snippet)
      const newTiles = newNodes.filter(tile => tile.doesExtend && tile.doesExtend("abstractTileTreeComponentNode"))
      tab.autosaveTab()
      tabProgram.clearSelection()
      tab.getTabWall().unmount()
      await tabProgram.loadAndIncrementalRender()
      newTiles.forEach(tile => tile.selectTile())
      newTiles[0].scrollIntoView()
    }
    async copyDataCommand(delimiter) {
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(this.getOutputOrInputTable().toDelimited(delimiter))
    }
    async copyDataAsJavascriptCommand() {
      const table = this.getOutputOrInputTable()
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(JSON.stringify(table.toTree().toDataTable(table.getColumnNames()), null, 2))
    }
    async copyDataAsTreeCommand() {
      const text = this.getOutputOrInputTable()
        .toTree()
        .toString()
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(text)
    }
    async exportTileDataCommand(format = "csv") {
      // todo: figure this out. use the browsers filename? tile title? id?
      let extension = "csv"
      let type = "text/csv"
      let str = this.getOutputOrInputTable().toDelimited(",")
      if (format === "tree") {
        extension = "tree"
        type = "text"
        str = this.getOutputOrInputTable()
          .toTree()
          .toString()
      }
      this.getRootNode()
        .getWillowBrowser()
        .downloadFile(str, this.getTab().getFileName() + "." + extension, type)
    }
  }

  class basicRecursiveTileNode extends abstractTileTreeComponentNode {
    get hakonTemplate() {
      return `.BasicRecursiveTile
 input
 textarea
  border 0
  font-size 14px
  height 100%
  width 100%`
    }
    getTileBodyStumpCode() {
      const edgeSymbol = " "
      const definition = this.getDefinition()
      const requiredCellIds = definition.getRequiredCellTypeIds()
      const catchAllIndex = requiredCellIds.length
      const catchAllCellTypeId = definition.getCatchAllCellTypeId()
      if (catchAllCellTypeId) requiredCellIds.push(catchAllCellTypeId)
      const cellInputs = requiredCellIds.map((cellTypeId, index) => {
        const isCatchAll = cellTypeId === catchAllCellTypeId && index === catchAllIndex
        const value = isCatchAll ? this.getWordsFrom(index + 1).join(edgeSymbol) : this.getWord(index + 1)
        return ` input
  placeholder ${cellTypeId}
  value ${value}
  name ${index + 1}
  changeCommand ${isCatchAll ? "changeWordsAndRenderCommand" : "changeWordAndRenderCommand"}`
      })
      return `div ${definition.getDescription()}
div
${cellInputs.join("\n")}`
    }
  }

  class DidYouMeanTileNode extends abstractTileTreeComponentNode {
    get bodyStumpTemplate() {
      return `div
 span No tile '{input}' found. Line {lineNo}. Did you mean
 a {closestTile}
  collapse
  tabindex -1
  value {closestTile}
  clickCommand changeTileTypeCommand
 span ?`
    }
    getTileBodyStumpCode() {
      const input = this.getFirstWord()
      const lineNo = this.getLineNumber()
      const closestTile = jtree.Utils.didYouMean(
        input,
        this.getRootNode()
          .getGrammarProgram()
          .getTopNodeTypeDefinitions()
          .map(def => def.get("crux"))
      )
      if (!closestTile) {
        if (!input) return `div Your program has a blank line on line ${lineNo}.`
        return `div No tile '${input}' found.`
      }
      return this.qFormat(this.bodyStumpTemplate, { input, lineNo, closestTile })
    }
    getErrors() {
      return [new jtree.UnknownNodeTypeError(this)]
    }
    getTileHeaderBern() {
      return ""
    }
  }

  class abstractDocTileNode extends abstractTileTreeComponentNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get tileStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div
  class TileBody HeaderLess
  {body}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get bodyStumpTemplate() {
      return `{tagName}
 bern
  {content}`
    }
    get headerHeight() {
      return 0
    }
    get footerHeight() {
      return 0
    }
    _getBody() {
      return this.qFormat(this.bodyStumpTemplate, { content: this.getContent() || "", tagName: this.tagName })
    }
    toStumpCode() {
      return this.qFormat(this.tileStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        footer: this.getTileToolbarButtonStumpCode(),
        id: this.getTreeComponentId(),
        body: this._getBody()
      })
    }
  }

  class docTitleNode extends abstractDocTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get stringCell() {
      return this.getWordsFrom(1)
    }
    get tagName() {
      return `h1`
    }
    get tileSize() {
      return `600 75`
    }
  }

  class docSubtitleNode extends docTitleNode {
    get tagName() {
      return `h2`
    }
  }

  class docSectionNode extends abstractDocTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          subtitle: docSectionSubtitleNode,
          paragraph: docSectionParagraphNode,
          link: docSectionLinkNode,
          code: docSectionCodeNode
        }),
        undefined
      )
    }
    _getBody() {
      return this.compile()
    }
    _getCompiledLine() {
      return ""
    }
  }

  class docReferenceNode extends abstractDocTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { url: docReferenceUrlNode }),
        undefined
      )
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get referenceIdCell() {
      return this.getWord(1)
    }
    get tagName() {
      return `p`
    }
  }

  class docCommentNode extends abstractTileTreeComponentNode {
    createParser() {
      return new jtree.TreeNode.Parser(commentLineNode, undefined, undefined)
    }
    get commentKeywordCell() {
      return this.getWord(0)
    }
    get commentCell() {
      return this.getWordsFrom(1)
    }
    get visible() {
      return false
    }
  }

  class abstractPickerTileNode extends abstractTileTreeComponentNode {
    get tileHeader() {
      return `Gallery`
    }
    get categoryBreakStumpTemplate() {
      return `div {category}
 class PickerCategory`
    }
    get itemStumpTemplate() {
      return `{categoryBreak}
a {name}
 br
  span {description}
 title {description}
 tabindex -1
 value {value}
 clickCommand {command}`
    }
    get hakonTemplate() {
      return `.PickerTileNode
 .PickerCategory
  width 100%
  margin-top 20px
  text-align center
 .TileBody
  display flex
  flex-flow row wrap
  a
   &:hover
    background-color {borderColor}
   padding 10px
   margin 5px
   height 30px
   background-color {backgroundColor}
   border 1px solid {borderColor}
   overflow hidden
   text-align center
   text-overflow ellipsis
   font-size 14px
   width 120px
   span
    font-size 70%`
    }
    get tileSize() {
      return `480 420`
    }
    async fetchTableInputs() {
      return { rows: this.getChoices().map(obj => obj.toObject()) }
    }
    getTileBodyStumpCode() {
      let lastCat = ""
      return this.getChoices()
        .map(choice => {
          choice.categoryBreak = lastCat !== choice.category ? this.qFormat(this.categoryBreakStumpTemplate, { category: choice.category }) : ""
          lastCat = choice.category
          return this.qFormat(this.itemStumpTemplate, choice)
        })
        .join("\n")
    }
    getTileHeaderBern() {
      return this.tileHeader
    }
  }

  class PickerTileNode extends abstractPickerTileNode {
    get tileHeader() {
      return `Tile Gallery`
    }
    getChoices() {
      const allChoices = this.getRootNode()
        .getGrammarProgram()
        .getTopNodeTypeDefinitions()
      const filteredChoices = allChoices.filter(nodeDef => !(nodeDef.get(jtree.GrammarConstants.tags) || "").includes(TilesConstants.noPicker))
      const theChoices = filteredChoices.length ? filteredChoices : allChoices
      return theChoices.map(nodeDefinition => {
        const nodeId = nodeDefinition.get("crux") || nodeDefinition.getNodeTypeIdFromDefinition()
        const name = nodeId.split(".")[1] || ""
        const category = lodash.upperFirst(nodeId.split(".")[0])
        const description = nodeDefinition.getDescription()
        return { name, category, description, value: nodeId, command: "changeTileTypeCommand" }
      })
    }
  }

  class abstractMaiaTileNode extends abstractTileTreeComponentNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          "tiles.didyoumean": DidYouMeanTileNode,
          "doc.title": docTitleNode,
          "doc.subtitle": docSubtitleNode,
          "doc.section": docSectionNode,
          "doc.ref": docReferenceNode,
          "doc.comment": docCommentNode,
          "doc.picker": PickerTileNode,
          "challenge.list": challengeListNode,
          "samples.list": samplesListNode,
          "vega.data.list": vegaDataListNode,
          "vega.example.list": vegaExampleListNode,
          "challenge.play": challengePlayNode,
          "dtjs.basic": dtjsBasicNode,
          "html.text": htmlTextNode,
          "html.printAs": htmlPrintAsNode,
          "html.h1": htmlH1Node,
          "html.img": htmlImgNode,
          "html.iframe": htmlIframeNode,
          "html.custom": htmlCustomNode,
          "show.rowCount": showRowCountNode,
          "show.columnCount": showColumnCountNode,
          "show.static": showStaticNode,
          "show.median": showMedianNode,
          "show.sum": showSumNode,
          "show.mean": showMeanNode,
          "show.min": showMinNode,
          "show.max": showMaxNode,
          "vega.bar": vegaBarNode,
          "vega.line": vegaLineNode,
          "vega.area": vegaAreaNode,
          "vega.scatter": vegaScatterNode,
          "vega.bubble": vegaBubbleNode,
          "vega.emoji": vegaEmojiNode,
          "vega.histogram": vegaHistogramNode,
          "vega.example": vegaExampleNode,
          "date.heatcal": dateHeatcalNode,
          "icons.human": iconsHumanNode,
          "icons.circle": iconsCircleNode,
          "markdown.toHtml": markdownToHtmlNode,
          "treenotation.outline": treenotationOutlineNode,
          "treenotation.dotline": treenotationDotlineNode,
          "amazon.history": amazonHistoryNode,
          "fitbit.all": fitbitAllNode,
          "datawrapper.comingSoon": datawrapperComingSoonNode,
          "dcjs.comingSoon": dcjsComingSoonNode,
          "finos.perspective.comingSoon": finosPerspectiveComingSoonNode,
          "fivethirtyeight.comingSoon": fivethirtyeightComingSoonNode,
          "highcharts.comingSoon": highchartsComingSoonNode,
          "re3data.comingSoon": re3dataComingSoonNode,
          "zing.comingSoon": zingComingSoonNode,
          "editor.helloWorld": editorHelloWorldNode,
          "debug.dump": debugDumpNode,
          "web.dump": webDumpNode,
          "debug.commands": debugCommandsNode,
          "debug.grammarTree": debugGrammarTreeNode,
          "debug.sleep": debugSleepNode,
          "debug.throw": debugThrowNode,
          "editor.gallery": editorGalleryNode,
          "handsontable.basic": handsontableBasicNode,
          "list.basic": listBasicNode,
          "list.links": listLinksNode,
          "tables.basic": tablesBasicNode,
          "tables.interesting": tablesInterestingNode,
          "tables.dump": tablesDumpNode,
          "text.wordcloud": textWordcloudNode,
          "treenotation.3d": treenotation3dNode,
          "disk.browse": diskBrowseNode,
          "disk.read": diskReadNode,
          "hackernews.top": hackernewsTopNode,
          "hackernews.submissions": hackernewsSubmissionsNode,
          "web.get": webGetNode,
          "web.post": webPostNode,
          "cancer.cases": cancerCasesNode,
          "kaggle.datasets.heart": kaggleDatasetsHeartNode,
          "samples.telescopes": samplesTelescopesNode,
          "samples.mtcars": samplesMtcarsNode,
          "samples.iris": samplesIrisNode,
          "samples.flights14": samplesFlights14Node,
          "samples.si": samplesSiNode,
          "samples.portals": samplesPortalNode,
          "samples.starWars": samplesStarWarsNode,
          "samples.populations": samplesPopulationsNode,
          "samples.babyNames": samplesBabyNamesNode,
          "samples.declaration": samplesDeclarationNode,
          "samples.periodicTable": samplesPeriodicTableNode,
          "samples.letters": samplesLettersNode,
          "samples.presidents": samplesPresidentsNode,
          "ucimlr.datasets": ucimlrDatasetsNode,
          "vega.data": vegaDataNode,
          "reddit.all": redditAllNode,
          "reddit.subs": redditSubsNode,
          "reddit.sub": redditSubNode,
          "samples.patients": samplesPatientsNode,
          "samples.poem": samplesPoemNode,
          "samples.outerSpace": samplesOuterSpaceNode,
          "samples.treeProgram": samplesTreeProgramNode,
          "samples.waterBill": samplesWaterBillNode,
          "samples.gapMinder": samplesGapMinderNode,
          "date.addColumns": dateAddColumnsNode,
          "math.log": mathLogNode,
          "rows.addIndexColumn": rowsAddIndexColumnNode,
          "rows.runningTotal": rowsRunningTotalNode,
          "text.length": textLengthNode,
          "text.split": textSplitNode,
          "text.toLowerCase": textToLowerCaseNode,
          "text.substring": textSubstringNode,
          "columns.describe": columnsDescribeNode,
          "columns.list": columnsListNode,
          "data.eval": dataEvalNode,
          "join.by": joinByNode,
          "match.columnsFuzzy": matchColumnsFuzzyNode,
          "text.wordCount": textWordCountNode,
          "text.lineCount": textLineCountNode,
          "treenotation.wordTypes": treenotationWordTypesNode,
          "columns.first": columnsFirstNode,
          "columns.last": columnsLastNode,
          "columns.drop": columnsDropNode,
          "columns.dropConstants": columnsDropConstantsNode,
          "columns.keep": columnsKeepNode,
          "rows.shuffle": rowsShuffleNode,
          "rows.reverse": rowsReverseNode,
          "filter.where": filterWhereNode,
          "rows.dropIfMissing": rowsDropIfMissingNode,
          "filter.with": filterWithNode,
          "filter.without": filterWithoutNode,
          "rows.first": rowsFirstNode,
          "rows.last": rowsLastNode,
          "columns.setType": columnsSetTypeNode,
          "group.by": groupByNode,
          "rows.sortBy": rowsSortByNode,
          "rows.sortByReverse": rowsSortByReverseNode,
          "rows.addOne": rowsAddOneNode,
          "data.inline": dataInlineNode,
          "data.localStorage": dataLocalStorageNode,
          "debug.parserTest": debugParserTestNode,
          "editor.files": editorFilesNode,
          "editor.commandHistory": editorCommandHistoryNode,
          "math.gen": mathGenNode,
          "random.float": randomFloatNode,
          "random.int": randomIntNode,
          "samples.tinyIris": samplesTinyIrisNode,
          "shell.csv": toCsvNode,
          "templates.list": templatesListNode,
          hidden: hiddenNode,
          visible: visibleNode,
          maximized: maximizedNode,
          left: leftNode,
          top: topNode,
          width: widthNode,
          height: heightNode
        }),
        undefined
      )
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get maiaStumpInspectionTemplate() {
      return `div TileStruct:
 pre
  bern
   {settings}
div Input rows: {inputCount} Output rows: {outputCount}
div Load time: {timeToLoad} Render time: {renderTime}
div Input Columns:
pre
 bern
  {inputColumnsAsTable}
div Output Columns
pre
 bern
  {outputColumnsAsTable}
div Output Numeric Values:
pre
 bern
  {outputNumericValues}
div TypeScript Interface:
pre
 bern
  {typeScriptInterface}
div Input Numeric Values:
pre
 bern
  {inputNumericValues}`
    }
    get yearKey() {
      return `year`
    }
    get monthKey() {
      return `month`
    }
    get dayKey() {
      return `day`
    }
    get maiaFileExtensionKey() {
      return `.maia`
    }
    get columnPredictionHintsKey() {
      return `columnPredictionHints`
    }
    get sizeColumnKey() {
      return `sizeColumn`
    }
    get shapeColumnKey() {
      return `shapeColumn`
    }
    get colorColumnKey() {
      return `colorColumn`
    }
    get yColumnKey() {
      return `yColumn`
    }
    get xColumnKey() {
      return `xColumn`
    }
    get contentKey() {
      return `content`
    }
    get rowDisplayLimitKey() {
      return `rowDisplayLimit`
    }
    get settingKey() {
      return `setting`
    }
    // todo: ADD TYPINGS
    getPipishInput() {
      // todo: add placeholder property?
      return this.getSettingsStruct().content || this.getParentOrDummyTable().getFirstColumnAsString() || ""
    }
    getDependencies() {
      return [{ getLineModifiedTime: () => this.getParentOrDummyTable().getTableCTime() }] // todo: we removed this: this.getOutputOrInputTable().getTableCTime()...i think we had it because we want to return true to update children.
    }
    getRunTimeEnumOptions(cell) {
      // todo: only works if codemirror === tab
      try {
        if (cell.getCellTypeId() === "columnNameCell") {
          const mirrorNode = typeof app === "undefined" ? this : app.mountedProgram.nodeAtLine(this.getLineNumber() - 1)
          return mirrorNode.getParentOrDummyTable().getColumnNames()
        }
      } catch (err) {
        console.log(err)
      }
    }
    mapSettingNamesToColumnNames(settingNames) {
      const tileStruct = this.getSettingsStruct()
      return settingNames.map(name => tileStruct[name])
    }
    getOutputOrInputTable() {
      return this._outputTable || this.getParentOrDummyTable()
    }
    getOutputTable() {
      return this._outputTable
    }
    getParentOrDummyTable() {
      // Returns: non-empty input table || dummy table || empty input table.
      const parentTable = this.getParent().getOutputOrInputTable()
      if (!parentTable.isBlankTable()) return parentTable
      return this._getDummyTable() || parentTable
    }
    _getDummyTable() {
      const dataSet = DummyDataSets[this.dummyDataSetName]
      if (!this._dummyTable && dataSet) this._dummyTable = new Table(jtree.Utils.javascriptTableWithHeaderRowToObjects(dataSet))
      return this._dummyTable
    }
    getRequiredTableWithHeader(headerSettingNames) {
      const columnNames = this.mapSettingNamesToColumnNames(headerSettingNames)
      const table = this.getParentOrDummyTable()
      const columns = columnNames.map(name => table.getTableColumnByName(name))
      if (columns.some(col => !col)) return []
      return this.getRowsAsDataTableArrayWithHeader(table.getRows(), columnNames)
    }
    setIsDataLoaded(value) {
      this._isDataLoaded = value
      this.makeDirty() // todo: remove
      return this
    }
    isLoaded() {
      return super.isLoaded() && this._isDataLoaded
    }
    getRowsAsDataTableArrayWithHeader(rows, header) {
      const data = rows.map(row => row.getAsArray(header))
      data.unshift(header)
      return data
    }
    async _executeChildNodes() {
      this.setIsDataLoaded(true)
      return super._executeChildNodes()
    }
    getTileQualityCheck() {
      const definition = this.getDefinition()
      const name = this.getFirstWord()
      let score = 0
      return {
        name: name,
        namespace: name.split(".")[0],
        description: definition.getDescription() ? 1 : 0,
        dummyDataSetName: this.dummyDataSetName,
        runTimeErrors: Object.values(this.getRunTimePhaseErrors()).length,
        examples: definition.getExamples().length,
        edgeTests: 0,
        speedTests: 0,
        roadMap: 0,
        idealStyleUXDescription: 0,
        secPriTests: 0,
        userType: 0
      }
    }
    _getCachedSettings() {
      if (this._cache_settingsObject) return this._cache_settingsObject
      this._cache_settingsObject = {}
      this.filter(child => child.doesExtend("abstractTileSettingTerminalNode") || child.doesExtend("abstractTileSettingNonTerminalNode")).forEach(setting => {
        this._cache_settingsObject[setting.getFirstWord()] = setting.getSettingValue()
      })
      return this._cache_settingsObject
    }
    // todo: ADD TYPINGS
    getSettingsStruct() {
      const settingsFromCache = this._getCachedSettings()
      // todo: this wont work anymore
      const hintsNode = this.getDefinition().getConstantsObject()[this.columnPredictionHintsKey]
      if (hintsNode)
        Object.assign(
          settingsFromCache,
          this.getParentOrDummyTable().getPredictionsForAPropertyNameToColumnNameMapGivenHintsNode(new jtree.TreeNode(hintsNode), settingsFromCache)
        )
      return settingsFromCache
    }
    toInspectionStumpCode() {
      const inputTable = this.getParentOrDummyTable()
      const outputTable = this.getOutputOrInputTable()
      const outputColumns = outputTable.getColumnsArrayOfObjects()
      const inputCols = inputTable.getColumnsArrayOfObjects()
      const inputCount = inputTable.getRowCount()
      const outputCount = outputTable.getRowCount()
      const timeToLoad = this.getTimeToLoad()
      const renderTime = this.getNewestTimeToRender()
      const inputColumnsAsTable = new jtree.TreeNode(inputCols).toTable()
      const outputColumnsAsTable = new jtree.TreeNode(outputColumns).toTable()
      const settings = JSON.stringify(this.getSettingsStruct(), null, 2)
      const outputNumericValues = new jtree.TreeNode(outputTable.getJavascriptNativeTypedValues()).toTable()
      const typeScriptInterface = outputTable.toTypeScriptInterface()
      const inputNumericValues = new jtree.TreeNode(inputTable.getJavascriptNativeTypedValues()).toTable()
      return (
        super.toInspectionStumpCode() +
        "\n" +
        this.qFormat(this.maiaStumpInspectionTemplate, {
          settings,
          inputCount,
          outputCount,
          timeToLoad,
          renderTime,
          inputColumnsAsTable,
          outputColumnsAsTable,
          outputNumericValues,
          typeScriptInterface,
          inputNumericValues
        })
      )
    }
  }

  class abstractChartNode extends abstractMaiaTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { rowDisplayLimit: rowDisplayLimitNode }),
        undefined
      )
    }
    get rowDisplayLimit() {
      return 10000
    }
    getTileFooterStumpCode() {
      const table = this.getParentOrDummyTable()
      return `${this.getTileToolbarButtonStumpCode()}
span Rows: ${table.getRowCount()} Columns Out: ${table.getColumnCount()}`
    }
    toDisplayString(value, columnName) {
      // todo: remove.
      if (value === undefined) return ""
      return this.getParentOrDummyTable()
        .getTableColumnByName(columnName)
        .toDisplayString(value)
    }
    _getRowDisplayLimit() {
      const limitStr = this.getSettingsStruct()[this.rowDisplayLimitKey] || this.rowDisplayLimit
      const limit = parseInt(limitStr)
      if (!limitStr || isNaN(limit)) return undefined
      return limit
    }
    getRowsWithRowDisplayLimit() {
      return this.getParentOrDummyTable()
        .getRows()
        .slice(0, this._getRowDisplayLimit())
    }
  }

  class abstractHeaderlessChartTileNode extends abstractChartNode {
    get tileStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div
  class TileBody HeaderLess
  {body}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get headerHeight() {
      return 0
    }
    toStumpCode() {
      return this.qFormat(this.tileStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        id: this.getTreeComponentId(),
        body: this._getBodyStumpCodeCache(),
        footer: this.getTileToolbarButtonStumpCode()
      })
    }
    get _tileWidth() {
      return this.getTileDimensionIfAny().width - 10
    }
    get _tileHeight() {
      return this.getTileDimensionIfAny().height - 60 // 10 for padding. 10 for top grabber. 30 for footer. 10 fot bottom grabber.
    }
  }

  class abstractEmptyFooterTileNode extends abstractHeaderlessChartTileNode {
    get footerHeight() {
      return 0
    }
  }

  class abstractSnippetGalleryNode extends abstractEmptyFooterTileNode {
    get optionStumpTemplate() {
      return `li
 a {title}
  value {value}
  class appendSnippetButton
  clickCommand appendSnippetTemplateCommand`
    }
    get bodyStumpTemplate() {
      return `h4 {title}
 ol
  class TileSelectable
  {options}`
    }
    get tileSize() {
      return `600 240`
    }
    getGalleryNodes() {}
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, {
        title: this.title,
        options: new jtree.TreeNode(
          this.getGalleryNodes()
            .map(node => this.qFormat(this.optionStumpTemplate, { title: node.evalTemplateString(this.itemFormat), value: node.get("id") }))
            .join("\n")
        ).toString()
      })
    }
  }

  class abstractTemplateGalleryNode extends abstractSnippetGalleryNode {
    get optionStumpTemplate() {
      return `li
 a {title}
  value {value}
  class createProgramButton
  clickCommand createProgramFromTemplateCommand`
    }
  }

  class challengeListNode extends abstractSnippetGalleryNode {
    get itemFormat() {
      return `{question}`
    }
    get title() {
      return `Try a challenge:`
    }
    getGalleryNodes() {
      return typeof challengesTree === "undefined" ? jtree.TreeNode.fromDisk("maia/packages/challenge/challenges.tree") : new jtree.TreeNode(challengesTree)
    }
    getSnippetTemplate(id) {
      return `challenge.play ${id}`
    }
  }

  class samplesListNode extends abstractSnippetGalleryNode {
    get itemFormat() {
      return `{id} - {description}`
    }
    get title() {
      return `All samples:`
    }
    getGalleryNodes() {
      // todo: cleanup.
      const maia = this.getWebApp().getMaiaGrammarAsTree()
      const hits = maia.getNodesByRegex(/^samples/).map(node => {
        return {
          id: node.get("crux"),
          description: node.get("description")
        }
      })
      return new jtree.TreeNode(hits)
    }
    getSnippetTemplate(id) {
      return id
    }
  }

  class vegaDataListNode extends abstractSnippetGalleryNode {
    get itemFormat() {
      return `{id}`
    }
    get title() {
      return `All Vega datasets:`
    }
    getGalleryNodes() {
      // todo: cleanup this line.
      const node = this.getWebApp()
        .getMaiaGrammarAsTree()
        .getNodesByRegex(/^vegaDataSetCell/)[0]
      return new jtree.TreeNode(
        node
          .get("enum")
          .split(" ")
          .map(item => {
            return {
              id: item
            }
          })
      )
    }
    getSnippetTemplate(id) {
      return `vega.data ${id}`
    }
  }

  class vegaExampleListNode extends abstractSnippetGalleryNode {
    get itemFormat() {
      return `{id}`
    }
    get title() {
      return `All Vega examples:`
    }
    getGalleryNodes() {
      // todo: cleanup this line.
      const node = this.getWebApp()
        .getMaiaGrammarAsTree()
        .getNodesByRegex(/^vegaExampleNameCell/)[0]
      return new jtree.TreeNode(
        node
          .get("enum")
          .split(" ")
          .map(item => {
            return {
              id: item
            }
          })
      )
    }
    getSnippetTemplate(id) {
      return `vega.example ${id}`
    }
  }

  class challengePlayNode extends abstractEmptyFooterTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get challengeIdCell() {
      return parseInt(this.getWord(1))
    }
    get challengeAnswerCell() {
      return this.getWordsFrom(2).map(val => parseFloat(val))
    }
    get tileSize() {
      return `640 240`
    }
    getProgramTemplate(id) {
      const challengeNode = this._getChallengeNode(parseInt(id))
      return {
        template: challengeNode.getNode("solution").childrenToString(),
        name: "challenge-" + id + "-solution.maia"
      }
    }
    _getChallengeNode(challengeId) {
      const challenges =
        typeof challengesTree === "undefined" ? jtree.TreeNode.fromDisk("maia/packages/challenge/challenges.tree") : new jtree.TreeNode(challengesTree)
      return challenges.nodeAt(challengeId - 1) || challenges.nodeAt(0)
    }
    getTileBodyStumpCode() {
      const challengeId = parseInt(this.getWord(1))
      const answer = this.getWord(2)
      const challengeNode = this._getChallengeNode(challengeId)
      const isCorrect = answer === challengeNode.get("answer")
      const theme = this.getTheme()
      const color = answer ? (isCorrect ? theme.successColor : theme.errorColor) : theme.warningColor
      const answerMessage = answer !== undefined ? (isCorrect ? "CORRECT!" : "Wrong.") : ""
      return `h3 Challenge #${challengeId}
 style color:${color}
br
div ${challengeNode.evalTemplateString(`Question: {question}`)}
 class TileSelectable
br
input
 placeholder Enter your answer here. All answers are a number.
 value ${answer !== undefined ? answer : ""}
 style width: 300px;
 name 2
 changeCommand changeWordAndRenderCommand
span ${answerMessage}
 style color: ${color};
br
div
 a See a solution
  clickCommand createProgramFromTemplateCommand
  value ${challengeId}`
    }
  }

  class dtjsBasicNode extends abstractEmptyFooterTileNode {
    get rowStumpTemplate() {
      return `tr
 {cols}`
    }
    get cellStumpTemplate() {
      return `td
 bern
  {box}`
    }
    get bodyStumpTemplate() {
      return `div
table
 class DataTable
 thead
  tr
   {headerRows}
 tbody
  {rows}`
    }
    get tileScript() {
      return `maia/packages/dtjs/datatables.min.js`
    }
    get tileCssScript() {
      return `maia/packages/dtjs/datatables.min.css`
    }
    get tileSize() {
      return `1200 500`
    }
    getTileBodyStumpCode() {
      const columnDefs = this.getParentOrDummyTable()
        .getColumnsArray()
        .slice(0, 10)
      const headerRows = this._getHeaderRowsStumpCode(columnDefs.map(col => col.getColumnName()))
      const rows = this._getTableRowsStumpCode(columnDefs)
      return this.qFormat(this.bodyStumpTemplate, { headerRows, rows })
    }
    _getHeaderRowsStumpCode(columns) {
      return columns.map(colName => `th ${colName}`).join("\n")
    }
    _getTableRowsStumpCode(columns) {
      return this.getRowsWithRowDisplayLimit()
        .slice(0, 10)
        .map((row, index) => {
          const cols = columns
            .map(column => {
              const box = row.getRowHtmlSafeValue(column.getColumnName()) // todo: cache?
              return this.qFormat(this.cellStumpTemplate, { box })
            })
            .join("\n")
          return this.qFormat(this.cellStumpTemplate, { cols })
        })
        .join("\n")
    }
    treeComponentWillUnmount() {
      // cleanup
    }
    treeComponentDidUpdate() {
      super.treeComponentDidUpdate()
      const table = this.getParentOrDummyTable()
      const columnDefs = this.getParentOrDummyTable()
        .getColumnsArray()
        .slice(0, 10)
      const container = this.getStumpNode().findStumpNodeByChild("class DataTable")
      if (this.isNodeJs()) return undefined
      const tileDimension = this.getTileDimensionIfAny()
      const width = tileDimension.width - 20 // remove 10 for boddy padding?
      const height = tileDimension.height - 150
      const shadow = container.getShadow()
      const el = shadow.getShadowElement()
      shadow.setShadowCss({ width: width, height: height })
      const rows = this.getRowsWithRowDisplayLimit()
      // todo: note, this is only works with jQuery
      jQuery.fn.dataTable.ext.errMode = "throw"
      this._dataTables = jQuery(el).DataTable({
        data: this.getRowsAsDataTableArrayWithHeader(rows, columnDefs.map(col => col.getColumnName())).slice(1),
        pageLength: 10,
        scrollY: height
        //"scrollCollapse": true,
        //"paging": false
      })
    }
    treeComponentDidMount() {
      this.treeComponentDidUpdate()
    }
  }

  class abstractHtmlNode extends abstractEmptyFooterTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { style: styleNode, content: contentNode }),
        undefined
      )
    }
    get htmlCell() {
      return this.getWordsFrom(0)
    }
    get bodyStumpTemplate() {
      return `{tag}
 {style}
 {src}
 bern
  {content}`
    }
    getTileFooterStumpCode() {
      return this.getTileToolbarButtonStumpCode()
    }
    async fetchTableInputs() {
      return { rows: [{ text: this.getHtmlContent() }] }
    }
    getHtmlContent() {
      return this.getWordsFrom(2).join(" ") || "No html content to show."
    }
    getTag() {
      return this.getWord(1) || "div" // todo: verify this is legal tag.
    }
    getSrc() {
      return this.getSettingsStruct().src
    }
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, {
        tag: this.getTag(),
        style: this.style ? `style ${this.style}` : "",
        src: this.getSrc() ? `src ${this.getSrc()}` : "",
        content: this.getHtmlContent() || ""
      })
    }
  }

  class htmlTextNode extends abstractHtmlNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get htmlTextTagCell() {
      return this.getWord(1)
    }
    get htmlCell() {
      return this.getWordsFrom(2)
    }
  }

  class htmlPrintAsNode extends abstractHtmlNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get htmlTextTagCell() {
      return this.getWord(1)
    }
    getHtmlContent() {
      return this.getPipishInput()
    }
  }

  class abstractHTMLFixedTagTileNode extends abstractHtmlNode {
    getHtmlContent() {
      return this.getContent()
    }
    getTag() {
      return this.htmlTagName
    }
  }

  class htmlH1Node extends abstractHTMLFixedTagTileNode {
    get htmlCell() {
      return this.getWordsFrom(0)
    }
    get style() {
      return `text-align:center;`
    }
    get htmlTagName() {
      return `h1`
    }
    get tileSize() {
      return `600 75`
    }
  }

  class abstractHTMLContentIsSrcTileNode extends abstractHTMLFixedTagTileNode {
    getHtmlContent() {
      return ""
    }
    getSrc() {
      return this.getContent() || super.getSrc()
    }
  }

  class htmlImgNode extends abstractHTMLContentIsSrcTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
    get style() {
      return `width:100%;`
    }
    get htmlTagName() {
      return `img`
    }
  }

  class htmlIframeNode extends abstractHTMLContentIsSrcTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
    get htmlTagName() {
      return `iframe`
    }
  }

  class htmlCustomNode extends abstractEmptyFooterTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { content: contentNode }),
        undefined
      )
    }
    get bodyStumpTemplate() {
      return `div
 bern
  {content}`
    }
    getTileBodyStumpCode() {
      // https://meta.stackexchange.com/questions/1777/what-html-tags-are-allowed-on-stack-exchange-sites
      // todo: sanitize tags
      const contentNode = this.getNode("content")
      const content = contentNode ? contentNode.childrenToString() : "No HTML content to show"
      return this.qFormat(this.bodyStumpTemplate, { content })
    }
  }

  class abstractShowTileNode extends abstractEmptyFooterTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    get titleCell() {
      return this.getWordsFrom(2)
    }
    get bodyStumpTemplate() {
      return `h6 {title}
h3 {number}`
    }
    get hakonTemplate() {
      return `.abstractShowTileNode
 h3
  text-align center
 h6
  text-align center
  height 40px
  overflow hidden`
    }
    get dummyDataSetName() {
      return `stockPrice`
    }
    get tileSize() {
      return `140 120`
    }
    getTileBodyStumpCode() {
      const columnName = this.getWord(1)
      if (!columnName) return `No data for ${this.getFirstWord()}`
      const col = this.getParentOrDummyTable().getTableColumnByName(columnName)
      if (!col) return ""
      const reductionName = this.getWord(0).split(".")[1]
      const title = this.getWordsFrom(2).join(" ") || [columnName, reductionName].join(" ")
      const number = this.toDisplayString(col.getReductions()[reductionName], columnName)
      return this.qFormat(this.bodyStumpTemplate, { title, number })
    }
  }

  class showRowCountNode extends abstractShowTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get titleCell() {
      return this.getWordsFrom(1)
    }
    get dummyDataSetName() {
      return `stockPrice`
    }
    get tileSize() {
      return `140 120`
    }
    getTileBodyStumpCode() {
      const title = this.getWordsFrom(1).join(" ") || "Total rows"
      return this.qFormat(this.bodyStumpTemplate, { title, number: this._getNumber() })
    }
    _getNumber() {
      return this.getParentOrDummyTable().getRowCount()
    }
  }

  class showColumnCountNode extends showRowCountNode {
    _getNumber() {
      return this.getParentOrDummyTable().getColumnNames().length
    }
  }

  class showStaticNode extends abstractShowTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get numberCell() {
      return parseFloat(this.getWord(1))
    }
    get titleCell() {
      return this.getWordsFrom(2)
    }
    getTileBodyStumpCode() {
      const title = this.getWordsFrom(2).join(" ")
      return this.qFormat(this.bodyStumpTemplate, { title, number: this.getWord(1) || "" })
    }
  }

  class showMedianNode extends abstractShowTileNode {}

  class showSumNode extends abstractShowTileNode {}

  class showMeanNode extends abstractShowTileNode {}

  class showMinNode extends abstractShowTileNode {}

  class showMaxNode extends abstractShowTileNode {}

  class abstractVegaNode extends abstractEmptyFooterTileNode {
    get titleCell() {
      return this.getWordsFrom(0)
    }
    get bodyStumpTemplate() {
      return `div
 class divForExternalLibrary`
    }
    get markName() {
      return `bar`
    }
    get dummyDataSetName() {
      return `stockPrice`
    }
    get tileScript() {
      return `maia/packages/vega/vega.combined.min.js`
    }
    get tileSize() {
      return `800 300`
    }
    // todo: I don't think vega handles . in column names.
    getTileBodyStumpCode() {
      return this.bodyStumpTemplate
    }
    _getColumnToField(columnName) {
      if (!columnName) return undefined
      const columnsMap = this.getParentOrDummyTable().getColumnsMap()
      const col = columnsMap[columnName]
      const obj = { field: columnName, type: col.getVegaType() }
      if (col.isTemporal()) {
        const timeUnit = col.getVegaTimeUnit()
        if (timeUnit) obj.timeUnit = timeUnit
      }
      return obj
    }
    _adjustVegaSize() {
      const adjustSize = !this.has("width")
      if (adjustSize) {
        const shadow = this.getStumpNode()
          .findStumpNodeByChild("class divForExternalLibrary")
          .getShadow()
        this.set("width", Math.round((30 + shadow.getShadowOuterWidth()) / 20) + "")
        this.set("height", Math.round((30 + shadow.getShadowOuterHeight()) / 20) + "")
      }
    }
    _getElementForVega() {
      return this.getStumpNode()
        .findStumpNodeByChild("class divForExternalLibrary")
        .getShadow()
        .getShadowElement()
    }
    async _drawVega() {
      // todo: don't rerun this if we dont need to.
      await vegaEmbed(this._getElementForVega(), this._getVegaSpec())
      // this._adjustVegaSize()
    }
    treeComponentDidUpdate() {
      super.treeComponentDidUpdate()
      if (this.isNodeJs()) return undefined
      this._drawVega()
    }
    _getTileWidth() {
      return this.getTileDimensionIfAny().width - 120
    }
    _getTileHeight() {
      return this.getTileDimensionIfAny().height - 90
    }
    treeComponentDidMount() {
      this.treeComponentDidUpdate()
    }
    _getVegaData() {
      return {
        values: this.getParentOrDummyTable()
          .cloneNativeJavascriptTypedRows()
          .slice(0, this._getRowDisplayLimit())
      }
    }
    _getVegaTitle() {
      return this.getContent()
    }
    _getVegaSpec() {
      return {
        description: "A simple bar chart with embedded data.",
        data: this._getVegaData(),
        width: this._getTileWidth(),
        height: this._getTileHeight(),
        mark: this._getVegaMarkObj(),
        encoding: this._getEncodingMap(),
        transform: this._getVegaTransform(),
        title: this._getVegaTitle(),
        config: this._getVegaConfig()
      }
    }
    _getVegaTransform() {
      return undefined
    }
    _getVegaConfig() {
      return undefined
    }
    _getEncodingMap() {
      return {}
    }
    // todo: add type
    _getVegaMarkObj() {
      return { type: this._getVegaMark(), tooltip: { content: "data" } }
    }
    _getVegaMark() {
      return this.markName
    }
  }

  class vegaBarNode extends abstractVegaNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          colorColumn: colorColumnNode,
          shapeColumn: shapeColumnNode,
          xColumn: xColumnNode,
          yColumn: yColumnNode
        }),
        undefined
      )
    }
    get columnPredictionHints() {
      return `xColumn
yColumn isString=false,!xColumn`
    }
    _getEncodingMap() {
      const columnNames = this.mapSettingNamesToColumnNames([this.xColumnKey, this.yColumnKey, this.colorColumnKey])
      return {
        x: this._getColumnToField(columnNames[0]),
        y: this._getColumnToField(columnNames[1]),
        color: this._getColumnToField(columnNames[2])
      }
    }
  }

  class vegaLineNode extends vegaBarNode {
    get markName() {
      return `line`
    }
  }

  class vegaAreaNode extends vegaLineNode {
    get markName() {
      return `area`
    }
  }

  class vegaScatterNode extends vegaBarNode {
    get markName() {
      return `point`
    }
    _getEncodingMap() {
      const columnNames = this.mapSettingNamesToColumnNames([this.xColumnKey, this.yColumnKey, this.colorColumnKey, this.shapeColumnKey])
      return {
        x: this._getColumnToField(columnNames[0]),
        y: this._getColumnToField(columnNames[1]),
        color: this._getColumnToField(columnNames[2]),
        shape: this._getColumnToField(columnNames[3])
      }
    }
  }

  class vegaBubbleNode extends vegaScatterNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { sizeColumn: sizeColumnNode, colorColumn: colorColumnNode }),
        undefined
      )
    }
    get columnPredictionHints() {
      return `sizeColumn isString=false
xColumn isString=false`
    }
    get dummyDataSetName() {
      return `gapMinder`
    }
    get markName() {
      return `circle`
    }
    _getEncodingMap() {
      const columnNames = this.mapSettingNamesToColumnNames([this.xColumnKey, this.yColumnKey, this.sizeColumnKey, this.colorColumnKey])
      return {
        y: {
          field: columnNames[1],
          type: "quantitative",
          scale: { zero: false },
          axis: { minExtent: 30 }
        },
        x: this._getColumnToField(columnNames[0]),
        size: { field: columnNames[2], type: "quantitative" },
        color: { value: "#000" }
      }
    }
  }

  class vegaEmojiNode extends vegaBarNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { yColumn: yColumnNode, emojiColumn: emojiColumnNode }),
        undefined
      )
    }
    get dummyDataSetName() {
      return `emojis`
    }
    get columnPredictionHints() {
      return `emojiColumn isString=true
yColumn isString=false`
    }
    _getVegaConfig() {
      return { view: { stroke: "" } }
    }
    _getVegaMark() {
      return { type: "text", baseline: "middle" }
    }
    _getEncodingMap() {
      const columnNames = this.mapSettingNamesToColumnNames([this.yColumnKey, "emoji"])
      return {
        x: { field: columnNames[1], type: "nominal", axis: null },
        y: { field: columnNames[0], type: "quantitative", axis: null, sort: null },
        text: { field: columnNames[1], type: "nominal" },
        size: { value: 65 }
      }
    }
  }

  class vegaHistogramNode extends abstractVegaNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { xColumn: xColumnNode }),
        undefined
      )
    }
    get dummyDataSetName() {
      return `wordCounts`
    }
    get columnPredictionHints() {
      return `xColumn isString=false`
    }
    _getEncodingMap() {
      const columnName = this.getContent() || this.mapSettingNamesToColumnNames([this.xColumnKey])[0]
      return {
        x: {
          bin: true,
          field: columnName,
          type: "quantitative"
        },
        y: {
          aggregate: "count",
          type: "quantitative"
        }
      }
    }
  }

  class vegaExampleNode extends abstractVegaNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get vegaExampleNameCell() {
      return this.getWord(1)
    }
    _getVegaSpec() {
      return this._spec
    }
    async _fetchSpec() {
      // todo: localtesting.
      if (this.isNodeJs()) return undefined
      const exampleName = this.getContent() || "area" // todo: pull this default from the gram?
      const url = `maia/packages/vega/ignore/vega-lite/examples/compiled/${exampleName}.vg.json`
      const res = await this.getWebApp()
        .getWillowBrowser()
        .httpGetUrl(url)
      const spec = JSON.parse(res.text)
      // rewrite data urls
      spec.data.forEach(row => {
        if (row.url) row.url = row.url.replace("data/", "packages/vega/datasets/")
      })
      this._spec = spec
      return spec
    }
    // todo: clean this up.
    async fetchTableInputs() {
      const spec = await this._fetchSpec()
      if (this.isNodeJs()) return { rows: [] }
      const el = jQuery("<div></div>")[0]
      const embedded = await vegaEmbed(el, spec)
      const rows = await this._getVegaPostTransformOutputRows(spec, embedded)
      return { rows: rows }
    }
    async _getVegaPostTransformOutputRows(spec, embedded) {
      const tableName = spec.data[0] && spec.data[0].name
      if (tableName) return embedded.view.data(tableName)
      // const values = spec.data.values
      // if (values && values.entries) return Array.from(values.entries())
      // if (typeof values === "function") return []
      // else if (values) return values
      return []
    }
  }

  class dateHeatcalNode extends abstractHeaderlessChartTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { count: countNode, dayColumn: dayColumnNode }),
        undefined
      )
    }
    get hakonTemplate() {
      return `.heatCal
 rect
  fill {darkerBackground}
  shape-rendering crispedges
 text
  font-size 10px
  fill #ddd`
    }
    get bodyStumpTemplate() {
      return `div
 class heatCal
 bern
  {svg}`
    }
    get dummyDataSetName() {
      return `waterBill`
    }
    get columnPredictionHints() {
      return `count getPrimitiveTypeName=number
dayColumn getPrimitiveTypeName=day`
    }
    get tileSize() {
      return `750 200`
    }
    _getLegend(quins, squareSideWithPadding, position) {
      const theme = this.getTheme()
      const quinSvgs = quins
        .map((quin, index) => {
          const left = position.left + squareSideWithPadding * index
          const style = "fill: " + theme.getHeatColor(1 - quin.percent)
          return `<rect style="${style}" width="10" height="10" x="${left}" y="${position.top}"></rect>`
        })
        .join("")
      return `<g>
<text x="${position.left - 25}" y="${position.top + 10}">Less</text>
${quinSvgs}
<text x="${position.left + 70}" y="${position.top + 10}">More</text>
</g>`
    }
    getTileBodyStumpCode() {
      const svg = this.getSvg()
      return this.qFormat(this.bodyStumpTemplate, { svg })
    }
    _getDayMap(quins, rows, dayColumnName, countColumnName) {
      const getQuin = val => {
        for (let index = 0; index < quins.length; index++) {
          if (val <= quins[index].value) return quins[index].percent
        }
      }
      const dayMap = {}
      rows.forEach(row => {
        dayMap[moment(row[dayColumnName]).format("MM/DD/YYYY")] = {
          Quin: getQuin(row[countColumnName]),
          count: row[countColumnName],
          row: row
        }
      })
      return dayMap
    }
    _getDaysArray(startDay, daysToShow) {
      const days = []
      const firstDay = parseInt(startDay.format("e"))
      for (let dayIndex = 0; dayIndex <= daysToShow; dayIndex++) {
        const day = startDay.clone().add(dayIndex, "days")
        days.push({
          day: day,
          row: parseInt(day.format("e")),
          col: Math.floor((firstDay + dayIndex) / 7)
        })
      }
      return days
    }
    _getDayNamesG(squareSideWithPadding) {
      const dayNames = [{ day: "Mon", row: 2 }, { day: "Wed", row: 4 }, { day: "Fri", row: 6 }]
        .map(day => {
          const _top = 20 + day.row * squareSideWithPadding - 3
          return `<text x="0" y="${_top}">${day.day}</text>`
        })
        .join("")
      return `<g>${dayNames}</g>`
    }
    _getMonthNamesG(daysArray, squareSideWithPadding) {
      const _usedMonths = {}
      const monthNames = daysArray
        .map(day => {
          const monthName = day.day.format("MMM")
          const monthYear = day.day.format("MM/YYYY")
          if (_usedMonths[monthYear]) return ""
          _usedMonths[monthYear] = true
          const left = 40 + day.col * squareSideWithPadding
          return `<text x="${left}" y="10">${monthName}</text>`
        })
        .join("")
      return `<g>${monthNames}</g>`
    }
    _getDataSquaresG(daysArray, squareSideWithPadding, dayMap) {
      const dayFormat = "MM/DD/YYYY"
      const today = moment(Date.now()).format(dayFormat)
      const theme = this.getTheme()
      const dataSquares = daysArray
        .map(day => {
          const dayKey = day.day.format(dayFormat)
          const _top = 20 + day.row * squareSideWithPadding
          const left = 40 + day.col * squareSideWithPadding
          const value = dayMap[dayKey]
          const todayStyle = dayKey === today ? "stroke-width:2;stroke:rgb(0,0,0);" : ""
          const style = (value ? "fill: " + theme.getHeatColor(1 - value.Quin) : "") + ";" + todayStyle
          const title = `${dayKey}: ${value ? value.count : 0}`
          return `<rect style="${style}" data-day="${dayKey}" width="10" height="10" x="${left}" y="${_top}"><title>${title}</title></rect>`
        })
        .join("")
      return `<g>${dataSquares}</g>`
    }
    getSvg() {
      const inputTable = this.getParentOrDummyTable()
      const rows = inputTable.getJavascriptNativeTypedValues()
      if (!rows.length) return ""
      const tileStruct = this.getSettingsStruct()
      const dayColumnName = tileStruct.dayColumn
      const countColumnName = tileStruct.count
      if (!dayColumnName || !countColumnName) return ""
      const dayCol = inputTable.getTableColumnByName(dayColumnName)
      const countCol = inputTable.getTableColumnByName(countColumnName)
      let daysToShow = 365 * 1 // todo: make configurable
      let endDay = moment(Date.now())
      let startDay = endDay.clone().subtract(daysToShow, "days")
      // todo: make configurable
      // reductions = dayCol.getReductions()
      //  startDay = moment(reductions.min)
      // endDay = moment(reductions.max)
      // daysToShow = endDay.diff(startDay, "days")
      const squareSide = 10
      const squarePadding = 2
      const squareSideWithPadding = squareSide + squarePadding
      const width = squareSideWithPadding * (daysToShow / 6)
      const height = 7 * squareSideWithPadding + 100
      const quins = countCol.getQuins()
      const dayMap = this._getDayMap(quins, rows, dayColumnName, countColumnName)
      const daysArray = this._getDaysArray(startDay, daysToShow)
      const dayNamesG = this._getDayNamesG(squareSideWithPadding)
      const monthNamesG = this._getMonthNamesG(daysArray, squareSideWithPadding)
      const squaresG = this._getDataSquaresG(daysArray, squareSideWithPadding, dayMap)
      const keyG = this._getLegend(quins, squareSideWithPadding, { top: 110, left: 60 })
      return `<svg width="${width}" height="${height}">${dayNamesG + squaresG + monthNamesG + keyG}</svg>`
    }
  }

  class iconsIconNode extends abstractHeaderlessChartTileNode {}

  class iconsHumanNode extends iconsIconNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { genderColumn: genderColumnNode, headSize: headSizeNode }),
        undefined
      )
    }
    get dummyDataSetName() {
      return `patients`
    }
    get bodyStumpTemplate() {
      return `div
 bern
  {bern}`
    }
    get columnPredictionHints() {
      return `headSize isString=false
genderColumn isString=true`
    }
    getTileBodyStumpCode() {
      // Now, what if there is no input table?
      const table = this.getParentOrDummyTable()
      const rows = table.getRows()
      // Now, what if we are using dummy input table?
      const headSizeColumn = this.getSettingsStruct().headSize
      const genderColumn = this.getSettingsStruct().genderColumn
      const reducts = table.getColumnByName(headSizeColumn).getReductions()
      const headColMax = reducts.max
      const bern = rows
        .map(row => {
          const typedRow = row.rowToObjectWithOnlyNativeJavascriptTypes()
          const value = typedRow[headSizeColumn]
          // TODO: ADD TYPINGS
          const genderVal = typedRow[genderColumn].toLowerCase()
          const gender = genderVal === "male" ? "blue" : "pink"
          let character = "O"
          let percent = value / headColMax
          if (isNaN(value)) {
            character = "x"
            percent = reducts.median / headColMax
          }
          const title = row.getHoverTitle()
          percent = Math.round(18 * percent)
          return `<span title="${title}" style="font-size:${percent}px; color:${gender};">${character}</span>`
        })
        .join(" ")
      return this.qFormat(this.bodyStumpTemplate, { bern: bern })
    }
  }

  class iconsCircleNode extends iconsIconNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { radius: radiusNode }),
        undefined
      )
    }
    get bodyStumpTemplate() {
      return `div
 bern
  {bern}`
    }
    get dummyDataSetName() {
      return `playerGoals`
    }
    get columnPredictionHints() {
      return `radius isString=false`
    }
    getTileBodyStumpCode() {
      const column = this.getSettingsStruct().radius
      const bern = this.getParentOrDummyTable()
        .getRows()
        .map(row => `<span style="font-size:${row.rowToObjectWithOnlyNativeJavascriptTypes()[column] / 3}em;">O</span>`)
        .join(" ")
      return this.qFormat(this.bodyStumpTemplate, { bern: bern })
    }
  }

  class markdownToHtmlNode extends abstractHeaderlessChartTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { content: contentNode }),
        undefined
      )
    }
    get dummyDataSetName() {
      return `markdown`
    }
    get tileSize() {
      return `400 400`
    }
    get bodyStumpTemplate() {
      return `div
 class TileSelectable
 bern
  {md}`
    }
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, { md: marked(this.getPipishInput()) })
    }
  }

  class treenotationOutlineNode extends abstractHeaderlessChartTileNode {
    get bodyStumpTemplate() {
      return `pre
 style overflow: scroll; width: 100%; height: 100%; margin: 0; box-sizing: border-box; font-family: monospace; line-height: 13px;
 bern
  {bern}`
    }
    get tileSize() {
      return `800 500`
    }
    get dummyDataSetName() {
      return `outerSpace`
    }
    _getTheBern() {
      return new jtree.TreeNode(this.getPipishInput()).toOutline()
    }
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, { bern: this._getTheBern() })
    }
  }

  class treenotationDotlineNode extends treenotationOutlineNode {
    get dummyDataSetName() {
      return `outerSpace`
    }
    get dots() {
      return true
    }
    _getTheBern() {
      return new jtree.TreeNode(this.getPipishInput()).toMappedOutline(
        node =>
          "o" +
          node
            .getLine()
            .split(" ")
            .map(word => "º")
            .join("")
      )
    }
  }

  class abstractTextNode extends abstractChartNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { content: contentNode }),
        undefined
      )
    }
    get stringCell() {
      return this.getWordsFrom(0)
    }
    get bodyStumpTemplate() {
      return `div
 class TileSelectable
 bern
  {content}`
    }
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, { content: this.content ? jtree.Utils.linkify(this.content) : "" })
    }
  }

  class abstractInstructionsNode extends abstractTextNode {
    get content() {
      return `Instructions go here.`
    }
    get tileSize() {
      return `600 240`
    }
  }

  class amazonHistoryNode extends abstractInstructionsNode {
    get dummyDataSetName() {
      return `amazonPurchases`
    }
    get content() {
      return `Step 1. Go to https://www.amazon.com/gp/b2b/reports to download your Amazon order history.<br> Step 2. Add the data here.`
    }
  }

  class fitbitAllNode extends abstractInstructionsNode {
    get content() {
      return `Step 1. Go to <a target="_blank" href="https://www.fitbit.com/settings/data/export">https://www.fitbit.com/settings/data/export</a> to download your Fitbit data.<br> Step 2. Drop the CSV onto this page.`
    }
  }

  class abstractComingSoonNode extends abstractTextNode {
    get content() {
      return `Instructions go here.`
    }
    get tileSize() {
      return `600 240`
    }
  }

  class datawrapperComingSoonNode extends abstractComingSoonNode {
    get content() {
      return `We don't have support yet for https://www.datawrapper.de/`
    }
  }

  class dcjsComingSoonNode extends abstractComingSoonNode {
    get content() {
      return `We don't have support yet for https://github.com/dc-js/dc.js`
    }
  }

  class finosPerspectiveComingSoonNode extends abstractComingSoonNode {
    get content() {
      return `We don't have support yet for https://perspective.finos.org/`
    }
  }

  class fivethirtyeightComingSoonNode extends abstractComingSoonNode {
    get content() {
      return `We don't have support yet for https://github.com/fivethirtyeight/data/`
    }
  }

  class highchartsComingSoonNode extends abstractComingSoonNode {
    get content() {
      return `We don't have support yet for https://www.highcharts.com/blog/snippets/3d-solar-system/`
    }
  }

  class re3dataComingSoonNode extends abstractComingSoonNode {
    get content() {
      return `We don't have support yet for https://www.re3data.org/`
    }
  }

  class zingComingSoonNode extends abstractComingSoonNode {
    get content() {
      return `We don't have support yet for https://www.zingchart.com/`
    }
  }

  class editorHelloWorldNode extends abstractTextNode {
    get content() {
      return `Ohayo world!`
    }
  }

  class debugDumpNode extends abstractChartNode {
    get bodyStumpTemplate() {
      return `div
 style overflow: scroll; width: 100%; height: 100%; white-space: pre;
 bern
  {text}`
    }
    _getCharacterLimit() {
      // Todo: great example of a scale test. I found it to be slow with:
      /*
vega.sample movies.json
 web.dump
So some tiles will have characterLimit, rowDisplayLimit, et cetera. And have "speedTestExamples" .
*/
      return 20000
    }
    getTileBodyStumpCode() {
      const text = this._getTextToDump()
      const characterLimit = this._getCharacterLimit()
      let sub = text.substr(0, characterLimit)
      if (text.length > characterLimit)
        // todo: Show standardized truncation warning
        sub = `<i>(Notice: Results truncated to ${characterLimit} characters)</i><br>` + sub
      return this.qFormat(this.bodyStumpTemplate, { text: sub || "No data to dump" })
    }
    _getTextToDump() {
      return this.getPipishInput()
    }
  }

  class webDumpNode extends debugDumpNode {
    _getTextToDump() {
      return this.getParent().getWillowHttpResponse ? this.getParent().getWillowHttpResponse().text : `${this.constructor.name} requires a parent web tile.`
    }
  }

  class debugCommandsNode extends abstractChartNode {
    get bodyStumpTemplate() {
      return `a Run Speed Test on all Files in Working Directory
 clickCommand _runSpeedTestCommand
br
a Run Tile Quality Check
 clickCommand _doTileQualityCheckCommand`
    }
    getTileBodyStumpCode() {
      return this.bodyStumpTemplate
    }
  }

  class debugGrammarTreeNode extends abstractChartNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get supportedTreeLanguageCell() {
      return this.getWord(1)
    }
    async fetchTableInputs() {
      const fileExtension = this.getWord(1) || "maia"
      const programClass = this.getWebApp().getProgramConstructorFromFileExtension(fileExtension)
      const tree = new programClass("").getGrammarProgram().getNodeTypeFamilyTree()
      return { rows: [{ text: tree.toString() }] }
    }
  }

  class debugSleepNode extends abstractChartNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get millisecondsCell() {
      return parseInt(this.getWord(1))
    }
    get dummyDataSetIdCell() {
      return this.getWord(2)
    }
    get dummyDataSetName() {
      return `waterBill`
    }
    async fetchTableInputs() {
      const ms = parseInt(this.getWord(1) || 1)
      await this.getWebApp().sleepCommand(ms)
      return { rows: jtree.Utils.javascriptTableWithHeaderRowToObjects(DummyDataSets[this.getWord(2) || "stockPrice"]) }
    }
  }

  class debugThrowNode extends abstractChartNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get tileEventNameCell() {
      return this.getWord(1)
    }
    async fetchTableInputs() {
      this._throwIfMethodNameIs("fetchTableInputs")
      return {
        rows: []
      }
    }
    _throwIfMethodNameIs(name) {
      // Never throw if no word provided. That ensures it wont throw during testing.
      const lookingFor = this.getContent()
      if (lookingFor === name) throw new Error(`DebugTile threw an error on purpose on event: "${lookingFor}"`)
    }
    getTileBodyStumpCode() {
      this._throwIfMethodNameIs("getTileBodyStumpCode")
    }
    treeComponentDidMount() {
      this._throwIfMethodNameIs("treeComponentDidMount")
    }
    treeComponentDidUpdate() {
      this._throwIfMethodNameIs("treeComponentDidUpdate")
    }
  }

  class editorGalleryNode extends abstractChartNode {
    get miniStyleTemplate() {
      return `div
 style {style}`
    }
    get bodyStumpTemplate() {
      return `div
 class MiniMapTile
 {minis}`
    }
    get miniStumpTemplate() {
      return `a
 class miniMap
 {onClick}
 {value}
 {href}
 div
  class miniPreview
  {theTiles}
 div {filename}
  class miniFooter`
    }
    get hakonTemplate() {
      return `.MiniMapTile
 .miniMap
  background {backgroundColor}
  width 120px
  height 90px
  margin 6px
  position relative
  overflow hidden
  box-sizing border-box
  display inline-block
  &:hover
   border 1px solid {boxShadow}
  &:active
   border 2px solid {boxShadow}
  .miniFooter
   font-size 12px
   position absolute
   bottom 0
   width 100%
   height 15px
   line-height 15px
   white-space nowrap
   text-align center
  .miniPreview
   position absolute
   width 100%
   height calc(100% - 15px)
   top 0
   overflow hidden
   div
    position absolute
    background {linkColor}`
    }
    get dummyDataSetName() {
      return `maiaPrograms`
    }
    get tileSize() {
      return `1080 600`
    }
    async openFullPathInNewTabAndFocusCommand(url) {
      return this.getTab()
        .getRootNode()
        .openFullPathInNewTabAndFocusCommand(url)
    }
    _getMiniStumpCode(sourceCode, filename, permalink, width = 120, height = 75) {
      const maiaProgram = new maiaNode(sourceCode)
      const dimensions = maiaProgram.getTileDimensionMap(width, height)
      const theTiles = maiaProgram
        .getTiles()
        .filter(tile => tile.isVisible())
        .map(tile => this.qFormat(this.miniStyleTemplate, { style: dimensions.get(tile).getScaledCss(0.1) }))
        .join("\n")
      const onClick = permalink ? "clickCommand openFullPathInNewTabAndFocusCommand" : ""
      const value = permalink ? `value ${permalink}` : ""
      const href = permalink ? `href ${permalink}` : ""
      return this.qFormat(this.miniStumpTemplate, { filename, theTiles, onClick, value, href })
    }
    getTileBodyStumpCode() {
      // todo: cache.
      const minis = this.getRowsWithRowDisplayLimit()
        .map(row => this._getMiniStumpCode(row.getRowOriginalValue("bytes"), row.getRowOriginalValue("filename"), row.getRowOriginalValue("link")))
        .join("\n")
      return this.qFormat(this.bodyStumpTemplate, { minis })
    }
  }

  class handsontableBasicNode extends abstractChartNode {
    get bodyStumpTemplate() {
      return `div
 class hot`
    }
    get hakonTemplate() {
      return `.hot
 color black`
    }
    get tileScript() {
      return `maia/packages/handsontable/handsontable.full.min.js`
    }
    get tileCssScript() {
      return `maia/packages/handsontable/handsontable.min.css`
    }
    get tileSize() {
      return `1200 500`
    }
    getTileBodyStumpCode() {
      return this.bodyStumpTemplate
    }
    // todo: allow editing
    treeComponentWillUnmount() {
      if (this._hot) this._hot.destroy()
      delete this._hot
    }
    treeComponentDidUpdate() {
      super.treeComponentDidUpdate()
      const table = this.getParentOrDummyTable()
      const columnDefs = table.getColumnsByImportance()
      const colNames = columnDefs.map(col => col.getColumnName())
      const rows = this.getRowsWithRowDisplayLimit()
      const data = this.getRowsAsDataTableArrayWithHeader(rows, colNames)
      const tileDimension = this.getTileDimensionIfAny()
      const container = this.getStumpNode().findStumpNodeByChild("class hot")
      const app = this.getWebApp()
      if (this.isNodeJs()) return undefined
      const width = tileDimension.width - 20 // remove 10 for boddy padding?
      const height = tileDimension.height - 60
      this._hot = new Handsontable(container.getShadow().getShadowElement(), {
        data: data,
        rowHeaders: true,
        colHeaders: true,
        stretchH: "all",
        width: width,
        minSpareCols: 10,
        minSpareRows: 30,
        afterSelection: () => app.pauseShortcutListener(),
        afterDeselect: () => app.startShortcutListener(),
        height: height
      })
      return this._hot
    }
    treeComponentDidMount() {
      this.treeComponentDidUpdate()
    }
  }

  class listBasicNode extends abstractChartNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { label: labelNode }),
        undefined
      )
    }
    get columnNameCell() {
      return this.getWordsFrom(0)
    }
    get columnPredictionHints() {
      return `label getTitlePotential`
    }
    get dummyDataSetName() {
      return `telescopes`
    }
    get tileSize() {
      return `400 400`
    }
    get listItemStumpTemplate() {
      return `li
 span {label}`
    }
    get bodyStumpTemplate() {
      return `ol
 {items}`
    }
    _getListItem(label) {
      return this.qFormat(this.listItemStumpTemplate, { label })
    }
    _getLabelColumnName() {
      // todo: more automatic! Need to fix our columns/keywords issues
      return this.getWord(1) || this.getSettingsStruct().label
    }
    getTileBodyStumpCode() {
      const labelColumnName = this._getLabelColumnName()
      const items = this.getRowsWithRowDisplayLimit()
        .map(row => this._getListItem(jtree.Utils.stripHtml(row.getRowOriginalValue(labelColumnName)), row))
        .join("\n")
      return this.qFormat(this.bodyStumpTemplate, { items })
    }
  }

  class listLinksNode extends listBasicNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { label: labelNode, link: linkNode }),
        undefined
      )
    }
    get columnNameCell() {
      return this.getWordsFrom(0)
    }
    get columnPredictionHints() {
      return `label getTitlePotential
link isLink`
    }
    get listItemHakonTemplate() {
      return `li
 a {label}
  href {link}`
    }
    get dummyDataSetName() {
      return `telescopes`
    }
    _getUrlColumnName() {
      // todo: more automatic! Need to fix our columns/keywords issues
      return this.getWord(2) || this.getSettingsStruct().link
    }
    _getListItem(label, row) {
      const urlColumnName = this._getUrlColumnName()
      if (!urlColumnName) return super._getListItem(label, row)
      return this.qFormat(this.listItemHakonTemplate, { label, link: jtree.Utils.stripHtml(row.getRowOriginalValue(urlColumnName)) })
    }
  }

  class tablesBasicNode extends abstractChartNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { columnLimit: columnLimitNode }),
        undefined
      )
    }
    get titleCell() {
      return this.getWordsFrom(0)
    }
    get bodyStumpTemplate() {
      return `div
 class tablesBasicNode
 table
  thead
   {headerRows}
  tbody
   {bodyRows}`
    }
    get headerRowStumpTemplate() {
      return `th
 value {colName}
 span {colName}
 value {colName}`
    }
    get contextMenuStumpTemplate() {
      return `a Delete all rows
 clickCommand deleteAllRowsInTargetTileCommand`
    }
    get rowStumpTemplate() {
      return `tr
 class tableRow
 value {value}
 td {number}
 {cols}`
    }
    get cellLinkStumpTemplate() {
      return `td
 a
  href {content}
  bern
   {content}`
    }
    get cellStumpTemplate() {
      return `td
 bern
  {content}`
    }
    get hakonTemplate() {
      return `.tablesBasicNode
 font-size 14px
 box-sizing border-box
 width 100%
 height 100%
 {enableTextSelect1}
 top 34px
 table
  width 100%
 tr
  white-space nowrap
  padding 0
 td
  border 1px solid {lineColor}
 tr:nth-child(even)
  background-color {veryLightGrey}
 td,th
  padding 2px 3px
  text-align left
  overflow hidden
  text-overflow ellipsis
  max-width 250px
 td:hover,th:hover
  overflow visible
 td:first-child,th:first-child
  padding-left 5px
  color {greyish}
  width 60px
 th
  cursor pointer
  background-color {lightGrey}
  border 1px solid {lineColor}
  border-bottom-color {greyish}
 input,textarea
  border 0
  font-size 14px
  box-sizing border-box
  padding 0
  font-family {fonts}`
    }
    get customBodyStyle() {
      return `padding:0px;`
    }
    get tileSize() {
      return `750 300`
    }
    get columnLimit() {
      return 20
    }
    get rowDisplayLimit() {
      return 100
    }
    getTileHeaderBern() {
      return this.getContent() || super.getTileHeaderBern()
    }
    _getTableRowsStumpCode(columns) {
      return this.getRowsWithRowDisplayLimit()
        .map((row, index) => {
          const cols = columns
            .map(column => {
              return this.qFormat(column.isLink() ? this.cellLinkStumpTemplate : this.cellStumpTemplate, {
                content: row.getRowHtmlSafeValue(column.getColumnName())
              })
            })
            .join("\n")
          return this.qFormat(this.rowStumpTemplate, { number: index + 1, value: row.getPuid(), cols })
        })
        .join("\n")
    }
    getContextMenuStumpCode() {
      return this.contextMenuStumpTemplate
    }
    _getHeaderRowsStumpCode(columns) {
      // todo: can we get a copy column command?
      return ["Row"]
        .concat(columns)
        .map(colName => this.qFormat(this.headerRowStumpTemplate, { colName }))
        .join("\n")
    }
    getTileBodyStumpCode() {
      const tileStruct = this.getSettingsStruct()
      const table = this.getParentOrDummyTable()
      if (table.isBlankTable()) return `div No data to show`
      let columnDefs = tileStruct.columnOrder === "importance" ? table.getColumnsByImportance() : table.getColumnsArray()
      columnDefs = columnDefs.slice(0, tileStruct.columnLimit || this.columnLimit)
      const columnNames = columnDefs.map(col => col.getColumnName())
      // todo: if the types for a column are all equal, add a total row to the bottom.
      // todo: if the types for a row are all equal, add a total column to the right.
      const headerRows = this._getHeaderRowsStumpCode(columnNames)
      const bodyRows = this._getTableRowsStumpCode(columnDefs)
      return this.qFormat(this.bodyStumpTemplate, { headerRows, bodyRows })
    }
  }

  class tablesInterestingNode extends tablesBasicNode {
    get columnOrder() {
      return `importance`
    }
  }

  class tablesDumpNode extends tablesBasicNode {
    get columnOrder() {
      return `default`
    }
  }

  class textWordcloudNode extends abstractChartNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { column: columnNode, count: countNode }),
        undefined
      )
    }
    get columnPredictionHints() {
      return `name isString=true
count isString=false`
    }
    get dummyDataSetName() {
      return `wordCounts`
    }
    get tileScript() {
      return `maia/packages/text/wordcloud2.min.js`
    }
    getTileBodyStumpCode() {
      return `div
class divWhereWordCloudWillGo
style width: 100%; height: 100%;`
    }
    _getAllWords() {
      return this.getRequiredTableWithHeader(["name", "count"])
    }
    treeComponentDidUpdate() {
      this._draw()
    }
    treeComponentDidMount() {
      this._draw()
    }
    _draw() {
      if (this.isNodeJs()) return undefined
      const tileStruct = this.getSettingsStruct()
      const words = this._getAllWords()
      if (!words.length) return
      words.shift() // drop header
      const shadow = this.getStumpNode().getShadow()
      const width = shadow.getShadowOuterWidth()
      const powConstant = 10 / Math.log(words.length) // breaks if too hgih.
      const options = {
        list: words.map(word => [word[0], word[1]]),
        shuffle: false,
        gridSize: Math.round((16 * width) / 1024),
        weightFactor: size => (Math.pow(size, powConstant) * width) / 1024,
        backgroundColor: "transparent",
        random: jtree.Utils.makeSemiRandomFn(),
        wait: 0
      }
      Object.assign(options, tileStruct)
      const element = this.getStumpNode()
        .findStumpNodeByChild("class divWhereWordCloudWillGo")
        .getShadow()
        .getShadowElement()
      WordCloud(element, options)
    }
  }

  class treenotation3dNode extends abstractChartNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          size: sizeNode,
          cameraPosition: cameraPositionNode,
          content: contentNode
        }),
        undefined
      )
    }
    get dummyDataSetName() {
      return `treeProgram`
    }
    get tileScript() {
      return `maia/packages/treenotation/vis.min.js`
    }
    get tileSize() {
      return `800 500`
    }
    getTileBodyStumpCode() {
      return `div
class visjs`
    }
    treeComponentDidMount() {
      super.treeComponentDidMount()
      this.treeComponentDidUpdate()
    }
    // Called when the Visualization API is loaded.
    treeComponentDidUpdate() {
      super.treeComponentDidUpdate()
      if (this.isNodeJs()) return undefined
      try {
        this._tryVis()
      } catch (err) {
        // log error
        console.error(err)
      }
    }
    _tryVis() {
      const tileStruct = this.getSettingsStruct()
      const source = this.getPipishInput()
      const app = this.getWebApp()
      const language = app.getLanguageBestGuess(source)
      const program = app.generateProgram(source, language)
      const rows = this._treeTo3D(program)
      // Create and populate a data table.
      const data = new vis.DataSet()
      rows.forEach(row => data.add(row))
      const dotSize = tileStruct.size
      const showGrid = tileStruct.showGrid
      // specify options
      // docs: http://visjs.org/docs/graph3d/
      const tileDimension = this.getTileDimensionIfAny()
      const cameraPositionNode = this.getNode("cameraPosition") || new jtree.TreeNode("cameraPosition 4 .1 1.5").getNode("cameraPosition")
      const distance = parseFloat(cameraPositionNode.getWord(1))
      const horizontal = parseFloat(cameraPositionNode.getWord(2))
      const vertical = parseFloat(cameraPositionNode.getWord(3))
      const options = {
        width: tileDimension.width + "px",
        height: tileDimension.height - 80 + "px",
        style: "dot-color", // dot?
        showPerspective: false,
        showLegend: false,
        showShadow: false,
        keepAspectRatio: true,
        xStep: 1,
        yStep: 1,
        zStep: 1,
        zMax: 5,
        showGrid: true,
        showZAxis: false,
        showXAxis: false,
        showYAxis: false,
        dotSizeRatio: dotSize,
        dotSizeMinFraction: 1,
        cameraPosition: {
          distance: distance,
          horizontal: horizontal,
          vertical: vertical
        },
        verticalRatio: 1.0,
        // parameter point contains properties x, y, z, and data
        // data is the original object passed to the point constructor
        tooltip: point => point.data.line
      }
      // create a graph3d
      const element = this.getStumpNode()
        .findStumpNodeByChild("class visjs")
        .getShadow()
        .getShadowElement()
      this._graph3d = new vis.Graph3d(element, data, options)
      const throttled = lodash.throttle(evt => this._onCameraPositionChange(evt), 100)
      this._graph3d.on("cameraPositionChange", throttled)
    }
    async _onCameraPositionChange(evt) {
      // todo: throttle
      const pos = this._graph3d.getCameraPosition()
      const str = `${pos.distance} ${pos.horizontal} ${pos.vertical}`
      this.touchNode("cameraPosition").setContent(str)
      await this.getTab().autosaveTab()
    }
    _treeTo3D(program) {
      // getCameraPosition
      // setCameraPosition
      // onCameraPositionChange
      const theme = this.getWebApp().getTheme()
      // todo: use node type for color.
      const tagMap = {}
      const tagTree = new jtree.TreeNode(program.toCellTypeTree())
      // const outlineFn = node => node.getIndex()
      // use language to get dict, use dict to get type overlay to get tag types.
      const randomFn = jtree.Utils.makeSemiRandomFn()
      const makeColor = word => {
        if (!tagMap[word]) tagMap[word] = randomFn() // todo: give word types certain colors. green for keword, red for error, etc
        const color = tagMap[word]
        //console.log(color)
        return color
      }
      const points = []
      const nodeToPoint = (node, index) => {
        const nodePath = node.getPathVector(program)
        const tagNode = tagTree.nodeAt(nodePath)
        node.getWords().forEach((word, wordIndex) => {
          const wordType = tagNode.getWord(wordIndex)
          const colorNumber = makeColor(wordType)
          const xcc = node.getIndentLevel(program) + wordIndex
          const ycc = -node.getLineNumber()
          const zcc = 0
          points.push({
            x: xcc,
            y: ycc,
            z: zcc,
            line: `cellType: ${wordType} | word: ${word}`,
            style: colorNumber
          })
        })
      }
      program.getTopDownArray().forEach(nodeToPoint)
      return points
    }
  }

  class abstractProviderNode extends abstractMaiaTileNode {
    get tileStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div
  class TileBody HeaderLess
  {body}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get tileSize() {
      return `140 60`
    }
    getTileFooterStumpCode() {
      const table = this.getOutputOrInputTable()
      const time = (this.getTimeToLoad() / 1000).toFixed(1)
      const parserId = this.getParserId()
      return `${this.getTileToolbarButtonStumpCode()}
span Rows Out: ${table.getRowCount()} Columns Out: ${table.getColumnCount()} Time: ${time}s Parser: ${parserId || "?"}${this.getErrorMessageHtml()}`
    }
    getRowClass() {
      return Row
    }
    getTileBodyStumpCode() {
      const description = this.getDefinition().get("description")
      return "div " + (description ? jtree.Utils.linkify(description) : "")
    }
    toStumpCode() {
      return this.qFormat(this.tileStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        id: this.getTreeComponentId(),
        body: this._getBodyStumpCodeCache(),
        footer: this.getTileFooterStumpCode()
      })
    }
    getParserId() {
      return this.getSettingsStruct().parser
    }
    async fetchTableInputs() {
      return {
        rows: []
      }
    }
    async _executeChildNodes() {
      const timeLoadStarted = this._getProcessTimeInMilliseconds()
      this._timeLastLoadStarted = timeLoadStarted
      const fetchedTableInputs = await this.fetchTableInputs()
      // If a new request happened after this one, abort this one.
      // todo: what happens to children?
      // todo: add testing for this.
      if (this._timeLastLoadStarted !== timeLoadStarted) {
        console.log("superceded")
        return null
      }
      this._outputTable = new Table(fetchedTableInputs.rows, fetchedTableInputs.columnDefinitions, this.getRowClass())
      this._timeToLoad = this._getProcessTimeInMilliseconds() - timeLoadStarted
      this.setIsDataLoaded(true)
      await this._runChildTiles()
    }
  }

  class abstractUrlNoCellsNode extends abstractProviderNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { parser: parserNode, useCache: useCacheNode }),
        undefined
      )
    }
    get tileSize() {
      return `300 150`
    }
    get useCache() {
      return true
    }
    getUrl() {
      const struct = Object.assign(this.getSettingsStruct(), this.getDefinition().getConstantsObject())
      if (struct.urlTemplate && this.getContent()) return new jtree.TreeNode({ content: this.getContent() }).evalTemplateString(struct.urlTemplate)
      if (struct.urlPrefix && this.getContent()) return struct.urlPrefix + this.getContent()
      return struct.urlCell || this.getContent() || this.url || ""
    }
    getParserId() {
      const url = this.getUrl()
      if (super.getParserId()) return super.getParserId()
      const extension = jtree.Utils.getFileExtension(url)
      if (new TableParser().getAllTableParserIds().includes(extension)) return extension
    }
    getWillowHttpResponse() {
      return this._willowHttpResponse
    }
    _setWillowHttpResponse(willowHttpResponse) {
      this._willowHttpResponse = willowHttpResponse
      return this
    }
    // todo: add support for Arrow.
    // todo: remove this cache. use higher level.
    async _getData(url) {
      const useCache = this.getSettingsStruct().useCache !== "false" || this.useCache
      const willowBrowser = this.getWebApp().getWillowBrowser()
      let response
      if (useCache) response = await willowBrowser.httpGetUrlFromCache(url)
      else response = await willowBrowser.httpGetUrl(url)
      if (response.fromCache)
        this.emitLogMessage(`div
bern
 Loading from cache: ${url}`)
      this._setWillowHttpResponse(response)
      return response.getParsedDataOrText()
    }
    async fetchTableInputs() {
      let url = this.getUrl()
      if (!url) return { rows: [] }
      url = encodeURI(url)
      const parserId = this.getParserId()
      this.setRunTimePhaseError("fetchUrl")
      try {
        const data = await this._getData(url)
        const parser = new TableParser()
        return typeof data === "string" ? parser.parseTableInputsFromString(data, parserId) : parser.parseTableInputsFromObject(data, parserId)
      } catch (err) {
        // todo: solve the superagent not throwing response message thing.
        const txt = (err.text || err.toString()).substr(0, 280)
        this.emitLogMessage(`Error getting url: ${url}<br>
 ${txt}`)
        this.setRunTimePhaseError("fetchUrl", txt)
        return { rows: [] }
      }
    }
  }

  class abstractUrlNode extends abstractUrlNoCellsNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
    get tileSize() {
      return `300 100`
    }
  }

  class diskBrowseNode extends abstractUrlNode {
    get pathCell() {
      return this.getWordsFrom(0)
    }
    get tileSize() {
      return `500 500`
    }
    get hakonTemplate() {
      return `.DiskTile
 table
  width 100%
  td,th
   overflow hidden
   text-overflow ellipsis
  tr
   white-space nowrap`
    }
    getUrl() {
      return this.getContent() ? "/disk?path=" + this.getContent() : "/disk"
    }
    getTileBodyStumpCode() {
      const labelCol = "name"
      const path = this.getContent() || ""
      const parentPath = path.replace(/\/[^\/]*$/, "")
      const rowDisplayLimit = 1000 // todo: adjustable?
      let rows = this.getOutputTable()
        .getRows()
        .slice(0, rowDisplayLimit)
      rows = lodash.sortBy(rows, row => row.getRowOriginalValue("isDirectory") === "false")
      return `input
 placeholder Filepath
 value ${path}
 changeCommand changeTileContentAndRenderCommand
 class LargeTileInput
table
 tr
  td
   a ..
    clickCommand changeTileContentAndRenderCommand
    value ${parentPath}
${rows
  .map(row => {
    const label = jtree.Utils.stripHtml(row.getRowOriginalValue(labelCol))
    const isDir = row.getRowOriginalValue("isDirectory") === "true"
    const size = row.getRowOriginalValue("bytes")
    const mtime = row.getRowOriginalValue("mtime")
    if (!isDir)
      return ` tr
  td ${label}
  td ${numeral(size).format("0.0 b")}
  td ${moment(parseFloat(mtime)).fromNow()}`
    return ` tr
  td
   a ${label}
    clickCommand changeTileContentAndRenderCommand
    value ${path.replace(/\/$/, "") + "/" + label}`
  })
  .join("\n")}`
    }
  }

  class diskReadNode extends abstractUrlNode {
    get urlPrefix() {
      return `/disk.read?path=`
    }
  }

  class abstractHackernewsNode extends abstractUrlNode {}

  class hackernewsTopNode extends abstractHackernewsNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get quantityCell() {
      return parseInt(this.getWord(1))
    }
    async fetchTableInputs() {
      // todo: allow cache breaking.
      const willowBrowser = this.getWebApp().getWillowBrowser()
      const firstUrls = this._getFirstUrls()
      if (!firstUrls.length || this.isNodeJs()) return []
      let allResults = []
      const fetchMethod = async url =>
        this.getWebApp().isUrlGetProxyAvailable() ? willowBrowser.httpGetUrlFromProxyCache(url) : willowBrowser.httpGetUrlFromCache(url)
      for (let mainUrl of firstUrls) {
        const response = await fetchMethod(mainUrl)
        const nextUrls = this._parseNextUrls(response)
        const batchResults = await Promise.all(nextUrls.slice(0, this._getLimit()).map(url => fetchMethod(url)))
        allResults = allResults.concat(batchResults)
      }
      return { rows: allResults.map(res => res.asJson) }
    }
    _getLimit() {
      return parseInt(this.getContent() || 10)
    }
    _parseNextUrls(response) {
      return response.asJson.map(id => `https://hacker-news.firebaseio.com/v0/item/${id}.json?print=pretty`)
    }
    _getFirstUrls() {
      return ["https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty"]
    }
  }

  class hackernewsSubmissionsNode extends hackernewsTopNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get quantityCell() {
      return parseInt(this.getWord(1))
    }
    get hackerNewsUserNameCell() {
      return this.getWordsFrom(2)
    }
    _getFirstUrls() {
      return this.getWordsFrom(2).map(username => `https://hacker-news.firebaseio.com/v0/user/${username}.json?print=pretty`)
    }
    _getLimit() {
      return parseInt(this.getWord(1) || 10)
    }
    _parseNextUrls(response) {
      return response.asJson.submitted.map(id => `https://hacker-news.firebaseio.com/v0/item/${id}.json?print=pretty`)
    }
  }

  class webGetNode extends abstractUrlNode {
    get tileSize() {
      return `400 100`
    }
    get bodyStumpTemplate() {
      return `span {kind}
 class LargeLabel
input
 value {content}
 placeholder {placeholderMessage}
 changeCommand changeTileContentAndRenderCommand
 class LargeTileInput`
    }
    get placeholderMessage() {
      return `Enter a url.`
    }
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, { kind: this.getFirstWord(), content: this.getContent() || "", placeholderMessage: this.placeholderMessage })
    }
  }

  class webPostNode extends abstractUrlNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { post: postNode }),
        undefined
      )
    }
    get tileSize() {
      return `400 130`
    }
    get webPostBodyStumpTemplate() {
      return `textarea
 bern
  {post}
 placeholder This data will be sent as the value of the 'q' param
 name post
 changeCommand changeTileSettingMultilineCommand
 class TileTextArea`
    }
    getTileBodyStumpCode() {
      return super.getTileBodyStumpCode() + this.qFormat(this.webPostBodyStumpTemplate, { post: jtree.Utils.stripHtml(this.getSettingsStruct().post || "") })
    }
    async _getData(url) {
      const settings = this.getSettingsStruct()
      // todo, but make a separate tile
      // if (settings.pushButton) {
      //   if (!settings.pushed) return ""
      //   settings.pushed = false
      // }
      const postData = settings.post || ""
      const res = await this.getWebApp()
        .getWillowBrowser()
        .httpPostUrl(url, { q: postData.trim() })
      this._setWillowHttpResponse(res)
      return res.getParsedDataOrText()
    }
  }

  class abstractFixedDatasetFromUrlNode extends abstractUrlNoCellsNode {}

  class abstractFixedDatasetFromMaiaCollectionNode extends abstractFixedDatasetFromUrlNode {
    get tileSize() {
      return `300 150`
    }
    async _getData(url) {
      if (!this.isNodeJs()) return super._getData(url)
      const fs = require("fs")
      const filepath = __dirname + "/../" + url
      return fs.readFileSync(filepath, "utf8")
    }
  }

  class cancerCasesNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/cancer/cases.csv`
    }
  }

  class kaggleDatasetsHeartNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/kaggle/heart.csv`
    }
  }

  class samplesTelescopesNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/telescopes.tsv`
    }
  }

  class samplesMtcarsNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/mtcars.tsv`
    }
  }

  class samplesIrisNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/iris.tsv`
    }
  }

  class samplesFlights14Node extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/flights14-sample.csv`
    }
  }

  class samplesSiNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get parser() {
      return `text`
    }
    get url() {
      return `maia/packages/samples/si.tree`
    }
  }

  class samplesPortalNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/portals.ssv`
    }
  }

  class samplesStarWarsNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/starwars.json`
    }
  }

  class samplesPopulationsNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/populations.tsv`
    }
  }

  class samplesBabyNamesNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/baby-names-sample.csv`
    }
  }

  class samplesDeclarationNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/declaration-of-independence.text`
    }
  }

  class samplesPeriodicTableNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/periodic-table.csv`
    }
  }

  class samplesLettersNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/letters.tsv`
    }
  }

  class samplesPresidentsNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/samples/presidents.csv`
    }
  }

  class ucimlrDatasetsNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get url() {
      return `maia/packages/ucimlr/datasets.tsv`
    }
  }

  class vegaDataNode extends abstractFixedDatasetFromMaiaCollectionNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get vegaDataSetCell() {
      return this.getWord(1)
    }
    get urlPrefix() {
      return `maia/packages/vega/datasets/`
    }
  }

  class redditAllNode extends abstractUrlNoCellsNode {
    get offlineDataSet() {
      return `maia/packages/reddit/all.json`
    }
    get url() {
      return `https://www.reddit.com/r/all/top/.json?sort=top`
    }
    async fetchTableInputs() {
      const inputs = await super.fetchTableInputs()
      // Todo: add tests/external dependency, as reddit API changes.
      // Here it looks like we have the equivalent of a custom parser just for a Reddit Data source.
      // todo: explore/define/typescriptAPI this custom parser pattern more. probably will be common.
      return inputs.rows.length ? { rows: inputs.rows[0].data.children.map(obj => obj.data) } : inputs
    }
    getParserId() {
      return "json"
    }
  }

  class redditSubsNode extends redditAllNode {
    get url() {
      return `https://www.reddit.com/reddits.json`
    }
  }

  class redditSubNode extends redditAllNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get subredditNameCell() {
      return this.getWord(1)
    }
    getUrl() {
      const subreddit = this.getContent() || "all"
      return `https://www.reddit.com/r/${subreddit}/top/.json?sort=top`
    }
  }

  class abstractDummyNode extends abstractProviderNode {
    get tileSize() {
      return `300 150`
    }
    async _executeChildNodes() {
      this.setIsDataLoaded(true)
      await this._runChildTiles()
    }
  }

  class samplesPatientsNode extends abstractDummyNode {
    get dummyDataSetName() {
      return `patients`
    }
  }

  class samplesPoemNode extends abstractDummyNode {
    get dummyDataSetName() {
      return `poem`
    }
  }

  class samplesOuterSpaceNode extends abstractDummyNode {
    get dummyDataSetName() {
      return `outerSpace`
    }
  }

  class samplesTreeProgramNode extends abstractDummyNode {
    get dummyDataSetName() {
      return `treeProgram`
    }
  }

  class samplesWaterBillNode extends abstractDummyNode {
    get dummyDataSetName() {
      return `waterBill`
    }
  }

  class samplesGapMinderNode extends abstractDummyNode {
    get dummyDataSetName() {
      return `gapMinder`
    }
  }

  class abstractTransformerNode extends abstractProviderNode {
    get bodyStumpTemplate() {
      return `span {kind}
 class LargeLabel
input
 value {content}
 placeholder {placeholderMessage}
 changeCommand changeTileContentAndRenderCommand
 class LargeTileInput`
    }
    get placeholderMessage() {
      return ``
    }
    get tileSize() {
      return `160 100`
    }
    getTileFooterStumpCode() {
      const inputCount = this.getParentOrDummyTable().getRowCount()
      const outputTable = this.getOutputOrInputTable()
      return `${this.getTileToolbarButtonStumpCode()}
span Rows In: ${inputCount} Rows Out: ${outputTable.getRowCount()} Columns Out: ${outputTable.getColumnCount()}`
    }
    async _executeChildNodes() {
      this._outputTable = this._createOutputTable()
      this.setIsDataLoaded(true)
      await this._runChildTiles()
    }
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, { kind: this.getFirstWord(), content: this.getContent() || "", placeholderMessage: this.placeholderMessage })
    }
  }

  class abstractColumnAdderTileNode extends abstractTransformerNode {
    _createOutputTable() {
      return this.getParentOrDummyTable().addColumns(this.getNewColumns())
    }
  }

  class dateAddColumnsNode extends abstractColumnAdderTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { sourceColumn: sourceColumnNode }),
        undefined
      )
    }
    get dateColumnTypeCell() {
      return this.getWordsFrom(0)
    }
    get placeholderMessage() {
      return `Enter the source column and new date columns you want, or leave blank to get 'day month year'.`
    }
    get columnPredictionHints() {
      return `sourceColumn isTemporal=true`
    }
    getNewColumns() {
      const inputColumnName = this.getSettingsStruct().sourceColumn // todo: this is probably broken. need to fix settings timing issues.
      if (!inputColumnName) return []
      const addColumns = this.getContent() ? this.getWordsFrom(1) : ["day", "week", "month"]
      // what happened to dayName? timeOfDay?
      return addColumns.map(outputCol => {
        return {
          source: inputColumnName,
          name: outputCol,
          type: outputCol
        }
      })
    }
  }

  class mathLogNode extends abstractColumnAdderTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    getNewColumns() {
      const inputColumnName = this.getWord(1)
      if (!inputColumnName) return []
      const inputCol = this.getParentOrDummyTable().getColumnByName(inputColumnName)
      return [
        {
          source: inputColumnName,
          name: inputColumnName + "Log",
          type: inputCol.getPrimitiveTypeName(),
          mathFn: Math.log
        }
      ]
    }
  }

  class rowsAddIndexColumnNode extends abstractColumnAdderTileNode {
    getNewColumns() {
      let index = 0
      return [
        {
          name: "index",
          accessorFn: row => index++
        }
      ]
    }
  }

  class rowsRunningTotalNode extends abstractColumnAdderTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    getNewColumns() {
      const sourceColumnName = this.getWord(1)
      let total = 0
      return [
        {
          source: sourceColumnName,
          name: "total",
          accessorFn: row => {
            total += row[sourceColumnName]
            return total
          }
        }
      ]
    }
  }

  class textLengthNode extends abstractColumnAdderTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    getNewColumns() {
      const sourceColumnName = this.getWord(1)
      const destinationColumnName = sourceColumnName + "Length"
      return [
        {
          source: sourceColumnName,
          name: destinationColumnName,
          accessorFn: row => row[sourceColumnName].length
        }
      ]
    }
  }

  class textSplitNode extends abstractColumnAdderTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    get delimiterCell() {
      return this.getWord(2)
    }
    get newColumnNamesCell() {
      return this.getWordsFrom(3)
    }
    get dummyDataSetName() {
      return `poem`
    }
    // note: delimiter can probably be ""
    // todo: how would we split on a space???
    // perhaps its better to use getContent() as delimiter, and if you want to name the columns, you can do that later?
    getNewColumns() {
      const sourceColumnName = this.getWord(1)
      const delimiter = this.getWord(2)
      const destinationColumns = this.getWordsFrom(3)
      return destinationColumns.map((destinationColumnName, index) => {
        return {
          source: sourceColumnName,
          name: destinationColumnName,
          accessorFn: row => row[sourceColumnName].split(delimiter)[index]
        }
      })
      return [
        {
          source: sourceColumnName,
          name: destinationColumnName,
          accessorFn: row => row[sourceColumnName].length
        }
      ]
    }
  }

  class textToLowerCaseNode extends abstractColumnAdderTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    get dummyDataSetName() {
      return `poem`
    }
    getNewColumns() {
      const sourceColumnName = this.getWord(1) || "text"
      return [
        {
          source: sourceColumnName,
          name: sourceColumnName,
          accessorFn: row => row[sourceColumnName].toLowerCase()
        }
      ]
    }
  }

  class textSubstringNode extends abstractColumnAdderTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    get newColumnNameCell() {
      return this.getWord(2)
    }
    get startIndexCell() {
      return parseInt(this.getWord(3))
    }
    get lengthCell() {
      return parseInt(this.getWord(4))
    }
    get dummyDataSetName() {
      return `poem`
    }
    getNewColumns() {
      const sourceColumnName = this.getWord(1)
      const destinationColumnName = this.getWord(2)
      const startPosition = parseInt(this.getWord(3))
      const endPosition = this.getWord(4) === undefined ? undefined : parseInt(this.getWord(4))
      return [
        {
          source: sourceColumnName,
          name: destinationColumnName,
          accessorFn: row => (row[sourceColumnName] ? row[sourceColumnName].substr(startPosition, endPosition) : "")
        }
      ]
    }
  }

  class abstractNewRowsTransformerTileNode extends abstractTransformerNode {
    _createOutputTable() {
      // todo: remove this
      return new Table(this.makeNewRows())
    }
  }

  class columnsDescribeNode extends abstractNewRowsTransformerTileNode {
    makeNewRows() {
      return this.getParentOrDummyTable().getColumnNamesAndTypesAndReductions()
    }
  }

  class columnsListNode extends columnsDescribeNode {
    makeNewRows() {
      return this.getParentOrDummyTable().getColumnNamesAndTypes()
    }
  }

  class dataEvalNode extends abstractNewRowsTransformerTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { content: contentNode }),
        undefined
      )
    }
    makeNewRows() {
      const node = this.getNode(this.contentKey)
      const code = node && node.childrenToString() // "rows => { return []}"
      let fn
      try {
        fn = code && eval(code)
      } catch (err) {
        // todo: warn user
        console.error(err)
      }
      const inputRows = this.getParentOrDummyTable().cloneNativeJavascriptTypedRows()
      return fn ? fn(inputRows) : inputRows
    }
  }

  class joinByNode extends abstractNewRowsTransformerTileNode {
    get columnNameCell() {
      return this.getWordsFrom(0)
    }
    makeNewRows() {
      // Todo: move to table project
      const parentTile = this.getParent()
      if (parentTile.isRoot()) return []
      const grandParentTile = parentTile.getParent()
      if (grandParentTile.isRoot()) return parentTile.getOutputOrInputTable().cloneNativeJavascriptTypedRows()
      const tiles = [parentTile, grandParentTile]
      const arrays = tiles.map(tile => tile.getOutputOrInputTable().cloneNativeJavascriptTypedRows())
      const joinOn = this.getContent()
      if (!joinOn) return jtree.Utils.flatten(arrays)
      const cols = tiles.map(tile => tile.getOutputOrInputTable().getColumnNames())
      return jtree.Utils.joinArraysOn(joinOn, arrays, cols)
    }
  }

  class matchColumnsFuzzyNode extends abstractNewRowsTransformerTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get needleColumnNameCell() {
      return this.getWord(1)
    }
    get haystackColumnNameCell() {
      return this.getWord(2)
    }
    get tileScript() {
      return `maia/packages/match/fuse.min.js`
    }
    makeNewRows() {
      // Todo: move some of this logic to table project?
      const parentTile = this.getParent()
      if (parentTile.isRoot()) return []
      const grandParentTile = parentTile.getParent()
      if (grandParentTile.isRoot()) return parentTile.getOutputOrInputTable().cloneNativeJavascriptTypedRows()
      const tiles = [parentTile, grandParentTile]
      const arrays = tiles.map(tile => tile.getOutputOrInputTable().cloneNativeJavascriptTypedRows())
      return this._addFuzz(arrays[0], arrays[1])
    }
    get fuse() {
      return this.isNodeJs() ? require("fuse.js") : Fuse
    }
    _addFuzz(needles, haystacks) {
      const needleColumnName = this.getWord(1) || "name"
      const haystackColumnName = this.getWord(2) || "name"
      const options = {
        shouldSort: true,
        includeScore: true,
        threshold: 0.6,
        location: 0,
        distance: 100,
        maxPatternLength: 32,
        minMatchCharLength: 1,
        keys: [haystackColumnName]
      }
      const fuse = new this.fuse(haystacks, options) // "list" is the item array
      return needles.map(needle => {
        const searchValue = needle[needleColumnName]
        const result = fuse.search(searchValue)
        if (!result.length)
          return {
            search: searchValue,
            match: ""
          }
        const match = result[0]
        return {
          search: searchValue,
          match: match.item[haystackColumnName],
          confidence: parseFloat((1 - match.score).toFixed(3))
        }
      })
    }
  }

  class textWordCountNode extends abstractNewRowsTransformerTileNode {
    get dummyDataSetName() {
      return `poem`
    }
    makeNewRows() {
      return this._getAllWords(this.getPipishInput())
    }
    _getAllWords(text) {
      const rows = []
      if (!text) return rows
      const words = text
        .split(/\s/g)
        .map(word => word.replace(/[^a-z0-9\-]/gi, ""))
        .filter(word => word)
      const index = {}
      words.forEach(word => {
        if (!index[word]) index[word] = 1
        else index[word]++
      })
      Object.keys(index).forEach(word => {
        const trimmedWord = word.trim()
        if (trimmedWord)
          rows.push({
            word: trimmedWord,
            count: index[trimmedWord]
          })
      })
      return rows
    }
  }

  class textLineCountNode extends abstractNewRowsTransformerTileNode {
    get dummyDataSetName() {
      return `poem`
    }
    makeNewRows() {
      return [{ lines: this.getPipishInput().split(/\n/g).length }]
    }
  }

  class treenotationWordTypesNode extends abstractNewRowsTransformerTileNode {
    get dummyDataSetName() {
      return `treeProgram`
    }
    makeNewRows() {
      const sourceCode = this.getPipishInput()
      const app = this.getWebApp()
      const language = app.getLanguageBestGuess(sourceCode) // todo: use treeLanguage setting
      const program = app.generateProgram(sourceCode, language)
      return [{ text: program.toCellTypeTree() }]
    }
  }

  class abstractColumnFilterTileNode extends abstractTransformerNode {
    _createOutputTable() {
      return this.getParentOrDummyTable().dropAllColumnsExcept(this.getColumnNamesToKeep())
    }
  }

  class columnsFirstNode extends abstractColumnFilterTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
    get placeholderMessage() {
      return `Enter the number of columns you want to keep`
    }
    getColumnNamesToKeep() {
      return this.getParentOrDummyTable()
        .getColumnsArrayOfObjects()
        .slice(0, parseInt(this.getContent()))
        .map(col => col.name)
    }
  }

  class columnsLastNode extends abstractColumnFilterTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
    get placeholderMessage() {
      return `Enter the number of columns you want to keep`
    }
    getColumnNamesToKeep() {
      const cols = this.getParentOrDummyTable().getColumnsArrayOfObjects()
      return cols.slice(cols.length - parseInt(this.getContent())).map(col => col.name)
    }
  }

  class columnsDropNode extends abstractColumnFilterTileNode {
    get columnNameCell() {
      return this.getWordsFrom(0)
    }
    getColumnNamesToKeep() {
      const colsToDrop = this.getWordsFrom(1)
      return this.getParentOrDummyTable()
        .getColumnsArrayOfObjects()
        .filter(col => !colsToDrop.includes(col.name))
        .map(col => col.name)
    }
  }

  class columnsDropConstantsNode extends abstractColumnFilterTileNode {
    getColumnNamesToKeep() {
      return this.getParentOrDummyTable()
        .getColumnsArray()
        .filter(col => col.getReductions().uniqueValues > 1)
        .map(col => col.getColumnName())
    }
  }

  class columnsKeepNode extends abstractColumnFilterTileNode {
    get columnNameCell() {
      return this.getWordsFrom(0)
    }
    get placeholderMessage() {
      return `Enter the columns to keep.`
    }
    getColumnNamesToKeep() {
      const colsToKeep = this.getWordsFrom(1)
      return this.getParentOrDummyTable()
        .getColumnsArrayOfObjects()
        .filter(col => colsToKeep.includes(col.name))
        .map(col => col.name)
    }
  }

  class abstractTransformerNoParamsTileNode extends abstractTransformerNode {
    getTileBodyStumpCode() {
      return `span ${this.getFirstWord()}
class LargeLabel`
    }
  }

  class rowsShuffleNode extends abstractTransformerNoParamsTileNode {
    _createOutputTable() {
      return this.getParentOrDummyTable().shuffleRows()
    }
  }

  class rowsReverseNode extends abstractTransformerNoParamsTileNode {
    _createOutputTable() {
      return this.getParentOrDummyTable().reverseRows()
    }
  }

  class abstractRowFilterTileNode extends abstractTransformerNode {
    get placeholderMessage() {
      return `Enter a string to filter by.`
    }
    // todo: pass thru.
    // todo: remove this?
    _createOutputTable() {
      const fn = this.getRowFilterFn()
      if (!fn) return this.getParentOrDummyTable().clone()
      return this.getParentOrDummyTable().filterRowsByFn(fn)
    }
  }

  class filterWhereNode extends abstractRowFilterTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    get comparisonCell() {
      return this.getWord(2)
    }
    get scalarValueCell() {
      return this.getWord(3)
    }
    get tileSize() {
      return `250 100`
    }
    _createOutputTable() {
      // todo: use cells here.
      const columnName = this.getWord(1)
      const comparison = this.getWord(2)
      let untypedScalarValue = this.getWord(3)
      const table = this.getParentOrDummyTable()
      if (!columnName || !comparison || untypedScalarValue === undefined) return table.clone()
      const column = table.getColumnByName(columnName)
      if (!column) return table
      return table.filterClonedRowsByScalar(columnName, comparison, untypedScalarValue)
    }
  }

  class rowsDropIfMissingNode extends filterWhereNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    getRowFilterFn() {
      const column = this.getContent()
      return row => row[column] !== ""
    }
  }

  class filterWithNode extends abstractRowFilterTileNode {
    get stringCell() {
      return this.getWordsFrom(0)
    }
    get expectedBooleanValue() {
      return true
    }
    get tileSize() {
      return `250 100`
    }
    getRowFilterFn() {
      const words = this.getWordsFrom(1)
      // todo: problem here is, getRows has too many columns if after a transformed column.
      const rows = this.getParentOrDummyTable().getRows()
      if (!words.length) return undefined
      const len = words.length
      const expectedValue = this.expectedBooleanValue
      return row => {
        const str = JSON.stringify(row)
        for (let index = 0; index < len; index++) {
          if (str.includes(words[index]) !== expectedValue) return false
        }
        return true
      }
    }
  }

  class filterWithoutNode extends filterWithNode {
    get expectedBooleanValue() {
      return false
    }
  }

  class rowsFirstNode extends abstractRowFilterTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
    getRowFilterFn() {
      const limit = parseInt(this.getContent())
      if (isNaN(limit)) return undefined
      return (row, rowIndex) => rowIndex < limit
    }
  }

  class rowsLastNode extends abstractRowFilterTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
    getRowFilterFn() {
      const limit = parseInt(this.getContent())
      if (isNaN(limit)) return undefined
      const start = this.getParentOrDummyTable().getRowCount() - limit
      return (row, rowIndex) => rowIndex >= start
    }
  }

  class columnsSetTypeNode extends abstractTransformerNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    get primitiveTypeCell() {
      return this.getWord(2)
    }
    _createOutputTable() {
      const colToChange = this.getWord(1)
      const newType = this.getWord(2)
      return this.getParentOrDummyTable().changeColumnType(colToChange, newType)
    }
  }

  class groupByNode extends abstractTransformerNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { reduce: reduceNode }),
        undefined
      )
    }
    get columnNameCell() {
      return this.getWordsFrom(0)
    }
    get placeholderMessage() {
      return `Enter the column to groupby.`
    }
    _createOutputTable() {
      const groupByColNames = this.getWordsFrom(1)
      if (!groupByColNames.length) return this.getParentOrDummyTable().clone()
      const newCols = this.findNodes("reduce").map(reduceNode => {
        return {
          source: reduceNode.getWord(1),
          reduction: reduceNode.getWord(2),
          name: reduceNode.getWord(3) || reduceNode.getWordsFrom(1).join("_")
        }
      })
      return this.getParentOrDummyTable().makePivotTable(groupByColNames, newCols)
    }
  }

  class rowsSortByNode extends abstractTransformerNode {
    get columnNameCell() {
      return this.getWordsFrom(0)
    }
    get placeholderMessage() {
      return `Columns you want to sort by`
    }
    _createOutputTable() {
      const table = this.getParentOrDummyTable().sortBy(this.getWordsFrom(1))
      if (this.getFirstWord().includes("Reverse")) return table.reverseRows()
      return table
    }
  }

  class rowsSortByReverseNode extends rowsSortByNode {}

  class rowsAddOneNode extends abstractTransformerNode {
    get anyCell() {
      return this.getWordsFrom(0)
    }
    _createOutputTable() {
      return this.getParentOrDummyTable().addRow(this.getWordsFrom(1))
    }
  }

  class dataInlineNode extends abstractProviderNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          parser: parserNode,
          treeLanguage: treeLanguageNode,
          content: contentNode
        }),
        undefined
      )
    }
    get tileSize() {
      return `280 220`
    }
    get bodyStumpTemplate() {
      return `textarea
 name content
 changeCommand changeTileSettingMultilineCommand
 placeholder Enter data in any format here. It will be saved directly in your document.
 class TileTextArea savable
 bern
  {text}`
    }
    getDataContent() {
      const node = this.getNode("content")
      return node ? node.childrenToString() : ""
    }
    getTileBodyStumpCode() {
      const text = lodash.escape(this.getDataContent())
      return this.qFormat(this.bodyStumpTemplate, { text })
    }
    getRowClass() {
      class InlineDataTileRow extends Row {}
      return InlineDataTileRow
    }
    getParserId() {
      return super.getParserId() || new TableParser().guessTableParserId(this.getDataContent())
    }
    async fetchTableInputs() {
      return new TableParser().parseTableInputsFromString(this.getDataContent(), this.getParserId())
    }
  }

  class dataLocalStorageNode extends dataInlineNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get localStorageKeyCell() {
      return this.getWord(1)
    }
    get bodyStumpTemplate() {
      return `textarea
 changeCommand triggerTileMethodCommand
 placeholder Enter data in any format here. It will be saved in your browser's localStorage.
 name storeValueCommand
 class TileTextArea savable
 bern
  {text}`
    }
    // Note: for now, only way to clear a key is to do it manually through UI (select all delete) or console. That might be good enough.
    _getStoreKey() {
      return this.getContent()
    }
    getDataContent() {
      const key = this._getStoreKey()
      return key ? this.getWebApp().getFromStore(key) || "" : ""
    }
    storeValueCommand(value) {
      let key = this._getStoreKey()
      if (key) this.getWebApp().storeValue(key, value)
      else this.setContent(this.getWebApp().initLocalDataStorage(this.constructor.name + ".data", value))
    }
    getTileBodyStumpCode() {
      const text = encodeURIComponent(this.getDataContent())
      return this.qFormat(this.bodyStumpTemplate, { text })
    }
  }

  class debugParserTestNode extends abstractProviderNode {
    async fetchTableInputs() {
      const parentTile = this.getParent()
      if (parentTile.getWillowHttpResponse) {
        const probs = new TableParser().guessProbabilitiesForAllTableParsers(parentTile.getWillowHttpResponse().text)
        return {
          rows: Object.keys(probs).map(key => {
            return {
              parser: key,
              probability: probs[key]
            }
          })
        }
      }
      return [{ rows: [] }]
    }
  }

  class editorFilesNode extends abstractProviderNode {
    get tileSize() {
      return `140 120`
    }
    getRowClass() {
      class FileRow extends Row {
        destroyRow(app) {
          return app.deleteFileCommand(this.getRowOriginalValue("link"))
        }
      }
      return FileRow
    }
    getTileHeaderBern() {
      return this.getWebApp()
        .getDefaultDisk()
        .getPathBase()
    }
    async fetchTableInputs() {
      const files = await this.getWebApp()
        .getDefaultDisk()
        .readFiles()
      return { rows: files.map(file => file.toFileObject()) }
    }
  }

  class editorCommandHistoryNode extends abstractProviderNode {
    get methodName() {
      return `getCommandsBuffer`
    }
    async fetchTableInputs() {
      return { rows: this.getWebApp()[this.methodName]() }
    }
  }

  class mathGenNode extends abstractProviderNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get mathFunctionNameCell() {
      return this.getWord(1)
    }
    get fromCell() {
      return parseFloat(this.getWord(2))
    }
    get toCell() {
      return parseFloat(this.getWord(3))
    }
    get incrementCell() {
      return parseFloat(this.getWord(4))
    }
    async fetchTableInputs() {
      const rows = []
      const fn = Math[this.getWord(1)]
      for (let input = parseFloat(this.fromCell); input < parseFloat(this.toCell); input += parseFloat(this.incrementCell)) {
        rows.push({ input, output: fn(input) })
      }
      return {
        rows
      }
    }
  }

  class abstractRandomTileNode extends abstractProviderNode {
    async fetchTableInputs() {
      let howMany = this.quantityCell || 30
      const rows = []
      for (let index = 1; index <= howMany; index++) {
        rows.push(this._genRow(index))
      }
      return { rows }
    }
  }

  class randomFloatNode extends abstractRandomTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get quantityCell() {
      return parseInt(this.getWord(1))
    }
    get minCell() {
      return parseFloat(this.getWord(2))
    }
    get maxCell() {
      return parseFloat(this.getWord(3))
    }
    get max() {
      return 1
    }
    get min() {
      return 0
    }
    _genRow(index) {
      return { index, number: jtree.Utils.randomUniformFloat(this.minCell, this.maxCell, Math.random()) }
    }
  }

  class randomIntNode extends abstractRandomTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get quantityCell() {
      return parseInt(this.getWord(1))
    }
    get minCell() {
      return parseFloat(this.getWord(2))
    }
    get maxCell() {
      return parseFloat(this.getWord(3))
    }
    get max() {
      return 100
    }
    get min() {
      return 0
    }
    _genRow(index) {
      return { index, number: jtree.Utils.randomUniformInt(this.minCell, this.maxCell, Math.random()) }
    }
  }

  class samplesTinyIrisNode extends abstractProviderNode {
    get bodyStumpTemplate() {
      return `pre
 class TileSelectable
 style overflow: scroll; max-height: 100%;
 bern
  {text}`
    }
    get data() {
      return `petal_length,petal_width,species
4.9,1.8,virginica
4.2,1.3,versicolor
4.9,2,virginica
1.5,0.2,setosa`
    }
    getDataContent() {
      return this.data
    }
    getTileBodyStumpCode() {
      return this.qFormat(this.bodyStumpTemplate, { text: this.getDataContent() })
    }
    getParserId() {
      return super.getParserId() || new TableParser().guessTableParserId(this.getDataContent())
    }
    async fetchTableInputs() {
      return new TableParser().parseTableInputsFromString(this.getDataContent(), this.getParserId())
    }
  }

  class toCsvNode extends abstractMaiaTileNode {
    execute() {
      console.log(this.getParentOrDummyTable().toDelimited(","))
    }
  }

  class abstractTemplatePickerTileNode extends abstractMaiaTileNode {
    get tileHeader() {
      return `Gallery`
    }
    get categoryBreakStumpTemplate() {
      return `div {category}
 class PickerCategory`
    }
    get itemStumpTemplate() {
      return `{categoryBreak}
a {name}
 br
  span {description}
 title {description}
 tabindex -1
 value {value}
 class pickerItemButton
 clickCommand {command}`
    }
    get hakonTemplate() {
      return `.abstractTemplatePickerTileNode
 .PickerCategory
  width 100%
  margin-top 20px
  text-align center
 .TileBody
  display flex
  flex-flow row wrap
  a
   &:hover
    background-color {borderColor}
   padding 10px
   margin 5px
   height 30px
   background-color {backgroundColor}
   border 1px solid {borderColor}
   overflow hidden
   text-align center
   text-overflow ellipsis
   font-size 14px
   width 120px
   span
    font-size 70%`
    }
    get tileSize() {
      return `480 420`
    }
    async fetchTableInputs() {
      return { rows: this.getChoices().map(obj => obj.toObject()) }
    }
    getTileBodyStumpCode() {
      let lastCat = ""
      return this.getChoices()
        .map(choice => {
          choice.categoryBreak = lastCat !== choice.category ? this.qFormat(this.categoryBreakStumpTemplate, { category: choice.category }) : ""
          lastCat = choice.category
          return this.qFormat(this.itemStumpTemplate, choice)
        })
        .join("\n")
    }
    getTileHeaderBern() {
      return this.tileHeader
    }
  }

  class templatesListNode extends abstractTemplatePickerTileNode {
    get tileHeader() {
      return `Template Gallery`
    }
    getChoices() {
      // todo: cleanup.
      const choices = this._getTheTemplates().map(node => {
        const id = node
          .getWord(1)
          .replace("templates/", "")
          .replace(this.maiaFileExtensionKey, "")
        return {
          command: "createProgramFromTemplateCommand",
          name: node.get("data doc.title"),
          value: id,
          category: lodash.upperFirst(node.get("data doc.categories")),
          description: ""
        }
      })
      return lodash.sortBy(choices, "category")
    }
    _getTheTemplates() {
      // todo: trim?
      return typeof TemplatesStamp === "undefined"
        ? jtree.TreeNode.fromDisk("maia/packages/templates/Templates.stamp").trim()
        : new jtree.TreeNode(TemplatesStamp).trim()
    }
    getProgramTemplate(id) {
      const node = this._getTheTemplates().filter(node => node.getContent() === `templates/${id}${this.maiaFileExtensionKey}`)[0]
      return {
        template: node.getNode("data").childrenToString(),
        name: id + this.maiaFileExtensionKey
      }
    }
  }

  class tileBlankLineNode extends jtree.GrammarBackedNode {
    get emptyCell() {
      return this.getWord(0)
    }
    get visible() {
      return false
    }
  }

  class abstractDocSettingNode extends jtree.GrammarBackedNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get visible() {
      return false
    }
  }

  class docCategoriesNode extends abstractDocSettingNode {
    get documentCategoryCell() {
      return this.getWordsFrom(0)
    }
  }

  class docAuthorNode extends abstractDocSettingNode {
    get stringCell() {
      return this.getWordsFrom(0)
    }
  }

  class docDefaultHiddenNode extends abstractDocSettingNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
  }

  class docDateNode extends abstractDocSettingNode {
    get dateCell() {
      return this.getWordsFrom(0)
    }
  }

  class docZoomNode extends abstractDocSettingNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get zoomCell() {
      return parseFloat(this.getWord(1))
    }
  }

  class docLayoutNode extends abstractDocSettingNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get docLayoutOptionCell() {
      return this.getWord(1)
    }
  }

  class abstractDocSectionComponentNode extends jtree.GrammarBackedNode {}

  class docSectionSubtitleNode extends abstractDocSectionComponentNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get stringCell() {
      return this.getWordsFrom(1)
    }
    compile() {
      return `h2 ${this.getContent()}`
    }
  }

  class docSectionParagraphNode extends abstractDocSectionComponentNode {
    createParser() {
      return new jtree.TreeNode.Parser(docParagraphLineNode, undefined, undefined)
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get stringCell() {
      return this.getWordsFrom(1)
    }
    get stumpTemplate() {
      return `p
 bern
  {content}`
    }
    compile() {
      return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getContentWithChildren() })
    }
  }

  class docSectionLinkNode extends abstractDocSectionComponentNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
    get stringCell() {
      return this.getWordsFrom(2)
    }
    get stumpTemplate() {
      return `a {content}
 href {url}`
    }
    compile() {
      return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getWordsFrom(2).join(" "), url: this.getWord(1) })
    }
  }

  class docSectionCodeNode extends abstractDocSectionComponentNode {
    createParser() {
      return new jtree.TreeNode.Parser(docLineOfCodeNode, undefined, undefined)
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get programmingLanguageNameCell() {
      return this.getWord(1)
    }
    get stumpTemplate() {
      return `code
 bern
  {content}`
    }
    compile() {
      return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.childrenToString().replace(/</g, "&lt;") })
    }
  }

  class docLineOfCodeNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(docLineOfCodeNode, undefined, undefined)
    }
    get codeCell() {
      return this.getWordsFrom(0)
    }
  }

  class docParagraphLineNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(docParagraphLineNode, undefined, undefined)
    }
    get stringCell() {
      return this.getWordsFrom(0)
    }
  }

  class commentLineNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(commentLineNode, undefined, undefined)
    }
    get commentCell() {
      return this.getWordsFrom(0)
    }
  }

  class docReferenceUrlNode extends jtree.GrammarBackedNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
  }

  class catchAllErrorNode extends jtree.GrammarBackedNode {
    getErrors() {
      return this._getErrorNodeErrors()
    }
    get errorCell() {
      return this.getWordsFrom(0)
    }
  }

  class hashBangNode extends jtree.GrammarBackedNode {
    get hashBangWordCell() {
      return this.getWordsFrom(0)
    }
  }

  class tilesNode extends AbstractTreeComponent {
    createParser() {
      return new jtree.TreeNode.Parser(DidYouMeanTileNode, undefined, undefined)
    }
    get wallType() {
      return `wall`
    }
    getTileClosestToLine(lineIndex) {
      let current = this.nodeAtLine(lineIndex)
      while (current) {
        if (current.doesExtend("abstractTileTreeComponentNode")) return current
        current = current.getParent()
      }
    }
    setTab(tab) {
      this._tab = tab
    }
    getTheme() {
      const tab = this.getTab()
      return tab ? tab.getTheme() : super.getTheme()
    }
    getTab() {
      return this._tab
    }
    tilesAreVisible() {
      return !this.has(TilesConstants.defaultHidden)
    }
    canUseCustomLayout() {
      const definedLayout = this.get(TilesConstants.layout)
      if (definedLayout === TilesConstants.layouts.custom) return true
      if (this.getTiles().some(tile => tile.has(TilesConstants.left) || tile.has(TilesConstants.top))) return true
      return false
    }
    _getLayoutStrategy() {
      const definedLayout = this.get(TilesConstants.layout)
      return (
        definedLayout ||
        (this.wallType === OhayoConstants.flex
          ? this.canUseCustomLayout()
            ? TilesConstants.layouts.custom
            : TilesConstants.layouts.tiled
          : TilesConstants.layouts.tree)
      )
    }
    getTileDimensionMap(width, height) {
      // todo: cache?
      return new Layout().getTileDimensionMap(this, this._getLayoutStrategy(), width, height)
    }
    async loadAndIncrementalRender() {
      const app = this.getTab().getRootNode()
      await Promise.all(this.getTiles().map(tile => tile.loadRequirements()))
      await Promise.all(
        this.getRootLevelTiles().map(async tile => {
          await tile.execute()
          app.renderApp()
        })
      )
      app.renderApp() // this one might be superfluous
      return this
    }
    getTiles() {
      return this.getTopDownArray().filter(node => node.doesExtend("abstractTileTreeComponentNode"))
    }
    getRootLevelTiles() {
      return this.filter(node => node.doesExtend("abstractTileTreeComponentNode"))
    }
    _getProjectRootDir() {
      return this.isNodeJs() ? jtree.Utils.findProjectRoot(__dirname, "ohayo") : ""
    }
    toRunTimeStats() {
      const tiles = this.getTiles()
      const stats = {
        tiles: tiles.length,
        treeLanguage: this.getGrammarProgram().getExtensionName(),
        url: this.getTab().getFileName()
      }
      stats.timeToLoad = this.getTiles()
        .map(tile => tile.getTimeToLoad())
        .sort()
        .reverse()[0]
      stats.timeToRender = this.getTiles()
        .map(tile => tile.getNewestTimeToRender())
        .sort()
        .reverse()[0]
      return stats
    }
  }

  class maiaNode extends tilesNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        DidYouMeanTileNode,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          "tiles.didyoumean": DidYouMeanTileNode,
          "doc.title": docTitleNode,
          "doc.subtitle": docSubtitleNode,
          "doc.section": docSectionNode,
          "doc.ref": docReferenceNode,
          "doc.comment": docCommentNode,
          "doc.picker": PickerTileNode,
          "challenge.list": challengeListNode,
          "samples.list": samplesListNode,
          "vega.data.list": vegaDataListNode,
          "vega.example.list": vegaExampleListNode,
          "challenge.play": challengePlayNode,
          "dtjs.basic": dtjsBasicNode,
          "html.text": htmlTextNode,
          "html.printAs": htmlPrintAsNode,
          "html.h1": htmlH1Node,
          "html.img": htmlImgNode,
          "html.iframe": htmlIframeNode,
          "html.custom": htmlCustomNode,
          "show.rowCount": showRowCountNode,
          "show.columnCount": showColumnCountNode,
          "show.static": showStaticNode,
          "show.median": showMedianNode,
          "show.sum": showSumNode,
          "show.mean": showMeanNode,
          "show.min": showMinNode,
          "show.max": showMaxNode,
          "vega.bar": vegaBarNode,
          "vega.line": vegaLineNode,
          "vega.area": vegaAreaNode,
          "vega.scatter": vegaScatterNode,
          "vega.bubble": vegaBubbleNode,
          "vega.emoji": vegaEmojiNode,
          "vega.histogram": vegaHistogramNode,
          "vega.example": vegaExampleNode,
          "date.heatcal": dateHeatcalNode,
          "icons.human": iconsHumanNode,
          "icons.circle": iconsCircleNode,
          "markdown.toHtml": markdownToHtmlNode,
          "treenotation.outline": treenotationOutlineNode,
          "treenotation.dotline": treenotationDotlineNode,
          "amazon.history": amazonHistoryNode,
          "fitbit.all": fitbitAllNode,
          "datawrapper.comingSoon": datawrapperComingSoonNode,
          "dcjs.comingSoon": dcjsComingSoonNode,
          "finos.perspective.comingSoon": finosPerspectiveComingSoonNode,
          "fivethirtyeight.comingSoon": fivethirtyeightComingSoonNode,
          "highcharts.comingSoon": highchartsComingSoonNode,
          "re3data.comingSoon": re3dataComingSoonNode,
          "zing.comingSoon": zingComingSoonNode,
          "editor.helloWorld": editorHelloWorldNode,
          "debug.dump": debugDumpNode,
          "web.dump": webDumpNode,
          "debug.commands": debugCommandsNode,
          "debug.grammarTree": debugGrammarTreeNode,
          "debug.sleep": debugSleepNode,
          "debug.throw": debugThrowNode,
          "editor.gallery": editorGalleryNode,
          "handsontable.basic": handsontableBasicNode,
          "list.basic": listBasicNode,
          "list.links": listLinksNode,
          "tables.basic": tablesBasicNode,
          "tables.interesting": tablesInterestingNode,
          "tables.dump": tablesDumpNode,
          "text.wordcloud": textWordcloudNode,
          "treenotation.3d": treenotation3dNode,
          "disk.browse": diskBrowseNode,
          "disk.read": diskReadNode,
          "hackernews.top": hackernewsTopNode,
          "hackernews.submissions": hackernewsSubmissionsNode,
          "web.get": webGetNode,
          "web.post": webPostNode,
          "cancer.cases": cancerCasesNode,
          "kaggle.datasets.heart": kaggleDatasetsHeartNode,
          "samples.telescopes": samplesTelescopesNode,
          "samples.mtcars": samplesMtcarsNode,
          "samples.iris": samplesIrisNode,
          "samples.flights14": samplesFlights14Node,
          "samples.si": samplesSiNode,
          "samples.portals": samplesPortalNode,
          "samples.starWars": samplesStarWarsNode,
          "samples.populations": samplesPopulationsNode,
          "samples.babyNames": samplesBabyNamesNode,
          "samples.declaration": samplesDeclarationNode,
          "samples.periodicTable": samplesPeriodicTableNode,
          "samples.letters": samplesLettersNode,
          "samples.presidents": samplesPresidentsNode,
          "ucimlr.datasets": ucimlrDatasetsNode,
          "vega.data": vegaDataNode,
          "reddit.all": redditAllNode,
          "reddit.subs": redditSubsNode,
          "reddit.sub": redditSubNode,
          "samples.patients": samplesPatientsNode,
          "samples.poem": samplesPoemNode,
          "samples.outerSpace": samplesOuterSpaceNode,
          "samples.treeProgram": samplesTreeProgramNode,
          "samples.waterBill": samplesWaterBillNode,
          "samples.gapMinder": samplesGapMinderNode,
          "date.addColumns": dateAddColumnsNode,
          "math.log": mathLogNode,
          "rows.addIndexColumn": rowsAddIndexColumnNode,
          "rows.runningTotal": rowsRunningTotalNode,
          "text.length": textLengthNode,
          "text.split": textSplitNode,
          "text.toLowerCase": textToLowerCaseNode,
          "text.substring": textSubstringNode,
          "columns.describe": columnsDescribeNode,
          "columns.list": columnsListNode,
          "data.eval": dataEvalNode,
          "join.by": joinByNode,
          "match.columnsFuzzy": matchColumnsFuzzyNode,
          "text.wordCount": textWordCountNode,
          "text.lineCount": textLineCountNode,
          "treenotation.wordTypes": treenotationWordTypesNode,
          "columns.first": columnsFirstNode,
          "columns.last": columnsLastNode,
          "columns.drop": columnsDropNode,
          "columns.dropConstants": columnsDropConstantsNode,
          "columns.keep": columnsKeepNode,
          "rows.shuffle": rowsShuffleNode,
          "rows.reverse": rowsReverseNode,
          "filter.where": filterWhereNode,
          "rows.dropIfMissing": rowsDropIfMissingNode,
          "filter.with": filterWithNode,
          "filter.without": filterWithoutNode,
          "rows.first": rowsFirstNode,
          "rows.last": rowsLastNode,
          "columns.setType": columnsSetTypeNode,
          "group.by": groupByNode,
          "rows.sortBy": rowsSortByNode,
          "rows.sortByReverse": rowsSortByReverseNode,
          "rows.addOne": rowsAddOneNode,
          "data.inline": dataInlineNode,
          "data.localStorage": dataLocalStorageNode,
          "debug.parserTest": debugParserTestNode,
          "editor.files": editorFilesNode,
          "editor.commandHistory": editorCommandHistoryNode,
          "math.gen": mathGenNode,
          "random.float": randomFloatNode,
          "random.int": randomIntNode,
          "samples.tinyIris": samplesTinyIrisNode,
          "shell.csv": toCsvNode,
          "templates.list": templatesListNode,
          "doc.categories": docCategoriesNode,
          "doc.author": docAuthorNode,
          "doc.defaultHidden": docDefaultHiddenNode,
          "doc.date": docDateNode,
          "doc.zoom": docZoomNode,
          "doc.layout": docLayoutNode,
          "#!": hashBangNode
        }),
        [{ regex: /^$/, nodeConstructor: tileBlankLineNode }]
      )
    }
    get wallType() {
      return `flex`
    }
    _getProgramRowCount() {
      return this.getAllRowsFromAllOutputTables().reduce((acc, curr) => acc + curr.length, 0)
    }
    getOutputOrInputTable() {
      // todo: remove this?
      if (!this._outputTable) this._outputTable = new Table()
      return this._outputTable
    }
    getMaiaTiles() {
      return this.getTopDownArray().filter(node => node.doesExtend("abstractMaiaTileNode"))
    }
    getAllRowsFromAllOutputTables() {
      return jtree.Utils.flatten(
        this.getMaiaTiles()
          .map(tile => tile.getOutputTable())
          .filter(table => table)
          .map(table => table.getRows())
      )
    }
    getGrammarProgram() {
      if (!this._cachedGrammarProgramRoot)
        this._cachedGrammarProgramRoot = new jtree.GrammarProgram(`emptyCell
programmingLanguageNameCell
 enum javascript latex css html ruby rust python csv tsv xml php typescript lisp swift java c cpp markdown bash
 highlightScope constant
codeCell
 highlightScope string
documentCategoryCell
 highlightScope constant
 enum shopping chemistry programming socialMedia math parenting writing dataScience ohayo
zoomCell
 extends numberCell
referenceIdCell
 highlightScope string
docLayoutOptionCell
 enum custom bin tree column tiled
 highlightScope constant
commentCell
 highlightScope comment
commentKeywordCell
 highlightScope comment
errorCell
 highlightScope invalid
hashBangWordCell
 highlightScope comment
stringCell
 highlightScope string
urlCell
 highlightScope constant
dateCell
 highlightScope string
intCell
 regex \\-?[0-9]+
numberCell
 regex \\-?[0-9]*\\.?[0-9]*
tileKeywordCell
 highlightScope keyword
intCell
tileSettingKeywordCell
 highlightScope variable.language
quantityCell
 extends intCell
minCell
 extends numberCell
maxCell
 extends numberCell
millisecondsCell
 extends intCell
titleCell
 extends stringCell
anyCell
 todo remove
columnNameCell
 highlightScope entity.other.attribute-name
newColumnNameCell
 highlightScope entity.other.attribute-name
newColumnNamesCell
 description When you are creating new columns.
 highlightScope entity.other.attribute-name
primitiveTypeCell
 highlightScope constant.numeric
 description In Ohayo, all columns have a primitive type chosen from one of these. The type affects how the values in the column are understood and displayed. For example, a 0 could be interpretted as a "false", the number 0, or a string "0". Ohayo attempts to choose the correct type, but you can override the default with the columns.setType tile.
 enum boolean code date day dir feet hour hourMinute html int millisecond minute month monthDay number numberString object path second string text url usd week year
parserIdsCell
 description Ohayo has these parsers which convert your raw data to tables.
 enum csv tsv json treeRows tree ssv xml psv text spaced sections json list txt jsonMap jsonVector jsonCounts jsonDataTableWithHeader
 highlightScope constant
booleanCell
 enum false true
 highlightScope constant.numeric
pathCell
 highlightScope constant
 description A filepath
alphanumericCell
 regex [a-zA-Z0-9]+
extraWordCell
 todo Remove this? It looks like its a standard cell type.
 highlightScope invalid
reductionTypeCell
 enum count sum mean min max median
 highlightScope constant
supportedTreeLanguageCell
 enum maia stump hakon fire
challengeIdCell
 extends intCell
challengeAnswerCell
 extends numberCell
localStorageKeyCell
dateColumnTypeCell
 enum day month year monthDay
 highlightScope constant
dummyDataSetIdCell
 enum maiaPrograms waterBill gapMinder markdown webPages outerSpace wordCounts treeProgram poem playerGoals patients regionalMarkets stockPrice
tileEventNameCell
 enum fetchTableInputs getTileBodyStumpCode treeComponentDidMount treeComponentDidUpdate
scalarValueCell
 highlightScope constant.numeric
comparisonCell
 enum < > <= >= = !=
 highlightScope constant
hackerNewsUserNameCell
 highlightScope string
htmlTextTagCell
 enum div pre p h1 h2 h3 h4 h5 h6
htmlCell
 highlightScope string
needleColumnNameCell
 extends columnNameCell
haystackColumnNameCell
 extends columnNameCell
mathFunctionNameCell
 enum sin cos tan log exp
fromCell
 extends numberCell
toCell
 extends numberCell
incrementCell
 extends numberCell
subredditNameCell
delimiterCell
startIndexCell
 extends intCell
lengthCell
 extends intCell
cameraDistanceNumberCell
 extends numberCell
horizontalNumberCell
 extends numberCell
verticalNumberCell
 extends numberCell
vegaDataSetCell
 highlightScope constant.numeric
 enum 7zip.png airports.csv anscombe.json barley.json birdstrikes.json budget.json budgets.json burtin.json cars.json climate.json co2-concentration.csv countries.json crimea.json descriptions.json disasters.csv driving.json earthquakes.json ffox.png flare-dependencies.json flare.json flights-10k.json flights-200k.json flights-20k.json flights-2k.json flights-3m.csv flights-5k.json flights-airport.csv gapminder-health-income.csv gapminder.json gimp.png github.csv graticule.json income.json iowa-electricity.csv iris.json jobs.json la-riots.csv londonBoroughs.json londonCentroids.json londonTubeLines.json lookup_groups.csv lookup_people.csv miserables.json monarchs.json movies.json normal-2d.json obesity.json points.json population.json population_engineers_hurricanes.csv seattle-temps.csv seattle-weather.csv sf-temps.csv sp500.csv stocks.csv udistrict.json unemployment-across-industries.json unemployment.tsv us-10m.json us-employment.csv us-state-capitals.json weather.csv weather.json weball26.json wheat.json windvectors.csv world-110m.json zipcodes.csv
vegaExampleNameCell
 highlightScope constant.numeric
 enum airport_connections area area_cumulative_freq area_horizon area_overlay area_temperature_range area_vertical bar bar_1d bar_1d_rangestep_config bar_aggregate bar_aggregate_count bar_aggregate_format bar_aggregate_size bar_aggregate_sort_by_encoding bar_aggregate_sort_mean bar_aggregate_transform bar_aggregate_vertical bar_argmax bar_argmax_transform bar_array_aggregate bar_binned_data bar_color_disabled_scale bar_column_fold bar_custom_sort_full bar_custom_sort_partial bar_distinct bar_diverging_stack_transform bar_filter_calc bar_fit bar_gantt bar_grouped bar_grouped_horizontal bar_layered_transparent bar_layered_weather bar_month bar_month_temporal bar_size_default bar_size_explicit bar_size_explicit_bad bar_size_fit bar_size_rangestep_small bar_sort_by_count bar_swap_axes bar_swap_custom bar_title bar_title_start bar_tooltip bar_tooltip_multi bar_yearmonth bar_yearmonth_custom_format boxplot_1D_horizontal boxplot_1D_horizontal_custom_mark boxplot_1D_horizontal_explicit boxplot_1D_vertical boxplot_2D_horizontal boxplot_2D_horizontal_color_size boxplot_2D_vertical boxplot_minmax_2D_horizontal boxplot_minmax_2D_horizontal_custom_midtick_color boxplot_minmax_2D_vertical boxplot_tooltip_aggregate boxplot_tooltip_not_aggregate brush_table circle circle_binned circle_binned_maxbins_2 circle_binned_maxbins_20 circle_binned_maxbins_5 circle_bubble_health_income circle_flatten circle_github_punchcard circle_natural_disasters circle_opacity circle_scale_quantile circle_scale_quantize circle_scale_threshold concat_bar_layer_circle concat_bar_scales_discretize concat_bar_scales_discretize_2_cols concat_hover concat_hover_filter concat_layer_voyager_result_future concat_marginal_histograms concat_population_pyramid concat_weather connected_scatterplot embedded_csv errorband_2d_horizontal_color_encoding errorband_2d_vertical_borders errorbar_2d_vertical_ticks errorbar_aggregate errorbar_horizontal_aggregate facet_bullet facet_column_facet_column_point_future facet_column_facet_row_point_future facet_cross_independent_scale facet_custom facet_custom_header facet_independent_scale facet_independent_scale_layer_broken facet_row_facet_row_point_future geo_choropleth geo_circle geo_constant_value geo_custom_projection geo_graticule geo_graticule_object geo_layer geo_layer_line_london geo_layer_multi geo_line geo_point geo_repeat geo_rule geo_sphere geo_text geo_trellis hconcat_weather histogram histogram_bin_change histogram_bin_transform histogram_log histogram_no_spacing histogram_ordinal histogram_ordinal_sort interactive_area_brush interactive_bar_select_highlight interactive_brush interactive_concat_layer interactive_dashboard_europe_pop interactive_layered_crossfilter interactive_layered_crossfilter_discrete interactive_multi_line_label interactive_multi_line_tooltip interactive_overview_detail interactive_paintbrush interactive_paintbrush_color interactive_paintbrush_color_nearest interactive_paintbrush_interval interactive_paintbrush_simple_all interactive_paintbrush_simple_none interactive_panzoom_splom interactive_panzoom_vconcat_shared interactive_query_widgets interactive_seattle_weather interactive_splom interactive_stocks_nearest_index isotype_bar_chart isotype_bar_chart_emoji isotype_grid joinaggregate_mean_difference joinaggregate_mean_difference_by_year joinaggregate_percent_of_total joinaggregate_residual_graph layer_bar_annotations layer_bar_labels layer_bar_labels_style layer_bar_line layer_bar_line_union layer_bar_month layer_boxplot_circle layer_candlestick layer_circle_independent_color layer_color_legend_left layer_cumulative_histogram layer_dual_axis layer_falkensee layer_histogram layer_histogram_global_mean layer_line_co2_concentration layer_line_color_rule layer_line_errorband_2d_horizontal_borders_strokedash layer_line_errorband_ci layer_line_errorband_pre_aggregated layer_line_mean_point_raw layer_overlay layer_point_errorbar_1d_horizontal layer_point_errorbar_1d_vertical layer_point_errorbar_2d_horizontal layer_point_errorbar_2d_horizontal_ci layer_point_errorbar_2d_horizontal_color_encoding layer_point_errorbar_2d_horizontal_custom_ticks layer_point_errorbar_2d_horizontal_iqr layer_point_errorbar_2d_horizontal_stdev layer_point_errorbar_2d_vertical layer_point_errorbar_ci layer_point_errorbar_pre_aggregated_asymmetric_error layer_point_errorbar_pre_aggregated_symmetric_error layer_point_errorbar_pre_aggregated_upper_lower layer_point_errorbar_stdev layer_precipitation_mean layer_ranged_dot layer_rect_extent layer_scatter_errorband_1D_stdev_global_mean layer_scatter_errorband_1d_stdev layer_single_color layer_text_heatmap line line_calculate line_color line_color_binned line_detail line_encoding_impute_keyvals line_encoding_impute_keyvals_sequence line_impute_frame line_impute_keyvals line_impute_method line_impute_transform_frame line_impute_transform_value line_impute_value line_inside_domain_using_clip line_inside_domain_using_transform line_max_year line_mean_month line_mean_year line_monotone line_month line_outside_domain line_overlay line_overlay_stroked line_quarter_legend line_shape_overlay line_skip_invalid line_skip_invalid_mid line_skip_invalid_mid_cap_square line_skip_invalid_mid_overlay line_slope line_step line_timeunit_transform lookup parallel_coordinate point_1d point_1d_array point_2d point_2d_aggregate point_2d_array point_2d_array_named point_2d_tooltip_data point_aggregate_detail point_background point_binned_color point_binned_opacity point_binned_size point_bubble point_color point_color_custom point_color_ordinal point_color_quantitative point_color_shape_constant point_color_with_shape point_colorramp_size point_diverging_color point_dot_timeunit_color point_filled point_href point_invalid_color point_log point_no_axis_domain_grid point_ordinal_color point_overlap point_shape_custom point_tooltip rect_binned_heatmap rect_heatmap rect_heatmap_weather rect_lasagna_future rect_mosaic_labelled rect_mosaic_labelled_with_offset rect_mosaic_simple repeat_histogram repeat_histogram_flights repeat_independent_colors repeat_layer repeat_line_weather repeat_splom_cars repeat_splom_iris rule_color_mean rule_extent sample_scatterplot selection_bind_cylyr selection_bind_origin selection_brush_timeunit selection_clear_brush selection_composition_and selection_composition_or selection_concat selection_filter selection_filter_composition selection_heatmap selection_insert selection_interval_mark_style selection_layer_bar_month selection_multi_condition selection_project_binned_interval selection_project_interval selection_project_interval_x selection_project_interval_x_y selection_project_interval_y selection_project_multi selection_project_multi_cylinders selection_project_multi_cylinders_origin selection_project_multi_origin selection_project_single selection_project_single_cylinders selection_project_single_cylinders_origin selection_project_single_origin selection_resolution_global selection_resolution_intersect selection_resolution_union selection_toggle_altKey selection_toggle_altKey_shiftKey selection_toggle_shiftKey selection_translate_brush_drag selection_translate_brush_shift-drag selection_translate_scatterplot_drag selection_translate_scatterplot_shift-drag selection_type_interval selection_type_interval_invert selection_type_multi selection_type_single selection_type_single_dblclick selection_type_single_mouseover selection_zoom_brush_shift-wheel selection_zoom_brush_wheel selection_zoom_scatterplot_shift-wheel selection_zoom_scatterplot_wheel sequence_line square stacked_area stacked_area_normalize stacked_area_ordinal stacked_area_overlay stacked_area_stream stacked_bar_1d stacked_bar_count stacked_bar_h stacked_bar_h_order stacked_bar_h_order_custom stacked_bar_normalize stacked_bar_population stacked_bar_population_transform stacked_bar_size stacked_bar_sum_opacity stacked_bar_unaggregate stacked_bar_v stacked_bar_weather test_aggregate_nested test_field_with_spaces test_single_point_color test_subobject test_subobject_missing test_subobject_nested text_format text_scatterplot_colored tick_dot tick_dot_thickness tick_sort tick_strip time_output_utc_scale time_output_utc_timeunit time_parse_local time_parse_utc time_parse_utc_format trail_color trellis_anscombe trellis_area trellis_area_sort_array trellis_bar trellis_bar_histogram trellis_bar_histogram_label_rotated trellis_barley trellis_barley_independent trellis_barley_layer_median trellis_column_year trellis_cross_sort trellis_cross_sort_array trellis_line_quarter trellis_row_column trellis_scatter trellis_scatter_binned_row trellis_scatter_small trellis_selections trellis_stacked_bar vconcat_flatten vconcat_weather waterfall_chart wheat_wages window_cumulative_running_average window_percent_of_total window_rank window_top_k window_top_k_others
abstractTileTreeComponentNode
 abstract
 cells tileKeywordCell
 _extendsJsClass AbstractTreeComponent
 inScope tileBlankLineNode abstractCoreTileSettingTerminalNode
 catchAllNodeType catchAllErrorNode
 int headerHeight 30
 int footerHeight 30
 string hiddenKey hidden
 string visibleKey visible
 string pencilStumpTemplate
  span {icon}
   class TilePencilButton
   clickCommand toggleToolbarCommand
 string inspectionStumpTemplate
  div TileConstructor: {constructorName} ParentConstructor: {parentConstructorName}
  div Messages:
  ol
   {messages}
  div Tree:
  pre
   bern
    {sourceCode}
  div All Tile Settings:
  pre
   bern
    {settings}
 string errorStateStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div ERROR
    class TileHeader
   div
    class TileBody
    {content}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div {header}
    class TileHeader
   div
    style {bodyStyle}
    class TileBody
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  getProgramTemplate(id) {}
  getSnippetTemplate(id) {}
  getExampleTemplate(index) {
   // todo: right now we only have 1 example per tile.
   const exampleNode = this.getDefinition().getNode(jtree.GrammarConstants.example)
   return exampleNode ? exampleNode.childrenToString() : ""
  }
  emitLogMessage(message) {
   const tab = this.getTab()
   if (tab) tab.addStumpCodeMessageToLog(message)
   else if (this.isNodeJs()) console.log(message)
  }
  getTheme() {
   return this.getTab().getTheme()
  }
  qFormat(str, obj) {
   return new jtree.TreeNode(str).templateToString(obj)
  }
  scrollIntoView() {
   const el = this.getStumpNode()
    .getShadow()
    .getShadowElement()
   if (el) el.scrollIntoView()
  }
  async loadRequirements() {
   const loadingMap = this.getTab()
    .getRootNode()
    .getDefinitionLoadingPromiseMap()
   if (!loadingMap.has(this.constructor)) loadingMap.set(this.constructor, this._makeLoadRequirementsPromise(loadingMap))
   await loadingMap.get(this.constructor)
  }
  async _makeLoadRequirementsPromise(loadingMap) {
   const app = this.getWebApp()
   const cssScript = this[TilesConstants.tileCssScript]
   if (cssScript) this._loadTileCss(cssScript)
   const scriptPath = this[TilesConstants.tileScript]
   if (scriptPath) await app.getWillowBrowser().appendScript(scriptPath)
   loadingMap.set(this.constructor, true)
  }
  _loadTileCss(css) {
   const app = this.getWebApp()
   app
    .getWillowBrowser()
    .getBodyStumpNode()
    .insertChildNode(
     css
      .split(" ")
      .map(
       url => \`link
   rel stylesheet
   media screen
   href \${url}\`
      )
      .join("\\n")
    )
  }
  _hasRequirements() {
   return this.tileScript
  }
  _areRequirementsLoaded() {
   const loadingMap = this.getTab()
    .getRootNode()
    .getDefinitionLoadingPromiseMap()
   return !this._hasRequirements() || loadingMap.get(this.constructor) === true
  }
  isLoaded() {
   return this._areRequirementsLoaded()
  }
  getErrorMessageHtml() {
   const errors = Object.values(this.getRunTimePhaseErrors())
   return errors.length ? \` <span style="color: \${this.getTheme().errorColor};">\${errors.join(" ")}</span>\` : "" //todo: cleanup
  }
  toStumpErrorStateCode(err) {
   return this.qFormat(this.errorStateStumpTemplate, { classes: this.getCssClassNames().join(" "), id: this.getTreeComponentId(), content: \`div \` + err, footer: this.getTileToolbarButtonStumpCode() })
  }
  // todo: delete this
  makeDirty() {
   delete this._cache_settingsObject
   delete this._bodyStumpCodeCache // todo: cleanup
   this._setLastRenderedTime(0)
  }
  toggleToolbar() {
   if (!this._tileToolbar) {
    const TileToolbarTreeComponent = this.require("TileToolbarTreeComponent", this._getProjectRootDir() + "ohayoWebApp/treeComponents/TileToolbarTreeComponent.js")
    this._tileToolbar = new TileToolbarTreeComponent("", undefined, this)
    this._tileToolbar.renderAndGetRenderReport(this.getStumpNode())
   } else this._tileToolbar = this._tileToolbar.unmount()
  }
  getAllTileSettingsDefinitions() {
   const def = this.getDefinition()
   return Object.values(def.getFirstWordMapWithDefinitions()).filter(def => def.isOrExtendsANodeTypeInScope([TilesConstants.abstractTileSetting]))
  }
  getTab() {
   return this.getRootNode().getTab()
  }
  getChildTiles() {
   return this.getChildInstancesOfNodeTypeId("abstractTileTreeComponentNode")
  }
  selectTile() {
   this.selectNode()
   if (this.isMounted()) this.getStumpNode().addClassToStumpNode(TilesConstants.selectedClass)
  }
  unselectNode() {
   super.unselectNode()
   if (this.isMounted()) this.getStumpNode().removeClassFromStumpNode(TilesConstants.selectedClass)
  }
  getCssClassNames() {
   const classNames = super.getCssClassNames()
   if (this._isMaximized()) classNames.push("TileMaximized")
   return classNames
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, {
    classes: this.getCssClassNames().join(" "),
    id: this.getTreeComponentId(),
    header: this.getTileHeaderBern(),
    bodyStyle: this.customBodyStyle || "",
    body: this._getBodyStumpCodeCache() || "",
    footer: this.getTileFooterStumpCode()
   })
  }
  _getBodyStumpCodeCache() {
   if (!this._bodyStumpCodeCache) this._bodyStumpCodeCache = this.getTileBodyStumpCode()
   return this._bodyStumpCodeCache
  }
  getTileHeaderBern() {
   return \`\${this.getFirstWord()}\`
  }
  cloneAndOffset() {
   const clone = this.duplicate()
   const left = this.getLeft()
   const _top = this.getTop()
   if (left) clone.touchNode(TilesConstants.left).setContent(parseInt(left) + 1)
   if (_top) clone.touchNode(TilesConstants.top).setContent(parseInt(_top) + 1)
   return clone
  }
  getTileBodyStumpCode() {
   return \`\`
  }
  _getCss() {
   const selector = "#" + this.getTreeComponentId()
   const theme = this.getTheme()
   const visibleCss = this.isVisible() ? "" : "display: none"
   const dimensions = this.getTileDimensionIfAny()
   const dimensionCss = dimensions ? dimensions.toCss() : ""
   const hakonCode = this.hakonTemplate ? new jtree.TreeNode(theme).evalTemplateString(this.hakonTemplate) : this.toHakonCode()
   return \`\${selector} { \${visibleCss} \${dimensionCss} }
        \${theme.hakonToCss(hakonCode)}\`
  }
  getContextMenuStumpCode() {
   return ""
  }
  handleTileError(err) {
   if (!this._errorCount) this._errorCount = 0
   this._errorCount++
   this.getRootNode().goRed(err)
  }
  getWall() {
   return this.getWebApp().getAppWall()
  }
  getWebApp() {
   return this.getTab().getRootNode()
  }
  getTileDimensionIfAny() {
   const dimensions = this.getWall().getWallViewPortDimensions()
   return this.getRootNode()
    .getTileDimensionMap(dimensions.width, dimensions.height)
    .get(this)
  }
  getTileBodyDimension() {
   const dimension = this.getTileDimensionIfAny()
   dimension.height = dimension.height - this.headerHeight - this.footerHeight
   return dimension
  }
  getDependencies() {
   return []
  }
  async runAndrenderAndGetRenderReport() {
   await this.execute()
   return this.renderAndGetRenderReport()
  }
  getTimeToLoad() {
   return this._timeToLoad || 0
  }
  toHakonCode() {
   return ""
  }
  getTileFooterStumpCode() {
   return this.getTileToolbarButtonStumpCode()
  }
  getTileToolbarButtonStumpCode() {
   return this.qFormat(this.pencilStumpTemplate, { icon: Icons("pencil", 16) })
  }
  getDefinedOrSuggestedSize() {
   const size = this.getSuggestedSize()
   const width = this.getWidth()
   const height = this.getHeight()
   return {
    width: width ? width * 20 : size.width,
    height: height ? height * 20 : size.height
   }
  }
  getSuggestedSize() {
   const tileSize = this.tileSize || "280 220"
   const parts = tileSize.split(" ").map(tileSize => parseInt(tileSize))
   return {
    width: parts[0],
    height: parts[1]
   }
  }
  getRequiredDimensionsForTreeLayout(padding = 0) {
   const size = {
    width: 0,
    height: 0
   }
   const children = this.getChildTiles()
   const suggestedSize = this.getDefinedOrSuggestedSize()
   children.forEach(child => {
    const childSize = child.getRequiredDimensionsForTreeLayout(padding)
    size.width += childSize.width
    size.height = childSize.height > size.height ? childSize.height : size.height
   })
   size.width += children.length * padding
   size.width = Math.max(size.width, suggestedSize.width)
   size.height = suggestedSize.height + (children.length ? padding + size.height : 0)
   return size
  }
  getLeft() {
   return this.get(TilesConstants.left)
  }
  getTop() {
   return this.get(TilesConstants.top)
  }
  getWidth() {
   return this.get(TilesConstants.width)
  }
  getHeight() {
   return this.get(TilesConstants.height)
  }
  // Tile child rendering is done at the wall flex level.
  _getChildTreeComponents() {
   return []
  }
  getStumpNodeForChildren() {
   // We render all Tiles on the Wall.
   return this.getStumpNode().getParent()
  }
  async treeComponentDidMount() {
   super.treeComponentDidMount()
   if (this._tileToolbar) this._tileToolbar.renderAndGetRenderReport()
  }
  toInspectionStumpCode() {
   const messages = this.getMessageBuffer().map(message => \`li \${moment(message.getLineModifiedTime()).fromNow()} - \${message.childrenToString()}\`)
   const settingsDefinitions = this.getAllTileSettingsDefinitions()
    .map(setting => \`\${setting.getFirstWord()} \${setting.getDescription()}\`)
    .join("\\n")
   const parentConstructorName = this.getParent().constructor.name
   const constructorName = this.constructor.name
   const sourceCode = this.toString()
   const settings = settingsDefinitions
   return this.qFormat(this.inspectionStumpTemplate, {
    constructorName,
    parentConstructorName,
    sourceCode,
    messages,
    settings
   })
  }
  isVisible() {
   if (this.visible === false) return false
   return this.has(this.visibleKey) || (this.getRootNode().tilesAreVisible() && !this.has(this.hiddenKey))
  }
  _isMaximized() {
   return this.has(TilesConstants.maximized)
  }
  async _executeChildNodes() {
   await this._runChildTiles()
  }
  async _runChildTiles() {
   await Promise.all(this.getChildTiles().map(tile => tile.execute()))
  }
  async execute() {
   try {
    this.setRunTimePhaseError("execute")
    await this._executeChildNodes()
   } catch (err) {
    this.setRunTimePhaseError("execute", err)
    console.error(err)
    const theme = this.getTheme()
    this.emitLogMessage(\`div
     bern
      Error occurred. See console.
     style color: \${theme.errorColor};\`)
   }
   return this
  }
  cloneTileCommand() {
   this.cloneAndOffset()
   return this.getTab().autosaveAndRender()
  }
  async toggleTileMaximizeCommand() {
   if (this.has(TilesConstants.maximized)) this.delete(TilesConstants.maximized)
   else this.touchNode(TilesConstants.maximized)
   await this._runAfterTileUpdate(this)
  }
  async triggerTileMethodCommand(value, methodName) {
   await this[methodName](value)
   await this._runAfterTileUpdate(tile)
  }
  // todo: refactor.
  async changeTileTypeCommand(newValue) {
   this.setFirstWord(newValue)
   const newNode = this.duplicate()
   // todo: destroy or something? how do we reparse.
   this.unmountAndDestroy()
   const app = this.getTab().getRootNode()
   await this.getRootNode().loadRequirements()
   await this.getTab().autosaveAndRender()
   newNode.runAndrenderAndGetRenderReport()
  }
  changeParentCommand(pathVector) {
   // if (tile.getFirstWordPath() === value) return; // todo: do we need this line?
   const program = this.getRootNode()
   const indexPath = pathVector ? pathVector.split(" ").map(num => parseInt(num)) : ""
   const destinationTree = indexPath ? program.nodeAt(indexPath) : program
   // todo: on jtree should we make copyTo second param optional?
   this.copyTo(destinationTree, destinationTree.length)
   this.unmountAndDestroy()
   return this.getTab().autosaveAndRender()
  }
  async openTileContextMenuCommand() {
   this.getTab()
    .getRootNode()
    .setTargetNode(this)
    .toggleAndRender(OhayoConstants.tileContextMenu)
  }
  destroyTileCommand() {
   this.unmountAndDestroy()
   return this.getTab().autosaveAndRender()
  }
  getNewDataCommand() {
   // todo: have some type of paging system to fetch new data.
  }
  async changeTileSettingAndRenderCommand(value, settingName) {
   // note the unusual ordering of params.
   this.touchNode(settingName).setContent(value.toString())
   // todo: sometimes size needs to be redone (maximize, for example)
   await this._runAfterTileUpdate(this)
  }
  // todo: remove
  async changeTileSettingMultilineCommand(val, settingName) {
   this.touchNode(settingName).setChildren(val)
   await this._runAfterTileUpdate(this)
  }
  async changeTileSettingCommand(settingName, value) {
   this.touchNode(settingName).setContent(value)
  }
  async changeWordAndRenderCommand(value, index) {
   this.setWord(parseInt(index), value)
   await this._runAfterTileUpdate(this)
  }
  async changeWordsAndRenderCommand(value, index) {
   index = parseInt(index)
   const edgeSymbol = this.getEdgeSymbol()
   const words = this.getWords().slice(0, index)
   this.setLine(words.concat(value.split(edgeSymbol)).join(edgeSymbol))
   await this._runAfterTileUpdate(this)
  }
  async updateChildrenCommand(val) {
   this.setChildren(val)
   // reload the whole doc for now.
   await this._runAfterTileUpdate(this)
  }
  async _runAfterTileUpdate(tile) {
   tile.makeDirty() // ugly!
   tile.getChildTiles().forEach(tile => {
    tile.makeDirty() // todo: ugly!
   })
   // todo: what if you have a tile that has a contextare that allows editing of its children/
   // if you edit a child, then that parent tile needs to update to...should we allow that or ban that?
   await tile.getTab().autosaveTab()
   await tile.runAndrenderAndGetRenderReport()
   tile
    .getTab()
    .getRootNode()
    .renderApp() // Need to render full app because of code editor
  }
  // todo: downstream data changes?
  async changeTileContentAndRenderCommand(value) {
   this.setContent(value)
   await this._runAfterTileUpdate(this)
  }
  async copyTileCommand() {
   // todo: remove cousin tiles?
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(this.getFirstAncestor().toString())
  }
  async createProgramFromTileExampleCommand(index) {
   const template = this.getExampleTemplate(index)
   if (!template) return undefined
   const fileExtension = "maia" // todo: generalize
   const tab = await this.getTab()
    .getRootNode()
    ._createAndOpen(template, \`help-for-\${this.getFirstWord()}.\${fileExtension}\`)
   tab.addStumpCodeMessageToLog(\`div Created '\${tab.getFullTabFilePath()}'\`)
  }
  async inspectTileCommand() {
   if (!this.isNodeJs()) {
    console.log("Tile available at window.tile")
    window.tile = this
    console.log(this)
   }
   this.getTab().addStumpCodeMessageToLog(this.toInspectionStumpCode())
   this.getTab()
    .getRootNode()
    .renderApp()
  }
  async toggleToolbarCommand() {
   this.toggleToolbar()
  }
  async createProgramFromTemplateCommand(id) {
   const programTemplate = this.getProgramTemplate(id)
   if (!programTemplate) return undefined
   const tab = await this.getTab()
    .getRootNode()
    ._createAndOpen(programTemplate.template, programTemplate.name)
   tab.addStumpCodeMessageToLog(\`div Created '\${tab.getFullTabFilePath()}'\`)
  }
  async appendSnippetTemplateCommand(id) {
   const snippet = this.getSnippetTemplate(id)
   if (!snippet) return undefined
   const tab = this.getTab()
   const tabProgram = tab.getTabProgram()
   const newNodes = tabProgram.concat(snippet)
   const newTiles = newNodes.filter(tile => tile.doesExtend && tile.doesExtend("abstractTileTreeComponentNode"))
   tab.autosaveTab()
   tabProgram.clearSelection()
   tab.getTabWall().unmount()
   await tabProgram.loadAndIncrementalRender()
   newTiles.forEach(tile => tile.selectTile())
   newTiles[0].scrollIntoView()
  }
  async copyDataCommand(delimiter) {
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(this.getOutputOrInputTable().toDelimited(delimiter))
  }
  async copyDataAsJavascriptCommand() {
   const table = this.getOutputOrInputTable()
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(JSON.stringify(table.toTree().toDataTable(table.getColumnNames()), null, 2))
  }
  async copyDataAsTreeCommand() {
   const text = this.getOutputOrInputTable()
    .toTree()
    .toString()
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(text)
  }
  async exportTileDataCommand(format = "csv") {
   // todo: figure this out. use the browsers filename? tile title? id?
   let extension = "csv"
   let type = "text/csv"
   let str = this.getOutputOrInputTable().toDelimited(",")
   if (format === "tree") {
    extension = "tree"
    type = "text"
    str = this.getOutputOrInputTable()
     .toTree()
     .toString()
   }
   this.getRootNode()
    .getWillowBrowser()
    .downloadFile(str, this.getTab().getFileName() + "." + extension, type)
  }
basicRecursiveTileNode
 extends abstractTileTreeComponentNode
 string hakonTemplate
  .BasicRecursiveTile
   input
   textarea
    border 0
    font-size 14px
    height 100%
    width 100%
 javascript
  getTileBodyStumpCode() {
   const edgeSymbol = " "
   const definition = this.getDefinition()
   const requiredCellIds = definition.getRequiredCellTypeIds()
   const catchAllIndex = requiredCellIds.length
   const catchAllCellTypeId = definition.getCatchAllCellTypeId()
   if (catchAllCellTypeId) requiredCellIds.push(catchAllCellTypeId)
   const cellInputs = requiredCellIds.map((cellTypeId, index) => {
    const isCatchAll = cellTypeId === catchAllCellTypeId && index === catchAllIndex
    const value = isCatchAll ? this.getWordsFrom(index + 1).join(edgeSymbol) : this.getWord(index + 1)
    return \` input
    placeholder \${cellTypeId}
    value \${value}
    name \${index + 1}
    changeCommand \${isCatchAll ? "changeWordsAndRenderCommand" : "changeWordAndRenderCommand"}\`
   })
   return \`div \${definition.getDescription()}
  div
  \${cellInputs.join("\\n")}\`
  }
DidYouMeanTileNode
 tags noPicker
 description Provides suggestions for misspelled tiles.
 extends abstractTileTreeComponentNode
 crux tiles.didyoumean
 string bodyStumpTemplate
  div
   span No tile '{input}' found. Line {lineNo}. Did you mean
   a {closestTile}
    collapse
    tabindex -1
    value {closestTile}
    clickCommand changeTileTypeCommand
   span ?
 javascript
  getTileBodyStumpCode() {
   const input = this.getFirstWord()
   const lineNo = this.getLineNumber()
   const closestTile = jtree.Utils.didYouMean(
    input,
    this.getRootNode()
     .getGrammarProgram()
     .getTopNodeTypeDefinitions()
     .map(def => def.get("crux"))
   )
   if (!closestTile) {
    if (!input) return \`div Your program has a blank line on line \${lineNo}.\`
    return \`div No tile '\${input}' found.\`
   }
   return this.qFormat(this.bodyStumpTemplate, { input, lineNo, closestTile })
  }
  getErrors() {
   return [new jtree.UnknownNodeTypeError(this)]
  }
  getTileHeaderBern() {
   return ""
  }
abstractDocTileNode
 int footerHeight 0
 int headerHeight 0
 cells tileKeywordCell
 extends abstractTileTreeComponentNode
 abstract
 string bodyStumpTemplate
  {tagName}
   bern
    {content}
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div
    class TileBody HeaderLess
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  _getBody() {
   return this.qFormat(this.bodyStumpTemplate, { content: this.getContent() || "", tagName: this.tagName })
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, { classes: this.getCssClassNames().join(" "), footer: this.getTileToolbarButtonStumpCode(), id: this.getTreeComponentId(), body: this._getBody() })
  }
docTitleNode
 catchAllCellType stringCell
 description A title
 example A doc
  doc.title A Tale of Two Cities
 string tileSize 600 75
 extends abstractDocTileNode
 cells tileKeywordCell
 crux doc.title
 string tagName h1
docSubtitleNode
 extends docTitleNode
 description A subheader
 string tagName h2
 crux doc.subtitle
docSectionNode
 description A section containing subtitles, paragraphs, code blocks, etc.
 crux doc.section
 extends abstractDocTileNode
 inScope abstractDocSectionComponentNode
 javascript
  _getBody() {
   return this.compile()
  }
  _getCompiledLine() {
   return ""
  }
 example
  doc.section
   subtitle Subtitle
   paragraph Paragraph
   code python
    # some code
docReferenceNode
 crux doc.ref
 cells tileKeywordCell referenceIdCell
 inScope docReferenceUrlNode
 string tagName p
 doc.ref someRefId
  url https://en.wikipedia.org/wiki/Note_(typography)
 description A reference to an external source
 extends abstractDocTileNode
docCommentNode
 description A comment node
 cells commentKeywordCell
 extends abstractTileTreeComponentNode
 boolean visible false
 frequency 0
 example An example program with comments
  doc.comment get iris data
  samples.iris
   doc.comment filter is
   filter.where Species = virginica
    doc.comment display results
    tables.basic
 catchAllCellType commentCell
 catchAllNodeType commentLineNode
 crux doc.comment
abstractPickerTileNode
 extends abstractTileTreeComponentNode
 string tileSize 480 420
 abstract
 string hakonTemplate
  .PickerTileNode
   .PickerCategory
    width 100%
    margin-top 20px
    text-align center
   .TileBody
    display flex
    flex-flow row wrap
    a
     &:hover
      background-color {borderColor}
     padding 10px
     margin 5px
     height 30px
     background-color {backgroundColor}
     border 1px solid {borderColor}
     overflow hidden
     text-align center
     text-overflow ellipsis
     font-size 14px
     width 120px
     span
      font-size 70%
 string itemStumpTemplate
  {categoryBreak}
  a {name}
   br
    span {description}
   title {description}
   tabindex -1
   value {value}
   clickCommand {command}
 string categoryBreakStumpTemplate
  div {category}
   class PickerCategory
 string tileHeader Gallery
 javascript
  async fetchTableInputs() {
   return { rows: this.getChoices().map(obj => obj.toObject()) }
  }
  getTileBodyStumpCode() {
   let lastCat = ""
   return this.getChoices()
    .map(choice => {
     choice.categoryBreak = lastCat !== choice.category ? this.qFormat(this.categoryBreakStumpTemplate, { category: choice.category }) : ""
     lastCat = choice.category
     return this.qFormat(this.itemStumpTemplate, choice)
    })
    .join("\\n")
  }
  getTileHeaderBern() {
   return this.tileHeader
  }
PickerTileNode
 extends abstractPickerTileNode
 description Displays list of available tiles.
 crux doc.picker
 string tileHeader Tile Gallery
 javascript
  getChoices() {
   const allChoices = this.getRootNode()
    .getGrammarProgram()
    .getTopNodeTypeDefinitions()
   const filteredChoices = allChoices.filter(nodeDef => !(nodeDef.get(jtree.GrammarConstants.tags) || "").includes(TilesConstants.noPicker))
   const theChoices = filteredChoices.length ? filteredChoices : allChoices
   return theChoices.map(nodeDefinition => {
    const nodeId = nodeDefinition.get("crux") || nodeDefinition.getNodeTypeIdFromDefinition()
    const name = nodeId.split(".")[1] || ""
    const category = lodash.upperFirst(nodeId.split(".")[0])
    const description = nodeDefinition.getDescription()
    return { name, category, description, value: nodeId, command: "changeTileTypeCommand" }
   })
  }
abstractMaiaTileNode
 abstract
 extends abstractTileTreeComponentNode
 inScope abstractTileTreeComponentNode abstractCoreTileSettingTerminalNode
 cells tileKeywordCell
 string settingKey setting
 string rowDisplayLimitKey rowDisplayLimit
 string contentKey content
 string xColumnKey xColumn
 string yColumnKey yColumn
 string colorColumnKey colorColumn
 string shapeColumnKey shapeColumn
 string sizeColumnKey sizeColumn
 string columnPredictionHintsKey columnPredictionHints
 string maiaFileExtensionKey .maia
 string dayKey day
 string monthKey month
 string yearKey year
 string maiaStumpInspectionTemplate
  div TileStruct:
   pre
    bern
     {settings}
  div Input rows: {inputCount} Output rows: {outputCount}
  div Load time: {timeToLoad} Render time: {renderTime}
  div Input Columns:
  pre
   bern
    {inputColumnsAsTable}
  div Output Columns
  pre
   bern
    {outputColumnsAsTable}
  div Output Numeric Values:
  pre
   bern
    {outputNumericValues}
  div TypeScript Interface:
  pre
   bern
    {typeScriptInterface}
  div Input Numeric Values:
  pre
   bern
    {inputNumericValues}
 javascript
  // todo: ADD TYPINGS
  getPipishInput() {
   // todo: add placeholder property?
   return this.getSettingsStruct().content || this.getParentOrDummyTable().getFirstColumnAsString() || ""
  }
  getDependencies() {
   return [{ getLineModifiedTime: () => this.getParentOrDummyTable().getTableCTime() }] // todo: we removed this: this.getOutputOrInputTable().getTableCTime()...i think we had it because we want to return true to update children.
  }
  getRunTimeEnumOptions(cell) {
   // todo: only works if codemirror === tab
   try {
    if (cell.getCellTypeId() === "columnNameCell") {
     const mirrorNode = typeof app === "undefined" ? this : app.mountedProgram.nodeAtLine(this.getLineNumber() - 1)
     return mirrorNode.getParentOrDummyTable().getColumnNames()
    }
   } catch (err) {
    console.log(err)
   }
  }
  mapSettingNamesToColumnNames(settingNames) {
   const tileStruct = this.getSettingsStruct()
   return settingNames.map(name => tileStruct[name])
  }
  getOutputOrInputTable() {
   return this._outputTable || this.getParentOrDummyTable()
  }
  getOutputTable() {
   return this._outputTable
  }
  getParentOrDummyTable() {
   // Returns: non-empty input table || dummy table || empty input table.
   const parentTable = this.getParent().getOutputOrInputTable()
   if (!parentTable.isBlankTable()) return parentTable
   return this._getDummyTable() || parentTable
  }
  _getDummyTable() {
   const dataSet = DummyDataSets[this.dummyDataSetName]
   if (!this._dummyTable && dataSet) this._dummyTable = new Table(jtree.Utils.javascriptTableWithHeaderRowToObjects(dataSet))
   return this._dummyTable
  }
  getRequiredTableWithHeader(headerSettingNames) {
   const columnNames = this.mapSettingNamesToColumnNames(headerSettingNames)
   const table = this.getParentOrDummyTable()
   const columns = columnNames.map(name => table.getTableColumnByName(name))
   if (columns.some(col => !col)) return []
   return this.getRowsAsDataTableArrayWithHeader(table.getRows(), columnNames)
  }
  setIsDataLoaded(value) {
   this._isDataLoaded = value
   this.makeDirty() // todo: remove
   return this
  }
  isLoaded() {
   return super.isLoaded() && this._isDataLoaded
  }
  getRowsAsDataTableArrayWithHeader(rows, header) {
   const data = rows.map(row => row.getAsArray(header))
   data.unshift(header)
   return data
  }
  async _executeChildNodes() {
   this.setIsDataLoaded(true)
   return super._executeChildNodes()
  }
  getTileQualityCheck() {
   const definition = this.getDefinition()
   const name = this.getFirstWord()
   let score = 0
   return {
    name: name,
    namespace: name.split(".")[0],
    description: definition.getDescription() ? 1 : 0,
    dummyDataSetName: this.dummyDataSetName,
    runTimeErrors: Object.values(this.getRunTimePhaseErrors()).length,
    examples: definition.getExamples().length,
    edgeTests: 0,
    speedTests: 0,
    roadMap: 0,
    idealStyleUXDescription: 0,
    secPriTests: 0,
    userType: 0
   }
  }
  _getCachedSettings() {
   if (this._cache_settingsObject) return this._cache_settingsObject
   this._cache_settingsObject = {}
   this.filter(child => child.doesExtend("abstractTileSettingTerminalNode") || child.doesExtend("abstractTileSettingNonTerminalNode")).forEach(setting => {
    this._cache_settingsObject[setting.getFirstWord()] = setting.getSettingValue()
   })
   return this._cache_settingsObject
  }
  // todo: ADD TYPINGS
  getSettingsStruct() {
   const settingsFromCache = this._getCachedSettings()
   // todo: this wont work anymore
   const hintsNode = this.getDefinition().getConstantsObject()[this.columnPredictionHintsKey]
   if (hintsNode) Object.assign(settingsFromCache, this.getParentOrDummyTable().getPredictionsForAPropertyNameToColumnNameMapGivenHintsNode(new jtree.TreeNode(hintsNode), settingsFromCache))
   return settingsFromCache
  }
  toInspectionStumpCode() {
   const inputTable = this.getParentOrDummyTable()
   const outputTable = this.getOutputOrInputTable()
   const outputColumns = outputTable.getColumnsArrayOfObjects()
   const inputCols = inputTable.getColumnsArrayOfObjects()
   const inputCount = inputTable.getRowCount()
   const outputCount = outputTable.getRowCount()
   const timeToLoad = this.getTimeToLoad()
   const renderTime = this.getNewestTimeToRender()
   const inputColumnsAsTable = new jtree.TreeNode(inputCols).toTable()
   const outputColumnsAsTable = new jtree.TreeNode(outputColumns).toTable()
   const settings = JSON.stringify(this.getSettingsStruct(), null, 2)
   const outputNumericValues = new jtree.TreeNode(outputTable.getJavascriptNativeTypedValues()).toTable()
   const typeScriptInterface = outputTable.toTypeScriptInterface()
   const inputNumericValues = new jtree.TreeNode(inputTable.getJavascriptNativeTypedValues()).toTable()
   return (
    super.toInspectionStumpCode() +
    "\\n" +
    this.qFormat(this.maiaStumpInspectionTemplate, {
     settings,
     inputCount,
     outputCount,
     timeToLoad,
     renderTime,
     inputColumnsAsTable,
     outputColumnsAsTable,
     outputNumericValues,
     typeScriptInterface,
     inputNumericValues
    })
   )
  }
abstractChartNode
 inScope rowDisplayLimitNode
 int rowDisplayLimit 10000
 extends abstractMaiaTileNode
 abstract
 javascript
  getTileFooterStumpCode() {
   const table = this.getParentOrDummyTable()
   return \`\${this.getTileToolbarButtonStumpCode()}
  span Rows: \${table.getRowCount()} Columns Out: \${table.getColumnCount()}\`
  }
  toDisplayString(value, columnName) {
   // todo: remove.
   if (value === undefined) return ""
   return this.getParentOrDummyTable()
    .getTableColumnByName(columnName)
    .toDisplayString(value)
  }
  _getRowDisplayLimit() {
   const limitStr = this.getSettingsStruct()[this.rowDisplayLimitKey] || this.rowDisplayLimit
   const limit = parseInt(limitStr)
   if (!limitStr || isNaN(limit)) return undefined
   return limit
  }
  getRowsWithRowDisplayLimit() {
   return this.getParentOrDummyTable()
    .getRows()
    .slice(0, this._getRowDisplayLimit())
  }
abstractHeaderlessChartTileNode
 abstract
 extends abstractChartNode
 int headerHeight 0
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div
    class TileBody HeaderLess
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, { classes: this.getCssClassNames().join(" "), id: this.getTreeComponentId(), body: this._getBodyStumpCodeCache(), footer: this.getTileToolbarButtonStumpCode() })
  }
  get _tileWidth() {
   return this.getTileDimensionIfAny().width - 10
  }
  get _tileHeight() {
   return this.getTileDimensionIfAny().height - 60 // 10 for padding. 10 for top grabber. 30 for footer. 10 fot bottom grabber.
  }
abstractEmptyFooterTileNode
 abstract
 extends abstractHeaderlessChartTileNode
 int footerHeight 0
abstractSnippetGalleryNode
 string tileSize 600 240
 extends abstractEmptyFooterTileNode
 abstract
 string bodyStumpTemplate
  h4 {title}
   ol
    class TileSelectable
    {options}
 string optionStumpTemplate
  li
   a {title}
    value {value}
    class appendSnippetButton
    clickCommand appendSnippetTemplateCommand
 javascript
  getGalleryNodes() {}
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, {
    title: this.title,
    options: new jtree.TreeNode(
     this.getGalleryNodes()
      .map(node => this.qFormat(this.optionStumpTemplate, { title: node.evalTemplateString(this.itemFormat), value: node.get("id") }))
      .join("\\n")
    ).toString()
   })
  }
abstractTemplateGalleryNode
 extends abstractSnippetGalleryNode
 abstract
 string optionStumpTemplate
  li
   a {title}
    value {value}
    class createProgramButton
    clickCommand createProgramFromTemplateCommand
challengeListNode
 description View all challenges
 string title Try a challenge:
 string itemFormat {question}
 extends abstractSnippetGalleryNode
 crux challenge.list
 javascript
  getGalleryNodes() {
   return typeof challengesTree === "undefined" ? jtree.TreeNode.fromDisk("maia/packages/challenge/challenges.tree") : new jtree.TreeNode(challengesTree)
  }
  getSnippetTemplate(id) {
   return \`challenge.play \${id}\`
  }
samplesListNode
 description View all available sample tiles
 string title All samples:
 string itemFormat {id} - {description}
 extends abstractSnippetGalleryNode
 crux samples.list
 javascript
  getGalleryNodes() {
   // todo: cleanup.
   const maia = this.getWebApp().getMaiaGrammarAsTree()
   const hits = maia.getNodesByRegex(/^samples/).map(node => {
    return {
     id: node.get("crux"),
     description: node.get("description")
    }
   })
   return new jtree.TreeNode(hits)
  }
  getSnippetTemplate(id) {
   return id
  }
vegaDataListNode
 description View all available Vega datasets
 frequency .001
 string title All Vega datasets:
 string itemFormat {id}
 extends abstractSnippetGalleryNode
 crux vega.data.list
 javascript
  getGalleryNodes() {
   // todo: cleanup this line.
   const node = this.getWebApp()
    .getMaiaGrammarAsTree()
    .getNodesByRegex(/^vegaDataSetCell/)[0]
   return new jtree.TreeNode(
    node
     .get("enum")
     .split(" ")
     .map(item => {
      return {
       id: item
      }
     })
   )
  }
  getSnippetTemplate(id) {
   return \`vega.data \${id}\`
  }
vegaExampleListNode
 description View all available Vega examples
 frequency .001
 string title All Vega examples:
 string itemFormat {id}
 extends abstractSnippetGalleryNode
 crux vega.example.list
 javascript
  getGalleryNodes() {
   // todo: cleanup this line.
   const node = this.getWebApp()
    .getMaiaGrammarAsTree()
    .getNodesByRegex(/^vegaExampleNameCell/)[0]
   return new jtree.TreeNode(
    node
     .get("enum")
     .split(" ")
     .map(item => {
      return {
       id: item
      }
     })
   )
  }
  getSnippetTemplate(id) {
   return \`vega.example \${id}\`
  }
challengePlayNode
 cells tileKeywordCell challengeIdCell
 description Learn ohayo by trying a challenge.
 catchAllCellType challengeAnswerCell
 tags aTileThatCreatesPrograms
 example
  challenge.list
  challenge.play 1
  challenge.play 2
  doc.layout tiled
 string tileSize 640 240
 extends abstractEmptyFooterTileNode
 crux challenge.play
 javascript
  getProgramTemplate(id) {
   const challengeNode = this._getChallengeNode(parseInt(id))
   return {
    template: challengeNode.getNode("solution").childrenToString(),
    name: "challenge-" + id + "-solution.maia"
   }
  }
  _getChallengeNode(challengeId) {
   const challenges = typeof challengesTree === "undefined" ? jtree.TreeNode.fromDisk("maia/packages/challenge/challenges.tree") : new jtree.TreeNode(challengesTree)
   return challenges.nodeAt(challengeId - 1) || challenges.nodeAt(0)
  }
  getTileBodyStumpCode() {
   const challengeId = parseInt(this.getWord(1))
   const answer = this.getWord(2)
   const challengeNode = this._getChallengeNode(challengeId)
   const isCorrect = answer === challengeNode.get("answer")
   const theme = this.getTheme()
   const color = answer ? (isCorrect ? theme.successColor : theme.errorColor) : theme.warningColor
   const answerMessage = answer !== undefined ? (isCorrect ? "CORRECT!" : "Wrong.") : ""
   return \`h3 Challenge #\${challengeId}
   style color:\${color}
  br
  div \${challengeNode.evalTemplateString(\`Question: {question}\`)}
   class TileSelectable
  br
  input
   placeholder Enter your answer here. All answers are a number.
   value \${answer !== undefined ? answer : ""}
   style width: 300px;
   name 2
   changeCommand changeWordAndRenderCommand
  span \${answerMessage}
   style color: \${color};
  br
  div
   a See a solution
    clickCommand createProgramFromTemplateCommand
    value \${challengeId}\`
  }
dtjsBasicNode
 description A spreadsheet-like table.
 string tileSize 1200 500
 string tileCssScript maia/packages/dtjs/datatables.min.css
 string tileScript maia/packages/dtjs/datatables.min.js
 extends abstractEmptyFooterTileNode
 crux dtjs.basic
 string bodyStumpTemplate
  div
  table
   class DataTable
   thead
    tr
     {headerRows}
   tbody
    {rows}
 string cellStumpTemplate
  td
   bern
    {box}
 string rowStumpTemplate
  tr
   {cols}
 javascript
  getTileBodyStumpCode() {
   const columnDefs = this.getParentOrDummyTable()
    .getColumnsArray()
    .slice(0, 10)
   const headerRows = this._getHeaderRowsStumpCode(columnDefs.map(col => col.getColumnName()))
   const rows = this._getTableRowsStumpCode(columnDefs)
   return this.qFormat(this.bodyStumpTemplate, { headerRows, rows })
  }
  _getHeaderRowsStumpCode(columns) {
   return columns.map(colName => \`th \${colName}\`).join("\\n")
  }
  _getTableRowsStumpCode(columns) {
   return this.getRowsWithRowDisplayLimit()
    .slice(0, 10)
    .map((row, index) => {
     const cols = columns
      .map(column => {
       const box = row.getRowHtmlSafeValue(column.getColumnName()) // todo: cache?
       return this.qFormat(this.cellStumpTemplate, { box })
      })
      .join("\\n")
     return this.qFormat(this.cellStumpTemplate, { cols })
    })
    .join("\\n")
  }
  treeComponentWillUnmount() {
   // cleanup
  }
  treeComponentDidUpdate() {
   super.treeComponentDidUpdate()
   const table = this.getParentOrDummyTable()
   const columnDefs = this.getParentOrDummyTable()
    .getColumnsArray()
    .slice(0, 10)
   const container = this.getStumpNode().findStumpNodeByChild("class DataTable")
   if (this.isNodeJs()) return undefined
   const tileDimension = this.getTileDimensionIfAny()
   const width = tileDimension.width - 20 // remove 10 for boddy padding?
   const height = tileDimension.height - 150
   const shadow = container.getShadow()
   const el = shadow.getShadowElement()
   shadow.setShadowCss({ width: width, height: height })
   const rows = this.getRowsWithRowDisplayLimit()
   // todo: note, this is only works with jQuery
   jQuery.fn.dataTable.ext.errMode = "throw"
   this._dataTables = jQuery(el).DataTable({
    data: this.getRowsAsDataTableArrayWithHeader(rows, columnDefs.map(col => col.getColumnName())).slice(1),
    pageLength: 10,
    scrollY: height
    //"scrollCollapse": true,
    //"paging": false
   })
  }
  treeComponentDidMount() {
   this.treeComponentDidUpdate()
  }
abstractHtmlNode
 catchAllCellType htmlCell
 frequency 0
 description An HTML element
 inScope styleNode contentNode
 extends abstractEmptyFooterTileNode
 abstract
 string bodyStumpTemplate
  {tag}
   {style}
   {src}
   bern
    {content}
 javascript
  getTileFooterStumpCode() {
   return this.getTileToolbarButtonStumpCode()
  }
  async fetchTableInputs() {
   return { rows: [{ text: this.getHtmlContent() }] }
  }
  getHtmlContent() {
   return this.getWordsFrom(2).join(" ") || "No html content to show."
  }
  getTag() {
   return this.getWord(1) || "div" // todo: verify this is legal tag.
  }
  getSrc() {
   return this.getSettingsStruct().src
  }
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, { tag: this.getTag(), style: this.style ? \`style \${this.style}\` : "", src: this.getSrc() ? \`src \${this.getSrc()}\` : "", content: this.getHtmlContent() || "" })
  }
htmlTextNode
 description Displays fixed text in the given HTML element.
 cells tileKeywordCell htmlTextTagCell
 catchAllCellType htmlCell
 frequency .002
 extends abstractHtmlNode
 crux html.text
htmlPrintAsNode
 description Displays input table in the given HTML element.
 cells tileKeywordCell htmlTextTagCell
 frequency .002
 javascript
  getHtmlContent() {
   return this.getPipishInput()
  }
 extends abstractHtmlNode
 crux html.printAs
abstractHTMLFixedTagTileNode
 abstract
 extends abstractHtmlNode
 javascript
  getHtmlContent() {
   return this.getContent()
  }
  getTag() {
   return this.htmlTagName
  }
htmlH1Node
 catchAllCellType htmlCell
 description Displays an H1 Header with fixed text
 example A title
  html.h1 Hello world
 frequency .002
 string tileSize 600 75
 string htmlTagName h1
 string style text-align:center;
 extends abstractHTMLFixedTagTileNode
 crux html.h1
abstractHTMLContentIsSrcTileNode
 abstract
 extends abstractHTMLFixedTagTileNode
 javascript
  getHtmlContent() {
   return ""
  }
  getSrc() {
   return this.getContent() || super.getSrc()
  }
htmlImgNode
 description Displays an image from given url.
 cells tileKeywordCell urlCell
 frequency .002
 string htmlTagName img
 string style width:100%;
 extends abstractHTMLContentIsSrcTileNode
 crux html.img
htmlIframeNode
 description Displays an iframe from given url.
 cells tileKeywordCell urlCell
 string htmlTagName iframe
 extends abstractHTMLContentIsSrcTileNode
 crux html.iframe
htmlCustomNode
 description Display custom HTML.
 example Hello world
  html.custom
   content
    <h1>Hello world</h1>
 inScope contentNode
 extends abstractEmptyFooterTileNode
 crux html.custom
 string bodyStumpTemplate
  div
   bern
    {content}
 javascript
  getTileBodyStumpCode() {
   // https://meta.stackexchange.com/questions/1777/what-html-tags-are-allowed-on-stack-exchange-sites
   // todo: sanitize tags
   const contentNode = this.getNode("content")
   const content = contentNode ? contentNode.childrenToString() : "No HTML content to show"
   return this.qFormat(this.bodyStumpTemplate, { content })
  }
abstractShowTileNode
 cells tileKeywordCell columnNameCell
 catchAllCellType titleCell
 frequency .02
 example A dashboard for a Seattle family's water bill.
  samples.waterBill
   hidden
   vega.scatter
   tables.basic
   show.mean Amount
   show.median Amount
   show.sum Amount
   show.min Amount
   show.max Amount
  doc.layout bin
 string tileSize 140 120
 string dummyDataSetName stockPrice
 extends abstractEmptyFooterTileNode
 abstract
 string hakonTemplate
  .abstractShowTileNode
   h3
    text-align center
   h6
    text-align center
    height 40px
    overflow hidden
 string bodyStumpTemplate
  h6 {title}
  h3 {number}
 javascript
  getTileBodyStumpCode() {
   const columnName = this.getWord(1)
   if (!columnName) return \`No data for \${this.getFirstWord()}\`
   const col = this.getParentOrDummyTable().getTableColumnByName(columnName)
   if (!col) return ""
   const reductionName = this.getWord(0).split(".")[1]
   const title = this.getWordsFrom(2).join(" ") || [columnName, reductionName].join(" ")
   const number = this.toDisplayString(col.getReductions()[reductionName], columnName)
   return this.qFormat(this.bodyStumpTemplate, { title, number })
  }
showRowCountNode
 catchAllCellType titleCell
 description Show the total number of rows
 frequency .02
 string tileSize 140 120
 string dummyDataSetName stockPrice
 cells tileKeywordCell
 extends abstractShowTileNode
 crux show.rowCount
 javascript
  getTileBodyStumpCode() {
   const title = this.getWordsFrom(1).join(" ") || "Total rows"
   return this.qFormat(this.bodyStumpTemplate, { title, number: this._getNumber() })
  }
  _getNumber() {
   return this.getParentOrDummyTable().getRowCount()
  }
showColumnCountNode
 extends showRowCountNode
 description Show the total number of columns
 crux show.columnCount
 javascript
  _getNumber() {
   return this.getParentOrDummyTable().getColumnNames().length
  }
showStaticNode
 description Show a hard coded number
 extends abstractShowTileNode
 example
  show.static 20 Sales
 cells tileKeywordCell numberCell
 catchAllCellType titleCell
 crux show.static
 javascript
  getTileBodyStumpCode() {
   const title = this.getWordsFrom(2).join(" ")
   return this.qFormat(this.bodyStumpTemplate, { title, number: this.getWord(1) || "" })
  }
showMedianNode
 description Show the median value of a column
 extends abstractShowTileNode
 crux show.median
showSumNode
 description Show the sum of a column
 extends abstractShowTileNode
 crux show.sum
showMeanNode
 description Show the mean of a column
 extends abstractShowTileNode
 crux show.mean
showMinNode
 description Show the min value of a column
 extends abstractShowTileNode
 crux show.min
showMaxNode
 description Show the max value of a column
 extends abstractShowTileNode
 crux show.max
abstractVegaNode
 frequency .1
 catchAllCellType titleCell
 string tileSize 800 300
 string tileScript maia/packages/vega/vega.combined.min.js
 string dummyDataSetName stockPrice
 string markName bar
 extends abstractEmptyFooterTileNode
 abstract
 string bodyStumpTemplate
  div
   class divForExternalLibrary
 javascript
  // todo: I don't think vega handles . in column names.
  getTileBodyStumpCode() {
   return this.bodyStumpTemplate
  }
  _getColumnToField(columnName) {
   if (!columnName) return undefined
   const columnsMap = this.getParentOrDummyTable().getColumnsMap()
   const col = columnsMap[columnName]
   const obj = { field: columnName, type: col.getVegaType() }
   if (col.isTemporal()) {
    const timeUnit = col.getVegaTimeUnit()
    if (timeUnit) obj.timeUnit = timeUnit
   }
   return obj
  }
  _adjustVegaSize() {
   const adjustSize = !this.has("width")
   if (adjustSize) {
    const shadow = this.getStumpNode()
     .findStumpNodeByChild("class divForExternalLibrary")
     .getShadow()
    this.set("width", Math.round((30 + shadow.getShadowOuterWidth()) / 20) + "")
    this.set("height", Math.round((30 + shadow.getShadowOuterHeight()) / 20) + "")
   }
  }
  _getElementForVega() {
   return this.getStumpNode()
    .findStumpNodeByChild("class divForExternalLibrary")
    .getShadow()
    .getShadowElement()
  }
  async _drawVega() {
   // todo: don't rerun this if we dont need to.
   await vegaEmbed(this._getElementForVega(), this._getVegaSpec())
   // this._adjustVegaSize()
  }
  treeComponentDidUpdate() {
   super.treeComponentDidUpdate()
   if (this.isNodeJs()) return undefined
   this._drawVega()
  }
  _getTileWidth() {
   return this.getTileDimensionIfAny().width - 120
  }
  _getTileHeight() {
   return this.getTileDimensionIfAny().height - 90
  }
  treeComponentDidMount() {
   this.treeComponentDidUpdate()
  }
  _getVegaData() {
   return {
    values: this.getParentOrDummyTable()
     .cloneNativeJavascriptTypedRows()
     .slice(0, this._getRowDisplayLimit())
   }
  }
  _getVegaTitle() {
   return this.getContent()
  }
  _getVegaSpec() {
   return {
    description: "A simple bar chart with embedded data.",
    data: this._getVegaData(),
    width: this._getTileWidth(),
    height: this._getTileHeight(),
    mark: this._getVegaMarkObj(),
    encoding: this._getEncodingMap(),
    transform: this._getVegaTransform(),
    title: this._getVegaTitle(),
    config: this._getVegaConfig()
   }
  }
  _getVegaTransform() {
   return undefined
  }
  _getVegaConfig() {
   return undefined
  }
  _getEncodingMap() {
   return {}
  }
  // todo: add type
  _getVegaMarkObj() {
   return { type: this._getVegaMark(), tooltip: { content: "data" } }
  }
  _getVegaMark() {
   return this.markName
  }
vegaBarNode
 description A bar chart
 inScope xColumnNode yColumnNode colorColumnNode shapeColumnNode
 javascript
  _getEncodingMap() {
   const columnNames = this.mapSettingNamesToColumnNames([this.xColumnKey, this.yColumnKey, this.colorColumnKey])
   return {
    x: this._getColumnToField(columnNames[0]),
    y: this._getColumnToField(columnNames[1]),
    color: this._getColumnToField(columnNames[2])
   }
  }
 string columnPredictionHints
  xColumn
  yColumn isString=false,!xColumn
 extends abstractVegaNode
 crux vega.bar
vegaLineNode
 description A line chart
 string markName line
 extends vegaBarNode
 crux vega.line
vegaAreaNode
 description An area chart
 string markName area
 extends vegaLineNode
 crux vega.area
vegaScatterNode
 description A scatterplot
 string markName point
 extends vegaBarNode
 crux vega.scatter
 javascript
  _getEncodingMap() {
   const columnNames = this.mapSettingNamesToColumnNames([this.xColumnKey, this.yColumnKey, this.colorColumnKey, this.shapeColumnKey])
   return {
    x: this._getColumnToField(columnNames[0]),
    y: this._getColumnToField(columnNames[1]),
    color: this._getColumnToField(columnNames[2]),
    shape: this._getColumnToField(columnNames[3])
   }
  }
vegaBubbleNode
 description A bubble plot
 inScope sizeColumnNode colorColumnNode
 string markName circle
 string dummyDataSetName gapMinder
 string columnPredictionHints
  sizeColumn isString=false
  xColumn isString=false
 extends vegaScatterNode
 crux vega.bubble
 javascript
  _getEncodingMap() {
   const columnNames = this.mapSettingNamesToColumnNames([this.xColumnKey, this.yColumnKey, this.sizeColumnKey, this.colorColumnKey])
   return {
    y: {
     field: columnNames[1],
     type: "quantitative",
     scale: { zero: false },
     axis: { minExtent: 30 }
    },
    x: this._getColumnToField(columnNames[0]),
    size: { field: columnNames[2], type: "quantitative" },
    color: { value: "#000" }
   }
  }
vegaEmojiNode
 description A bar chart with emojis
 frequency .001
 inScope yColumnNode emojiColumnNode
 string columnPredictionHints
  emojiColumn isString=true
  yColumn isString=false
 string dummyDataSetName emojis
 javascript
  _getVegaConfig() {
   return { view: { stroke: "" } }
  }
  _getVegaMark() {
   return { type: "text", baseline: "middle" }
  }
  _getEncodingMap() {
   const columnNames = this.mapSettingNamesToColumnNames([this.yColumnKey, "emoji"])
   return {
    x: { field: columnNames[1], type: "nominal", axis: null },
    y: { field: columnNames[0], type: "quantitative", axis: null, sort: null },
    text: { field: columnNames[1], type: "nominal" },
    size: { value: 65 }
   }
  }
 extends vegaBarNode
 crux vega.emoji
vegaHistogramNode
 description A histogram
 inScope xColumnNode
 javascript
  _getEncodingMap() {
   const columnName = this.getContent() || this.mapSettingNamesToColumnNames([this.xColumnKey])[0]
   return {
    x: {
     bin: true,
     field: columnName,
     type: "quantitative"
    },
    y: {
     aggregate: "count",
     type: "quantitative"
    }
   }
  }
 string columnPredictionHints
  xColumn isString=false
 string dummyDataSetName wordCounts
 extends abstractVegaNode
 crux vega.histogram
vegaExampleNode
 description Shows a chart from the Vega Example Gallery
 frequency .001
 cells tileKeywordCell vegaExampleNameCell
 example
  vega.example trellis_anscombe
 extends abstractVegaNode
 crux vega.example
 javascript
  _getVegaSpec() {
   return this._spec
  }
  async _fetchSpec() {
   // todo: localtesting.
   if (this.isNodeJs()) return undefined
   const exampleName = this.getContent() || "area" // todo: pull this default from the gram?
   const url = \`maia/packages/vega/ignore/vega-lite/examples/compiled/\${exampleName}.vg.json\`
   const res = await this.getWebApp()
    .getWillowBrowser()
    .httpGetUrl(url)
   const spec = JSON.parse(res.text)
   // rewrite data urls
   spec.data.forEach(row => {
    if (row.url) row.url = row.url.replace("data/", "packages/vega/datasets/")
   })
   this._spec = spec
   return spec
  }
  // todo: clean this up.
  async fetchTableInputs() {
   const spec = await this._fetchSpec()
   if (this.isNodeJs()) return { rows: [] }
   const el = jQuery("<div></div>")[0]
   const embedded = await vegaEmbed(el, spec)
   const rows = await this._getVegaPostTransformOutputRows(spec, embedded)
   return { rows: rows }
  }
  async _getVegaPostTransformOutputRows(spec, embedded) {
   const tableName = spec.data[0] && spec.data[0].name
   if (tableName) return embedded.view.data(tableName)
   // const values = spec.data.values
   // if (values && values.entries) return Array.from(values.entries())
   // if (typeof values === "function") return []
   // else if (values) return values
   return []
  }
dateHeatcalNode
 description Shows which days have higher counts.
 inScope countNode dayColumnNode
 string tileSize 750 200
 string columnPredictionHints
  count getPrimitiveTypeName=number
  dayColumn getPrimitiveTypeName=day
 string dummyDataSetName waterBill
 extends abstractHeaderlessChartTileNode
 crux date.heatcal
 string bodyStumpTemplate
  div
   class heatCal
   bern
    {svg}
 string hakonTemplate
  .heatCal
   rect
    fill {darkerBackground}
    shape-rendering crispedges
   text
    font-size 10px
    fill #ddd
 javascript
  _getLegend(quins, squareSideWithPadding, position) {
   const theme = this.getTheme()
   const quinSvgs = quins
    .map((quin, index) => {
     const left = position.left + squareSideWithPadding * index
     const style = "fill: " + theme.getHeatColor(1 - quin.percent)
     return \`<rect style="\${style}" width="10" height="10" x="\${left}" y="\${position.top}"></rect>\`
    })
    .join("")
   return \`<g>
  <text x="\${position.left - 25}" y="\${position.top + 10}">Less</text>
  \${quinSvgs}
  <text x="\${position.left + 70}" y="\${position.top + 10}">More</text>
  </g>\`
  }
  getTileBodyStumpCode() {
   const svg = this.getSvg()
   return this.qFormat(this.bodyStumpTemplate, { svg })
  }
  _getDayMap(quins, rows, dayColumnName, countColumnName) {
   const getQuin = val => {
    for (let index = 0; index < quins.length; index++) {
     if (val <= quins[index].value) return quins[index].percent
    }
   }
   const dayMap = {}
   rows.forEach(row => {
    dayMap[moment(row[dayColumnName]).format("MM/DD/YYYY")] = {
     Quin: getQuin(row[countColumnName]),
     count: row[countColumnName],
     row: row
    }
   })
   return dayMap
  }
  _getDaysArray(startDay, daysToShow) {
   const days = []
   const firstDay = parseInt(startDay.format("e"))
   for (let dayIndex = 0; dayIndex <= daysToShow; dayIndex++) {
    const day = startDay.clone().add(dayIndex, "days")
    days.push({
     day: day,
     row: parseInt(day.format("e")),
     col: Math.floor((firstDay + dayIndex) / 7)
    })
   }
   return days
  }
  _getDayNamesG(squareSideWithPadding) {
   const dayNames = [{ day: "Mon", row: 2 }, { day: "Wed", row: 4 }, { day: "Fri", row: 6 }]
    .map(day => {
     const _top = 20 + day.row * squareSideWithPadding - 3
     return \`<text x="0" y="\${_top}">\${day.day}</text>\`
    })
    .join("")
   return \`<g>\${dayNames}</g>\`
  }
  _getMonthNamesG(daysArray, squareSideWithPadding) {
   const _usedMonths = {}
   const monthNames = daysArray
    .map(day => {
     const monthName = day.day.format("MMM")
     const monthYear = day.day.format("MM/YYYY")
     if (_usedMonths[monthYear]) return ""
     _usedMonths[monthYear] = true
     const left = 40 + day.col * squareSideWithPadding
     return \`<text x="\${left}" y="10">\${monthName}</text>\`
    })
    .join("")
   return \`<g>\${monthNames}</g>\`
  }
  _getDataSquaresG(daysArray, squareSideWithPadding, dayMap) {
   const dayFormat = "MM/DD/YYYY"
   const today = moment(Date.now()).format(dayFormat)
   const theme = this.getTheme()
   const dataSquares = daysArray
    .map(day => {
     const dayKey = day.day.format(dayFormat)
     const _top = 20 + day.row * squareSideWithPadding
     const left = 40 + day.col * squareSideWithPadding
     const value = dayMap[dayKey]
     const todayStyle = dayKey === today ? "stroke-width:2;stroke:rgb(0,0,0);" : ""
     const style = (value ? "fill: " + theme.getHeatColor(1 - value.Quin) : "") + ";" + todayStyle
     const title = \`\${dayKey}: \${value ? value.count : 0}\`
     return \`<rect style="\${style}" data-day="\${dayKey}" width="10" height="10" x="\${left}" y="\${_top}"><title>\${title}</title></rect>\`
    })
    .join("")
   return \`<g>\${dataSquares}</g>\`
  }
  getSvg() {
   const inputTable = this.getParentOrDummyTable()
   const rows = inputTable.getJavascriptNativeTypedValues()
   if (!rows.length) return ""
   const tileStruct = this.getSettingsStruct()
   const dayColumnName = tileStruct.dayColumn
   const countColumnName = tileStruct.count
   if (!dayColumnName || !countColumnName) return ""
   const dayCol = inputTable.getTableColumnByName(dayColumnName)
   const countCol = inputTable.getTableColumnByName(countColumnName)
   let daysToShow = 365 * 1 // todo: make configurable
   let endDay = moment(Date.now())
   let startDay = endDay.clone().subtract(daysToShow, "days")
   // todo: make configurable
   // reductions = dayCol.getReductions()
   //  startDay = moment(reductions.min)
   // endDay = moment(reductions.max)
   // daysToShow = endDay.diff(startDay, "days")
   const squareSide = 10
   const squarePadding = 2
   const squareSideWithPadding = squareSide + squarePadding
   const width = squareSideWithPadding * (daysToShow / 6)
   const height = 7 * squareSideWithPadding + 100
   const quins = countCol.getQuins()
   const dayMap = this._getDayMap(quins, rows, dayColumnName, countColumnName)
   const daysArray = this._getDaysArray(startDay, daysToShow)
   const dayNamesG = this._getDayNamesG(squareSideWithPadding)
   const monthNamesG = this._getMonthNamesG(daysArray, squareSideWithPadding)
   const squaresG = this._getDataSquaresG(daysArray, squareSideWithPadding, dayMap)
   const keyG = this._getLegend(quins, squareSideWithPadding, { top: 110, left: 60 })
   return \`<svg width="\${width}" height="\${height}">\${dayNamesG + squaresG + monthNamesG + keyG}</svg>\`
  }
iconsIconNode
 extends abstractHeaderlessChartTileNode
 abstract
iconsHumanNode
 description Assuming each row in your data represents a human, creates a human icon.
 example
  samples.patients
   icons.human
 inScope genderColumnNode headSizeNode
 string columnPredictionHints
  headSize isString=false
  genderColumn isString=true
 string bodyStumpTemplate
  div
   bern
    {bern}
 javascript
  getTileBodyStumpCode() {
   // Now, what if there is no input table?
   const table = this.getParentOrDummyTable()
   const rows = table.getRows()
   // Now, what if we are using dummy input table?
   const headSizeColumn = this.getSettingsStruct().headSize
   const genderColumn = this.getSettingsStruct().genderColumn
   const reducts = table.getColumnByName(headSizeColumn).getReductions()
   const headColMax = reducts.max
   const bern = rows
    .map(row => {
     const typedRow = row.rowToObjectWithOnlyNativeJavascriptTypes()
     const value = typedRow[headSizeColumn]
     // TODO: ADD TYPINGS
     const genderVal = typedRow[genderColumn].toLowerCase()
     const gender = genderVal === "male" ? "blue" : "pink"
     let character = "O"
     let percent = value / headColMax
     if (isNaN(value)) {
      character = "x"
      percent = reducts.median / headColMax
     }
     const title = row.getHoverTitle()
     percent = Math.round(18 * percent)
     return \`<span title="\${title}" style="font-size:\${percent}px; color:\${gender};">\${character}</span>\`
    })
    .join(" ")
   return this.qFormat(this.bodyStumpTemplate, { bern: bern })
  }
 string dummyDataSetName patients
 extends iconsIconNode
 crux icons.human
iconsCircleNode
 description Displays a simple icon for each row of your data.
 example
  samples.iris
   icons.circle
    radius Petal.Length
 inScope radiusNode
 string columnPredictionHints
  radius isString=false
 string dummyDataSetName playerGoals
 extends iconsIconNode
 crux icons.circle
 string bodyStumpTemplate
  div
   bern
    {bern}
 javascript
  getTileBodyStumpCode() {
   const column = this.getSettingsStruct().radius
   const bern = this.getParentOrDummyTable()
    .getRows()
    .map(row => \`<span style="font-size:\${row.rowToObjectWithOnlyNativeJavascriptTypes()[column] / 3}em;">O</span>\`)
    .join(" ")
   return this.qFormat(this.bodyStumpTemplate, { bern: bern })
  }
markdownToHtmlNode
 description Displays Markdown rendered as HTML.
 example Show a text editor and some rendered Markdown.
  data.inline
   parser text
   content
    # My header
    ## My subheader
    
    Hello world
   markdown.toHtml
 inScope contentNode
 string bodyStumpTemplate
  div
   class TileSelectable
   bern
    {md}
 javascript
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, { md: marked(this.getPipishInput()) })
  }
 string tileSize 400 400
 string dummyDataSetName markdown
 extends abstractHeaderlessChartTileNode
 crux markdown.toHtml
treenotationOutlineNode
 description A simple pretty text-only view of a Tree Notation document.
 example Outer space
  samples.outerSpace
   treenotation.outline
 string dummyDataSetName outerSpace
 string tileSize 800 500
 extends abstractHeaderlessChartTileNode
 crux treenotation.outline
 string bodyStumpTemplate
  pre
   style overflow: scroll; width: 100%; height: 100%; margin: 0; box-sizing: border-box; font-family: monospace; line-height: 13px;
   bern
    {bern}
 javascript
  _getTheBern() {
   return new jtree.TreeNode(this.getPipishInput()).toOutline()
  }
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, { bern: this._getTheBern() })
  }
treenotationDotlineNode
 description A simple pretty icon-only visualization of the structure of a Tree Notation doc.
 example Outer space
  samples.outerSpace
   treenotation.dotline
 boolean dots true
 string dummyDataSetName outerSpace
 javascript
  _getTheBern() {
   return new jtree.TreeNode(this.getPipishInput()).toMappedOutline(
    node =>
     "o" +
     node
      .getLine()
      .split(" ")
      .map(word => "º")
      .join("")
   )
  }
 extends treenotationOutlineNode
 crux treenotation.dotline
abstractTextNode
 catchAllCellType stringCell
 frequency 0
 description Prints a message
 inScope contentNode
 string bodyStumpTemplate
  div
   class TileSelectable
   bern
    {content}
 javascript
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, { content: this.content ? jtree.Utils.linkify(this.content) : "" })
  }
 extends abstractChartNode
 abstract
abstractInstructionsNode
 string tileSize 600 240
 string content Instructions go here.
 extends abstractTextNode
 abstract
amazonHistoryNode
 description Instructions on how to get your Amazon order history.
 string content Step 1. Go to https://www.amazon.com/gp/b2b/reports to download your Amazon order history.<br> Step 2. Add the data here.
 string dummyDataSetName amazonPurchases
 extends abstractInstructionsNode
 crux amazon.history
fitbitAllNode
 description Instructions on how to get your Fitbit data.
 string content Step 1. Go to <a target="_blank" href="https://www.fitbit.com/settings/data/export">https://www.fitbit.com/settings/data/export</a> to download your Fitbit data.<br> Step 2. Drop the CSV onto this page.
 extends abstractInstructionsNode
 crux fitbit.all
abstractComingSoonNode
 frequency 0
 description Coming soon
 string tileSize 600 240
 string content Instructions go here.
 extends abstractTextNode
 abstract
datawrapperComingSoonNode
 string content We don't have support yet for https://www.datawrapper.de/
 extends abstractComingSoonNode
 crux datawrapper.comingSoon
dcjsComingSoonNode
 string content We don't have support yet for https://github.com/dc-js/dc.js
 extends abstractComingSoonNode
 crux dcjs.comingSoon
finosPerspectiveComingSoonNode
 string content We don't have support yet for https://perspective.finos.org/
 extends abstractComingSoonNode
 crux finos.perspective.comingSoon
fivethirtyeightComingSoonNode
 string content We don't have support yet for https://github.com/fivethirtyeight/data/
 extends abstractComingSoonNode
 crux fivethirtyeight.comingSoon
highchartsComingSoonNode
 string content We don't have support yet for https://www.highcharts.com/blog/snippets/3d-solar-system/
 extends abstractComingSoonNode
 crux highcharts.comingSoon
re3dataComingSoonNode
 string content We don't have support yet for https://www.re3data.org/
 extends abstractComingSoonNode
 crux re3data.comingSoon
zingComingSoonNode
 string content We don't have support yet for https://www.zingchart.com/
 extends abstractComingSoonNode
 crux zing.comingSoon
editorHelloWorldNode
 description Prints hello world
 example Say hello.
  editor.helloWorld
 string content Ohayo world!
 extends abstractTextNode
 crux editor.helloWorld
debugDumpNode
 description Dumps data from content or dump's first column input as 1 concatenated string.
 example Print a poem.
  samples.poem
   debug.dump
 extends abstractChartNode
 crux debug.dump
 string bodyStumpTemplate
  div
   style overflow: scroll; width: 100%; height: 100%; white-space: pre;
   bern
    {text}
 javascript
  _getCharacterLimit() {
   // Todo: great example of a scale test. I found it to be slow with:
   /*
  vega.sample movies.json
   web.dump
  So some tiles will have characterLimit, rowDisplayLimit, et cetera. And have "speedTestExamples" .
  */
   return 20000
  }
  getTileBodyStumpCode() {
   const text = this._getTextToDump()
   const characterLimit = this._getCharacterLimit()
   let sub = text.substr(0, characterLimit)
   if (text.length > characterLimit)
    // todo: Show standardized truncation warning
    sub = \`<i>(Notice: Results truncated to \${characterLimit} characters)</i><br>\` + sub
   return this.qFormat(this.bodyStumpTemplate, { text: sub || "No data to dump" })
  }
  _getTextToDump() {
   return this.getPipishInput()
  }
webDumpNode
 frequency .02
 description Dump the raw text from the web request.
 extends debugDumpNode
 javascript
  _getTextToDump() {
   return this.getParent().getWillowHttpResponse ? this.getParent().getWillowHttpResponse().text : \`\${this.constructor.name} requires a parent web tile.\`
  }
 crux web.dump
debugCommandsNode
 description Tools for ohayo developers.
 example Show debug commands
  debug.commands
 extends abstractChartNode
 crux debug.commands
 string bodyStumpTemplate
  a Run Speed Test on all Files in Working Directory
   clickCommand _runSpeedTestCommand
  br
  a Run Tile Quality Check
   clickCommand _doTileQualityCheckCommand
 javascript
  getTileBodyStumpCode() {
   return this.bodyStumpTemplate
  }
debugGrammarTreeNode
 description Show the family tree for a grammar.
 cells tileKeywordCell supportedTreeLanguageCell
 example Show the family tree for a grammar
  debug.grammarTree maia
   treenotation.outline
 extends abstractChartNode
 crux debug.grammarTree
 javascript
  async fetchTableInputs() {
   const fileExtension = this.getWord(1) || "maia"
   const programClass = this.getWebApp().getProgramConstructorFromFileExtension(fileExtension)
   const tree = new programClass("").getGrammarProgram().getNodeTypeFamilyTree()
   return { rows: [{ text: tree.toString() }] }
  }
debugSleepNode
 cells tileKeywordCell millisecondsCell dummyDataSetIdCell
 description Sleeps for a few seconds and then loads data. Useful for testing and development.
 example Sleep for 1 second then load data
  debug.sleep 100 waterBill
   tables.basic
 string dummyDataSetName waterBill
 extends abstractChartNode
 crux debug.sleep
 javascript
  async fetchTableInputs() {
   const ms = parseInt(this.getWord(1) || 1)
   await this.getWebApp().sleepCommand(ms)
   return { rows: jtree.Utils.javascriptTableWithHeaderRowToObjects(DummyDataSets[this.getWord(2) || "stockPrice"]) }
  }
debugThrowNode
 description Throws an error during load. Used for testing.
 cells tileKeywordCell tileEventNameCell
 example Throw an error
  samples.poem
  debug.throw fetchTableInputs
 extends abstractChartNode
 crux debug.throw
 javascript
  async fetchTableInputs() {
   this._throwIfMethodNameIs("fetchTableInputs")
   return {
    rows: []
   }
  }
  _throwIfMethodNameIs(name) {
   // Never throw if no word provided. That ensures it wont throw during testing.
   const lookingFor = this.getContent()
   if (lookingFor === name) throw new Error(\`DebugTile threw an error on purpose on event: "\${lookingFor}"\`)
  }
  getTileBodyStumpCode() {
   this._throwIfMethodNameIs("getTileBodyStumpCode")
  }
  treeComponentDidMount() {
   this._throwIfMethodNameIs("treeComponentDidMount")
  }
  treeComponentDidUpdate() {
   this._throwIfMethodNameIs("treeComponentDidUpdate")
  }
editorGalleryNode
 description Show a thumbnail of all the Ohayo documents in the input table.
 example
  editor.files
   editor.gallery
 string tileSize 1080 600
 string dummyDataSetName maiaPrograms
 extends abstractChartNode
 crux editor.gallery
 string hakonTemplate
  .MiniMapTile
   .miniMap
    background {backgroundColor}
    width 120px
    height 90px
    margin 6px
    position relative
    overflow hidden
    box-sizing border-box
    display inline-block
    &:hover
     border 1px solid {boxShadow}
    &:active
     border 2px solid {boxShadow}
    .miniFooter
     font-size 12px
     position absolute
     bottom 0
     width 100%
     height 15px
     line-height 15px
     white-space nowrap
     text-align center
    .miniPreview
     position absolute
     width 100%
     height calc(100% - 15px)
     top 0
     overflow hidden
     div
      position absolute
      background {linkColor}
 string miniStumpTemplate
  a
   class miniMap
   {onClick}
   {value}
   {href}
   div
    class miniPreview
    {theTiles}
   div {filename}
    class miniFooter
 string bodyStumpTemplate
  div
   class MiniMapTile
   {minis}
 string miniStyleTemplate
  div
   style {style}
 javascript
  async openFullPathInNewTabAndFocusCommand(url) {
   return this.getTab()
    .getRootNode()
    .openFullPathInNewTabAndFocusCommand(url)
  }
  _getMiniStumpCode(sourceCode, filename, permalink, width = 120, height = 75) {
   const maiaProgram = new maiaNode(sourceCode)
   const dimensions = maiaProgram.getTileDimensionMap(width, height)
   const theTiles = maiaProgram
    .getTiles()
    .filter(tile => tile.isVisible())
    .map(tile => this.qFormat(this.miniStyleTemplate, { style: dimensions.get(tile).getScaledCss(0.1) }))
    .join("\\n")
   const onClick = permalink ? "clickCommand openFullPathInNewTabAndFocusCommand" : ""
   const value = permalink ? \`value \${permalink}\` : ""
   const href = permalink ? \`href \${permalink}\` : ""
   return this.qFormat(this.miniStumpTemplate, { filename, theTiles, onClick, value, href })
  }
  getTileBodyStumpCode() {
   // todo: cache.
   const minis = this.getRowsWithRowDisplayLimit()
    .map(row => this._getMiniStumpCode(row.getRowOriginalValue("bytes"), row.getRowOriginalValue("filename"), row.getRowOriginalValue("link")))
    .join("\\n")
   return this.qFormat(this.bodyStumpTemplate, { minis })
  }
handsontableBasicNode
 description A spreadsheet-like table.
 string tileSize 1200 500
 string tileCssScript maia/packages/handsontable/handsontable.min.css
 string tileScript maia/packages/handsontable/handsontable.full.min.js
 string hakonTemplate
  .hot
   color black
 string bodyStumpTemplate
  div
   class hot
 javascript
  getTileBodyStumpCode() {
   return this.bodyStumpTemplate
  }
  // todo: allow editing
  treeComponentWillUnmount() {
   if (this._hot) this._hot.destroy()
   delete this._hot
  }
  treeComponentDidUpdate() {
   super.treeComponentDidUpdate()
   const table = this.getParentOrDummyTable()
   const columnDefs = table.getColumnsByImportance()
   const colNames = columnDefs.map(col => col.getColumnName())
   const rows = this.getRowsWithRowDisplayLimit()
   const data = this.getRowsAsDataTableArrayWithHeader(rows, colNames)
   const tileDimension = this.getTileDimensionIfAny()
   const container = this.getStumpNode().findStumpNodeByChild("class hot")
   const app = this.getWebApp()
   if (this.isNodeJs()) return undefined
   const width = tileDimension.width - 20 // remove 10 for boddy padding?
   const height = tileDimension.height - 60
   this._hot = new Handsontable(container.getShadow().getShadowElement(), {
    data: data,
    rowHeaders: true,
    colHeaders: true,
    stretchH: "all",
    width: width,
    minSpareCols: 10,
    minSpareRows: 30,
    afterSelection: () => app.pauseShortcutListener(),
    afterDeselect: () => app.startShortcutListener(),
    height: height
   })
   return this._hot
  }
  treeComponentDidMount() {
   this.treeComponentDidUpdate()
  }
 extends abstractChartNode
 crux handsontable.basic
listBasicNode
 catchAllCellType columnNameCell
 description Show 1 column as a text list.
 example List of world's telescopes
  samples.telescopes
   list.basic
 inScope labelNode
 string bodyStumpTemplate
  ol
   {items}
 string listItemStumpTemplate
  li
   span {label}
 javascript
  _getListItem(label) {
   return this.qFormat(this.listItemStumpTemplate, { label })
  }
  _getLabelColumnName() {
   // todo: more automatic! Need to fix our columns/keywords issues
   return this.getWord(1) || this.getSettingsStruct().label
  }
  getTileBodyStumpCode() {
   const labelColumnName = this._getLabelColumnName()
   const items = this.getRowsWithRowDisplayLimit()
    .map(row => this._getListItem(jtree.Utils.stripHtml(row.getRowOriginalValue(labelColumnName)), row))
    .join("\\n")
   return this.qFormat(this.bodyStumpTemplate, { items })
  }
 string tileSize 400 400
 string dummyDataSetName telescopes
 string columnPredictionHints
  label getTitlePotential
 extends abstractChartNode
 crux list.basic
listLinksNode
 description Show 1 column as a list of links, using 1 column for the url.
 catchAllCellType columnNameCell
 example List of world's telescopes with links
  samples.telescopes
   list.links
 inScope labelNode linkNode
 string dummyDataSetName telescopes
 string listItemHakonTemplate
  li
   a {label}
    href {link}
 javascript
  _getUrlColumnName() {
   // todo: more automatic! Need to fix our columns/keywords issues
   return this.getWord(2) || this.getSettingsStruct().link
  }
  _getListItem(label, row) {
   const urlColumnName = this._getUrlColumnName()
   if (!urlColumnName) return super._getListItem(label, row)
   return this.qFormat(this.listItemHakonTemplate, { label, link: jtree.Utils.stripHtml(row.getRowOriginalValue(urlColumnName)) })
  }
 string columnPredictionHints
  label getTitlePotential
  link isLink
 extends listBasicNode
 crux list.links
tablesBasicNode
 frequency .1
 description Basic table with sorting.
 example Basic table with Iris data
  samples.iris
   tables.basic
 catchAllCellType titleCell
 inScope columnLimitNode
 int rowDisplayLimit 100
 int columnLimit 20
 string tileSize 750 300
 todo added the below to allow custom body styling in tables
 string customBodyStyle padding:0px;
 string hakonTemplate
  .tablesBasicNode
   font-size 14px
   box-sizing border-box
   width 100%
   height 100%
   {enableTextSelect1}
   top 34px
   table
    width 100%
   tr
    white-space nowrap
    padding 0
   td
    border 1px solid {lineColor}
   tr:nth-child(even)
    background-color {veryLightGrey}
   td,th
    padding 2px 3px
    text-align left
    overflow hidden
    text-overflow ellipsis
    max-width 250px
   td:hover,th:hover
    overflow visible
   td:first-child,th:first-child
    padding-left 5px
    color {greyish}
    width 60px
   th
    cursor pointer
    background-color {lightGrey}
    border 1px solid {lineColor}
    border-bottom-color {greyish}
   input,textarea
    border 0
    font-size 14px
    box-sizing border-box
    padding 0
    font-family {fonts}
 string cellStumpTemplate
  td
   bern
    {content}
 string cellLinkStumpTemplate
  td
   a
    href {content}
    bern
     {content}
 string rowStumpTemplate
  tr
   class tableRow
   value {value}
   td {number}
   {cols}
 javascript
  getTileHeaderBern() {
   return this.getContent() || super.getTileHeaderBern()
  }
  _getTableRowsStumpCode(columns) {
   return this.getRowsWithRowDisplayLimit()
    .map((row, index) => {
     const cols = columns
      .map(column => {
       return this.qFormat(column.isLink() ? this.cellLinkStumpTemplate : this.cellStumpTemplate, { content: row.getRowHtmlSafeValue(column.getColumnName()) })
      })
      .join("\\n")
     return this.qFormat(this.rowStumpTemplate, { number: index + 1, value: row.getPuid(), cols })
    })
    .join("\\n")
  }
  getContextMenuStumpCode() {
   return this.contextMenuStumpTemplate
  }
  _getHeaderRowsStumpCode(columns) {
   // todo: can we get a copy column command?
   return ["Row"]
    .concat(columns)
    .map(colName => this.qFormat(this.headerRowStumpTemplate, { colName }))
    .join("\\n")
  }
  getTileBodyStumpCode() {
   const tileStruct = this.getSettingsStruct()
   const table = this.getParentOrDummyTable()
   if (table.isBlankTable()) return \`div No data to show\`
   let columnDefs = tileStruct.columnOrder === "importance" ? table.getColumnsByImportance() : table.getColumnsArray()
   columnDefs = columnDefs.slice(0, tileStruct.columnLimit || this.columnLimit)
   const columnNames = columnDefs.map(col => col.getColumnName())
   // todo: if the types for a column are all equal, add a total row to the bottom.
   // todo: if the types for a row are all equal, add a total column to the right.
   const headerRows = this._getHeaderRowsStumpCode(columnNames)
   const bodyRows = this._getTableRowsStumpCode(columnDefs)
   return this.qFormat(this.bodyStumpTemplate, { headerRows, bodyRows })
  }
 string contextMenuStumpTemplate
  a Delete all rows
   clickCommand deleteAllRowsInTargetTileCommand
 string headerRowStumpTemplate
  th
   value {colName}
   span {colName}
   value {colName}
 string bodyStumpTemplate
  div
   class tablesBasicNode
   table
    thead
     {headerRows}
    tbody
     {bodyRows}
 extends abstractChartNode
 crux tables.basic
tablesInterestingNode
 frequency .01
 description Prints most interesting columns.
 string columnOrder importance
 extends tablesBasicNode
 crux tables.interesting
tablesDumpNode
 description Prints data with no formatting or column reordering.
 frequency .01
 string columnOrder default
 extends tablesBasicNode
 crux tables.dump
textWordcloudNode
 description Turn text into a word cloud.
 inScope columnNode countNode
 example A poem analyzed
  samples.poem
   text.wordCount
    text.wordcloud
 javascript
  getTileBodyStumpCode() {
   return \`div
  class divWhereWordCloudWillGo
  style width: 100%; height: 100%;\`
  }
  _getAllWords() {
   return this.getRequiredTableWithHeader(["name", "count"])
  }
  treeComponentDidUpdate() {
   this._draw()
  }
  treeComponentDidMount() {
   this._draw()
  }
  _draw() {
   if (this.isNodeJs()) return undefined
   const tileStruct = this.getSettingsStruct()
   const words = this._getAllWords()
   if (!words.length) return
   words.shift() // drop header
   const shadow = this.getStumpNode().getShadow()
   const width = shadow.getShadowOuterWidth()
   const powConstant = 10 / Math.log(words.length) // breaks if too hgih.
   const options = {
    list: words.map(word => [word[0], word[1]]),
    shuffle: false,
    gridSize: Math.round((16 * width) / 1024),
    weightFactor: size => (Math.pow(size, powConstant) * width) / 1024,
    backgroundColor: "transparent",
    random: jtree.Utils.makeSemiRandomFn(),
    wait: 0
   }
   Object.assign(options, tileStruct)
   const element = this.getStumpNode()
    .findStumpNodeByChild("class divWhereWordCloudWillGo")
    .getShadow()
    .getShadowElement()
   WordCloud(element, options)
  }
 string tileScript maia/packages/text/wordcloud2.min.js
 string dummyDataSetName wordCounts
 string columnPredictionHints
  name isString=true
  count isString=false
 extends abstractChartNode
 crux text.wordcloud
treenotation3dNode
 description A 3D visualization of Tree Language source code.
 example 3D vis of a Tree Program.
  samples.treeProgram
   treenotation.3d
 inScope contentNode sizeNode cameraPositionNode
 string tileSize 800 500
 string tileScript maia/packages/treenotation/vis.min.js
 string dummyDataSetName treeProgram
 extends abstractChartNode
 crux treenotation.3d
 javascript
  getTileBodyStumpCode() {
   return \`div
  class visjs\`
  }
  treeComponentDidMount() {
   super.treeComponentDidMount()
   this.treeComponentDidUpdate()
  }
  // Called when the Visualization API is loaded.
  treeComponentDidUpdate() {
   super.treeComponentDidUpdate()
   if (this.isNodeJs()) return undefined
   try {
    this._tryVis()
   } catch (err) {
    // log error
    console.error(err)
   }
  }
  _tryVis() {
   const tileStruct = this.getSettingsStruct()
   const source = this.getPipishInput()
   const app = this.getWebApp()
   const language = app.getLanguageBestGuess(source)
   const program = app.generateProgram(source, language)
   const rows = this._treeTo3D(program)
   // Create and populate a data table.
   const data = new vis.DataSet()
   rows.forEach(row => data.add(row))
   const dotSize = tileStruct.size
   const showGrid = tileStruct.showGrid
   // specify options
   // docs: http://visjs.org/docs/graph3d/
   const tileDimension = this.getTileDimensionIfAny()
   const cameraPositionNode = this.getNode("cameraPosition") || new jtree.TreeNode("cameraPosition 4 .1 1.5").getNode("cameraPosition")
   const distance = parseFloat(cameraPositionNode.getWord(1))
   const horizontal = parseFloat(cameraPositionNode.getWord(2))
   const vertical = parseFloat(cameraPositionNode.getWord(3))
   const options = {
    width: tileDimension.width + "px",
    height: tileDimension.height - 80 + "px",
    style: "dot-color", // dot?
    showPerspective: false,
    showLegend: false,
    showShadow: false,
    keepAspectRatio: true,
    xStep: 1,
    yStep: 1,
    zStep: 1,
    zMax: 5,
    showGrid: true,
    showZAxis: false,
    showXAxis: false,
    showYAxis: false,
    dotSizeRatio: dotSize,
    dotSizeMinFraction: 1,
    cameraPosition: {
     distance: distance,
     horizontal: horizontal,
     vertical: vertical
    },
    verticalRatio: 1.0,
    // parameter point contains properties x, y, z, and data
    // data is the original object passed to the point constructor
    tooltip: point => point.data.line
   }
   // create a graph3d
   const element = this.getStumpNode()
    .findStumpNodeByChild("class visjs")
    .getShadow()
    .getShadowElement()
   this._graph3d = new vis.Graph3d(element, data, options)
   const throttled = lodash.throttle(evt => this._onCameraPositionChange(evt), 100)
   this._graph3d.on("cameraPositionChange", throttled)
  }
  async _onCameraPositionChange(evt) {
   // todo: throttle
   const pos = this._graph3d.getCameraPosition()
   const str = \`\${pos.distance} \${pos.horizontal} \${pos.vertical}\`
   this.touchNode("cameraPosition").setContent(str)
   await this.getTab().autosaveTab()
  }
  _treeTo3D(program) {
   // getCameraPosition
   // setCameraPosition
   // onCameraPositionChange
   const theme = this.getWebApp().getTheme()
   // todo: use node type for color.
   const tagMap = {}
   const tagTree = new jtree.TreeNode(program.toCellTypeTree())
   // const outlineFn = node => node.getIndex()
   // use language to get dict, use dict to get type overlay to get tag types.
   const randomFn = jtree.Utils.makeSemiRandomFn()
   const makeColor = word => {
    if (!tagMap[word]) tagMap[word] = randomFn() // todo: give word types certain colors. green for keword, red for error, etc
    const color = tagMap[word]
    //console.log(color)
    return color
   }
   const points = []
   const nodeToPoint = (node, index) => {
    const nodePath = node.getPathVector(program)
    const tagNode = tagTree.nodeAt(nodePath)
    node.getWords().forEach((word, wordIndex) => {
     const wordType = tagNode.getWord(wordIndex)
     const colorNumber = makeColor(wordType)
     const xcc = node.getIndentLevel(program) + wordIndex
     const ycc = -node.getLineNumber()
     const zcc = 0
     points.push({
      x: xcc,
      y: ycc,
      z: zcc,
      line: \`cellType: \${wordType} | word: \${word}\`,
      style: colorNumber
     })
    })
   }
   program.getTopDownArray().forEach(nodeToPoint)
   return points
  }
abstractProviderNode
 string tileSize 140 60
 extends abstractMaiaTileNode
 abstract
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div
    class TileBody HeaderLess
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  getTileFooterStumpCode() {
   const table = this.getOutputOrInputTable()
   const time = (this.getTimeToLoad() / 1000).toFixed(1)
   const parserId = this.getParserId()
   return \`\${this.getTileToolbarButtonStumpCode()}
  span Rows Out: \${table.getRowCount()} Columns Out: \${table.getColumnCount()} Time: \${time}s Parser: \${parserId || "?"}\${this.getErrorMessageHtml()}\`
  }
  getRowClass() {
   return Row
  }
  getTileBodyStumpCode() {
   const description = this.getDefinition().get("description")
   return "div " + (description ? jtree.Utils.linkify(description) : "")
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, { classes: this.getCssClassNames().join(" "), id: this.getTreeComponentId(), body: this._getBodyStumpCodeCache(), footer: this.getTileFooterStumpCode() })
  }
  getParserId() {
   return this.getSettingsStruct().parser
  }
  async fetchTableInputs() {
   return {
    rows: []
   }
  }
  async _executeChildNodes() {
   const timeLoadStarted = this._getProcessTimeInMilliseconds()
   this._timeLastLoadStarted = timeLoadStarted
   const fetchedTableInputs = await this.fetchTableInputs()
   // If a new request happened after this one, abort this one.
   // todo: what happens to children?
   // todo: add testing for this.
   if (this._timeLastLoadStarted !== timeLoadStarted) {
    console.log("superceded")
    return null
   }
   this._outputTable = new Table(fetchedTableInputs.rows, fetchedTableInputs.columnDefinitions, this.getRowClass())
   this._timeToLoad = this._getProcessTimeInMilliseconds() - timeLoadStarted
   this.setIsDataLoaded(true)
   await this._runChildTiles()
  }
abstractUrlNoCellsNode
 boolean useCache true
 inScope parserNode useCacheNode
 string tileSize 300 150
 extends abstractProviderNode
 abstract
 javascript
  getUrl() {
   const struct = Object.assign(this.getSettingsStruct(), this.getDefinition().getConstantsObject())
   if (struct.urlTemplate && this.getContent()) return new jtree.TreeNode({ content: this.getContent() }).evalTemplateString(struct.urlTemplate)
   if (struct.urlPrefix && this.getContent()) return struct.urlPrefix + this.getContent()
   return struct.urlCell || this.getContent() || this.url || ""
  }
  getParserId() {
   const url = this.getUrl()
   if (super.getParserId()) return super.getParserId()
   const extension = jtree.Utils.getFileExtension(url)
   if (new TableParser().getAllTableParserIds().includes(extension)) return extension
  }
  getWillowHttpResponse() {
   return this._willowHttpResponse
  }
  _setWillowHttpResponse(willowHttpResponse) {
   this._willowHttpResponse = willowHttpResponse
   return this
  }
  // todo: add support for Arrow.
  // todo: remove this cache. use higher level.
  async _getData(url) {
   const useCache = this.getSettingsStruct().useCache !== "false" || this.useCache
   const willowBrowser = this.getWebApp().getWillowBrowser()
   let response
   if (useCache) response = await willowBrowser.httpGetUrlFromCache(url)
   else response = await willowBrowser.httpGetUrl(url)
   if (response.fromCache)
    this.emitLogMessage(\`div
  bern
   Loading from cache: \${url}\`)
   this._setWillowHttpResponse(response)
   return response.getParsedDataOrText()
  }
  async fetchTableInputs() {
   let url = this.getUrl()
   if (!url) return { rows: [] }
   url = encodeURI(url)
   const parserId = this.getParserId()
   this.setRunTimePhaseError("fetchUrl")
   try {
    const data = await this._getData(url)
    const parser = new TableParser()
    return typeof data === "string" ? parser.parseTableInputsFromString(data, parserId) : parser.parseTableInputsFromObject(data, parserId)
   } catch (err) {
    // todo: solve the superagent not throwing response message thing.
    const txt = (err.text || err.toString()).substr(0, 280)
    this.emitLogMessage(\`Error getting url: \${url}<br>
   \${txt}\`)
    this.setRunTimePhaseError("fetchUrl", txt)
    return { rows: [] }
   }
  }
abstractUrlNode
 cells tileKeywordCell urlCell
 string tileSize 300 100
 extends abstractUrlNoCellsNode
 abstract
diskBrowseNode
 frequency .01
 tags localVersion
 catchAllCellType pathCell
 description An interactive list of files and folders.
 string hakonTemplate
  .DiskTile
   table
    width 100%
    td,th
     overflow hidden
     text-overflow ellipsis
    tr
     white-space nowrap
 javascript
  getUrl() {
   return this.getContent() ? "/disk?path=" + this.getContent() : "/disk"
  }
  getTileBodyStumpCode() {
   const labelCol = "name"
   const path = this.getContent() || ""
   const parentPath = path.replace(/\\/[^\\/]*$/, "")
   const rowDisplayLimit = 1000 // todo: adjustable?
   let rows = this.getOutputTable()
    .getRows()
    .slice(0, rowDisplayLimit)
   rows = lodash.sortBy(rows, row => row.getRowOriginalValue("isDirectory") === "false")
   return \`input
   placeholder Filepath
   value \${path}
   changeCommand changeTileContentAndRenderCommand
   class LargeTileInput
  table
   tr
    td
     a ..
      clickCommand changeTileContentAndRenderCommand
      value \${parentPath}
  \${rows
  .map(row => {
   const label = jtree.Utils.stripHtml(row.getRowOriginalValue(labelCol))
   const isDir = row.getRowOriginalValue("isDirectory") === "true"
   const size = row.getRowOriginalValue("bytes")
   const mtime = row.getRowOriginalValue("mtime")
   if (!isDir)
    return \` tr
    td \${label}
    td \${numeral(size).format("0.0 b")}
    td \${moment(parseFloat(mtime)).fromNow()}\`
   return \` tr
    td
     a \${label}
      clickCommand changeTileContentAndRenderCommand
      value \${path.replace(/\\/$/, "") + "/" + label}\`
  })
  .join("\\n")}\`
  }
 string tileSize 500 500
 extends abstractUrlNode
 crux disk.browse
diskReadNode
 frequency .01
 tags localVersion
 description Reads a file from disk.
 string urlPrefix /disk.read?path=
 extends abstractUrlNode
 crux disk.read
abstractHackernewsNode
 frequency .01
 tags internetConnectionRequired
 extends abstractUrlNode
 abstract
hackernewsTopNode
 cells tileKeywordCell quantityCell
 description Get the top stories on hackernews
 example A dashboard of the Hacker News homepage.
  hackernews.top 10
   rows.sortBy by
    tables.basic
     vega.scatter
      xColumn time
      yColumn score
  doc.layout tree
 javascript
  async fetchTableInputs() {
   // todo: allow cache breaking.
   const willowBrowser = this.getWebApp().getWillowBrowser()
   const firstUrls = this._getFirstUrls()
   if (!firstUrls.length || this.isNodeJs()) return []
   let allResults = []
   const fetchMethod = async url => (this.getWebApp().isUrlGetProxyAvailable() ? willowBrowser.httpGetUrlFromProxyCache(url) : willowBrowser.httpGetUrlFromCache(url))
   for (let mainUrl of firstUrls) {
    const response = await fetchMethod(mainUrl)
    const nextUrls = this._parseNextUrls(response)
    const batchResults = await Promise.all(nextUrls.slice(0, this._getLimit()).map(url => fetchMethod(url)))
    allResults = allResults.concat(batchResults)
   }
   return { rows: allResults.map(res => res.asJson) }
  }
  _getLimit() {
   return parseInt(this.getContent() || 10)
  }
  _parseNextUrls(response) {
   return response.asJson.map(id => \`https://hacker-news.firebaseio.com/v0/item/\${id}.json?print=pretty\`)
  }
  _getFirstUrls() {
   return ["https://hacker-news.firebaseio.com/v0/topstories.json?print=pretty"]
  }
 extends abstractHackernewsNode
 crux hackernews.top
hackernewsSubmissionsNode
 description Get a user's comments and submissions
 cells tileKeywordCell quantityCell
 catchAllCellType hackerNewsUserNameCell
 example View a users comment and story submissions
  hackernews.submissions 100 breck
   tables.basic
    filter.where type = story
     vega.scatter Stories
      xColumn time
      yColumn score
    filter.where type = comment
     vega.scatter Comments
      xColumn time
      yColumn score
  doc.layout tree
 javascript
  _getFirstUrls() {
   return this.getWordsFrom(2).map(username => \`https://hacker-news.firebaseio.com/v0/user/\${username}.json?print=pretty\`)
  }
  _getLimit() {
   return parseInt(this.getWord(1) || 10)
  }
  _parseNextUrls(response) {
   return response.asJson.submitted.map(id => \`https://hacker-news.firebaseio.com/v0/item/\${id}.json?print=pretty\`)
  }
 extends hackernewsTopNode
 crux hackernews.submissions
webGetNode
 description Get a URL and parse the fetched data.
 example Fetch a TSV from the web and show results
  web.get https://raw.githubusercontent.com/treenotation/ohayo/master/maia/packages/samples/iris.tsv
   tables.basic
 frequency .1
 string placeholderMessage Enter a url.
 string bodyStumpTemplate
  span {kind}
   class LargeLabel
  input
   value {content}
   placeholder {placeholderMessage}
   changeCommand changeTileContentAndRenderCommand
   class LargeTileInput
 javascript
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, { kind: this.getFirstWord(), content: this.getContent() || "", placeholderMessage: this.placeholderMessage })
  }
 string tileSize 400 100
 extends abstractUrlNode
 crux web.get
webPostNode
 frequency .02
 description Post data to a URL and parse the returned data.
 inScope postNode
 string webPostBodyStumpTemplate
  textarea
   bern
    {post}
   placeholder This data will be sent as the value of the 'q' param
   name post
   changeCommand changeTileSettingMultilineCommand
   class TileTextArea
 javascript
  getTileBodyStumpCode() {
   return super.getTileBodyStumpCode() + this.qFormat(this.webPostBodyStumpTemplate, { post: jtree.Utils.stripHtml(this.getSettingsStruct().post || "") })
  }
  async _getData(url) {
   const settings = this.getSettingsStruct()
   // todo, but make a separate tile
   // if (settings.pushButton) {
   //   if (!settings.pushed) return ""
   //   settings.pushed = false
   // }
   const postData = settings.post || ""
   const res = await this.getWebApp()
    .getWillowBrowser()
    .httpPostUrl(url, { q: postData.trim() })
   this._setWillowHttpResponse(res)
   return res.getParsedDataOrText()
  }
 string tileSize 400 130
 extends abstractUrlNode
 crux web.post
abstractFixedDatasetFromUrlNode
 description A dataset that generally is fixed and will never change.
 extends abstractUrlNoCellsNode
 abstract
abstractFixedDatasetFromMaiaCollectionNode
 description A dataset that ships with Ohayo.
 string tileSize 300 150
 javascript
  async _getData(url) {
   if (!this.isNodeJs()) return super._getData(url)
   const fs = require("fs")
   const filepath = __dirname + "/../" + url
   return fs.readFileSync(filepath, "utf8")
  }
 extends abstractFixedDatasetFromUrlNode
 abstract
cancerCasesNode
 description Estimated new cancer cases in the U.S. in 2019 from https://cancerstatisticscenter.cancer.org/
 string url maia/packages/cancer/cases.csv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux cancer.cases
kaggleDatasetsHeartNode
 tags internetConnectionRequired
 description Heart Disease dataset from https://www.kaggle.com/ronitf/heart-disease-uci
 string url maia/packages/kaggle/heart.csv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux kaggle.datasets.heart
samplesTelescopesNode
 description A partial list of humankind's largest telescopes.
 frequency .03
 example Display list of links to telescope websites.
  samples.telescopes
   list.links Name Url
 string url maia/packages/samples/telescopes.tsv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.telescopes
samplesMtcarsNode
 description Dataset from 1974 Motor Trend US magazine.
 frequency .03
 string url maia/packages/samples/mtcars.tsv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.mtcars
samplesIrisNode
 description The famous Iris flower data set.
 frequency .15
 string url maia/packages/samples/iris.tsv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.iris
samplesFlights14Node
 description On-Time flights data from the Bureau of Transporation Statistics for all the flights that departed from New York City airports in 2014. The data is available only for Jan-Oct'14.
 string url maia/packages/samples/flights14-sample.csv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.flights14
samplesSiNode
 description A description of The International System of Units (SI) aka the metric system.
 example View outline of SI system.
  samples.si
   treenotation.outline
 frequency .03
 string url maia/packages/samples/si.tree
 string parser text
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.si
samplesPortalNode
 description A list of online data portals.
 frequency .03
 string url maia/packages/samples/portals.ssv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.portals
samplesStarWarsNode
 description All Star Wars characters. Data comes from https://swapi.co/
 frequency .03
 string url maia/packages/samples/starwars.json
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.starWars
samplesPopulationsNode
 description Countries of the world and their populations.
 frequency .15
 string url maia/packages/samples/populations.tsv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.populations
samplesBabyNamesNode
 description 30 rows of a much larger dataset of baby name popularity over time in the U.S.
 frequency .03
 string url maia/packages/samples/baby-names-sample.csv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.babyNames
samplesDeclarationNode
 description The 1776 Declaration of Independence
 frequency .02
 string url maia/packages/samples/declaration-of-independence.text
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.declaration
samplesPeriodicTableNode
 description Periodic table from https://gist.github.com/GoodmanSciences
 frequency .15
 extends abstractFixedDatasetFromMaiaCollectionNode
 string url maia/packages/samples/periodic-table.csv
 crux samples.periodicTable
samplesLettersNode
 description Letter usage frequency in English from mobostock.
 frequency .03
 extends abstractFixedDatasetFromMaiaCollectionNode
 string url maia/packages/samples/letters.tsv
 crux samples.letters
samplesPresidentsNode
 description CSV of president's of United States.
 frequency .03
 string url maia/packages/samples/presidents.csv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux samples.presidents
ucimlrDatasetsNode
 description A list of datasets from the UC Irvine Machine Learning Repository at http://archive.ics.uci.edu/ml/index.php.
 frequency .001
 example Display list of datasets from UCIMLR
  ucimlr.datasets
   tables.basic
 string url maia/packages/ucimlr/datasets.tsv
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux ucimlr.datasets
vegaDataNode
 cells tileKeywordCell vegaDataSetCell
 frequency .001
 description Fetchs a Vega sample dataset
 string urlPrefix maia/packages/vega/datasets/
 extends abstractFixedDatasetFromMaiaCollectionNode
 crux vega.data
redditAllNode
 tags internetConnectionRequired
 description Fetches top stories from r/all.
 example A simple reddit dashboard
  reddit.all
   hidden
   columns.keep title created_utc score subreddit url
    hidden
    rows.sortBy score
     rows.reverse
      tables.basic Top Stories on Reddit
    vega.scatter
     yColumn score
     xColumn created_utc
  doc.layout bin
 frequency .05
 javascript
  async fetchTableInputs() {
   const inputs = await super.fetchTableInputs()
   // Todo: add tests/external dependency, as reddit API changes.
   // Here it looks like we have the equivalent of a custom parser just for a Reddit Data source.
   // todo: explore/define/typescriptAPI this custom parser pattern more. probably will be common.
   return inputs.rows.length ? { rows: inputs.rows[0].data.children.map(obj => obj.data) } : inputs
  }
  getParserId() {
   return "json"
  }
 string url https://www.reddit.com/r/all/top/.json?sort=top
 string offlineDataSet maia/packages/reddit/all.json
 extends abstractUrlNoCellsNode
 crux reddit.all
redditSubsNode
 description Fetches top subreddits.
 frequency .005
 string url https://www.reddit.com/reddits.json
 extends redditAllNode
 crux reddit.subs
redditSubNode
 cells tileKeywordCell subredditNameCell
 frequency .006
 description Fetches top stories in a subreddit.
 javascript
  getUrl() {
   const subreddit = this.getContent() || "all"
   return \`https://www.reddit.com/r/\${subreddit}/top/.json?sort=top\`
  }
 extends redditAllNode
 crux reddit.sub
abstractDummyNode
 javascript
  async _executeChildNodes() {
   this.setIsDataLoaded(true)
   await this._runChildTiles()
  }
 string tileSize 300 150
 extends abstractProviderNode
 abstract
samplesPatientsNode
 description A row for each patient in a sample clinical dataset.
 string dummyDataSetName patients
 extends abstractDummyNode
 crux samples.patients
samplesPoemNode
 description The Road Not Taken by Robert Frost
 string dummyDataSetName poem
 extends abstractDummyNode
 crux samples.poem
samplesOuterSpaceNode
 description A simple text document of major structures in the universe.
 string dummyDataSetName outerSpace
 extends abstractDummyNode
 crux samples.outerSpace
samplesTreeProgramNode
 description A simple program in a Tree Language.
 string dummyDataSetName treeProgram
 extends abstractDummyNode
 crux samples.treeProgram
samplesWaterBillNode
 description A family's water bill.
 frequency .15
 string dummyDataSetName waterBill
 extends abstractDummyNode
 crux samples.waterBill
samplesGapMinderNode
 description Health and income data from gapMinder
 frequency .15
 string dummyDataSetName gapMinder
 extends abstractDummyNode
 crux samples.gapMinder
abstractTransformerNode
 string tileSize 160 100
 extends abstractProviderNode
 string placeholderMessage 
 abstract
 string bodyStumpTemplate
  span {kind}
   class LargeLabel
  input
   value {content}
   placeholder {placeholderMessage}
   changeCommand changeTileContentAndRenderCommand
   class LargeTileInput
 javascript
  getTileFooterStumpCode() {
   const inputCount = this.getParentOrDummyTable().getRowCount()
   const outputTable = this.getOutputOrInputTable()
   return \`\${this.getTileToolbarButtonStumpCode()}
  span Rows In: \${inputCount} Rows Out: \${outputTable.getRowCount()} Columns Out: \${outputTable.getColumnCount()}\`
  }
  async _executeChildNodes() {
   this._outputTable = this._createOutputTable()
   this.setIsDataLoaded(true)
   await this._runChildTiles()
  }
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, { kind: this.getFirstWord(), content: this.getContent() || "", placeholderMessage: this.placeholderMessage })
  }
abstractColumnAdderTileNode
 abstract
 extends abstractTransformerNode
 javascript
  _createOutputTable() {
   return this.getParentOrDummyTable().addColumns(this.getNewColumns())
  }
dateAddColumnsNode
 description Takes an input table with a time column and adds a day, month and year column.
 catchAllCellType dateColumnTypeCell
 inScope sourceColumnNode
 string columnPredictionHints
  sourceColumn isTemporal=true
 extends abstractColumnAdderTileNode
 crux date.addColumns
 string placeholderMessage Enter the source column and new date columns you want, or leave blank to get 'day month year'.
 javascript
  getNewColumns() {
   const inputColumnName = this.getSettingsStruct().sourceColumn // todo: this is probably broken. need to fix settings timing issues.
   if (!inputColumnName) return []
   const addColumns = this.getContent() ? this.getWordsFrom(1) : ["day", "week", "month"]
   // what happened to dayName? timeOfDay?
   return addColumns.map(outputCol => {
    return {
     source: inputColumnName,
     name: outputCol,
     type: outputCol
    }
   })
  }
mathLogNode
 description Add a column that is the natural log (base e) of another column.
 cells tileKeywordCell columnNameCell
 extends abstractColumnAdderTileNode
 crux math.log
 javascript
  getNewColumns() {
   const inputColumnName = this.getWord(1)
   if (!inputColumnName) return []
   const inputCol = this.getParentOrDummyTable().getColumnByName(inputColumnName)
   return [
    {
     source: inputColumnName,
     name: inputColumnName + "Log",
     type: inputCol.getPrimitiveTypeName(),
     mathFn: Math.log
    }
   ]
  }
rowsAddIndexColumnNode
 description Add an index column to the data.
 extends abstractColumnAdderTileNode
 crux rows.addIndexColumn
 javascript
  getNewColumns() {
   let index = 0
   return [
    {
     name: "index",
     accessorFn: row => index++
    }
   ]
  }
rowsRunningTotalNode
 cells tileKeywordCell columnNameCell
 description Add a column that accumulates the running total of a column.
 extends abstractColumnAdderTileNode
 crux rows.runningTotal
 javascript
  getNewColumns() {
   const sourceColumnName = this.getWord(1)
   let total = 0
   return [
    {
     source: sourceColumnName,
     name: "total",
     accessorFn: row => {
      total += row[sourceColumnName]
      return total
     }
    }
   ]
  }
textLengthNode
 cells tileKeywordCell columnNameCell
 description Add a column which contains the string length of the given column.
 example Show the largest words in declaration of independence
  samples.declaration
   text.wordCount
    text.length word
     filter.where wordLength > 5
      rows.sortByReverse wordLength
       tables.basic
 javascript
  getNewColumns() {
   const sourceColumnName = this.getWord(1)
   const destinationColumnName = sourceColumnName + "Length"
   return [
    {
     source: sourceColumnName,
     name: destinationColumnName,
     accessorFn: row => row[sourceColumnName].length
    }
   ]
  }
 extends abstractColumnAdderTileNode
 crux text.length
textSplitNode
 description Split one column into multiple by a string
 cells tileKeywordCell columnNameCell delimiterCell
 catchAllCellType newColumnNamesCell
 example Split a filename into name and extension
  vega.data descriptions.json
   text.split filename . name extension
    tables.basic
 string dummyDataSetName poem
 javascript
  // note: delimiter can probably be ""
  // todo: how would we split on a space???
  // perhaps its better to use getContent() as delimiter, and if you want to name the columns, you can do that later?
  getNewColumns() {
   const sourceColumnName = this.getWord(1)
   const delimiter = this.getWord(2)
   const destinationColumns = this.getWordsFrom(3)
   return destinationColumns.map((destinationColumnName, index) => {
    return {
     source: sourceColumnName,
     name: destinationColumnName,
     accessorFn: row => row[sourceColumnName].split(delimiter)[index]
    }
   })
   return [
    {
     source: sourceColumnName,
     name: destinationColumnName,
     accessorFn: row => row[sourceColumnName].length
    }
   ]
  }
 extends abstractColumnAdderTileNode
 crux text.split
textToLowerCaseNode
 description Convert all cells in a column to LowerCase text
 cells tileKeywordCell columnNameCell
 example Select the first character of someone's name
  samples.declaration
   text.wordCount
    tables.basic
   text.toLowerCase text
    tables.basic
 string dummyDataSetName poem
 javascript
  getNewColumns() {
   const sourceColumnName = this.getWord(1) || "text"
   return [
    {
     source: sourceColumnName,
     name: sourceColumnName,
     accessorFn: row => row[sourceColumnName].toLowerCase()
    }
   ]
  }
 extends abstractColumnAdderTileNode
 crux text.toLowerCase
textSubstringNode
 description Extract parts of one column into another column.
 cells tileKeywordCell columnNameCell newColumnNameCell startIndexCell lengthCell
 example Select the first character of someone's name
  samples.presidents
   text.substring name firstLetter 0 1
    tables.basic
 string dummyDataSetName poem
 extends abstractColumnAdderTileNode
 crux text.substring
 javascript
  getNewColumns() {
   const sourceColumnName = this.getWord(1)
   const destinationColumnName = this.getWord(2)
   const startPosition = parseInt(this.getWord(3))
   const endPosition = this.getWord(4) === undefined ? undefined : parseInt(this.getWord(4))
   return [
    {
     source: sourceColumnName,
     name: destinationColumnName,
     accessorFn: row => (row[sourceColumnName] ? row[sourceColumnName].substr(startPosition, endPosition) : "")
    }
   ]
  }
abstractNewRowsTransformerTileNode
 abstract
 extends abstractTransformerNode
 javascript
  _createOutputTable() {
   // todo: remove this
   return new Table(this.makeNewRows())
  }
columnsDescribeNode
 description Computes statistics for each input column.
 example List column information
  samples.iris
   columns.describe
 extends abstractNewRowsTransformerTileNode
 crux columns.describe
 javascript
  makeNewRows() {
   return this.getParentOrDummyTable().getColumnNamesAndTypesAndReductions()
  }
columnsListNode
 description Provides a list of table columns and their types.
 example List columns
  samples.iris
   columns.list
 extends columnsDescribeNode
 crux columns.list
 javascript
  makeNewRows() {
   return this.getParentOrDummyTable().getColumnNamesAndTypes()
  }
dataEvalNode
 description Passes input rows, if any, to a Javascript function and returns transformed or new rows.
 example Generate some data.
  data.eval
   content
    inputRows => [{name: "Swift", year: 2015}, {name: "Kotlin", year: 2011}]
   tables.basic
 inScope contentNode
 extends abstractNewRowsTransformerTileNode
 crux data.eval
 javascript
  makeNewRows() {
   const node = this.getNode(this.contentKey)
   const code = node && node.childrenToString() // "rows => { return []}"
   let fn
   try {
    fn = code && eval(code)
   } catch (err) {
    // todo: warn user
    console.error(err)
   }
   const inputRows = this.getParentOrDummyTable().cloneNativeJavascriptTypedRows()
   return fn ? fn(inputRows) : inputRows
  }
joinByNode
 catchAllCellType columnNameCell
 description Combines multiple tables into one, linking the rows by the provided key column.
 extends abstractNewRowsTransformerTileNode
 crux join.by
 javascript
  makeNewRows() {
   // Todo: move to table project
   const parentTile = this.getParent()
   if (parentTile.isRoot()) return []
   const grandParentTile = parentTile.getParent()
   if (grandParentTile.isRoot()) return parentTile.getOutputOrInputTable().cloneNativeJavascriptTypedRows()
   const tiles = [parentTile, grandParentTile]
   const arrays = tiles.map(tile => tile.getOutputOrInputTable().cloneNativeJavascriptTypedRows())
   const joinOn = this.getContent()
   if (!joinOn) return jtree.Utils.flatten(arrays)
   const cols = tiles.map(tile => tile.getOutputOrInputTable().getColumnNames())
   return jtree.Utils.joinArraysOn(joinOn, arrays, cols)
  }
matchColumnsFuzzyNode
 description Attempts to fuzzy match words in one column of parent table against words in a column in grandparent table.
 cells tileKeywordCell needleColumnNameCell haystackColumnNameCell
 example Try to match different spellings of country names.
  samples.gapMinder
   samples.populations
    match.columnsFuzzy Country country
     rows.sortBy confidence
      rows.reverse
       tables.basic
 string tileScript maia/packages/match/fuse.min.js
 extends abstractNewRowsTransformerTileNode
 crux match.columnsFuzzy
 javascript
  makeNewRows() {
   // Todo: move some of this logic to table project?
   const parentTile = this.getParent()
   if (parentTile.isRoot()) return []
   const grandParentTile = parentTile.getParent()
   if (grandParentTile.isRoot()) return parentTile.getOutputOrInputTable().cloneNativeJavascriptTypedRows()
   const tiles = [parentTile, grandParentTile]
   const arrays = tiles.map(tile => tile.getOutputOrInputTable().cloneNativeJavascriptTypedRows())
   return this._addFuzz(arrays[0], arrays[1])
  }
  get fuse() {
   return this.isNodeJs() ? require("fuse.js") : Fuse
  }
  _addFuzz(needles, haystacks) {
   const needleColumnName = this.getWord(1) || "name"
   const haystackColumnName = this.getWord(2) || "name"
   const options = {
    shouldSort: true,
    includeScore: true,
    threshold: 0.6,
    location: 0,
    distance: 100,
    maxPatternLength: 32,
    minMatchCharLength: 1,
    keys: [haystackColumnName]
   }
   const fuse = new this.fuse(haystacks, options) // "list" is the item array
   return needles.map(needle => {
    const searchValue = needle[needleColumnName]
    const result = fuse.search(searchValue)
    if (!result.length)
     return {
      search: searchValue,
      match: ""
     }
    const match = result[0]
    return {
     search: searchValue,
     match: match.item[haystackColumnName],
     confidence: parseFloat((1 - match.score).toFixed(3))
    }
   })
  }
textWordCountNode
 description Splits a string into words and counts the number of uses of each word.
 string dummyDataSetName poem
 extends abstractNewRowsTransformerTileNode
 crux text.wordCount
 javascript
  makeNewRows() {
   return this._getAllWords(this.getPipishInput())
  }
  _getAllWords(text) {
   const rows = []
   if (!text) return rows
   const words = text
    .split(/\\s/g)
    .map(word => word.replace(/[^a-z0-9\\-]/gi, ""))
    .filter(word => word)
   const index = {}
   words.forEach(word => {
    if (!index[word]) index[word] = 1
    else index[word]++
   })
   Object.keys(index).forEach(word => {
    const trimmedWord = word.trim()
    if (trimmedWord)
     rows.push({
      word: trimmedWord,
      count: index[trimmedWord]
     })
   })
   return rows
  }
textLineCountNode
 description Counts the number of lines in the input data.
 string dummyDataSetName poem
 javascript
  makeNewRows() {
   return [{ lines: this.getPipishInput().split(/\\n/g).length }]
  }
 extends abstractNewRowsTransformerTileNode
 crux text.lineCount
treenotationWordTypesNode
 description Generates the word types for a Tree Language program.
 example See counts of word types in a Tree Language program.
  treenotation.wordTypes
   treenotation.outline
   text.wordCount
    tables.basic
 string dummyDataSetName treeProgram
 extends abstractNewRowsTransformerTileNode
 crux treenotation.wordTypes
 javascript
  makeNewRows() {
   const sourceCode = this.getPipishInput()
   const app = this.getWebApp()
   const language = app.getLanguageBestGuess(sourceCode) // todo: use treeLanguage setting
   const program = app.generateProgram(sourceCode, language)
   return [{ text: program.toCellTypeTree() }]
  }
abstractColumnFilterTileNode
 abstract
 extends abstractTransformerNode
 javascript
  _createOutputTable() {
   return this.getParentOrDummyTable().dropAllColumnsExcept(this.getColumnNamesToKeep())
  }
columnsFirstNode
 cells tileKeywordCell intCell
 description Keeps only the first N columns.
 example Drop all but first column
  samples.iris
   columns.first 1
    tables.basic
 extends abstractColumnFilterTileNode
 crux columns.first
 string placeholderMessage Enter the number of columns you want to keep
 javascript
  getColumnNamesToKeep() {
   return this.getParentOrDummyTable()
    .getColumnsArrayOfObjects()
    .slice(0, parseInt(this.getContent()))
    .map(col => col.name)
  }
columnsLastNode
 cells tileKeywordCell intCell
 description Keeps only the last N columns.
 example Drop all but 1 column
  samples.iris
   columns.last 1
    tables.basic
 extends abstractColumnFilterTileNode
 crux columns.last
 string placeholderMessage Enter the number of columns you want to keep
 javascript
  getColumnNamesToKeep() {
   const cols = this.getParentOrDummyTable().getColumnsArrayOfObjects()
   return cols.slice(cols.length - parseInt(this.getContent())).map(col => col.name)
  }
columnsDropNode
 description Drop certain columns. Inverse of columns.keep.
 extends abstractColumnFilterTileNode
 example
  samples.iris
   show.columnCount
   columns.drop Petal.Length
    show.columnCount
 crux columns.drop
 catchAllCellType columnNameCell
 javascript
  getColumnNamesToKeep() {
   const colsToDrop = this.getWordsFrom(1)
   return this.getParentOrDummyTable()
    .getColumnsArrayOfObjects()
    .filter(col => !colsToDrop.includes(col.name))
    .map(col => col.name)
  }
columnsDropConstantsNode
 description Drop any columns that contain only a single value.
 extends abstractColumnFilterTileNode
 example
  data.inline
   content
    state,country
    hawaii,usa
    maine,usa
   show.columnCount
   columns.dropConstants
    show.columnCount
 crux columns.dropConstants
 javascript
  getColumnNamesToKeep() {
   return this.getParentOrDummyTable()
    .getColumnsArray()
    .filter(col => col.getReductions().uniqueValues > 1)
    .map(col => col.getColumnName())
  }
columnsKeepNode
 catchAllCellType columnNameCell
 description Keep only the named columns
 example Show 2 columns
  samples.iris
   columns.keep Species Petal.Length
    tables.basic
 extends abstractColumnFilterTileNode
 crux columns.keep
 string placeholderMessage Enter the columns to keep.
 javascript
  getColumnNamesToKeep() {
   const colsToKeep = this.getWordsFrom(1)
   return this.getParentOrDummyTable()
    .getColumnsArrayOfObjects()
    .filter(col => colsToKeep.includes(col.name))
    .map(col => col.name)
  }
abstractTransformerNoParamsTileNode
 abstract
 extends abstractTransformerNode
 javascript
  getTileBodyStumpCode() {
   return \`span \${this.getFirstWord()}
  class LargeLabel\`
  }
rowsShuffleNode
 description Shuffle the rows into a random order.
 extends abstractTransformerNoParamsTileNode
 crux rows.shuffle
 javascript
  _createOutputTable() {
   return this.getParentOrDummyTable().shuffleRows()
  }
rowsReverseNode
 description Reverse the order of the rows
 extends abstractTransformerNoParamsTileNode
 crux rows.reverse
 javascript
  _createOutputTable() {
   return this.getParentOrDummyTable().reverseRows()
  }
abstractRowFilterTileNode
 abstract
 extends abstractTransformerNode
 string placeholderMessage Enter a string to filter by.
 javascript
  // todo: pass thru.
  // todo: remove this?
  _createOutputTable() {
   const fn = this.getRowFilterFn()
   if (!fn) return this.getParentOrDummyTable().clone()
   return this.getParentOrDummyTable().filterRowsByFn(fn)
  }
filterWhereNode
 description Each row must meet a certain condition
 cells tileKeywordCell columnNameCell comparisonCell scalarValueCell
 example Select rows by a certain text column
  samples.iris
   show.rowCount
   filter.where Species = setosa
    show.rowCount
 frequency .01
 string tileSize 250 100
 extends abstractRowFilterTileNode
 crux filter.where
 javascript
  _createOutputTable() {
   // todo: use cells here.
   const columnName = this.getWord(1)
   const comparison = this.getWord(2)
   let untypedScalarValue = this.getWord(3)
   const table = this.getParentOrDummyTable()
   if (!columnName || !comparison || untypedScalarValue === undefined) return table.clone()
   const column = table.getColumnByName(columnName)
   if (!column) return table
   return table.filterClonedRowsByScalar(columnName, comparison, untypedScalarValue)
  }
rowsDropIfMissingNode
 cells tileKeywordCell columnNameCell
 description Drop a row if it is missing a value in a column.
 extends filterWhereNode
 crux rows.dropIfMissing
 javascript
  getRowFilterFn() {
   const column = this.getContent()
   return row => row[column] !== ""
  }
filterWithNode
 description Each row must contain all of these words
 frequency .01
 catchAllCellType stringCell
 string tileSize 250 100
 extends abstractRowFilterTileNode
 crux filter.with
 boolean expectedBooleanValue true
 javascript
  getRowFilterFn() {
   const words = this.getWordsFrom(1)
   // todo: problem here is, getRows has too many columns if after a transformed column.
   const rows = this.getParentOrDummyTable().getRows()
   if (!words.length) return undefined
   const len = words.length
   const expectedValue = this.expectedBooleanValue
   return row => {
    const str = JSON.stringify(row)
    for (let index = 0; index < len; index++) {
     if (str.includes(words[index]) !== expectedValue) return false
    }
    return true
   }
  }
filterWithoutNode
 description Each row CANNOT contain any of these words
 extends filterWithNode
 crux filter.without
 boolean expectedBooleanValue false
rowsFirstNode
 cells tileKeywordCell intCell
 description Return the first N rows.
 extends abstractRowFilterTileNode
 crux rows.first
 javascript
  getRowFilterFn() {
   const limit = parseInt(this.getContent())
   if (isNaN(limit)) return undefined
   return (row, rowIndex) => rowIndex < limit
  }
rowsLastNode
 cells tileKeywordCell intCell
 description Return the last N rows.
 extends abstractRowFilterTileNode
 crux rows.last
 javascript
  getRowFilterFn() {
   const limit = parseInt(this.getContent())
   if (isNaN(limit)) return undefined
   const start = this.getParentOrDummyTable().getRowCount() - limit
   return (row, rowIndex) => rowIndex >= start
  }
columnsSetTypeNode
 cells tileKeywordCell columnNameCell primitiveTypeCell
 description Ohayo attempts to choose the correct primitive type, but you can override the default with this tile.
 example List column information
  samples.waterBill
   columns.keep Amount Gallons
    columns.setType Gallons year
     columns.describe
      tables.basic
 extends abstractTransformerNode
 crux columns.setType
 javascript
  _createOutputTable() {
   const colToChange = this.getWord(1)
   const newType = this.getWord(2)
   return this.getParentOrDummyTable().changeColumnType(colToChange, newType)
  }
groupByNode
 frequency .01
 catchAllCellType columnNameCell
 inScope reduceNode
 description Group rows with the same value for a column into one row and provide summary columns.
 example Group rows and display counts for each group.
  samples.iris
   group.by Species
    tables.basic
 extends abstractTransformerNode
 crux group.by
 string placeholderMessage Enter the column to groupby.
 javascript
  _createOutputTable() {
   const groupByColNames = this.getWordsFrom(1)
   if (!groupByColNames.length) return this.getParentOrDummyTable().clone()
   const newCols = this.findNodes("reduce").map(reduceNode => {
    return {
     source: reduceNode.getWord(1),
     reduction: reduceNode.getWord(2),
     name: reduceNode.getWord(3) || reduceNode.getWordsFrom(1).join("_")
    }
   })
   return this.getParentOrDummyTable().makePivotTable(groupByColNames, newCols)
  }
rowsSortByNode
 catchAllCellType columnNameCell
 description Sort the rows by a column(s) from smallest to largest.
 example See cheaptest and most expensive months in a family's water bills
  samples.waterBill
   rows.sortBy Amount
    rows.first 1
     tables.basic Cheapest month
    rows.reverse
     rows.first 1
      tables.basic Most expensive
  doc.layout tiled
 extends abstractTransformerNode
 crux rows.sortBy
 string placeholderMessage Columns you want to sort by
 javascript
  _createOutputTable() {
   const table = this.getParentOrDummyTable().sortBy(this.getWordsFrom(1))
   if (this.getFirstWord().includes("Reverse")) return table.reverseRows()
   return table
  }
rowsSortByReverseNode
 description Sort the rows by a column(s) from largest to smallest.
 extends rowsSortByNode
 crux rows.sortByReverse
rowsAddOneNode
 description Add a single row to the parent table, in space-separated value format
 catchAllCellType anyCell
 extends abstractTransformerNode
 crux rows.addOne
 javascript
  _createOutputTable() {
   return this.getParentOrDummyTable().addRow(this.getWordsFrom(1))
  }
dataInlineNode
 inScope contentNode parserNode treeLanguageNode
 frequency .2
 description Store data in your doc, in CSV, TSV, JSON, and other formats.
 example
  data.inline
   parser csv
   content
    petal_length,petal_width,species
    4.9,1.8,virginica
    4.9,2,virginica
    1.5,0.2,setosa
 string bodyStumpTemplate
  textarea
   name content
   changeCommand changeTileSettingMultilineCommand
   placeholder Enter data in any format here. It will be saved directly in your document.
   class TileTextArea savable
   bern
    {text}
 javascript
  getDataContent() {
   const node = this.getNode("content")
   return node ? node.childrenToString() : ""
  }
  getTileBodyStumpCode() {
   const text = lodash.escape(this.getDataContent())
   return this.qFormat(this.bodyStumpTemplate, { text })
  }
  getRowClass() {
   class InlineDataTileRow extends Row {}
   return InlineDataTileRow
  }
  getParserId() {
   return super.getParserId() || new TableParser().guessTableParserId(this.getDataContent())
  }
  async fetchTableInputs() {
   return new TableParser().parseTableInputsFromString(this.getDataContent(), this.getParserId())
  }
 string tileSize 280 220
 extends abstractProviderNode
 crux data.inline
dataLocalStorageNode
 cells tileKeywordCell localStorageKeyCell
 description Use your browser's localStorage for storing data.
 string bodyStumpTemplate
  textarea
   changeCommand triggerTileMethodCommand
   placeholder Enter data in any format here. It will be saved in your browser's localStorage.
   name storeValueCommand
   class TileTextArea savable
   bern
    {text}
 example
  data.localStorage a-dropped-file.csv
 javascript
  // Note: for now, only way to clear a key is to do it manually through UI (select all delete) or console. That might be good enough.
  _getStoreKey() {
   return this.getContent()
  }
  getDataContent() {
   const key = this._getStoreKey()
   return key ? this.getWebApp().getFromStore(key) || "" : ""
  }
  storeValueCommand(value) {
   let key = this._getStoreKey()
   if (key) this.getWebApp().storeValue(key, value)
   else this.setContent(this.getWebApp().initLocalDataStorage(this.constructor.name + ".data", value))
  }
  getTileBodyStumpCode() {
   const text = encodeURIComponent(this.getDataContent())
   return this.qFormat(this.bodyStumpTemplate, { text })
  }
 extends dataInlineNode
 crux data.localStorage
debugParserTestNode
 description Dumps data on why a certain file parser was chosen.
 example See why a certain file parser was chosen.
  vega.data descriptions.json
   debug.parserTest
    tables.basic
 extends abstractProviderNode
 crux debug.parserTest
 javascript
  async fetchTableInputs() {
   const parentTile = this.getParent()
   if (parentTile.getWillowHttpResponse) {
    const probs = new TableParser().guessProbabilitiesForAllTableParsers(parentTile.getWillowHttpResponse().text)
    return {
     rows: Object.keys(probs).map(key => {
      return {
       parser: key,
       probability: probs[key]
      }
     })
    }
   }
   return [{ rows: [] }]
  }
editorFilesNode
 description Fetch your files in the current working folder.
 example
  editor.files
   editor.gallery
 string tileSize 140 120
 javascript
  getRowClass() {
   class FileRow extends Row {
    destroyRow(app) {
     return app.deleteFileCommand(this.getRowOriginalValue("link"))
    }
   }
   return FileRow
  }
  getTileHeaderBern() {
   return this.getWebApp()
    .getDefaultDisk()
    .getPathBase()
  }
  async fetchTableInputs() {
   const files = await this.getWebApp()
    .getDefaultDisk()
    .readFiles()
   return { rows: files.map(file => file.toFileObject()) }
  }
 extends abstractProviderNode
 crux editor.files
editorCommandHistoryNode
 description Outputs row for each command executed in this Ohayo session.
 example Show what you've done in this tab session.
  editor.commandHistory
   tables.basic
 javascript
  async fetchTableInputs() {
   return { rows: this.getWebApp()[this.methodName]() }
  }
 string methodName getCommandsBuffer
 extends abstractProviderNode
 crux editor.commandHistory
mathGenNode
 description Generate a stream of numbers from common mathematical functions
 cells tileKeywordCell mathFunctionNameCell fromCell toCell incrementCell
 extends abstractProviderNode
 example
  math.gen sin 0 10 .1
   vega.scatter
    xColumn input
    yColumn output
 crux math.gen
 javascript
  async fetchTableInputs() {
   const rows = []
   const fn = Math[this.getWord(1)]
   for (let input = parseFloat(this.fromCell); input < parseFloat(this.toCell); input += parseFloat(this.incrementCell)) {
    rows.push({ input, output: fn(input) })
   }
   return {
    rows
   }
  }
abstractRandomTileNode
 abstract
 extends abstractProviderNode
 javascript
  async fetchTableInputs() {
   let howMany = this.quantityCell || 30
   const rows = []
   for (let index = 1; index <= howMany; index++) {
    rows.push(this._genRow(index))
   }
   return { rows }
  }
randomFloatNode
 description Generates uniform random floats between min and max.
 cells tileKeywordCell quantityCell minCell maxCell
 example Get 10 random probabilities above .5
  random.float 10 .5 1
 float min 0
 float max 1
 javascript
  _genRow(index) {
   return { index, number: jtree.Utils.randomUniformFloat(this.minCell, this.maxCell, Math.random()) }
  }
 extends abstractRandomTileNode
 crux random.float
randomIntNode
 description Generates uniform random ints between min and max.
 cells tileKeywordCell quantityCell minCell maxCell
 example Get 30 random numbers between 0 and 100
  random.int 30 0 100
 int min 0
 int max 100
 javascript
  _genRow(index) {
   return { index, number: jtree.Utils.randomUniformInt(this.minCell, this.maxCell, Math.random()) }
  }
 crux random.int
 extends abstractRandomTileNode
samplesTinyIrisNode
 description A snippet of the Iris dataset.
 string data
  petal_length,petal_width,species
  4.9,1.8,virginica
  4.2,1.3,versicolor
  4.9,2,virginica
  1.5,0.2,setosa
 extends abstractProviderNode
 crux samples.tinyIris
 string bodyStumpTemplate
  pre
   class TileSelectable
   style overflow: scroll; max-height: 100%;
   bern
    {text}
 javascript
  getDataContent() {
   return this.data
  }
  getTileBodyStumpCode() {
   return this.qFormat(this.bodyStumpTemplate, { text: this.getDataContent() })
  }
  getParserId() {
   return super.getParserId() || new TableParser().guessTableParserId(this.getDataContent())
  }
  async fetchTableInputs() {
   return new TableParser().parseTableInputsFromString(this.getDataContent(), this.getParserId())
  }
toCsvNode
 description Print input table to console as csv.
 extends abstractMaiaTileNode
 crux shell.csv
 javascript
  execute() {
   console.log(this.getParentOrDummyTable().toDelimited(","))
  }
abstractTemplatePickerTileNode
 extends abstractMaiaTileNode
 todo This is duplicate code from picker. Add mixins to Grammar?
 string tileSize 480 420
 abstract
 string hakonTemplate
  .abstractTemplatePickerTileNode
   .PickerCategory
    width 100%
    margin-top 20px
    text-align center
   .TileBody
    display flex
    flex-flow row wrap
    a
     &:hover
      background-color {borderColor}
     padding 10px
     margin 5px
     height 30px
     background-color {backgroundColor}
     border 1px solid {borderColor}
     overflow hidden
     text-align center
     text-overflow ellipsis
     font-size 14px
     width 120px
     span
      font-size 70%
 string itemStumpTemplate
  {categoryBreak}
  a {name}
   br
    span {description}
   title {description}
   tabindex -1
   value {value}
   class pickerItemButton
   clickCommand {command}
 string categoryBreakStumpTemplate
  div {category}
   class PickerCategory
 string tileHeader Gallery
 javascript
  async fetchTableInputs() {
   return { rows: this.getChoices().map(obj => obj.toObject()) }
  }
  getTileBodyStumpCode() {
   let lastCat = ""
   return this.getChoices()
    .map(choice => {
     choice.categoryBreak = lastCat !== choice.category ? this.qFormat(this.categoryBreakStumpTemplate, { category: choice.category }) : ""
     lastCat = choice.category
     return this.qFormat(this.itemStumpTemplate, choice)
    })
    .join("\\n")
  }
  getTileHeaderBern() {
   return this.tileHeader
  }
templatesListNode
 extends abstractTemplatePickerTileNode
 description Displays list of available templates.
 frequency .11
 crux templates.list
 string tileHeader Template Gallery
 javascript
  getChoices() {
   // todo: cleanup.
   const choices = this._getTheTemplates().map(node => {
    const id = node
     .getWord(1)
     .replace("templates/", "")
     .replace(this.maiaFileExtensionKey, "")
    return {
     command: "createProgramFromTemplateCommand",
     name: node.get("data doc.title"),
     value: id,
     category: lodash.upperFirst(node.get("data doc.categories")),
     description: ""
    }
   })
   return lodash.sortBy(choices, "category")
  }
  _getTheTemplates() {
   // todo: trim?
   return typeof TemplatesStamp === "undefined" ? jtree.TreeNode.fromDisk("maia/packages/templates/Templates.stamp").trim() : new jtree.TreeNode(TemplatesStamp).trim()
  }
  getProgramTemplate(id) {
   const node = this._getTheTemplates().filter(node => node.getContent() === \`templates/\${id}\${this.maiaFileExtensionKey}\`)[0]
   return {
    template: node.getNode("data").childrenToString(),
    name: id + this.maiaFileExtensionKey
   }
  }
tileBlankLineNode
 boolean visible false
 pattern ^$
 tags doNotSynthesize
 cells emptyCell
abstractDocSettingNode
 cells tileKeywordCell
 abstract
 boolean visible false
docCategoriesNode
 extends abstractDocSettingNode
 crux doc.categories
 description Add some categories to the document for organization.
 catchAllCellType documentCategoryCell
docAuthorNode
 extends abstractDocSettingNode
 catchAllCellType stringCell
 crux doc.author
 description Add one author per line.
docDefaultHiddenNode
 crux doc.defaultHidden
 example
  doc.defaultHidden
  samples.portals
   tables.basic
    visible
 description Change default tile visibility to hidden.
 cells tileKeywordCell
 extends abstractDocSettingNode
docDateNode
 description Date published.
 extends abstractDocSettingNode
 crux doc.date
 catchAllCellType dateCell
docZoomNode
 crux doc.zoom
 description Enlarge or shrink all tiles
 cells tileKeywordCell zoomCell
 extends abstractDocSettingNode
docLayoutNode
 cells tileKeywordCell docLayoutOptionCell
 extends abstractDocSettingNode
 crux doc.layout
abstractDocSectionComponentNode
 abstract
docSectionSubtitleNode
 extends abstractDocSectionComponentNode
 crux subtitle
 cells tileKeywordCell
 catchAllCellType stringCell
 javascript
  compile() {
   return \`h2 \${this.getContent()}\`
  }
docSectionParagraphNode
 extends abstractDocSectionComponentNode
 crux paragraph
 cells tileKeywordCell
 catchAllCellType stringCell
 catchAllNodeType docParagraphLineNode
 string stumpTemplate
  p
   bern
    {content}
 javascript
  compile() {
   return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getContentWithChildren() })
  }
docSectionLinkNode
 extends abstractDocSectionComponentNode
 crux link
 cells tileKeywordCell urlCell
 catchAllCellType stringCell
 string stumpTemplate
  a {content}
   href {url}
 javascript
  compile() {
   return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getWordsFrom(2).join(" "), url: this.getWord(1) })
  }
 example
  doc.section
   link http://ohayo.computer Ohayo
docSectionCodeNode
 extends abstractDocSectionComponentNode
 crux code
 cells tileKeywordCell programmingLanguageNameCell
 catchAllNodeType docLineOfCodeNode
 string stumpTemplate
  code
   bern
    {content}
 javascript
  compile() {
   return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.childrenToString().replace(/</g, "&lt;") })
  }
 example
  doc.section
   subtitle Some Code
   code latex
    E_0 &= mc^2
    E &= \\frac{mc^2}{\\sqrt{1-\\frac{v^2}{c^2}}}
docLineOfCodeNode
 catchAllCellType codeCell
 catchAllNodeType docLineOfCodeNode
docParagraphLineNode
 catchAllCellType stringCell
 catchAllNodeType docParagraphLineNode
commentLineNode
 catchAllCellType commentCell
 catchAllNodeType commentLineNode
docReferenceUrlNode
 crux url
 cells tileSettingKeywordCell urlCell
 description URL for the reference
catchAllErrorNode
 catchAllCellType errorCell
 baseNodeType errorNode
hashBangNode
 crux #!
 description Standard bash hashBang line.
 catchAllCellType hashBangWordCell
tilesNode
 root
 todo skipBlankLines
 _rootNodeJsHeader
  const projectRootDir = jtree.Utils.findProjectRoot(__dirname, "ohayo")
  const { AbstractTreeComponent } = require(projectRootDir + "node_modules/jtree/products/TreeComponentFramework.node.js")
  const TilesConstants = require(projectRootDir + "ohayoWebApp/tiles/TilesConstants.js")
  const OhayoConstants = require(projectRootDir + "ohayoWebApp/treeComponents/OhayoConstants.js")
  const Layout = require(projectRootDir + "ohayoWebApp/tiles/Layout.js")
  const Icons = require(projectRootDir + "ohayoWebApp/themes/Icons.js")
  const lodash = require(projectRootDir + "node_modules/lodash")
 _extendsJsClass AbstractTreeComponent
 catchAllNodeType DidYouMeanTileNode
 string wallType wall
 javascript
  getTileClosestToLine(lineIndex) {
   let current = this.nodeAtLine(lineIndex)
   while (current) {
    if (current.doesExtend("abstractTileTreeComponentNode")) return current
    current = current.getParent()
   }
  }
  setTab(tab) {
   this._tab = tab
  }
  getTheme() {
   const tab = this.getTab()
   return tab ? tab.getTheme() : super.getTheme()
  }
  getTab() {
   return this._tab
  }
  tilesAreVisible() {
   return !this.has(TilesConstants.defaultHidden)
  }
  canUseCustomLayout() {
   const definedLayout = this.get(TilesConstants.layout)
   if (definedLayout === TilesConstants.layouts.custom) return true
   if (this.getTiles().some(tile => tile.has(TilesConstants.left) || tile.has(TilesConstants.top))) return true
   return false
  }
  _getLayoutStrategy() {
   const definedLayout = this.get(TilesConstants.layout)
   return definedLayout || (this.wallType === OhayoConstants.flex ? (this.canUseCustomLayout() ? TilesConstants.layouts.custom : TilesConstants.layouts.tiled) : TilesConstants.layouts.tree)
  }
  getTileDimensionMap(width, height) {
   // todo: cache?
   return new Layout().getTileDimensionMap(this, this._getLayoutStrategy(), width, height)
  }
  async loadAndIncrementalRender() {
   const app = this.getTab().getRootNode()
   await Promise.all(this.getTiles().map(tile => tile.loadRequirements()))
   await Promise.all(
    this.getRootLevelTiles().map(async tile => {
     await tile.execute()
     app.renderApp()
    })
   )
   app.renderApp() // this one might be superfluous
   return this
  }
  getTiles() {
   return this.getTopDownArray().filter(node => node.doesExtend("abstractTileTreeComponentNode"))
  }
  getRootLevelTiles() {
   return this.filter(node => node.doesExtend("abstractTileTreeComponentNode"))
  }
  _getProjectRootDir() {
   return this.isNodeJs() ? jtree.Utils.findProjectRoot(__dirname, "ohayo") : ""
  }
  toRunTimeStats() {
   const tiles = this.getTiles()
   const stats = {
    tiles: tiles.length,
    treeLanguage: this.getGrammarProgram().getExtensionName(),
    url: this.getTab().getFileName()
   }
   stats.timeToLoad = this.getTiles()
    .map(tile => tile.getTimeToLoad())
    .sort()
    .reverse()[0]
   stats.timeToRender = this.getTiles()
    .map(tile => tile.getNewestTimeToRender())
    .sort()
    .reverse()[0]
   return stats
  }
maiaNode
 compilesTo html
 root
 _rootNodeJsHeader
  const { Table, DummyDataSets, Row, TableParser } = require("jtree/products/jtable.node.js")
  const marked = require("marked")
  const moment = require("moment")
  // https://github.com/gentooboontoo/js-quantities
  // https://github.com/moment/moment/issues/2469
  // todo: ugly. how do we ditch this or test?
  moment.createFromInputFallback = function(momentConfig) {
    momentConfig._d = new Date(momentConfig._i)
  }
  const numeral = require("numeral")
 extends tilesNode
 catchAllNodeType DidYouMeanTileNode
 string wallType flex
 description Maia is a programming language for doing data science.
 inScope abstractTileTreeComponentNode tileBlankLineNode abstractDocSettingNode hashBangNode
 javascript
  _getProgramRowCount() {
   return this.getAllRowsFromAllOutputTables().reduce((acc, curr) => acc + curr.length, 0)
  }
  getOutputOrInputTable() {
   // todo: remove this?
   if (!this._outputTable) this._outputTable = new Table()
   return this._outputTable
  }
  getMaiaTiles() {
   return this.getTopDownArray().filter(node => node.doesExtend("abstractMaiaTileNode"))
  }
  getAllRowsFromAllOutputTables() {
   return jtree.Utils.flatten(
    this.getMaiaTiles()
     .map(tile => tile.getOutputTable())
     .filter(table => table)
     .map(table => table.getRows())
   )
  }
abstractTileSettingNode
 cells tileSettingKeywordCell
 abstract
abstractTileSettingTerminalNode
 javascript
  getSettingValue() {
   return this.getContent()
  }
 extends abstractTileSettingNode
 abstract
abstractCoreTileSettingTerminalNode
 abstract
 extends abstractTileSettingTerminalNode
hiddenNode
 extends abstractCoreTileSettingTerminalNode
 crux hidden
visibleNode
 extends abstractCoreTileSettingTerminalNode
 crux visible
maximizedNode
 extends abstractCoreTileSettingTerminalNode
 crux maximized
abstractPagePositionNode
 frequency .2
 cells tileSettingKeywordCell intCell
 extends abstractCoreTileSettingTerminalNode
 abstract
leftNode
 extends abstractPagePositionNode
 crux left
topNode
 extends abstractPagePositionNode
 crux top
widthNode
 extends abstractPagePositionNode
 crux width
heightNode
 extends abstractPagePositionNode
 crux height
abstractColumnNode
 cells tileSettingKeywordCell columnNameCell
 extends abstractTileSettingTerminalNode
 abstract
 javascript
  getRunTimeEnumOptions(cell) {
   // todo: only works if codemirror === tab
   try {
    if (cell.getCellTypeId() === "columnNameCell") {
     const mirrorNode = typeof app === "undefined" ? this : app.mountedProgram.nodeAtLine(this.getLineNumber() - 1)
     return mirrorNode
      .getParent()
      .getParentOrDummyTable()
      .getColumnNames()
    }
   } catch (err) {
    console.log(err)
   }
  }
columnNode
 extends abstractColumnNode
 crux column
sourceColumnNode
 extends abstractColumnNode
 crux sourceColumn
labelNode
 extends abstractColumnNode
 crux label
linkNode
 extends abstractColumnNode
 crux link
sizeColumnNode
 extends abstractColumnNode
 crux sizeColumn
colorColumnNode
 extends abstractColumnNode
 crux colorColumn
shapeColumnNode
 extends abstractColumnNode
 crux shapeColumn
valueNode
 extends abstractColumnNode
 crux value
countNode
 extends abstractColumnNode
 crux count
dayColumnNode
 extends abstractColumnNode
 crux dayColumn
xColumnNode
 extends abstractColumnNode
 crux xColumn
yColumnNode
 extends abstractColumnNode
 crux yColumn
genderColumnNode
 extends abstractColumnNode
 crux genderColumn
headSizeNode
 extends abstractColumnNode
 crux headSize
radiusNode
 extends abstractColumnNode
 crux radius
emojiColumnNode
 extends abstractColumnNode
 crux emojiColumn
parserNode
 cells tileSettingKeywordCell parserIdsCell
 description Ohayo tries to pick the best parser for your data, but you can also specify it, like "csv" or "tsv".
 extends abstractTileSettingTerminalNode
 crux parser
useCacheNode
 cells tileSettingKeywordCell booleanCell
 extends abstractTileSettingTerminalNode
 crux useCache
reductionNode
 cells tileSettingKeywordCell reductionTypeCell
 extends abstractTileSettingTerminalNode
 crux reduction
reduceNode
 description Provide information to correctly parse a column.
 example 4 years of seattle weather
  vega.data seattle-weather.csv
   date.addColumns
    group.by year
     reduce temp_max mean average_max
     reduce temp_max max max_max
     reduce temp_min min min_min
     tables.basic
 cells tileSettingKeywordCell columnNameCell reductionTypeCell newColumnNameCell
 extends abstractTileSettingTerminalNode
 crux reduce
styleNode
 extends abstractTileSettingTerminalNode
 crux style
columnLimitNode
 description How many columns to show
 cells tileSettingKeywordCell intCell
 extends abstractTileSettingTerminalNode
 crux columnLimit
howManyNode
 cells tileSettingKeywordCell quantityCell
 extends abstractTileSettingTerminalNode
 crux howMany
sizeNode
 cells tileSettingKeywordCell numberCell
 description Size of mark.
 extends abstractTileSettingTerminalNode
 crux size
rowDisplayLimitNode
 cells tileSettingKeywordCell intCell
 frequency .5
 description Sets the maximum number of rows to show in a tile.
 extends abstractTileSettingTerminalNode
 crux rowDisplayLimit
srcNode
 cells tileSettingKeywordCell urlCell
 extends abstractTileSettingTerminalNode
 crux src
cameraPositionNode
 cells tileSettingKeywordCell cameraDistanceNumberCell horizontalNumberCell verticalNumberCell
 extends abstractTileSettingTerminalNode
 crux cameraPosition
treeLanguageNode
 cells tileSettingKeywordCell supportedTreeLanguageCell
 extends abstractTileSettingTerminalNode
 crux treeLanguage
abstractTileSettingNonTerminalNode
 javascript
  getSettingValue() {
   return this.childrenToString()
  }
 extends abstractTileSettingNode
 catchAllNodeType tileSettingNonTerminalContentNode
 abstract
contentNode
 catchAllNodeType lineOfContentNode
 extends abstractTileSettingNonTerminalNode
 crux content
catchAllNodesPostContentNode
 catchAllCellType anyCell
 extends abstractTileSettingNonTerminalNode
 crux catchAllNodesPostContent
postNode
 catchAllNodeType catchAllNodesPostContentNode
 extends abstractTileSettingNonTerminalNode
 crux post
tileSettingNonTerminalContentNode
 baseNodeType blobNode
lineOfContentNode
 catchAllNodeType lineOfContentNode
 catchAllCellType stringCell`)
      return this._cachedGrammarProgramRoot
    }
    static getNodeTypeMap() {
      return {
        abstractTileTreeComponentNode: abstractTileTreeComponentNode,
        basicRecursiveTileNode: basicRecursiveTileNode,
        DidYouMeanTileNode: DidYouMeanTileNode,
        abstractDocTileNode: abstractDocTileNode,
        docTitleNode: docTitleNode,
        docSubtitleNode: docSubtitleNode,
        docSectionNode: docSectionNode,
        docReferenceNode: docReferenceNode,
        docCommentNode: docCommentNode,
        abstractPickerTileNode: abstractPickerTileNode,
        PickerTileNode: PickerTileNode,
        abstractMaiaTileNode: abstractMaiaTileNode,
        abstractChartNode: abstractChartNode,
        abstractHeaderlessChartTileNode: abstractHeaderlessChartTileNode,
        abstractEmptyFooterTileNode: abstractEmptyFooterTileNode,
        abstractSnippetGalleryNode: abstractSnippetGalleryNode,
        abstractTemplateGalleryNode: abstractTemplateGalleryNode,
        challengeListNode: challengeListNode,
        samplesListNode: samplesListNode,
        vegaDataListNode: vegaDataListNode,
        vegaExampleListNode: vegaExampleListNode,
        challengePlayNode: challengePlayNode,
        dtjsBasicNode: dtjsBasicNode,
        abstractHtmlNode: abstractHtmlNode,
        htmlTextNode: htmlTextNode,
        htmlPrintAsNode: htmlPrintAsNode,
        abstractHTMLFixedTagTileNode: abstractHTMLFixedTagTileNode,
        htmlH1Node: htmlH1Node,
        abstractHTMLContentIsSrcTileNode: abstractHTMLContentIsSrcTileNode,
        htmlImgNode: htmlImgNode,
        htmlIframeNode: htmlIframeNode,
        htmlCustomNode: htmlCustomNode,
        abstractShowTileNode: abstractShowTileNode,
        showRowCountNode: showRowCountNode,
        showColumnCountNode: showColumnCountNode,
        showStaticNode: showStaticNode,
        showMedianNode: showMedianNode,
        showSumNode: showSumNode,
        showMeanNode: showMeanNode,
        showMinNode: showMinNode,
        showMaxNode: showMaxNode,
        abstractVegaNode: abstractVegaNode,
        vegaBarNode: vegaBarNode,
        vegaLineNode: vegaLineNode,
        vegaAreaNode: vegaAreaNode,
        vegaScatterNode: vegaScatterNode,
        vegaBubbleNode: vegaBubbleNode,
        vegaEmojiNode: vegaEmojiNode,
        vegaHistogramNode: vegaHistogramNode,
        vegaExampleNode: vegaExampleNode,
        dateHeatcalNode: dateHeatcalNode,
        iconsIconNode: iconsIconNode,
        iconsHumanNode: iconsHumanNode,
        iconsCircleNode: iconsCircleNode,
        markdownToHtmlNode: markdownToHtmlNode,
        treenotationOutlineNode: treenotationOutlineNode,
        treenotationDotlineNode: treenotationDotlineNode,
        abstractTextNode: abstractTextNode,
        abstractInstructionsNode: abstractInstructionsNode,
        amazonHistoryNode: amazonHistoryNode,
        fitbitAllNode: fitbitAllNode,
        abstractComingSoonNode: abstractComingSoonNode,
        datawrapperComingSoonNode: datawrapperComingSoonNode,
        dcjsComingSoonNode: dcjsComingSoonNode,
        finosPerspectiveComingSoonNode: finosPerspectiveComingSoonNode,
        fivethirtyeightComingSoonNode: fivethirtyeightComingSoonNode,
        highchartsComingSoonNode: highchartsComingSoonNode,
        re3dataComingSoonNode: re3dataComingSoonNode,
        zingComingSoonNode: zingComingSoonNode,
        editorHelloWorldNode: editorHelloWorldNode,
        debugDumpNode: debugDumpNode,
        webDumpNode: webDumpNode,
        debugCommandsNode: debugCommandsNode,
        debugGrammarTreeNode: debugGrammarTreeNode,
        debugSleepNode: debugSleepNode,
        debugThrowNode: debugThrowNode,
        editorGalleryNode: editorGalleryNode,
        handsontableBasicNode: handsontableBasicNode,
        listBasicNode: listBasicNode,
        listLinksNode: listLinksNode,
        tablesBasicNode: tablesBasicNode,
        tablesInterestingNode: tablesInterestingNode,
        tablesDumpNode: tablesDumpNode,
        textWordcloudNode: textWordcloudNode,
        treenotation3dNode: treenotation3dNode,
        abstractProviderNode: abstractProviderNode,
        abstractUrlNoCellsNode: abstractUrlNoCellsNode,
        abstractUrlNode: abstractUrlNode,
        diskBrowseNode: diskBrowseNode,
        diskReadNode: diskReadNode,
        abstractHackernewsNode: abstractHackernewsNode,
        hackernewsTopNode: hackernewsTopNode,
        hackernewsSubmissionsNode: hackernewsSubmissionsNode,
        webGetNode: webGetNode,
        webPostNode: webPostNode,
        abstractFixedDatasetFromUrlNode: abstractFixedDatasetFromUrlNode,
        abstractFixedDatasetFromMaiaCollectionNode: abstractFixedDatasetFromMaiaCollectionNode,
        cancerCasesNode: cancerCasesNode,
        kaggleDatasetsHeartNode: kaggleDatasetsHeartNode,
        samplesTelescopesNode: samplesTelescopesNode,
        samplesMtcarsNode: samplesMtcarsNode,
        samplesIrisNode: samplesIrisNode,
        samplesFlights14Node: samplesFlights14Node,
        samplesSiNode: samplesSiNode,
        samplesPortalNode: samplesPortalNode,
        samplesStarWarsNode: samplesStarWarsNode,
        samplesPopulationsNode: samplesPopulationsNode,
        samplesBabyNamesNode: samplesBabyNamesNode,
        samplesDeclarationNode: samplesDeclarationNode,
        samplesPeriodicTableNode: samplesPeriodicTableNode,
        samplesLettersNode: samplesLettersNode,
        samplesPresidentsNode: samplesPresidentsNode,
        ucimlrDatasetsNode: ucimlrDatasetsNode,
        vegaDataNode: vegaDataNode,
        redditAllNode: redditAllNode,
        redditSubsNode: redditSubsNode,
        redditSubNode: redditSubNode,
        abstractDummyNode: abstractDummyNode,
        samplesPatientsNode: samplesPatientsNode,
        samplesPoemNode: samplesPoemNode,
        samplesOuterSpaceNode: samplesOuterSpaceNode,
        samplesTreeProgramNode: samplesTreeProgramNode,
        samplesWaterBillNode: samplesWaterBillNode,
        samplesGapMinderNode: samplesGapMinderNode,
        abstractTransformerNode: abstractTransformerNode,
        abstractColumnAdderTileNode: abstractColumnAdderTileNode,
        dateAddColumnsNode: dateAddColumnsNode,
        mathLogNode: mathLogNode,
        rowsAddIndexColumnNode: rowsAddIndexColumnNode,
        rowsRunningTotalNode: rowsRunningTotalNode,
        textLengthNode: textLengthNode,
        textSplitNode: textSplitNode,
        textToLowerCaseNode: textToLowerCaseNode,
        textSubstringNode: textSubstringNode,
        abstractNewRowsTransformerTileNode: abstractNewRowsTransformerTileNode,
        columnsDescribeNode: columnsDescribeNode,
        columnsListNode: columnsListNode,
        dataEvalNode: dataEvalNode,
        joinByNode: joinByNode,
        matchColumnsFuzzyNode: matchColumnsFuzzyNode,
        textWordCountNode: textWordCountNode,
        textLineCountNode: textLineCountNode,
        treenotationWordTypesNode: treenotationWordTypesNode,
        abstractColumnFilterTileNode: abstractColumnFilterTileNode,
        columnsFirstNode: columnsFirstNode,
        columnsLastNode: columnsLastNode,
        columnsDropNode: columnsDropNode,
        columnsDropConstantsNode: columnsDropConstantsNode,
        columnsKeepNode: columnsKeepNode,
        abstractTransformerNoParamsTileNode: abstractTransformerNoParamsTileNode,
        rowsShuffleNode: rowsShuffleNode,
        rowsReverseNode: rowsReverseNode,
        abstractRowFilterTileNode: abstractRowFilterTileNode,
        filterWhereNode: filterWhereNode,
        rowsDropIfMissingNode: rowsDropIfMissingNode,
        filterWithNode: filterWithNode,
        filterWithoutNode: filterWithoutNode,
        rowsFirstNode: rowsFirstNode,
        rowsLastNode: rowsLastNode,
        columnsSetTypeNode: columnsSetTypeNode,
        groupByNode: groupByNode,
        rowsSortByNode: rowsSortByNode,
        rowsSortByReverseNode: rowsSortByReverseNode,
        rowsAddOneNode: rowsAddOneNode,
        dataInlineNode: dataInlineNode,
        dataLocalStorageNode: dataLocalStorageNode,
        debugParserTestNode: debugParserTestNode,
        editorFilesNode: editorFilesNode,
        editorCommandHistoryNode: editorCommandHistoryNode,
        mathGenNode: mathGenNode,
        abstractRandomTileNode: abstractRandomTileNode,
        randomFloatNode: randomFloatNode,
        randomIntNode: randomIntNode,
        samplesTinyIrisNode: samplesTinyIrisNode,
        toCsvNode: toCsvNode,
        abstractTemplatePickerTileNode: abstractTemplatePickerTileNode,
        templatesListNode: templatesListNode,
        tileBlankLineNode: tileBlankLineNode,
        abstractDocSettingNode: abstractDocSettingNode,
        docCategoriesNode: docCategoriesNode,
        docAuthorNode: docAuthorNode,
        docDefaultHiddenNode: docDefaultHiddenNode,
        docDateNode: docDateNode,
        docZoomNode: docZoomNode,
        docLayoutNode: docLayoutNode,
        abstractDocSectionComponentNode: abstractDocSectionComponentNode,
        docSectionSubtitleNode: docSectionSubtitleNode,
        docSectionParagraphNode: docSectionParagraphNode,
        docSectionLinkNode: docSectionLinkNode,
        docSectionCodeNode: docSectionCodeNode,
        docLineOfCodeNode: docLineOfCodeNode,
        docParagraphLineNode: docParagraphLineNode,
        commentLineNode: commentLineNode,
        docReferenceUrlNode: docReferenceUrlNode,
        catchAllErrorNode: catchAllErrorNode,
        hashBangNode: hashBangNode,
        tilesNode: tilesNode,
        maiaNode: maiaNode,
        abstractTileSettingNode: abstractTileSettingNode,
        abstractTileSettingTerminalNode: abstractTileSettingTerminalNode,
        abstractCoreTileSettingTerminalNode: abstractCoreTileSettingTerminalNode,
        hiddenNode: hiddenNode,
        visibleNode: visibleNode,
        maximizedNode: maximizedNode,
        abstractPagePositionNode: abstractPagePositionNode,
        leftNode: leftNode,
        topNode: topNode,
        widthNode: widthNode,
        heightNode: heightNode,
        abstractColumnNode: abstractColumnNode,
        columnNode: columnNode,
        sourceColumnNode: sourceColumnNode,
        labelNode: labelNode,
        linkNode: linkNode,
        sizeColumnNode: sizeColumnNode,
        colorColumnNode: colorColumnNode,
        shapeColumnNode: shapeColumnNode,
        valueNode: valueNode,
        countNode: countNode,
        dayColumnNode: dayColumnNode,
        xColumnNode: xColumnNode,
        yColumnNode: yColumnNode,
        genderColumnNode: genderColumnNode,
        headSizeNode: headSizeNode,
        radiusNode: radiusNode,
        emojiColumnNode: emojiColumnNode,
        parserNode: parserNode,
        useCacheNode: useCacheNode,
        reductionNode: reductionNode,
        reduceNode: reduceNode,
        styleNode: styleNode,
        columnLimitNode: columnLimitNode,
        howManyNode: howManyNode,
        sizeNode: sizeNode,
        rowDisplayLimitNode: rowDisplayLimitNode,
        srcNode: srcNode,
        cameraPositionNode: cameraPositionNode,
        treeLanguageNode: treeLanguageNode,
        abstractTileSettingNonTerminalNode: abstractTileSettingNonTerminalNode,
        contentNode: contentNode,
        catchAllNodesPostContentNode: catchAllNodesPostContentNode,
        postNode: postNode,
        tileSettingNonTerminalContentNode: tileSettingNonTerminalContentNode,
        lineOfContentNode: lineOfContentNode
      }
    }
  }

  class abstractTileSettingNode extends jtree.GrammarBackedNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
  }

  class abstractTileSettingTerminalNode extends abstractTileSettingNode {
    getSettingValue() {
      return this.getContent()
    }
  }

  class abstractCoreTileSettingTerminalNode extends abstractTileSettingTerminalNode {}

  class hiddenNode extends abstractCoreTileSettingTerminalNode {}

  class visibleNode extends abstractCoreTileSettingTerminalNode {}

  class maximizedNode extends abstractCoreTileSettingTerminalNode {}

  class abstractPagePositionNode extends abstractCoreTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
  }

  class leftNode extends abstractPagePositionNode {}

  class topNode extends abstractPagePositionNode {}

  class widthNode extends abstractPagePositionNode {}

  class heightNode extends abstractPagePositionNode {}

  class abstractColumnNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    getRunTimeEnumOptions(cell) {
      // todo: only works if codemirror === tab
      try {
        if (cell.getCellTypeId() === "columnNameCell") {
          const mirrorNode = typeof app === "undefined" ? this : app.mountedProgram.nodeAtLine(this.getLineNumber() - 1)
          return mirrorNode
            .getParent()
            .getParentOrDummyTable()
            .getColumnNames()
        }
      } catch (err) {
        console.log(err)
      }
    }
  }

  class columnNode extends abstractColumnNode {}

  class sourceColumnNode extends abstractColumnNode {}

  class labelNode extends abstractColumnNode {}

  class linkNode extends abstractColumnNode {}

  class sizeColumnNode extends abstractColumnNode {}

  class colorColumnNode extends abstractColumnNode {}

  class shapeColumnNode extends abstractColumnNode {}

  class valueNode extends abstractColumnNode {}

  class countNode extends abstractColumnNode {}

  class dayColumnNode extends abstractColumnNode {}

  class xColumnNode extends abstractColumnNode {}

  class yColumnNode extends abstractColumnNode {}

  class genderColumnNode extends abstractColumnNode {}

  class headSizeNode extends abstractColumnNode {}

  class radiusNode extends abstractColumnNode {}

  class emojiColumnNode extends abstractColumnNode {}

  class parserNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get parserIdsCell() {
      return this.getWord(1)
    }
  }

  class useCacheNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get booleanCell() {
      return this.getWord(1)
    }
  }

  class reductionNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get reductionTypeCell() {
      return this.getWord(1)
    }
  }

  class reduceNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get columnNameCell() {
      return this.getWord(1)
    }
    get reductionTypeCell() {
      return this.getWord(2)
    }
    get newColumnNameCell() {
      return this.getWord(3)
    }
  }

  class styleNode extends abstractTileSettingTerminalNode {}

  class columnLimitNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
  }

  class howManyNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get quantityCell() {
      return parseInt(this.getWord(1))
    }
  }

  class sizeNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get numberCell() {
      return parseFloat(this.getWord(1))
    }
  }

  class rowDisplayLimitNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
  }

  class srcNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
  }

  class cameraPositionNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get cameraDistanceNumberCell() {
      return parseFloat(this.getWord(1))
    }
    get horizontalNumberCell() {
      return parseFloat(this.getWord(2))
    }
    get verticalNumberCell() {
      return parseFloat(this.getWord(3))
    }
  }

  class treeLanguageNode extends abstractTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get supportedTreeLanguageCell() {
      return this.getWord(1)
    }
  }

  class abstractTileSettingNonTerminalNode extends abstractTileSettingNode {
    createParser() {
      return new jtree.TreeNode.Parser(tileSettingNonTerminalContentNode, undefined, undefined)
    }
    getSettingValue() {
      return this.childrenToString()
    }
  }

  class contentNode extends abstractTileSettingNonTerminalNode {
    createParser() {
      return new jtree.TreeNode.Parser(lineOfContentNode, undefined, undefined)
    }
  }

  class catchAllNodesPostContentNode extends abstractTileSettingNonTerminalNode {
    get anyCell() {
      return this.getWordsFrom(0)
    }
  }

  class postNode extends abstractTileSettingNonTerminalNode {
    createParser() {
      return new jtree.TreeNode.Parser(catchAllNodesPostContentNode, undefined, undefined)
    }
  }

  class tileSettingNonTerminalContentNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(this._getBlobNodeCatchAllNodeType())
    }
    getErrors() {
      return []
    }
  }

  class lineOfContentNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(lineOfContentNode, undefined, undefined)
    }
    get stringCell() {
      return this.getWordsFrom(0)
    }
  }

  window.maiaNode = maiaNode
}

"use strict";
window.challengesTree = `challenge
 id 1
 question How many U.S. Presidents were born in California?
 answer 2
 difficulty easy
 solution
  samples.presidents
   filter.with California
    tables.basic
challenge
 id 2
 question What is the score of the highest rated movie on IMDB?
 answer 9.2
 difficulty easy
 solution
  vega.data movies.json
   columns.keep Title IMDB_Rating
    filter.where IMDB_Rating > 0
     rows.sortBy IMDB_Rating
      rows.reverse
       tables.basic
challenge
 id 3
 question How many movies are rated 8+ on IMDB?
 answer 157
 difficulty easy
 solution
  vega.data movies.json
   filter.where IMDB_Rating > 8
    columns.keep Title IMDB_Rating
     tables.basic
challenge
 id 4
 question In the sample dataset "waterBill", what is the median monthly water bill?
 answer 65.03
 difficulty easy
 solution
  samples.waterBill
   columns.describe
    columns.keep Column median
     tables.basic
challenge
 id 5
 question In the Declaration of Independence, how many times does the word "people" appear, including when capitalized?
 answer 10
 difficulty medium
 solution
  samples.declaration
   text.toLowerCase text
    text.wordCount
     filter.where word = people
      show.max count Count`
"use strict";
window.TemplatesStamp = `file templates/amazon-purchase-history.maia
 data
  doc.title Amazon Purchase History
  doc.comment Delete the below line and replace with your data
  amazon.history
   columns.keep Category ItemTotal OrderDate Title
    tables.basic All Amazon Purchases
    group.by Category
     reduce ItemTotal sum sum
     vega.bar Amount Spent by Category
      xColumn Category
      yColumn sum
    date.addColumns year
     group.by year
      reduce ItemTotal sum totalSpent
      vega.bar Amount Spent by Year
       yColumn totalSpent
       xColumn year
      vega.bar Items Purchases by Year
       yColumn count
       xColumn year
  doc.layout column
  doc.categories shopping
file templates/cancer-rates-in-the-us.maia
 data
  doc.title Cancer Rates in the U.S.
  cancer.cases
   tables.basic
   show.sum Female Total female cases
   vega.bar
    xColumn CancerType
    yColumn Female
   show.sum Male Total male cases
   columns.setType Male number
    vega.bar
     xColumn CancerType
     yColumn Male
  doc.layout column
  doc.categories medicine
file templates/git-repo-dashboard.maia
 data
  doc.title Desktop Only: Statistics for Local Git Repo
  web.get http://localhost:2222/shell?command=gitlog
   date.addColumns
    group.by day
     date.heatcal
      count count
     show.median count Median Commits Per Coding Day
     show.rowCount # Coding Days
    group.by month
     vega.line Monthly Commit Trends
      xColumn month
      yColumn count
     vega.bar Days worked by month
      xColumn month
      yColumn count
   show.rowCount Total Commits
   show.max time Most Recent Commit
   show.min time First Commit
  doc.layout column
  doc.categories programming
file templates/loc-with-bars.maia
 data
  doc.title Desktop Only: Analyze lines of code in a folder
  web.get /disk?path=/ohayo/ohayoWebApp&lineStats=true&recursive=true
   filter.without .DS_Store min.js node_modules ignore package-lock.json
    show.sum lines Total LoC
    columns.keep name extension lines words bytes wordsPerLine
     rows.sortByReverse lines
      tables.basic All files
    group.by extension
     reduce words sum words
     reduce bytes sum bytes
     reduce lines sum lines
     vega.bar Lines of Code
      yColumn lines
     vega.bar Words
      yColumn words
     tables.basic Top Extensions
  doc.layout column
  doc.categories programming
file templates/logs.maia
 data
  doc.title Exponents
   visible
  math.gen exp 0 1 .01
   vega.line 2.718^x from 0 to 1
    visible
    xColumn input
    yColumn output
  math.gen exp 1 10 .1
   vega.line 2.718^x from 1 to 10
    visible
    xColumn input
    yColumn output
  math.gen exp 10 20 .1
   vega.line 2.718^x from 10 to 20
    visible
    xColumn input
    yColumn output
  doc.layout column
  doc.categories math
  doc.defaultHidden
file templates/maia-reference.maia
 data
  doc.title Maia Reference
  doc.author Breck Yunits
  doc.date 12/05/2019
  doc.categories ohayo
  doc.layout column
  
  doc.subtitle Maia is a language for data powered documents.
  
  doc.section
   subtitle Overview
   paragraph Maia is a combination of a Markdown-like language coupled with a collaboratively designed dataflow language for doing data science right in the browser.
  
  
  doc.section
   subtitle Sections
   paragraph You can put whole sections into 1 tile.
   paragraph Sections can have multiple paragraphs.
   code python
    # they can have code blocks too
  
  doc.section
   subtitle Mixing data with content
   paragraph You can mix and match doc tiles with any other Maia tile.
  
  data.inline
   parser ssv
   content
    team superbowls
    Patriots 6
    Bills 0
   vega.bar Number of Superbowl Wins
  
  
  doc.section
   subtitle Secondary Notation (aka Text Styling)
   paragraph Words can be bolded[bold] or italicized[em] or monospaced[mono] or linked[link http://ohayo.computer] or footnoted[ref someRefId].
  
  doc.section
   subtitle Links
   link http://ohayo.computer A whole sentence can be linked
  
  
  
  doc.section
   subtitle Layout
   paragraph Layout changes the layout strategy of the tiles
   code
    doc.layout column
  
  
  doc.section
   subtitle Zoom
   paragraph Zoom let's you adjust the zoom level of the doc.
   code
    doc.zoom .5
  
  
  doc.section
   subtitle Default visibilitiy
   paragraph You can change the default visibility of a tile
   paragraph The line below will hide all tiles by default.
   code maia
    doc.tiles hidden
   paragraph When you hide all tiles, you'll need to opt-in to visible to show tiles.
   code
    samples.portals
     vega.bar
      visible
   paragraph By default, all tiles are set to visible, which is equivalent to:
   code
    doc.tiles visible
  
  
  doc.section
   subtitle Categories
   paragraph You might want to add some tags categorizing your document.
   code maia
    doc.categories programming
  
  doc.section
   subtitle Blank lines
   paragraph
    Blank lines are fine.
    
    In paragraphs.
  
  doc.section
   subtitle Code
   code python
    # You can create blocks of code for printing
    # If you provide a supported language ID, secondary notation (highlighting) can be added.
  
  doc.ref someRefId
   url https://en.wikipedia.org/wiki/Note_(typography)
file templates/periodic-table.maia
 data
  doc.title The Periodic Table
  samples.periodicTable
   vega.scatter Boiling Point by Atomic Number
    xColumn AtomicNumber
    yColumn BoilingPoint
   vega.scatter Year of Discovery by Atomic Number
    xColumn Year
    yColumn AtomicNumber
  doc.layout column
  doc.categories chemistry
file templates/portals.maia
 data
  doc.title Data Portals
  samples.portals
   hidden
   rows.sortByReverse datasets
    hidden
    tables.basic
  doc.categories dataScience
  doc.layout column
file templates/random.maia
 data
  doc.title Random Numbers
  random.int 1000 0 1000
   hidden
   vega.scatter 1000 Random numbers between 0 and 100
    xColumn index
    yColumn number
   rows.first 100
    hidden
    vega.scatter 100 of those
     xColumn index
     yColumn number
  doc.categories math
  doc.layout column
file templates/reddit.maia
 data
  doc.title Top Stories on Reddit
  reddit.all
   hidden
   columns.keep title created_utc score subreddit url
    hidden
    rows.sortByReverse score
     tables.basic Top Stories on Reddit
    vega.scatter
     yColumn score
     xColumn created_utc
    vega.bar Top Stories on Reddit Right Now
     yColumn score
  doc.layout column
  doc.categories socialMedia
file templates/subreddit.maia
 data
  doc.title Top stories in a subreddit
  reddit.sub Astronomy
   columns.keep title created_utc score subreddit url
    vega.scatter
     yColumn score
     xColumn created_utc
    list.links
  doc.layout column
  doc.categories socialMedia
file templates/trends-in-baby-names.maia
 data
  doc.title Trends in Baby Names
  doc.comment Uncomment the below line, and delete the following line, to use the full dataset
  doc.comment  web.get https://raw.githubusercontent.com/hadley/data-baby-names/master/baby-names.csv
  samples.babyNames
   filter.where name = Aria
    filter.where sex = girl
     vega.line
      xColumn year
      yColumn percent
  doc.layout column
  doc.categories parenting
file templates/trigonometry.maia
 data
  doc.title Trigonometric Functions
   visible
  math.gen sin 0 10 .1
   vega.line Sin Wave
    visible
    xColumn input
    yColumn output
  math.gen cos 0 10 .1
   vega.line Cos Wave
    visible
    xColumn input
    yColumn output
  math.gen tan 0 10 .1
   vega.line Tan Wave
    visible
    xColumn input
    yColumn output
  doc.layout column
  doc.categories math
  doc.defaultHidden
file templates/ucimlr-overview.maia
 data
  doc.title The Datasets in UCIMLR
  doc.layout column
  ucimlr.datasets
   show.rowCount Total Datasets
   group.by Category
    vega.bar
   doc.comment  Filter out missing data:
   filter.where Year > 1910
    group.by Year
     columns.setType Year year
      vega.bar
       xColumn Year
       yColumn count
  doc.categories dataScience
file templates/word-cloud.maia
 data
  doc.title Word Cloud
  doc.layout column
  data.inline
   text.wordCount
    text.wordcloud
    rows.sortByReverse count
     tables.basic
   parser text
   content
    If you put some text here, you will make yourself a word cloud. The more text you add, the better it will be. So keep writing, writing, writing, and you will get something that looks good.
  doc.categories writing
`
"use strict";
window.OhayoDrums = `panel new createNewBlankProgramCommand ctrl+n New file
mounted new cloneTabCommand ctrl+shift+n Clone file
panel new createMiniMapCommand shift+m Browse files
mounted new createNewSourceCodeVisualizationProgramCommand  Visualize Source Code
mounted file saveTabAndNotifyCommand command+s Save file
mounted file showTabMoveFilePromptCommand  Move file
mounted file cellCheckProgramCommand shift+c Check file for Errors
mounted file showDeleteFileConfirmDialogCommand shift+backspace Delete file
panel file openDeleteAllTabsPromptCommand  Delete all open files
mounted navigation closeMountedProgramCommand ctrl+w Close focused tab
panel navigation closeAllTabsCommand ctrl+shift+w Close all tabs
mounted navigation mountPreviousTabCommand shift+left Previous tab
mounted navigation mountNextTabCommand shift+right Next tab
panel navigation openFullDiskFilePathPromptCommand shift+o Open file from path
panel navigation openFolderPromptCommand  Open folder
panel navigation changeWorkingFolderPromptCommand  Change working folder
mounted selection selectAllTilesCommand command+a Select all tiles
mounted selection selectNextTileCommand shift+down Select next tile
mounted selection selectPreviousTileCommand shift+up Select previous Tile
mounted selection deleteSelectionCommand backspace Delete Selection
mounted selection duplicateSelectionCommand command+d Duplicate Selection
panel window toggleThemeCommand shift+t Toggle Theme
panel window toggleGutterCommand shift+u Toggle Source Editor Gutter
panel window toggleFullScreenCommand shift+f Toggle Full Screen
panel window toggleFocusedModeCommand command+shift+f Toggle Focused Mode
panel window closeModalCommand escape Close any open modal
mounted window clearTabMessagesCommand command+\\ Clear tab messages
panel window toggleAutoSaveCommand  Toggle autosave
mounted window fetchAndReloadFocusedTabCommand shift+r Re-download and refresh tab
mounted edit toggleLayoutCommand shift+l Toggle layout
mounted edit undoFocusedProgramCommand command+z Undo
mounted edit redoFocusedProgramCommand command+shift+z Redo
mounted edit insertAdjacentTileCommand shift+i Insert Tile
panel ohayo toggleHelpCommand ? Help
panel ohayo confirmAndResetAppStateCommand  Reset Ohayo
panel ohayo toggleTreeComponentFrameworkDebuggerCommand shift+d Toggle TCF Debugger`
class AbstractPath {
  constructor(path) {
    this._checkPath(path)
    this._path = path
  }
  _checkPath() {}
  toString() {
    return this._path.toString()
  }
}

class FullFilePath extends AbstractPath {
  _checkPath(fullPath) {
    if (!fullPath.startsWith("/")) throw new Error(`File fullPath "${fullPath}" does not begin with /.`)
    if (fullPath.endsWith("/")) throw new Error(`File fullPath "${fullPath}" cannot end with /.`)
    if (fullPath.includes("//")) throw new Error(`File fullPath "${fullPath}" cannot include //`)
  }
}

class FolderPath extends AbstractPath {
  _checkPath(folderPath) {
    if (folderPath.includes("//")) throw new Error(`File folderPath "${folderPath}" cannot include //`)
    if (!folderPath.startsWith("/") || !folderPath.endsWith("/")) throw new Error(`Bad folder: '${folderPath}'. Folder must start and end with /.`)
  }
}

class AbstractPathWithApp {
  constructor(path, app) {
    this._checkPath(path, app)
    this._path = path
    this._app = app
  }

  getDiskId() {
    return this._path.slice(0).split("/")[0]
  }

  getFilePath() {
    return this._path.replace(/^[^\/]+\//, "/")
  }

  toString() {
    return this._path.toString()
  }
}

class FullFolderPath extends AbstractPathWithApp {
  _checkPath(fullFolderPath, app) {
    if (fullFolderPath.includes("//")) throw new Error(`File fullFolderPath "${fullFolderPath}" cannot include //`)
    if (!fullFolderPath.endsWith("/")) throw new Error(`Bad fullFolderPath: '${fullFolderPath}'. Must end with /`)
    if (fullFolderPath.startsWith("/")) throw new Error(`Bad fullFolderPath: '${fullFolderPath}'. Cannot start with /`)
    if (!fullFolderPath.includes("/")) throw new Error(`Bad fullFolderPath: '${fullFolderPath}' must have a disk id and a folder path part. No / detected.`)
  }

  async getFiles() {
    return this._app.getDisks()[this.getDiskId()].readFiles(this.getFolderPath())
  }

  getFolderPath() {
    return this.getFilePath()
  }
}

class FullDiskPath extends AbstractPathWithApp {
  _checkPath(fullDiskFilePath, app) {
    if (fullDiskFilePath.includes("//")) throw new Error(`File fullDiskFilePath "${fullDiskFilePath}" cannot include //`)
    if (fullDiskFilePath.endsWith("/")) throw new Error(`Bad fullDiskFilePath: '${fullDiskFilePath}'. Cannot end with /`)
    if (fullDiskFilePath.startsWith("/")) throw new Error(`Bad fullDiskFilePath: '${fullDiskFilePath}'. Cannot start with /`)
    if (!fullDiskFilePath.includes("/")) throw new Error(`Bad fullDiskFilePath: '${fullDiskFilePath}' must have a disk id and a path part. No / detected.`)
  }

  getWithoutFilename() {
    return this._path.replace(/\/[^\/]+$/, "/")
  }

  getFilename() {
    return this._path.split("/").pop()
  }
}

class FileHandle {
  constructor(fullDiskFilePath, app) {
    this._fullDiskFilePath = new FullDiskPath(fullDiskFilePath)
    this._app = app
  }

  _getDisk() {
    return this._app.getDisks()[this._fullDiskFilePath.getDiskId()]
  }

  unlinkFile() {
    return this._getDisk().unlinkFile(this._fullDiskFilePath.getFilePath())
  }

  readFile() {
    return this._getDisk().readFile(this._fullDiskFilePath.getFilePath())
  }

  writeFile(newVersion) {
    return this._getDisk().writeFile(this._fullDiskFilePath.getFilePath(), newVersion)
  }
}

window.FullFilePath = FullFilePath

window.FolderPath = FolderPath

window.FullFolderPath = FullFolderPath

window.FullDiskPath = FullDiskPath

window.FileHandle = FileHandle
;



class AbstractDisk {
  constructor(rootTreeComponent) {
    this._rootTreeComponent = rootTreeComponent
  }

  getPathBase() {
    return this.getDisplayName() + this.getFolder()
  }

  getRootTreeComponent() {
    return this._rootTreeComponent
  }

  getFolder() {
    return this._folder || "/"
  }

  setFolder(folderPath) {
    this._folder = new FolderPath(folderPath).toString()
    return this
  }
}

window.AbstractDisk
 = AbstractDisk
;




// todo: add a file type. program in PanelTreeComponent will be a child off
// File. then we can have diskFile, remoteFile, folderFile, templateFile, localstorageFile, et cetera.,
// each with it's own storage strategy. they can extend tree notation. they can implment fetch. they can
// handle readonly, et cetera. google docs file. dropbox file. derivative file (for example, from a png).
// then the bytes of the file get turned into a program. there are Tree Languages maia/fire caddoes and then there
// are non-treeLanguage files like pngs and JS, et cetera, that we can build maia in-memory templates for.

// folders and files =>

class AbstractFile extends jtree.TreeNode {
  getFileLink() {
    return this.getLine()
  }

  getFilename() {
    return new FullDiskPath(this.getLine()).getFilename()
  }

  toFileObject() {
    const str = this.childrenToString()
    return {
      filename: this.getFilename(),
      link: this.getFileLink(),
      size: str.length,
      bytes: str
    }
  }
}

window.AbstractFile
 = AbstractFile
;





class ServerStorageFile extends AbstractFile {}

// todo: use same constants file on serverside.

class ServerStorageDisk extends AbstractDisk {
  _getWillow() {
    return this.getRootTreeComponent().getWillowBrowser()
  }

  async _httpPostUrl(method, options) {
    const response = await this._getWillow().httpPostUrl("/serverStorage." + method, options)
    return response.text
  }

  getDisplayName() {
    return this._getWillow().getHost()
  }

  async readFiles(folder = this.getFolder()) {
    // todo: speed tests/checks
    const response = await this._getWillow().httpGetUrl("/serverStorage.list", { folder: folder })
    return response.body.map(file => new ServerStorageFile(file.data, this.getDisplayName() + folder + file.name))
  }

  async getAvailablePermalink(permalink) {
    const fullPath = this.getFolder() + permalink
    const res = await this._httpPostUrl("getAvailablePermalink", { permalink: new FullFilePath(fullPath).toString() })
    return res
  }

  async unlinkFile(fullPath) {
    const res = await this._httpPostUrl("delete", { fullPath: new FullFilePath(fullPath).toString() })
    return res
  }

  async writeFile(fullPath, newVersion) {
    // todo: speed tests/checks
    try {
      const res = await this._httpPostUrl("write", { fullPath: new FullFilePath(fullPath).toString(), newVersion: newVersion })
      return res
    } catch (err) {
      console.error(err)
      throw new Error("Save failed!")
    }
  }

  async exists(fullPath) {
    const res = await this._httpPostUrl("exists", { fullPath: new FullFilePath(fullPath).toString() })
    return res.toString() === "true"
  }

  async readFile(fullPath) {
    // todo: speed tests/checks
    const res = await this._httpPostUrl("read", { fullPath: new FullFilePath(fullPath).toString() })
    return res
  }
}

window.ServerStorageDisk
 = ServerStorageDisk
;

const StorageKeys = {}
StorageKeys.autoSave = "__autoSave"
StorageKeys.appState = "__appState"
StorageKeys.visitCount = "__visitCount"
StorageKeys.workingFolderFullDiskFolderPath = "__workingFolderFullDiskFolderPath"

StorageKeys.isKey = key => {
  if (!StorageKeys._storageKeysmap) {
    StorageKeys._storageKeysmap = {}
    Object.values(StorageKeys).forEach(value => (StorageKeys._storageKeysmap[value] = true))
  }
  return StorageKeys._storageKeysmap[key]
}

window.StorageKeys
 = StorageKeys
;









class LocalStorageFile extends AbstractFile {}

class LocalStorageDisk extends AbstractDisk {
  async readFiles() {
    return this.readFilesSync()
  }

  readFilesSync() {
    const app = this.getRootTreeComponent()
    return app
      .getStoreKeys()
      .filter(key => !StorageKeys.isKey(key))
      .filter(key => key.startsWith("/"))
      .map(filename => new LocalStorageFile(app.getFromStore(filename), this.getDisplayName() + filename))
  }

  getDisplayName() {
    return "localStorage"
  }

  async unlinkFile(fullPath) {
    this.getRootTreeComponent().removeValue(new FullFilePath(fullPath))
  }

  async getAvailablePermalink(permalink) {
    const app = this.getRootTreeComponent()
    return this.getFolder() + jtree.Utils.getAvailablePermalink(permalink, fullPath => app.getFromStore(this.getFolder() + fullPath) !== undefined)
  }

  async exists(fullPath) {
    return this.getRootTreeComponent().getFromStore(new FullFilePath(fullPath)) !== undefined
  }

  async writeFile(fullPath, newVersion) {
    this.getRootTreeComponent().storeValue(new FullFilePath(fullPath), newVersion)
  }

  async readFile(fullPath) {
    return this.getRootTreeComponent().getFromStore(new FullFilePath(fullPath))
  }
}

window.LocalStorageDisk
 = LocalStorageDisk
;

const DemoTemplates = `faq.maia
 web.get maia/packages/samples/faq.md
  parser text
  hidden
  markdown.toHtml
ohayo.maia
 web.get maia/packages/samples/welcome.md
  parser text
  hidden
  markdown.toHtml
 templates.list
 challenge.list
 doc.layout column`

window.DemoTemplates
 = DemoTemplates
;



const MaiaCodeEditorTemplate = (source, fileName, treeLanguage) =>
  new jtree.TreeNode(`doc.title Source code visualization of {fileName}
data.inline
 parser text
 treeLanguage {treeLanguage}
 text.lineCount
  show.median lines Total lines
 text.wordCount
  show.sum count Total words
 treenotation.3d
 treenotation.outline
 treenotation.wordTypes
  html.printAs pre
   text.wordCount
    tables.basic
    text.wordcloud
 content
  {source}
doc.layout column`).templateToString({ source, fileName, treeLanguage })

window.MaiaCodeEditorTemplate
 = MaiaCodeEditorTemplate
;

const MaiaTemplates = {}

MaiaTemplates._fromDelimited = (filename, data, app) => {
  const key = app.initLocalDataStorage(filename, data)
  return `data.localStorage ${key}
 tables.basic`
}

MaiaTemplates.tsv = MaiaTemplates._fromDelimited

MaiaTemplates.json = (filename, data, app) => {
  const key = app.initLocalDataStorage(filename, data)
  return `data.localStorage ${key}`
}

MaiaTemplates.csv = (filename, data, app) => {
  // todo: remove \r?
  // check csv subtypes
  const isMultiCsv = data.split("\n\n").length > 3
  if (isMultiCsv) return MaiaTemplates._multiCsv(filename, data, app)
  return MaiaTemplates._fromDelimited(filename, data, app)
}

MaiaTemplates._multiCsv = (filename, data, app) => {
  return data
    .split("\n\n")
    .map(t => t.trim())
    .filter(t => t)
    .map(table => {
      const rows = table.split("\n")
      const tableName = rows.shift()
      const key = app.initLocalDataStorage(filename + "-" + tableName, rows.join("\n"))
      return `data.localStorage ${key}
 tables.basic ${tableName}`
    })
    .join("\n")
}

window.MaiaTemplates
 = MaiaTemplates
;

// todo: title should be folder name?
const MiniTemplate = `editor.files
 hidden
 rows.sortBy link
  hidden
  editor.gallery`

window.MiniTemplate
 = MiniTemplate
;

const SpeedTestTemplate = (title, rows) =>
  `data.inline
 content
  ${rows.replace(/\n/g, "\n  ")}
 html.h1 ${title}
 rows.sortBy timeToLoad
  rows.reverse
   tables.basic Slow Load Times
 rows.sortBy timeToRender
  rows.reverse
   tables.basic Slow Render Times
 show.mean timeToLoad
 show.mean timeToRender
 show.median timeToRender
 show.sum timeToLoad
 show.sum timeToRender
 show.rowCount`

window.SpeedTestTemplate
 = SpeedTestTemplate
;

const CodeMirrorCss = `.CodeMirror {
  font-family: monospace;
  height: 300px;
  color: #000
}

.CodeMirror-lines {
  padding: 4px 0
}

.CodeMirror pre {
  padding: 0 4px
}

.CodeMirror-scrollbar-filler,
.CodeMirror-gutter-filler {
  background-color: #fff
}

.CodeMirror-gutters {
  border-right: 0;
  background-color: #f7f7f7;
  white-space: nowrap
}

.CodeMirror-linenumber {
  padding: 0 3px 0 5px;
  min-width: 20px;
  text-align: right;
  color: #999;
  white-space: nowrap
}

.CodeMirror-guttermarker {
  color: #000
}

.CodeMirror-guttermarker-subtle {
  color: #999
}

.CodeMirror-cursor {
  border-left: 1px solid #000;
  border-right: none;
  width: 0
}

.CodeMirror div.CodeMirror-secondarycursor {
  border-left: 1px solid silver
}

.cm-fat-cursor .CodeMirror-cursor {
  width: auto;
  border: 0!important;
  background: #7e7
}

.cm-fat-cursor div.CodeMirror-cursors {
  z-index: 1
}

.cm-animate-fat-cursor {
  width: auto;
  border: 0;
  -webkit-animation: blink 1.06s steps(1) infinite;
  -moz-animation: blink 1.06s steps(1) infinite;
  animation: blink 1.06s steps(1) infinite;
  background-color: #7e7
}

@-moz-keyframes blink {
  50% {
    background-color: transparent
  }
}

@-webkit-keyframes blink {
  50% {
    background-color: transparent
  }
}

@keyframes blink {
  50% {
    background-color: transparent
  }
}

.cm-tab {
  display: inline-block;
  text-decoration: inherit
}

.CodeMirror-rulers {
  position: absolute;
  left: 0;
  right: 0;
  top: -50px;
  bottom: -20px;
  overflow: hidden
}

.CodeMirror-ruler {
  border-left: 1px solid #ccc;
  top: 0;
  bottom: 0;
  position: absolute
}

.cm-s-default .cm-header {
  color: blue
}

.cm-s-default .cm-quote {
  color: #090
}

.cm-negative {
  color: #d44
}

.cm-positive {
  color: #292
}

.cm-header,
.cm-strong {
  font-weight: 700
}

.cm-em {
  font-style: italic
}

.cm-link {
  text-decoration: underline
}

.cm-strikethrough {
  text-decoration: line-through
}

.cm-s-default .cm-keyword {
  color: #708
}

.cm-s-default .cm-atom {
  color: #219
}

.cm-s-default .cm-number {
  color: #164
}

.cm-s-default .cm-def {
  color: #00f
}

.cm-s-default .cm-variable-2 {
  color: #05a
}

.cm-s-default .cm-variable-3,
.cm-s-default .cm-type {
  color: #085
}

.cm-s-default .cm-comment {
  color: #a50
}

.cm-s-default .cm-string {
  color: #a11
}

.cm-s-default .cm-string-2 {
  color: #f50
}

.cm-s-default .cm-meta {
  color: #555
}

.cm-s-default .cm-qualifier {
  color: #555
}

.cm-s-default .cm-builtin {
  color: #30a
}

.cm-s-default .cm-bracket {
  color: #997
}

.cm-s-default .cm-tag {
  color: #170
}

.cm-s-default .cm-attribute {
  color: #00c
}

.cm-s-default .cm-hr {
  color: #999
}

.cm-s-default .cm-link {
  color: #00c
}

.cm-s-default .cm-error {
  color: red
}

.cm-invalidchar {
  color: red
}

.CodeMirror-composing {
  border-bottom: 2px solid
}

div.CodeMirror span.CodeMirror-matchingbracket {
  color: #0f0
}

div.CodeMirror span.CodeMirror-nonmatchingbracket {
  color: #f22
}

.CodeMirror-matchingtag {
  background: rgba(255, 150, 0, .3)
}

.CodeMirror-activeline-background {
  background: #e8f2ff
}

.CodeMirror {
  position: relative;
  overflow: hidden;
  background: #fff
}

.CodeMirror-scroll {
  overflow: scroll!important;
  margin-bottom: -30px;
  margin-right: -30px;
  padding-bottom: 30px;
  height: 100%;
  outline: none;
  position: relative
}

.CodeMirror-sizer {
  position: relative;
  border-right: 30px solid transparent
}

.CodeMirror-vscrollbar,
.CodeMirror-hscrollbar,
.CodeMirror-scrollbar-filler,
.CodeMirror-gutter-filler {
  position: absolute;
  z-index: 6;
  display: none
}

.CodeMirror-vscrollbar {
  right: 0;
  top: 0;
  overflow-x: hidden;
  overflow-y: scroll
}

.CodeMirror-hscrollbar {
  bottom: 0;
  left: 0;
  overflow-y: hidden;
  overflow-x: scroll
}

.CodeMirror-scrollbar-filler {
  right: 0;
  bottom: 0
}

.CodeMirror-gutter-filler {
  left: 0;
  bottom: 0
}

.CodeMirror-gutters {
  position: absolute;
  left: 0;
  top: 0;
  min-height: 100%;
  z-index: 3
}

.CodeMirror-gutter {
  white-space: normal;
  height: 100%;
  display: inline-block;
  vertical-align: top;
  margin-bottom: -30px
}

.CodeMirror-gutter-wrapper {
  position: absolute;
  z-index: 4;
  background: none!important;
  border: none!important
}

.CodeMirror-gutter-background {
  position: absolute;
  top: 0;
  bottom: 0;
  z-index: 4
}

.CodeMirror-gutter-elt {
  position: absolute;
  cursor: default;
  z-index: 4
}

.CodeMirror-gutter-wrapper ::selection {
  background-color: transparent
}

.CodeMirror-gutter-wrapper ::-moz-selection {
  background-color: transparent
}

.CodeMirror-lines {
  cursor: text;
  min-height: 1px
}

.CodeMirror pre {
  -moz-border-radius: 0;
  -webkit-border-radius: 0;
  border-radius: 0;
  border-width: 0;
  background: transparent;
  font-family: inherit;
  font-size: inherit;
  margin: 0;
  white-space: pre;
  word-wrap: normal;
  line-height: inherit;
  color: inherit;
  z-index: 2;
  position: relative;
  overflow: visible;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-variant-ligatures: contextual;
  font-variant-ligatures: contextual
}

.CodeMirror-wrap pre {
  word-wrap: break-word;
  white-space: pre-wrap;
  word-break: normal
}

.CodeMirror-linebackground {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  z-index: 0
}

.CodeMirror-linewidget {
  position: relative;
  z-index: 2;
  overflow: auto
}

.CodeMirror-rtl pre {
  direction: rtl
}

.CodeMirror-code {
  outline: none
}

.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
  -moz-box-sizing: content-box;
  box-sizing: content-box
}

.CodeMirror-measure {
  position: absolute;
  width: 100%;
  height: 0;
  overflow: hidden;
  visibility: hidden
}

.CodeMirror-cursor {
  position: absolute;
  pointer-events: none
}

.CodeMirror-measure pre {
  position: static
}

div.CodeMirror-cursors {
  visibility: hidden;
  position: relative;
  z-index: 3
}

div.CodeMirror-dragcursors {
  visibility: visible
}

.CodeMirror-focused div.CodeMirror-cursors {
  visibility: visible
}

.CodeMirror-selected {
  background: #d9d9d9
}

.CodeMirror-focused .CodeMirror-selected {
  background: #d7d4f0
}

.CodeMirror-crosshair {
  cursor: crosshair
}

.CodeMirror-line::selection,
.CodeMirror-line>span::selection,
.CodeMirror-line>span>span::selection {
  background: #d7d4f0
}

.CodeMirror-line::-moz-selection,
.CodeMirror-line>span::-moz-selection,
.CodeMirror-line>span>span::-moz-selection {
  background: #d7d4f0
}

.cm-searching {
  background: #ffa;
  background: rgba(255, 255, 0, .4)
}

.cm-force-border {
  padding-right: .1px
}

@media print {
  .CodeMirror div.CodeMirror-cursors {
    visibility: hidden
  }
}

.cm-tab-wrap-hack:after {
  content: ''
}

span.CodeMirror-selectedtext {
  background: none
}

.CodeMirror-hints {
  position: absolute;
  z-index: 10;
  overflow: hidden;
  list-style: none;
  margin: 0;
  padding: 2px;
  -webkit-box-shadow: 2px 3px 5px rgba(0, 0, 0, .2);
  -moz-box-shadow: 2px 3px 5px rgba(0, 0, 0, .2);
  box-shadow: 2px 3px 5px rgba(0, 0, 0, .2);
  border-radius: 3px;
  border: 1px solid silver;
  background: #fff;
  font-size: 90%;
  font-family: monospace;
  max-height: 20em;
  overflow-y: auto
}

.CodeMirror-hint {
  margin: 0;
  padding: 0 4px;
  border-radius: 2px;
  white-space: pre;
  color: #000;
  cursor: pointer
}

li.CodeMirror-hint-active {
  background: #08f;
  color: #fff
}

.CodeMirror { background: transparent;}

.cm-s-oceanic-next.CodeMirror { background: #304148; color: #f8f8f2; }

.cm-s-oceanic-next div.CodeMirror-selected { background: rgba(101, 115, 126, 0.33); }
.cm-s-oceanic-next .CodeMirror-line::selection, .cm-s-oceanic-next .CodeMirror-line > span::selection, .cm-s-oceanic-next .CodeMirror-line > span > span::selection { background: rgba(101, 115, 126, 0.33); }
.cm-s-oceanic-next .CodeMirror-line::-moz-selection, .cm-s-oceanic-next .CodeMirror-line > span::-moz-selection, .cm-s-oceanic-next .CodeMirror-line > span > span::-moz-selection { background: rgba(101, 115, 126, 0.33); }
.cm-s-oceanic-next .CodeMirror-gutters { background: #304148; border-right: 10px; }
.cm-s-oceanic-next .CodeMirror-guttermarker { color: white; }
.cm-s-oceanic-next .CodeMirror-guttermarker-subtle { color: #d0d0d0; }
.cm-s-oceanic-next .CodeMirror-linenumber { color: #d0d0d0; }
.cm-s-oceanic-next .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }

.cm-s-oceanic-next span.cm-comment { color: #65737E; }
.cm-s-oceanic-next span.cm-atom { color: #C594C5; }
.cm-s-oceanic-next span.cm-number { color: #F99157; }

.cm-s-oceanic-next span.cm-property { color: #99C794; }
.cm-s-oceanic-next span.cm-attribute,
.cm-s-oceanic-next span.cm-keyword { color: #C594C5; }
.cm-s-oceanic-next span.cm-builtin { color: #66d9ef; }
.cm-s-oceanic-next span.cm-string { color: #99C794; }

.cm-s-oceanic-next span.cm-variable,
.cm-s-oceanic-next span.cm-variable-2,
.cm-s-oceanic-next span.cm-variable-3 { color: #f8f8f2; }
.cm-s-oceanic-next span.cm-def { color: #6699CC; }
.cm-s-oceanic-next span.cm-bracket { color: #5FB3B3; }
.cm-s-oceanic-next span.cm-tag { color: #C594C5; }
.cm-s-oceanic-next span.cm-header { color: #C594C5; }
.cm-s-oceanic-next span.cm-link { color: #C594C5; }
.cm-s-oceanic-next span.cm-error { background: #C594C5; color: #f8f8f0; }

.cm-s-oceanic-next .CodeMirror-activeline-background { background: rgba(101, 115, 126, 0.33); }
.cm-s-oceanic-next .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}

.cm-s-oceanic-next.CodeMirror {background: transparent;}
`.replace(/\n/g, "")

window.CodeMirrorCss
 = CodeMirrorCss
;

const SVGS = {}

SVGS["nw"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="331.062px" height="331.062px" viewBox="0 0 331.062 331.062" style="enable-background:new 0 0 331.062 331.062;"	 xml:space="preserve"><g>	<g>		<polygon points="69.626,40.791 218.332,40.791 218.332,0 0.009,0 0.009,218.328 40.782,218.328 40.806,69.638 302.219,331.062 			331.054,302.222 		"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["lt-eq"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="121.809px" height="121.809px" viewBox="0 0 121.809 121.809" style="enable-background:new 0 0 121.809 121.809;"	 xml:space="preserve"><g>	<g>		<path d="M12.183,121.809h97.443c4.037,0,7.309-3.271,7.309-7.31c0-4.035-3.271-7.309-7.309-7.309H12.183			c-4.037,0-7.309,3.272-7.309,7.309C4.874,118.537,8.146,121.809,12.183,121.809z"/>		<path d="M109.142,4.695c-1.443-3.766-5.66-5.657-9.439-4.207L10.785,34.593c-2.753,1.055-4.604,3.662-4.689,6.609			c-0.085,2.948,1.607,5.657,4.297,6.872l88.918,40.197c0.974,0.44,1.996,0.65,3.002,0.65c2.785,0,5.443-1.6,6.664-4.302			c1.664-3.678,0.028-8.007-3.649-9.671L32.366,41.967l72.568-27.834C108.704,12.69,110.588,8.464,109.142,4.695z"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["lt"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="103.537px" height="103.537px" viewBox="0 0 103.537 103.537" style="enable-background:new 0 0 103.537 103.537;"	 xml:space="preserve"><g>	<g>		<path d="M103.048,12.002c-1.445-3.771-5.679-5.649-9.438-4.207L4.692,41.9c-2.753,1.055-4.603,3.662-4.688,6.609			c-0.087,2.948,1.608,5.656,4.295,6.872l88.917,40.196c0.978,0.44,2,0.65,3.006,0.65c2.784,0,5.442-1.6,6.665-4.302			c1.661-3.678,0.029-8.007-3.648-9.671L26.273,49.277l72.568-27.834C102.61,19.998,104.496,15.771,103.048,12.002z"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["pencil"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 55.25 55.25" style="enable-background:new 0 0 55.25 55.25;" xml:space="preserve"><path d="M52.618,2.631c-3.51-3.508-9.219-3.508-12.729,0L3.827,38.693C3.81,38.71,3.8,38.731,3.785,38.749	c-0.021,0.024-0.039,0.05-0.058,0.076c-0.053,0.074-0.094,0.153-0.125,0.239c-0.009,0.026-0.022,0.049-0.029,0.075	c-0.003,0.01-0.009,0.02-0.012,0.03l-3.535,14.85c-0.016,0.067-0.02,0.135-0.022,0.202C0.004,54.234,0,54.246,0,54.259	c0.001,0.114,0.026,0.225,0.065,0.332c0.009,0.025,0.019,0.047,0.03,0.071c0.049,0.107,0.11,0.21,0.196,0.296	c0.095,0.095,0.207,0.168,0.328,0.218c0.121,0.05,0.25,0.075,0.379,0.075c0.077,0,0.155-0.009,0.231-0.027l14.85-3.535	c0.027-0.006,0.051-0.021,0.077-0.03c0.034-0.011,0.066-0.024,0.099-0.039c0.072-0.033,0.139-0.074,0.201-0.123	c0.024-0.019,0.049-0.033,0.072-0.054c0.008-0.008,0.018-0.012,0.026-0.02l36.063-36.063C56.127,11.85,56.127,6.14,52.618,2.631z	 M51.204,4.045c2.488,2.489,2.7,6.397,0.65,9.137l-9.787-9.787C44.808,1.345,48.716,1.557,51.204,4.045z M46.254,18.895l-9.9-9.9	l1.414-1.414l9.9,9.9L46.254,18.895z M4.961,50.288c-0.391-0.391-1.023-0.391-1.414,0L2.79,51.045l2.554-10.728l4.422-0.491	l-0.569,5.122c-0.004,0.038,0.01,0.073,0.01,0.11c0,0.038-0.014,0.072-0.01,0.11c0.004,0.033,0.021,0.06,0.028,0.092	c0.012,0.058,0.029,0.111,0.05,0.165c0.026,0.065,0.057,0.124,0.095,0.181c0.031,0.046,0.062,0.087,0.1,0.127	c0.048,0.051,0.1,0.094,0.157,0.134c0.045,0.031,0.088,0.06,0.138,0.084C9.831,45.982,9.9,46,9.972,46.017	c0.038,0.009,0.069,0.03,0.108,0.035c0.036,0.004,0.072,0.006,0.109,0.006c0,0,0.001,0,0.001,0c0,0,0.001,0,0.001,0h0.001	c0,0,0.001,0,0.001,0c0.036,0,0.073-0.002,0.109-0.006l5.122-0.569l-0.491,4.422L4.204,52.459l0.757-0.757	C5.351,51.312,5.351,50.679,4.961,50.288z M17.511,44.809L39.889,22.43c0.391-0.391,0.391-1.023,0-1.414s-1.023-0.391-1.414,0	L16.097,43.395l-4.773,0.53l0.53-4.773l22.38-22.378c0.391-0.391,0.391-1.023,0-1.414s-1.023-0.391-1.414,0L10.44,37.738	l-3.183,0.354L34.94,10.409l9.9,9.9L17.157,47.992L17.511,44.809z M49.082,16.067l-9.9-9.9l1.415-1.415l9.9,9.9L49.082,16.067z"/><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["fork"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="45.254px" height="45.254px" viewBox="0 0 45.254 45.254" style="enable-background:new 0 0 45.254 45.254;"	 xml:space="preserve"><g>	<path d="M44.68,12.649l-7.261-7.261c-0.562-0.562-1.41-0.729-2.144-0.426c-0.734,0.304-1.217,1.02-1.217,1.813v3.632		c-4.874,0.947-9.049,4.03-11.438,8.238c-2.388-4.208-6.514-7.291-11.436-8.238V6.775c0-0.793-0.477-1.509-1.211-1.813		C9.242,4.658,8.399,4.826,7.837,5.389L0.575,12.65c-0.767,0.767-0.767,2.009,0,2.775l7.262,7.263		c0.562,0.561,1.404,0.729,2.137,0.425c0.734-0.304,1.211-1.02,1.211-1.813v-2.735c3.378,1.291,5.742,4.55,5.742,8.357v10.619		c0,1.603,1.298,2.9,2.899,2.9h0.619h4.362h0.606c1.603,0,2.9-1.298,2.9-2.9V26.923c0-3.808,2.413-7.067,5.742-8.357v2.735		c0,0.794,0.481,1.509,1.217,1.813c0.732,0.304,1.578,0.136,2.14-0.425l7.265-7.263C45.447,14.659,45.447,13.417,44.68,12.649z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["call"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="348.077px" height="348.077px" viewBox="0 0 348.077 348.077" style="enable-background:new 0 0 348.077 348.077;"	 xml:space="preserve"><g>	<g>		<g>			<path d="M340.273,275.083l-53.755-53.761c-10.707-10.664-28.438-10.34-39.518,0.744l-27.082,27.076				c-1.711-0.943-3.482-1.928-5.344-2.973c-17.102-9.476-40.509-22.464-65.14-47.113c-24.704-24.701-37.704-48.144-47.209-65.257				c-1.003-1.813-1.964-3.561-2.913-5.221l18.176-18.149l8.936-8.947c11.097-11.1,11.403-28.826,0.721-39.521L73.39,8.194				C62.708-2.486,44.969-2.162,33.872,8.938l-15.15,15.237l0.414,0.411c-5.08,6.482-9.325,13.958-12.484,22.02				C3.74,54.28,1.927,61.603,1.098,68.941C-6,127.785,20.89,181.564,93.866,254.541c100.875,100.868,182.167,93.248,185.674,92.876				c7.638-0.913,14.958-2.738,22.397-5.627c7.992-3.122,15.463-7.361,21.941-12.43l0.331,0.294l15.348-15.029				C350.631,303.527,350.95,285.795,340.273,275.083z"/>		</g>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["hashtag"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 490 490" style="enable-background:new 0 0 490 490;" xml:space="preserve"><g>	<path d="M327.08,180.984H192.677L161.05,309.958h133.984L327.08,180.984z M180.58,294.646l24.12-98.35h102.791l-24.419,98.35		H180.58z"/>	<path d="M60.517,490h72.241l32.763-133.386h102.492L235.639,490h72.211l32.763-133.386h117.625v-61.968H355.702l24.434-98.35		h78.103v-61.968h-63.044L427.957,0h-72.615l-32.763,134.328H219.728L252.492,0h-72.256l-32.748,134.328H31.762v61.968h100.683		l-24.12,98.35H31.762v61.968h61.519L60.517,490z M47.074,341.301v-31.343h73.273l31.627-128.975h-104.9v-31.343H159.51		l32.748-134.328h40.734l-32.763,134.328h134.373l32.763-134.328h41.093l-32.763,134.328h67.231v31.343h-74.753l-32.061,128.975		h106.814v31.343H328.621l-32.763,133.386h-40.749l32.375-133.386H153.529l-32.763,133.386H80.047l32.763-133.386H47.074z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["minus"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 44 44" style="enable-background:new 0 0 44 44;" xml:space="preserve"><path d="M38.059,28H5.941C2.665,28,0,25.309,0,22s2.665-6,5.941-6h32.117C41.335,16,44,18.691,44,22S41.335,28,38.059,28z M5.941,18	C3.805,18,2,19.832,2,22s1.805,4,3.941,4h32.117C40.195,26,42,24.168,42,22s-1.805-4-3.941-4H5.941z"/><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["font-1"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="475.082px" height="475.082px" viewBox="0 0 475.082 475.082" style="enable-background:new 0 0 475.082 475.082;"	 xml:space="preserve"><g>	<path d="M473.371,433.11c-10.657-3.997-20.458-6.563-29.407-7.706c-8.945-0.767-15.516-2.95-19.701-6.567		c-2.475-1.529-5.808-6.95-9.996-16.279c-7.806-15.604-13.989-29.786-18.555-42.537c-7.427-20.181-13.617-35.789-18.565-46.829		c-10.845-25.311-19.982-47.678-27.401-67.092c-4.001-10.466-15.797-38.731-35.405-84.796L255.813,24.265l-3.142-5.996h-15.129		h-21.414l-79.94,206.704L68.523,400.847c-5.33,9.896-9.9,16.372-13.706,19.417c-3.996,2.848-14.466,5.805-31.405,8.843		c-11.042,2.102-18.654,3.812-22.841,5.141L0,456.812h5.996c16.37,0,32.264-1.334,47.679-3.997l13.706-2.279		c53.868,3.806,87.082,5.708,99.642,5.708c0.381-1.902,0.571-4.476,0.571-7.706c0-5.715-0.094-11.231-0.287-16.563		c-3.996-0.568-7.851-1.143-11.561-1.711c-3.711-0.575-6.567-1.047-8.565-1.431c-1.997-0.373-3.284-0.568-3.855-0.568		c-14.657-2.094-24.46-5.14-29.407-9.134c-3.236-2.282-4.854-6.375-4.854-12.278c0-3.806,2.19-11.796,6.567-23.982		c14.277-39.776,24.172-65.856,29.692-78.224l128.483,0.568l26.269,65.096l13.411,32.541c1.144,3.241,1.711,6.283,1.711,9.138		s-1.14,5.428-3.426,7.707c-2.285,1.905-8.753,4.093-19.417,6.563l-37.404,7.994c-0.763,6.283-1.136,13.702-1.136,22.271		l16.56-0.575l57.103-3.138c10.656-0.38,23.51-0.575,38.547-0.575c18.264,0,36.251,0.763,53.957,2.282		c21.313,1.523,39.588,2.283,54.819,2.283c0.192-2.283,0.281-4.754,0.281-7.423C475.082,445.957,474.513,440.537,473.371,433.11z		 M251.245,270.941c-2.666,0-7.662-0.052-14.989-0.144c-7.327-0.089-18.649-0.233-33.973-0.425		c-15.321-0.195-29.93-0.383-43.824-0.574l48.535-128.477c7.424,15.037,16.178,35.117,26.264,60.242		c11.425,27.79,20.179,50.727,26.273,68.809L251.245,270.941z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["check"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"	 xml:space="preserve"><g>	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225		C438.532,59.576,430.49,40.204,414.41,24.123z M370.88,159.024l-175.307,175.3c-3.615,3.614-7.898,5.428-12.85,5.428		c-4.95,0-9.233-1.807-12.85-5.421L67.663,232.118c-3.616-3.62-5.424-7.898-5.424-12.848c0-4.949,1.809-9.233,5.424-12.847		l29.124-29.124c3.617-3.616,7.895-5.424,12.847-5.424c4.952,0,9.235,1.809,12.851,5.424l60.242,60.24l133.334-133.333		c3.606-3.617,7.898-5.424,12.847-5.424c4.945,0,9.227,1.807,12.847,5.424l29.126,29.125c3.61,3.615,5.421,7.898,5.421,12.847		S374.49,155.411,370.88,159.024z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["copy"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="511.627px" height="511.627px" viewBox="0 0 511.627 511.627" style="enable-background:new 0 0 511.627 511.627;"	 xml:space="preserve"><g>	<path d="M503.633,117.628c-5.332-5.327-11.8-7.993-19.41-7.993H365.446c-11.417,0-23.603,3.806-36.542,11.42V27.412		c0-7.616-2.662-14.092-7.994-19.417C315.578,2.666,309.11,0,301.492,0H182.725c-7.614,0-15.99,1.903-25.125,5.708		c-9.136,3.806-16.368,8.376-21.7,13.706L19.414,135.901c-5.33,5.329-9.9,12.563-13.706,21.698C1.903,166.738,0,175.108,0,182.725		v191.858c0,7.618,2.663,14.093,7.992,19.417c5.33,5.332,11.803,7.994,19.414,7.994h155.318v82.229c0,7.61,2.662,14.085,7.992,19.41		c5.327,5.332,11.8,7.994,19.414,7.994h274.091c7.61,0,14.085-2.662,19.41-7.994c5.332-5.325,7.994-11.8,7.994-19.41V137.046		C511.627,129.432,508.965,122.958,503.633,117.628z M328.904,170.449v85.364h-85.366L328.904,170.449z M146.178,60.813v85.364		H60.814L146.178,60.813z M202.139,245.535c-5.33,5.33-9.9,12.564-13.706,21.701c-3.805,9.141-5.708,17.508-5.708,25.126v73.083		H36.547V182.725h118.766c7.616,0,14.087-2.664,19.417-7.994c5.327-5.33,7.994-11.801,7.994-19.412V36.547h109.637v118.771		L202.139,245.535z M475.078,475.085H219.263V292.355h118.775c7.614,0,14.082-2.662,19.41-7.994		c5.328-5.325,7.994-11.797,7.994-19.41V146.178h109.629v328.907H475.078z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["coding"] = `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 470 470" xmlns:xlink="http://www.w3.org/1999/xlink" enable-background="new 0 0 470 470">  <g>    <path d="m167.313,209.123c-2.12-3.559-6.723-4.726-10.281-2.605l-87.369,52.039c-2.271,1.352-3.663,3.8-3.663,6.443s1.392,5.091 3.662,6.443l87.369,52.039c1.203,0.717 2.525,1.058 3.831,1.058 2.556,0 5.048-1.308 6.45-3.663 2.12-3.559 0.953-8.162-2.605-10.281l-76.551-45.596 76.551-45.596c3.559-2.119 4.726-6.722 2.606-10.281z"/>    <path d="m302.688,320.877c1.403,2.356 3.894,3.663 6.45,3.663 1.306,0 2.628-0.341 3.831-1.058l87.369-52.039c2.271-1.353 3.662-3.8 3.662-6.443s-1.392-5.091-3.662-6.443l-87.369-52.039c-3.558-2.12-8.163-0.954-10.281,2.605-2.12,3.559-0.953,8.162 2.605,10.281l76.551,45.596-76.551,45.596c-3.559,2.119-4.726,6.722-2.605,10.281z"/>    <path d="m263.72,208.78l-69.893,104.078c-2.309,3.438-1.394,8.098 2.045,10.408 1.284,0.862 2.737,1.274 4.175,1.274 2.415,0 4.786-1.165 6.233-3.32l69.893-104.078c2.309-3.438 1.394-8.098-2.045-10.408-3.441-2.309-8.1-1.392-10.408,2.046z"/>    <path d="m462.5,22.5h-455c-4.143,0-7.5,3.358-7.5,7.5v410c0,4.142 3.357,7.5 7.5,7.5h455c4.143,0 7.5-3.358 7.5-7.5v-80c0-4.142-3.357-7.5-7.5-7.5s-7.5,3.358-7.5,7.5v72.5h-440v-335h440v232.5c0,4.142 3.357,7.5 7.5,7.5s7.5-3.358 7.5-7.5v-300c0-4.142-3.357-7.5-7.5-7.5zm-447.5,15h277.5v45h-277.5v-45zm292.5,45v-45h147.5v45h-147.5z"/>    <path d="m381.5,52c-4.411,0-8,3.589-8,8s3.589,8 8,8 8-3.589 8-8-3.589-8-8-8z"/>    <path d="m340.5,52c-4.411,0-8,3.589-8,8s3.589,8 8,8 8-3.589 8-8-3.589-8-8-8z"/>    <path d="m422.5,52c-4.411,0-8,3.589-8,8s3.589,8 8,8 8-3.589 8-8-3.589-8-8-8z"/>  </g></svg>`
SVGS["inspector"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 463.001 463.001" style="enable-background:new 0 0 463.001 463.001;" xml:space="preserve"><g>	<path d="M303.501,0c-87.948,0-159.5,71.551-159.5,159.5c0,36.188,12.122,69.593,32.507,96.386l-32.311,32.311		c-0.205,0.205-0.392,0.421-0.569,0.643c-2.645-0.551-5.363-0.84-8.127-0.84c-10.55,0-20.47,4.109-27.933,11.572l-95.999,95.999		C4.108,403.03,0,412.949,0,423.5s4.108,20.471,11.568,27.928C19.031,458.891,28.951,463,39.501,463s20.47-4.109,27.933-11.572		l95.999-95.999c7.461-7.458,11.569-17.377,11.569-27.929c0-2.765-0.289-5.484-0.84-8.129c0.222-0.176,0.437-0.363,0.642-0.568		l32.31-32.31C233.908,306.879,267.313,319,303.501,319c87.948,0,159.5-71.551,159.5-159.5S391.449,0,303.501,0z M56.826,440.822		C52.197,445.451,46.045,448,39.501,448s-12.696-2.549-17.326-7.179C17.548,436.196,15,430.045,15,423.5s2.548-12.696,7.176-17.322		l86.698-86.698l34.647,34.647L56.826,440.822z M154.075,343.468l-34.528-34.528c4.575-3.936,10.258-5.926,15.954-5.926		c6.274,0,12.55,2.389,17.326,7.166c4.627,4.625,7.175,10.776,7.175,17.321C160.002,333.427,157.906,339.027,154.075,343.468z		 M167.73,304.665c-1.278-1.796-2.706-3.503-4.296-5.092c-1.592-1.591-3.301-3.02-5.098-4.299l27.841-27.841		c3,3.259,6.134,6.393,9.393,9.393L167.73,304.665z M303.501,304c-79.678,0-144.5-64.822-144.5-144.5S223.823,15,303.501,15		s144.5,64.822,144.5,144.5S383.179,304,303.501,304z"/>	<path d="M303.501,32c-70.304,0-127.5,57.196-127.5,127.5S233.197,287,303.501,287s127.5-57.196,127.5-127.5S373.805,32,303.501,32z		 M303.501,272c-62.032,0-112.5-50.467-112.5-112.5S241.469,47,303.501,47s112.5,50.467,112.5,112.5S365.533,272,303.501,272z"/>	<path d="M355.58,79.438c-3.47-2.262-8.116-1.283-10.378,2.188c-2.262,3.47-1.282,8.117,2.188,10.378		c22.924,14.94,36.61,40.172,36.61,67.496c0,18.667-6.534,36.86-18.399,51.226c-2.638,3.193-2.187,7.921,1.007,10.559		c1.398,1.155,3.09,1.717,4.772,1.717c2.16,0,4.304-0.929,5.787-2.724c14.079-17.047,21.833-38.632,21.833-60.777		C399.001,127.087,382.769,97.158,355.58,79.438z"/>	<path d="M320.856,65.575C315.168,64.53,309.329,64,303.501,64c-4.143,0-7.5,3.358-7.5,7.5s3.357,7.5,7.5,7.5		c4.922,0,9.849,0.447,14.645,1.328c0.459,0.084,0.914,0.125,1.364,0.125c3.549,0,6.703-2.531,7.368-6.146		C327.626,70.233,324.93,66.324,320.856,65.575z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["trash"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 486.4 486.4" style="enable-background:new 0 0 486.4 486.4;" xml:space="preserve"><g>	<g>		<path d="M446,70H344.8V53.5c0-29.5-24-53.5-53.5-53.5h-96.2c-29.5,0-53.5,24-53.5,53.5V70H40.4c-7.5,0-13.5,6-13.5,13.5			S32.9,97,40.4,97h24.4v317.2c0,39.8,32.4,72.2,72.2,72.2h212.4c39.8,0,72.2-32.4,72.2-72.2V97H446c7.5,0,13.5-6,13.5-13.5			S453.5,70,446,70z M168.6,53.5c0-14.6,11.9-26.5,26.5-26.5h96.2c14.6,0,26.5,11.9,26.5,26.5V70H168.6V53.5z M394.6,414.2			c0,24.9-20.3,45.2-45.2,45.2H137c-24.9,0-45.2-20.3-45.2-45.2V97h302.9v317.2H394.6z"/>		<path d="M243.2,411c7.5,0,13.5-6,13.5-13.5V158.9c0-7.5-6-13.5-13.5-13.5s-13.5,6-13.5,13.5v238.5			C229.7,404.9,235.7,411,243.2,411z"/>		<path d="M155.1,396.1c7.5,0,13.5-6,13.5-13.5V173.7c0-7.5-6-13.5-13.5-13.5s-13.5,6-13.5,13.5v208.9			C141.6,390.1,147.7,396.1,155.1,396.1z"/>		<path d="M331.3,396.1c7.5,0,13.5-6,13.5-13.5V173.7c0-7.5-6-13.5-13.5-13.5s-13.5,6-13.5,13.5v208.9			C317.8,390.1,323.8,396.1,331.3,396.1z"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["multiply"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 32.526 32.526" style="enable-background:new 0 0 32.526 32.526;" xml:space="preserve"><polygon points="32.526,2.828 29.698,0 16.263,13.435 2.828,0 0,2.828 13.435,16.263 0,29.698 2.828,32.526 16.263,19.091 	29.698,32.526 32.526,29.698 19.091,16.263 "/><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["divide"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 42 42" style="enable-background:new 0 0 42 42;" xml:space="preserve"><g>	<rect y="19" width="42" height="4"/>	<path d="M21,13c2.757,0,5-2.243,5-5s-2.243-5-5-5s-5,2.243-5,5S18.243,13,21,13z"/>	<path d="M21,29c-2.757,0-5,2.243-5,5s2.243,5,5,5s5-2.243,5-5S23.757,29,21,29z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["add"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 42 42" style="enable-background:new 0 0 42 42;" xml:space="preserve"><polygon points="42,20 22,20 22,0 20,0 20,20 0,20 0,22 20,22 20,42 22,42 22,22 42,22 "/><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["printer"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 482.5 482.5" style="enable-background:new 0 0 482.5 482.5;" xml:space="preserve"><g>	<g>		<path d="M399.25,98.9h-12.4V71.3c0-39.3-32-71.3-71.3-71.3h-149.7c-39.3,0-71.3,32-71.3,71.3v27.6h-11.3			c-39.3,0-71.3,32-71.3,71.3v115c0,39.3,32,71.3,71.3,71.3h11.2v90.4c0,19.6,16,35.6,35.6,35.6h221.1c19.6,0,35.6-16,35.6-35.6			v-90.4h12.5c39.3,0,71.3-32,71.3-71.3v-115C470.55,130.9,438.55,98.9,399.25,98.9z M121.45,71.3c0-24.4,19.9-44.3,44.3-44.3h149.6			c24.4,0,44.3,19.9,44.3,44.3v27.6h-238.2V71.3z M359.75,447.1c0,4.7-3.9,8.6-8.6,8.6h-221.1c-4.7,0-8.6-3.9-8.6-8.6V298h238.3			V447.1z M443.55,285.3c0,24.4-19.9,44.3-44.3,44.3h-12.4V298h17.8c7.5,0,13.5-6,13.5-13.5s-6-13.5-13.5-13.5h-330			c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5h19.9v31.6h-11.3c-24.4,0-44.3-19.9-44.3-44.3v-115c0-24.4,19.9-44.3,44.3-44.3h316			c24.4,0,44.3,19.9,44.3,44.3V285.3z"/>		<path d="M154.15,364.4h171.9c7.5,0,13.5-6,13.5-13.5s-6-13.5-13.5-13.5h-171.9c-7.5,0-13.5,6-13.5,13.5S146.75,364.4,154.15,364.4			z"/>		<path d="M327.15,392.6h-172c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5h171.9c7.5,0,13.5-6,13.5-13.5S334.55,392.6,327.15,392.6z"			/>		<path d="M398.95,151.9h-27.4c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5h27.4c7.5,0,13.5-6,13.5-13.5S406.45,151.9,398.95,151.9z"			/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["function"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="142.514px" height="142.514px" viewBox="0 0 142.514 142.514" style="enable-background:new 0 0 142.514 142.514;"	 xml:space="preserve"><g>	<g>		<path d="M34.367,142.514c11.645,0,17.827-10.4,19.645-16.544c0.029-0.097,0.056-0.196,0.081-0.297			c4.236-17.545,10.984-45.353,15.983-65.58h17.886c3.363,0,6.09-2.726,6.09-6.09c0-3.364-2.727-6.09-6.09-6.09H73.103			c1.6-6.373,2.771-10.912,3.232-12.461l0.512-1.734c1.888-6.443,6.309-21.535,13.146-21.535c6.34,0,7.285,9.764,7.328,10.236			c0.27,3.343,3.186,5.868,6.537,5.579c3.354-0.256,5.864-3.187,5.605-6.539C108.894,14.036,104.087,0,89.991,0			C74.03,0,68.038,20.458,65.159,30.292l-0.49,1.659c-0.585,1.946-2.12,7.942-4.122,15.962H39.239c-3.364,0-6.09,2.726-6.09,6.09			c0,3.364,2.726,6.09,6.09,6.09H57.53c-6.253,25.362-14.334,58.815-15.223,62.498c-0.332,0.965-2.829,7.742-7.937,7.742			c-7.8,0-11.177-10.948-11.204-11.03c-0.936-3.229-4.305-5.098-7.544-4.156c-3.23,0.937-5.092,4.314-4.156,7.545			C13.597,130.053,20.816,142.514,34.367,142.514z"/>		<path d="M124.685,126.809c3.589,0,6.605-2.549,6.605-6.607c0-1.885-0.754-3.586-2.359-5.474l-12.646-14.534l12.271-14.346			c1.132-1.416,1.98-2.926,1.98-4.908c0-3.59-2.927-6.231-6.703-6.231c-2.547,0-4.527,1.604-6.229,3.684l-9.531,12.454L98.73,78.391			c-1.89-2.357-3.869-3.682-6.7-3.682c-3.59,0-6.607,2.551-6.607,6.609c0,1.885,0.756,3.586,2.357,5.471l11.799,13.592			L86.647,115.67c-1.227,1.416-1.98,2.926-1.98,4.908c0,3.589,2.926,6.229,6.699,6.229c2.549,0,4.53-1.604,6.229-3.682l10.19-13.4			l10.193,13.4C119.872,125.488,121.854,126.809,124.685,126.809z"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["export"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 67.671 67.671" style="enable-background:new 0 0 67.671 67.671;" xml:space="preserve"><g>	<path d="M52.946,23.348H42.834v6h10.112c3.007,0,5.34,1.536,5.34,2.858v26.606c0,1.322-2.333,2.858-5.34,2.858H14.724		c-3.007,0-5.34-1.536-5.34-2.858V32.207c0-1.322,2.333-2.858,5.34-2.858h10.11v-6h-10.11c-6.359,0-11.34,3.891-11.34,8.858v26.606		c0,4.968,4.981,8.858,11.34,8.858h38.223c6.358,0,11.34-3.891,11.34-8.858V32.207C64.286,27.239,59.305,23.348,52.946,23.348z"/>	<path d="M24.957,14.955c0.768,0,1.535-0.293,2.121-0.879l3.756-3.756v13.028v6v11.494c0,1.657,1.343,3,3,3s3-1.343,3-3V29.348v-6		V10.117l3.959,3.959c0.586,0.586,1.354,0.879,2.121,0.879s1.535-0.293,2.121-0.879c1.172-1.171,1.172-3.071,0-4.242l-8.957-8.957		C35.492,0.291,34.725,0,33.958,0c-0.008,0-0.015,0-0.023,0s-0.015,0-0.023,0c-0.767,0-1.534,0.291-2.12,0.877l-8.957,8.957		c-1.172,1.171-1.172,3.071,0,4.242C23.422,14.662,24.189,14.955,24.957,14.955z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["import"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 60.903 60.903" style="enable-background:new 0 0 60.903 60.903;" xml:space="preserve"><g>	<path d="M49.561,16.464H39.45v6h10.111c3.008,0,5.341,1.535,5.341,2.857v26.607c0,1.321-2.333,2.858-5.341,2.858H11.34		c-3.007,0-5.34-1.537-5.34-2.858V25.324c0-1.322,2.333-2.858,5.34-2.858h10.11v-6H11.34C4.981,16.466,0,20.357,0,25.324v26.605		c0,4.968,4.981,8.857,11.34,8.857h38.223c6.357,0,11.34-3.891,11.34-8.857V25.324C60.902,20.355,55.921,16.464,49.561,16.464z"/>	<path d="M39.529,29.004c-0.768,0-1.535,0.294-2.121,0.88l-3.756,3.755V20.612v-6V3.117c0-1.656-1.343-3-3-3s-3,1.344-3,3v11.494v6		v13.23l-3.959-3.958c-0.586-0.586-1.354-0.88-2.121-0.88s-1.535,0.294-2.121,0.88c-1.172,1.17-1.172,3.07,0,4.241l8.957,8.957		c0.586,0.586,1.354,0.877,2.12,0.877c0.008,0,0.016,0,0.023,0s0.015,0,0.022,0c0.768,0,1.534-0.291,2.12-0.877l8.957-8.957		c1.172-1.171,1.172-3.071,0-4.241C41.064,29.298,40.298,29.004,39.529,29.004z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["folder"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 59.911 59.911" style="enable-background:new 0 0 59.911 59.911;" xml:space="preserve"><path d="M59.605,23.399c-0.241-0.281-0.593-0.443-0.965-0.443H56V8.723c0-0.975-0.793-1.768-1.768-1.768H23.566l-2.485-4.141	c-0.317-0.53-0.898-0.859-1.516-0.859H5.767C4.793,1.956,4,2.749,4,3.723v19.232H1.27c-0.37,0-0.721,0.161-0.962,0.441	c-0.242,0.28-0.35,0.651-0.294,1.02l4.917,32.454c0.091,0.618,0.631,1.085,1.257,1.085h47.534c0.626,0,1.166-0.467,1.256-1.081	l4.918-32.454C59.953,24.053,59.847,23.681,59.605,23.399z M6,3.956h13.434l2.485,4.141c0.317,0.53,0.898,0.859,1.516,0.859H54v14	h-1v-4h-1v-3h-1v-3H9v3H8v3H7v4H6V3.956z M9,20.956h42v2H9V20.956z M10,17.956h40v1H10V17.956z M49,15.956H11v-1h38V15.956z	 M53.095,55.956H6.815l-4.696-31H4h3h46h3h1.792L53.095,55.956z"/><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["score"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 297 297" style="enable-background:new 0 0 297 297;" xml:space="preserve"><g>	<path d="M288.5,17.5H8.5C3.806,17.5,0,21.306,0,26v245c0,4.694,3.806,8.5,8.5,8.5h280c4.694,0,8.5-3.806,8.5-8.5V26		C297,21.306,293.194,17.5,288.5,17.5z M280,262.5H17v-228h263V262.5z"/>	<path d="M61,157h35c4.694,0,8.5-3.806,8.5-8.5v-70c0-4.694-3.806-8.5-8.5-8.5H61c-4.694,0-8.5,3.806-8.5,8.5v70		C52.5,153.194,56.306,157,61,157z M69.5,87h18v53h-18V87z"/>	<path d="M131,157h35c4.694,0,8.5-3.806,8.5-8.5v-70c0-4.694-3.806-8.5-8.5-8.5h-35c-4.694,0-8.5,3.806-8.5,8.5v70		C122.5,153.194,126.306,157,131,157z M139.5,87h18v53h-18V87z"/>	<path d="M201,140c-4.694,0-8.5,3.806-8.5,8.5s3.806,8.5,8.5,8.5h35c4.694,0,8.5-3.806,8.5-8.5v-70c0-4.694-3.806-8.5-8.5-8.5h-35		c-4.694,0-8.5,3.806-8.5,8.5s3.806,8.5,8.5,8.5h26.5v18H201c-4.694,0-8.5,3.806-8.5,8.5s3.806,8.5,8.5,8.5h26.5v18H201z"/>	<path d="M70,209.75c0,19.161,15.589,34.75,34.75,34.75s34.75-15.589,34.75-34.75S123.911,175,104.75,175S70,190.589,70,209.75z		 M104.75,192c9.787,0,17.75,7.963,17.75,17.75s-7.963,17.75-17.75,17.75S87,219.537,87,209.75S94.963,192,104.75,192z"/>	<path d="M157.5,209.75c0,19.161,15.589,34.75,34.75,34.75S227,228.911,227,209.75S211.411,175,192.25,175		S157.5,190.589,157.5,209.75z M192.25,192c9.787,0,17.75,7.963,17.75,17.75s-7.963,17.75-17.75,17.75s-17.75-7.963-17.75-17.75		S182.463,192,192.25,192z"/>	<path d="M35.017,253.52c2.24,0,4.431-0.91,6.01-2.5c1.58-1.58,2.49-3.77,2.49-6c0-2.24-0.91-4.43-2.49-6.02		c-1.579-1.58-3.77-2.48-6.01-2.48s-4.43,0.9-6.01,2.48c-1.58,1.59-2.49,3.779-2.49,6.02c0,2.23,0.91,4.42,2.49,6		C30.587,252.609,32.776,253.52,35.017,253.52z"/>	<path d="M35.017,60.49c2.24,0,4.42-0.91,6.01-2.49c1.58-1.59,2.49-3.78,2.49-6.021c0-2.229-0.91-4.42-2.49-6.01		c-1.579-1.58-3.77-2.49-6.01-2.49s-4.43,0.91-6.01,2.49c-1.58,1.59-2.49,3.78-2.49,6.01c0,2.24,0.91,4.431,2.49,6.021		C30.587,59.58,32.776,60.49,35.017,60.49z"/>	<path d="M260.927,253.52c2.23,0,4.42-0.91,6.01-2.5c1.58-1.58,2.49-3.77,2.49-6c0-2.24-0.91-4.43-2.49-6.02		c-1.59-1.58-3.779-2.48-6.01-2.48c-2.24,0-4.43,0.9-6.01,2.48c-1.59,1.59-2.49,3.779-2.49,6.02c0,2.23,0.9,4.42,2.49,6		C256.497,252.609,258.687,253.52,260.927,253.52z"/>	<path d="M260.927,60.49c2.23,0,4.42-0.91,6.01-2.49c1.58-1.59,2.49-3.78,2.49-6.021c0-2.229-0.91-4.42-2.49-6.01		c-1.59-1.58-3.779-2.49-6.01-2.49c-2.24,0-4.43,0.91-6.01,2.49c-1.59,1.59-2.49,3.78-2.49,6.01c0,2.24,0.9,4.431,2.49,6.021		C256.497,59.58,258.687,60.49,260.927,60.49z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["tree"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 483.6 483.6" style="enable-background:new 0 0 483.6 483.6;" xml:space="preserve"><g>	<path d="M466.2,353.25H451v-30.2c0-9.9-5.6-17.1-13.4-17.1h-53.1v-36.4h15.2c9.5,0,17.2-7.7,17.2-17.2v-30		c0-9.5-7.7-17.2-17.2-17.2h-15.2v-30.3c0-9.4-7.7-17.1-17.1-17.1H251.2v-27.3h15.4c9.5,0,17.2-7.7,17.2-17.2v-30		c0-9.5-7.7-17.2-17.2-17.2h-49.9c-9.5,0-17.2,7.7-17.2,17.2v30c0,9.5,7.7,17.2,17.2,17.2h15.1v27.3H116.1		c-9.4,0-17.1,7.7-17.1,17.1v30.2H83.7c-9.5,0-17.2,7.7-17.2,17.2v30c0,9.5,7.7,17.2,17.2,17.2h15.2v36.4h-53		c-7.8,0-13.4,7.2-13.4,17.1v30.2H17.2c-9.5,0-17.2,7.7-17.2,17.2v30c0,9.5,7.7,17.2,17.2,17.2h49.9c9.5,0,17.2-7.7,17.2-17.2v-30		c0-9.5-7.7-17.2-17.2-17.2H51.9v-27.9h113.6v27.9h-15.2c-9.5,0-17.2,7.7-17.2,17.2v30c0,9.5,7.7,17.2,17.2,17.2h49.9		c9.5,0,17.2-7.7,17.2-17.2v-30c0-9.5-7.7-17.2-17.2-17.2H185v-30.2c0-9.9-5.6-17.1-13.4-17.1h-53.1v-36.4h15.2		c9.5,0,17.2-7.7,17.2-17.2v-30c0-9.5-7.7-17.2-17.2-17.2h-15.2v-27.9h113.4v27.9h-15.1c-9.5,0-17.2,7.7-17.2,17.2v30		c0,9.5,7.7,17.2,17.2,17.2h49.9c9.5,0,17.2-7.7,17.2-17.2v-30c0-9.5-7.7-17.2-17.2-17.2h-15.4v-27.9h113.8v27.9h-15.2		c-9.5,0-17.2,7.7-17.2,17.2v30c0,9.5,7.7,17.2,17.2,17.2h15.2v36.4H312c-7.8,0-13.4,7.2-13.4,17.1v30.2h-15.2		c-9.5,0-17.2,7.7-17.2,17.2v30c0,9.5,7.7,17.2,17.2,17.2h49.9c9.5,0,17.2-7.7,17.2-17.2v-30c0-9.5-7.7-17.2-17.2-17.2h-15.2v-27.9		h113.6v27.9h-15.2c-9.5,0-17.2,7.7-17.2,17.2v30c0,9.5,7.7,17.2,17.2,17.2h49.9c9.5,0,17.2-7.7,17.2-17.2v-30		C483.3,360.95,475.7,353.25,466.2,353.25z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["www"] = `<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 512 512" style="enable-background:new 0 0 512 512;" xml:space="preserve"><g>	<g>		<g>			<path d="M446.147,117.431h-14.817h-41.561c-6.552-21.836-18.444-41.844-35.017-58.419C328.374,32.636,293.304,18.111,256,18.111				c-62.986,0-116.359,41.919-133.707,99.32H0v80.668h122.294c16.666,55.135,66.569,95.984,126.307,99.123v20.355l-24.699,0.005				l-0.005,176.307h64.2l0.005-176.32l-24.683,0.005v-20.352c59.728-3.14,109.624-43.989,126.287-99.123h41.623h14.817H512v-80.668				H446.147z M238.719,362.615h34.565l-0.003,86.228h-34.565L238.719,362.615z M238.715,479.075l0.001-15.414h34.565l-0.001,15.414				H238.715z M273.285,347.8h-34.565l0.001-15.409h34.565L273.285,347.8z M256,32.925c33.347,0,64.694,12.984,88.274,36.562				c6.155,6.155,11.581,12.844,16.249,19.955H151.571C173.895,55.433,212.365,32.925,256,32.925z M14.817,183.284v-51.036h103.874				c-1.534,8.276-2.344,16.802-2.344,25.516c0,8.715,0.81,17.243,2.345,25.521H14.817z M256.008,282.602				c-43.632-0.005-82.099-22.508-104.427-56.509h208.842C338.099,260.098,299.636,282.602,256.008,282.602z M368.77,211.276H143.232				c-7.733-16.228-12.068-34.374-12.068-53.514c0-19.136,4.333-37.277,12.061-53.501h225.637				c7.839,16.507,11.974,34.687,11.974,53.501C380.836,176.902,376.501,195.047,368.77,211.276z M431.329,183.284h-38.021				c1.535-8.277,2.345-16.806,2.345-25.521c0.001-8.653-0.791-17.183-2.32-25.516h37.997V183.284z M497.183,183.284h-51.036v-51.036				h51.036V183.284z"/>			<path d="M199.201,159.725l-4.938,7.409l-4.938-7.409v-24.686h-14.817v24.686l-4.938,7.409l-4.938-7.409v-24.686h-14.817v26.924				c0,1.462,0.435,2.89,1.244,4.109l12.347,18.522c1.375,2.063,3.689,3.3,6.164,3.3s4.79-1.236,6.164-3.297l6.183-9.276l6.182,9.273				c1.372,2.063,3.689,3.3,6.164,3.3c2.478,0,4.792-1.236,6.164-3.297l12.347-18.522c0.812-1.219,1.244-2.647,1.244-4.109v-26.926				h-14.817V159.725z"/>			<path d="M273.288,159.725l-4.938,7.409l-4.941-7.409v-24.686h0h-14.817v24.686l-4.938,7.409l-4.938-7.409v-24.686h-14.817v26.924				c0,1.462,0.435,2.89,1.244,4.109l12.347,18.522c1.372,2.063,3.689,3.3,6.164,3.3c2.475,0,4.79-1.236,6.164-3.297l6.184-9.275				l6.181,9.272c1.375,2.063,3.689,3.3,6.164,3.3s4.79-1.236,6.167-3.297l12.347-18.522c0.812-1.219,1.244-2.647,1.244-4.109				v-26.926h-14.817V159.725z"/>			<path d="M347.374,135.039v24.686l-4.941,7.409l-4.938-7.409v-24.686h-14.817h0v24.686l-4.938,7.409l-4.941-7.409v-24.686h-14.817				v26.924c0,1.462,0.435,2.89,1.244,4.109l12.347,18.522c1.372,2.063,3.686,3.3,6.164,3.3c2.476,0,4.79-1.236,6.167-3.297				l6.183-9.276l6.182,9.273c1.372,2.063,3.686,3.3,6.162,3.3s4.792-1.236,6.17-3.297l12.347-18.522				c0.809-1.219,1.244-2.647,1.244-4.109v-26.926H347.374z"/>		</g>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["font"] = `<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 340.111 340.111" style="enable-background:new 0 0 340.111 340.111;" xml:space="preserve"><g>	<polygon style="fill:#333E48;" points="340.111,76.316 340.111,65.175 292.206,65.175 292.206,76.316 310.588,76.316 		310.588,263.794 292.206,263.794 292.206,274.935 340.111,274.935 340.111,263.794 321.729,263.794 321.729,76.316 	"/>	<g>		<path style="fill:#1E252B;" d="M2.067,229.59l56.068-126.615c3.909-8.731,11.03-14.018,20.684-14.018h2.068			c9.648,0,16.544,5.286,20.449,14.018l56.07,126.615c1.149,2.528,1.84,4.825,1.84,7.124c0,9.421-7.354,17.004-16.776,17.004			c-8.272,0-13.788-4.825-17.004-12.18l-10.799-25.275H43.891l-11.26,26.426c-2.988,6.893-8.961,11.029-16.315,11.029			C7.121,253.718,0,246.365,0,237.173C0,234.645,0.918,232.118,2.067,229.59z M101.568,185.011l-22.291-53.082l-22.289,53.082			H101.568z"/>		<path style="fill:#1E252B;" d="M176.011,216.951v-0.46c0-26.885,20.452-39.294,49.635-39.294c12.41,0,21.373,2.068,30.105,5.056			v-2.068c0-14.478-8.963-22.519-26.427-22.519c-9.651,0-17.464,1.378-24.128,3.447c-2.067,0.689-3.447,0.918-5.058,0.918			c-8.04,0-14.474-6.204-14.474-14.246c0-6.205,3.905-11.49,9.419-13.559c11.03-4.136,22.981-6.434,39.296-6.434			c19.071,0,32.86,5.055,41.593,13.787c9.191,9.191,13.327,22.75,13.327,39.295v56.068c0,9.423-7.583,16.775-17.005,16.775			c-10.111,0-16.774-7.123-16.774-14.477v-0.23c-8.502,9.421-20.224,15.625-37.226,15.625			C195.083,254.637,176.011,241.311,176.011,216.951z M256.208,208.908v-6.204c-5.974-2.757-13.787-4.596-22.289-4.596			c-14.938,0-24.128,5.975-24.128,17.004v0.46c0,9.422,7.813,14.936,19.072,14.936C245.178,230.509,256.208,221.548,256.208,208.908			z"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["text"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 22.916 22.916" style="enable-background:new 0 0 22.916 22.916;" xml:space="preserve"><g>	<path d="M11.458,22.828H0.5c-0.276,0-0.5-0.224-0.5-0.5s0.224-0.5,0.5-0.5h10.958c0.276,0,0.5,0.224,0.5,0.5		S11.734,22.828,11.458,22.828z"/>	<path d="M22.416,15.582H0.5c-0.276,0-0.5-0.224-0.5-0.5s0.224-0.5,0.5-0.5h21.916c0.276,0,0.5,0.224,0.5,0.5		S22.692,15.582,22.416,15.582z"/>	<path d="M22.416,8.335H0.5c-0.276,0-0.5-0.224-0.5-0.5s0.224-0.5,0.5-0.5h21.916c0.276,0,0.5,0.224,0.5,0.5		S22.692,8.335,22.416,8.335z"/>	<path d="M22.416,1.088H0.5c-0.276,0-0.5-0.224-0.5-0.5s0.224-0.5,0.5-0.5h21.916c0.276,0,0.5,0.224,0.5,0.5		S22.692,1.088,22.416,1.088z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["table"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="475.082px" height="475.081px" viewBox="0 0 475.082 475.081" style="enable-background:new 0 0 475.082 475.081;"	 xml:space="preserve"><g>	<path d="M461.667,49.963c-8.949-8.947-19.698-13.418-32.265-13.418H45.682c-12.562,0-23.317,4.471-32.264,13.418		C4.473,58.912,0,69.663,0,82.228V392.86c0,12.566,4.473,23.309,13.418,32.261c8.947,8.949,19.701,13.415,32.264,13.415h383.72		c12.566,0,23.315-4.466,32.265-13.415c8.945-8.952,13.415-19.701,13.415-32.261V82.228		C475.082,69.663,470.612,58.909,461.667,49.963z M146.183,392.85c0,2.673-0.859,4.856-2.574,6.571		c-1.712,1.711-3.899,2.562-6.567,2.562h-91.36c-2.662,0-4.853-0.852-6.567-2.562c-1.713-1.715-2.568-3.898-2.568-6.571V338.03		c0-2.669,0.855-4.853,2.568-6.56c1.714-1.719,3.905-2.574,6.567-2.574h91.363c2.667,0,4.858,0.855,6.567,2.574		c1.711,1.707,2.57,3.891,2.57,6.56V392.85z M146.183,283.221c0,2.663-0.859,4.854-2.574,6.564		c-1.712,1.714-3.899,2.569-6.567,2.569h-91.36c-2.662,0-4.853-0.855-6.567-2.569c-1.713-1.711-2.568-3.901-2.568-6.564v-54.819		c0-2.664,0.855-4.854,2.568-6.567c1.714-1.709,3.905-2.565,6.567-2.565h91.363c2.667,0,4.854,0.855,6.567,2.565		c1.711,1.713,2.57,3.903,2.57,6.567V283.221z M146.183,173.587c0,2.666-0.859,4.853-2.574,6.567		c-1.712,1.709-3.899,2.568-6.567,2.568h-91.36c-2.662,0-4.853-0.859-6.567-2.568c-1.713-1.715-2.568-3.901-2.568-6.567V118.77		c0-2.666,0.855-4.856,2.568-6.567c1.714-1.713,3.905-2.568,6.567-2.568h91.363c2.667,0,4.854,0.855,6.567,2.568		c1.711,1.711,2.57,3.901,2.57,6.567V173.587z M292.362,392.85c0,2.673-0.855,4.856-2.563,6.571c-1.711,1.711-3.9,2.562-6.57,2.562		H191.86c-2.663,0-4.853-0.852-6.567-2.562c-1.713-1.715-2.568-3.898-2.568-6.571V338.03c0-2.669,0.855-4.853,2.568-6.56		c1.714-1.719,3.904-2.574,6.567-2.574h91.365c2.669,0,4.859,0.855,6.57,2.574c1.704,1.707,2.56,3.891,2.56,6.56v54.819H292.362z		 M292.362,283.221c0,2.663-0.855,4.854-2.563,6.564c-1.711,1.714-3.9,2.569-6.57,2.569H191.86c-2.663,0-4.853-0.855-6.567-2.569		c-1.713-1.711-2.568-3.901-2.568-6.564v-54.819c0-2.664,0.855-4.854,2.568-6.567c1.714-1.709,3.904-2.565,6.567-2.565h91.365		c2.669,0,4.859,0.855,6.57,2.565c1.704,1.713,2.56,3.903,2.56,6.567v54.819H292.362z M292.362,173.587		c0,2.666-0.855,4.853-2.563,6.567c-1.711,1.709-3.9,2.568-6.57,2.568H191.86c-2.663,0-4.853-0.859-6.567-2.568		c-1.713-1.715-2.568-3.901-2.568-6.567V118.77c0-2.666,0.855-4.856,2.568-6.567c1.714-1.713,3.904-2.568,6.567-2.568h91.365		c2.669,0,4.859,0.855,6.57,2.568c1.704,1.711,2.56,3.901,2.56,6.567v54.817H292.362z M438.536,392.85		c0,2.673-0.855,4.856-2.562,6.571c-1.718,1.711-3.908,2.562-6.571,2.562h-91.354c-2.673,0-4.862-0.852-6.57-2.562		c-1.711-1.715-2.56-3.898-2.56-6.571V338.03c0-2.669,0.849-4.853,2.56-6.56c1.708-1.719,3.897-2.574,6.57-2.574h91.354		c2.663,0,4.854,0.855,6.571,2.574c1.707,1.707,2.562,3.891,2.562,6.56V392.85z M438.536,283.221c0,2.663-0.855,4.854-2.562,6.564		c-1.718,1.714-3.908,2.569-6.571,2.569h-91.354c-2.673,0-4.862-0.855-6.57-2.569c-1.711-1.711-2.56-3.901-2.56-6.564v-54.819		c0-2.664,0.849-4.854,2.56-6.567c1.708-1.709,3.897-2.565,6.57-2.565h91.354c2.663,0,4.854,0.855,6.571,2.565		c1.707,1.713,2.562,3.903,2.562,6.567V283.221z M438.536,173.587c0,2.666-0.855,4.853-2.562,6.567		c-1.718,1.709-3.908,2.568-6.571,2.568h-91.354c-2.673,0-4.862-0.859-6.57-2.568c-1.711-1.715-2.56-3.901-2.56-6.567V118.77		c0-2.666,0.849-4.856,2.56-6.567c1.708-1.713,3.897-2.568,6.57-2.568h91.354c2.663,0,4.854,0.855,6.571,2.568		c1.707,1.711,2.562,3.901,2.562,6.567V173.587z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["filter"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 viewBox="0 0 247.46 247.46" style="enable-background:new 0 0 247.46 247.46;" xml:space="preserve"><path d="M246.744,13.984c-1.238-2.626-3.881-4.301-6.784-4.301H7.5c-2.903,0-5.545,1.675-6.784,4.301	c-1.238,2.626-0.85,5.73,0.997,7.97l89.361,108.384v99.94c0,2.595,1.341,5.005,3.545,6.373c1.208,0.749,2.579,1.127,3.955,1.127	c1.137,0,2.278-0.259,3.33-0.78l50.208-24.885c2.551-1.264,4.165-3.863,4.169-6.71l0.098-75.062l89.366-108.388	C247.593,19.714,247.982,16.609,246.744,13.984z M143.097,122.873c-1.105,1.34-1.711,3.023-1.713,4.761l-0.096,73.103	l-35.213,17.453v-90.546c0-1.741-0.605-3.428-1.713-4.771L23.404,24.682h200.651L143.097,122.873z"/><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["reddit"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="430.117px" height="430.117px" viewBox="0 0 430.117 430.117" style="enable-background:new 0 0 430.117 430.117;"	 xml:space="preserve"><g>	<path id="reddit" d="M307.523,231.062c1.11,2.838,1.614,5.769,1.614,8.681c0,5.862-2.025,11.556-5.423,16.204		c-3.36,4.593-8.121,8.158-13.722,9.727h0.01c-0.047,0.019-0.094,0.019-0.117,0.037c-0.023,0-0.061,0.019-0.079,0.019		c-2.623,0.896-5.312,1.316-7.98,1.316c-6.254,0-12.396-2.254-17.306-6.096c-4.872-3.826-8.56-9.324-9.717-15.845h-0.01		c0-0.019,0-0.042-0.009-0.069c0-0.019,0-0.038-0.019-0.065h0.019c-0.364-1.681-0.551-3.36-0.551-5.021		c0-5.647,1.923-11.07,5.097-15.551c3.164-4.453,7.626-7.99,12.848-9.811c0.019,0,0.038-0.01,0.038-0.01		c0.027,0,0.027-0.027,0.051-0.027c2.954-1.092,6.072-1.639,9.157-1.639c5.619,0,11.154,1.704,15.821,4.821		c4.611,3.066,8.354,7.561,10.23,13.143c0.019,0.037,0.019,0.07,0.037,0.103c0,0.037,0.019,0.057,0.037,0.084H307.523z		 M290.329,300.349c-2.202-1.428-4.751-2.291-7.448-2.291c-2.175,0-4.434,0.621-6.445,1.955l0,0		c-19.004,11.342-41.355,17.558-63.547,17.558c-16.65,0-33.199-3.514-48.192-10.879l-0.077-0.037l-0.075-0.028		c-2.261-0.924-4.837-2.889-7.647-4.76c-1.428-0.925-2.919-1.844-4.574-2.521c-1.633-0.695-3.447-1.181-5.386-1.181		c-1.605,0-3.292,0.359-4.957,1.115c-0.086,0.033-0.168,0.065-0.252,0.098h0.009c-2.616,0.999-4.66,2.829-5.974,4.994		c-1.372,2.23-2.046,4.826-2.046,7.411c0,2.334,0.551,4.667,1.691,6.786c1.085,2.007,2.754,3.762,4.938,4.938		c21.429,14.454,46.662,21.002,71.992,20.979c22.838,0,45.814-5.287,66.27-14.911l0.107-0.065l0.103-0.056		c2.697-1.597,6.282-3.029,9.661-5.115c1.671-1.064,3.304-2.296,4.704-3.897c1.4-1.591,2.525-3.551,3.16-5.875v-0.01		c0.266-1.026,0.392-2.025,0.392-3.024c0-1.899-0.467-3.701-1.241-5.32C294.361,303.775,292.504,301.778,290.329,300.349z		 M139.875,265.589c0.037,0,0.086,0.014,0.128,0.037c2.735,0.999,5.554,1.493,8.345,1.493c6.963,0,13.73-2.852,18.853-7.5		c5.115-4.662,8.618-11.257,8.618-18.775c0-0.196,0-0.392-0.009-0.625c0.019-0.336,0.028-0.705,0.028-1.083		c0-7.458-3.456-14.08-8.522-18.762c-5.085-4.686-11.836-7.551-18.825-7.551c-1.867,0-3.769,0.219-5.628,0.653		c-0.028,0-0.049,0.009-0.077,0.009c0,0-0.019,0-0.028,0c-9.252,1.937-17.373,8.803-20.37,18.248l0,0v0.01		c0,0.019-0.009,0.037-0.009,0.037c-0.861,2.586-1.262,5.255-1.262,7.896c0,5.787,1.913,11.426,5.211,16.064		c3.269,4.56,7.894,8.145,13.448,9.819C139.816,265.561,139.835,265.571,139.875,265.589z M430.033,198.094v0.038		c0.066,0.94,0.084,1.878,0.084,2.81c0,10.447-3.351,20.493-8.941,29.016c-5.218,7.976-12.414,14.649-20.703,19.177		c0.532,4.158,0.84,8.349,0.84,12.526c-0.01,22.495-7.766,44.607-21.272,62.329v0.009h-0.028		c-24.969,33.216-63.313,52.804-102.031,62.684h-0.01l-0.027,0.023c-20.647,5.013-41.938,7.574-63.223,7.574		c-31.729,0-63.433-5.722-93.018-17.585l-0.009-0.028h-0.028c-30.672-12.643-59.897-32.739-77.819-62.184		c-9.642-15.71-14.935-34.141-14.935-52.659c0-4.19,0.283-8.387,0.843-12.536c-8.072-4.545-15.063-10.99-20.255-18.687		c-5.542-8.266-9.056-17.95-9.5-28.187v-0.04v-0.037v-0.082c0.009-14.337,6.237-27.918,15.915-37.932		c9.677-10.011,22.896-16.554,37.075-16.554c0.196,0,0.392,0,0.588,0c1.487-0.101,2.987-0.159,4.488-0.159		c7.122,0,14.26,1.153,21.039,3.752l0.037,0.028l0.038,0.012c5.787,2.437,11.537,5.377,16.662,9.449		c1.661-0.871,3.472-1.851,5.504-2.625c31.064-18.395,67.171-25.491,102.358-27.538c0.306-17.431,2.448-35.68,10.949-51.65		c7.08-13.269,19.369-23.599,34-27.179l0.061-0.03l0.079-0.009c5.573-1.078,11.192-1.575,16.774-1.575		c14.869,0,29.561,3.521,43.31,9.017c6.086-9.185,14.776-16.354,24.97-20.375l0.098-0.056l0.098-0.037		c5.983-1.864,12.303-2.954,18.646-2.954c6.692,0,13.437,1.223,19.756,4.046v-0.023c0.009,0.023,0.019,0.023,0.019,0.023		c0.047,0.016,0.084,0.044,0.116,0.044c9.059,3.489,16.727,9.937,22.164,17.95c5.442,8.048,8.644,17.688,8.644,27.599		c0,1.827-0.103,3.657-0.317,5.489l-0.019,0.037c0,0.028,0,0.068-0.01,0.096c-1.063,12.809-7.551,24.047-16.736,32.063		c-9.24,8.048-21.207,12.909-33.49,12.909c-1.97,0-3.958-0.11-5.937-0.374c-12.182-0.931-23.541-6.826-31.886-15.595		c-8.373-8.755-13.768-20.453-13.768-33.08c0-0.611,0.056-1.237,0.074-1.843c-11.435-5.092-23.578-9.316-35.646-9.306		c-1.746,0-3.491,0.096-5.237,0.273h-0.019c-9.035,0.871-17.436,6.566-21.506,14.757v0.009v0.028		c-6.179,12.034-7.411,26.101-7.598,40.064c34.639,2.259,69.483,10.571,100.043,28.138h0.047l0.438,0.259		c0.579,0.343,1.652,0.931,2.623,1.449c2.101-1.704,4.322-3.456,6.856-4.966c9.264-6.17,20.241-9.238,31.223-9.238		c4.872,0,9.749,0.621,14.481,1.834h0.019l0.196,0.058c0.07,0.01,0.121,0.033,0.178,0.033v0.009		c11.183,2.845,21.3,9.267,28.917,17.927c7.612,8.674,12.731,19.648,13.73,31.561v0.025H430.033z M328.002,84.733		c0,0.469,0.01,0.95,0.057,1.44v0.028v0.056c0.224,6.018,3.065,11.619,7.383,15.756c4.34,4.14,10.1,6.702,15.942,6.725h0.08h0.079		c0.42,0.033,0.85,0.033,1.26,0.033c5.899,0.009,11.752-2.532,16.148-6.655c4.405-4.144,7.309-9.78,7.542-15.849l0.009-0.028v-0.037		c0.038-0.464,0.057-0.903,0.057-1.377c0-6.247-2.922-12.202-7.496-16.612c-4.555-4.406-10.688-7.136-16.735-7.12		c-1.951,0-3.884,0.266-5.778,0.854l-0.065,0.005l-0.056,0.023c-4.984,1.295-9.656,4.368-13.012,8.449		C330.046,74.486,328.002,79.508,328.002,84.733z M72.312,177.578c-4.63-2.156-9.418-3.696-14.15-3.676		c-0.794,0-1.597,0.047-2.39,0.133h-0.11l-0.11,0.014c-6.795,0.187-13.653,3.15-18.801,7.899		c-5.152,4.732-8.559,11.122-8.821,18.167v0.065l-0.012,0.058c-0.046,0.57-0.065,1.137-0.065,1.683		c0,4.345,1.333,8.545,3.593,12.368c1.673,2.847,3.867,5.441,6.348,7.701C45.735,204.602,58.142,189.845,72.312,177.578z		 M374.066,262.635c0-15.5-5.592-31.069-14.646-43.604c-18.053-25.119-46.055-41.502-75.187-50.636l-0.205-0.072		c-5.592-1.715-11.238-3.234-16.933-4.534c-17.025-3.876-34.48-5.806-51.917-5.806c-23.414,0-46.827,3.465-69.245,10.379		c-29.125,9.243-57.221,25.51-75.233,50.71v0.019c-9.129,12.587-14.475,28.208-14.475,43.763c0,5.727,0.716,11.453,2.23,17.025		l0.019,0.01c3.278,12.508,9.689,23.671,17.989,33.393c8.295,9.745,18.472,18.058,29.176,24.839c2.371,1.47,4.751,2.87,7.187,4.237		c31.094,17.356,66.898,24.964,102.445,24.964c6.012,0,12.06-0.214,18.033-0.644c35.797-2.959,71.742-13.525,100.8-35.115		l0.01-0.023c9.25-6.837,17.818-15.112,24.595-24.525c6.805-9.418,11.789-19.947,14.002-31.382V275.6l0.009-0.01		C373.627,271.32,374.066,266.985,374.066,262.635z M402.32,200.95c-0.009-3.762-0.868-7.507-2.753-11l-0.047-0.044l-0.019-0.056		c-2.521-5.19-6.479-9.11-11.248-11.782c-4.77-2.69-10.352-4.056-15.952-4.056c-5.063,0-10.1,1.132-14.57,3.379		c14.216,12.344,26.687,27.179,34.746,44.636c2.595-2.259,4.808-5.018,6.464-8.084C401.098,209.92,402.32,205.405,402.32,200.95z"/></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`
SVGS["whitehouse"] = `<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"	 width="529.234px" height="529.234px" viewBox="0 0 529.234 529.234" style="enable-background:new 0 0 529.234 529.234;"	 xml:space="preserve"><g>	<g>		<path d="M478.319,297.626h17.188c1.295,0,2.345-1.049,2.345-2.344v-30.86c0-1.294-1.05-2.344-2.345-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.86C475.977,296.577,477.024,297.626,478.319,297.626z M480.663,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M33.724,297.626h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.86c0-1.294-1.05-2.344-2.344-2.344H33.724			c-1.294,0-2.344,1.049-2.344,2.344v30.86C31.38,296.577,32.429,297.626,33.724,297.626z M36.067,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M74.088,297.626h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.86c0-1.294-1.05-2.344-2.344-2.344H74.088			c-1.294,0-2.344,1.049-2.344,2.344v30.86C71.745,296.577,72.794,297.626,74.088,297.626z M76.432,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M114.454,297.626h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.86c0-1.294-1.05-2.344-2.344-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.86C112.11,296.577,113.159,297.626,114.454,297.626z M116.797,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M154.818,297.626h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.86c0-1.294-1.05-2.344-2.344-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.86C152.475,296.577,153.523,297.626,154.818,297.626z M157.162,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M33.724,358.954h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.859c0-1.295-1.05-2.344-2.344-2.344H33.724			c-1.294,0-2.344,1.049-2.344,2.344v30.859C31.38,357.905,32.429,358.954,33.724,358.954z M36.067,328.095h12.5v26.172h-12.5			V328.095z"/>		<path d="M74.088,358.954h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.859c0-1.295-1.05-2.344-2.344-2.344H74.088			c-1.294,0-2.344,1.049-2.344,2.344v30.859C71.745,357.905,72.794,358.954,74.088,358.954z M76.432,328.095h12.5v26.172h-12.5			V328.095z"/>		<path d="M114.454,358.954h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.859c0-1.295-1.05-2.344-2.344-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.859C112.11,357.905,113.159,358.954,114.454,358.954z M116.797,328.095h12.5v26.172h-12.5			V328.095z"/>		<path d="M154.818,358.954h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.859c0-1.295-1.05-2.344-2.344-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.859C152.475,357.905,153.523,358.954,154.818,358.954z M157.162,328.095h12.5v26.172h-12.5			V328.095z"/>		<path d="M526.887,231.024h-9.113v-15.885c0-1.294-1.049-2.344-2.344-2.344H379.751V184.93c0-1.294-1.049-2.344-2.344-2.344h-9.114			V172.43c0-1.294-1.05-2.344-2.344-2.344c-1.295,0-2.344,1.049-2.344,2.344v10.156h-9.114c-1.295,0-2.344,1.049-2.344,2.344v27.865			h-12.5V197.43c0-1.294-1.049-2.344-2.345-2.344h-70.345v-37.632l12.399-6.377c0.009-0.005,0.017-0.012,0.024-0.017			c0.084-0.045,0.162-0.102,0.241-0.157c0.049-0.034,0.102-0.062,0.146-0.1c0.059-0.048,0.109-0.107,0.165-0.162			c0.055-0.055,0.112-0.105,0.161-0.165c0.036-0.045,0.065-0.098,0.101-0.146c0.055-0.079,0.111-0.156,0.156-0.241			c0.005-0.009,0.012-0.016,0.017-0.025c0.024-0.049,0.038-0.101,0.061-0.151c0.033-0.082,0.07-0.163,0.098-0.248			c0.021-0.073,0.032-0.146,0.048-0.22c0.015-0.075,0.032-0.149,0.039-0.225s0.005-0.151,0.005-0.228s0.002-0.151-0.005-0.228			s-0.024-0.15-0.039-0.226c-0.016-0.073-0.027-0.147-0.048-0.22c-0.026-0.085-0.063-0.166-0.098-0.248			c-0.021-0.05-0.035-0.102-0.061-0.151c-0.005-0.009-0.012-0.016-0.017-0.025c-0.046-0.086-0.104-0.165-0.158-0.244			c-0.034-0.047-0.062-0.099-0.098-0.143c-0.052-0.062-0.111-0.115-0.17-0.172c-0.053-0.052-0.101-0.108-0.157-0.155			c-0.047-0.039-0.104-0.07-0.154-0.106c-0.076-0.053-0.151-0.107-0.232-0.15c-0.01-0.005-0.017-0.012-0.025-0.017l-13.671-7.031			c-0.728-0.374-1.596-0.342-2.293,0.083c-0.697,0.425-1.123,1.184-1.123,2.001v53.125h-70.345c-1.294,0-2.344,1.049-2.344,2.344			v15.365h-12.5v-27.865c0-1.294-1.049-2.344-2.344-2.344h-9.114v-10.156c0-1.294-1.05-2.344-2.344-2.344			c-1.295,0-2.344,1.049-2.344,2.344v10.156h-9.115c-1.294,0-2.344,1.049-2.344,2.344v27.865H13.802			c-1.294,0-2.344,1.05-2.344,2.344v15.885H2.344c-1.295,0-2.344,1.049-2.344,2.344v9.375c0,1.294,1.049,2.344,2.344,2.344h9.114			v142.189c0,1.295,1.05,2.344,2.344,2.344h178.125h16.146H234.8h16.146h27.341h16.146h26.728h16.146h178.125			c1.295,0,2.344-1.049,2.344-2.344V245.086h9.114c1.295,0,2.344-1.049,2.344-2.344v-9.375			C529.23,232.073,528.183,231.024,526.887,231.024z M266.959,145.803l6.203,3.19l-6.203,3.19V145.803z M154.167,187.274h18.229			v25.521h-18.229V187.274z M189.583,384.931H16.146V245.086h173.438L189.583,384.931L189.583,384.931z M189.583,240.399H13.802			H4.688v-4.688h9.114h175.781V240.399z M189.583,231.024H16.146v-13.542h135.678h22.916h14.844L189.583,231.024L189.583,231.024z			 M264.615,201.811l61.474,26.87H203.142L264.615,201.811z M194.271,215.139v-15.365h63.301l-63.301,27.668V215.139z			 M205.729,384.931h-11.458V245.086h11.458L205.729,384.931L205.729,384.931z M232.455,384.931h-22.039V245.086h22.039V384.931z			 M248.601,384.931h-11.458V245.086h11.458V384.931z M275.941,384.931h-22.653V245.086h22.653V384.931z M292.087,384.931h-11.458			V245.086h11.458V384.931z M318.814,384.931h-22.04V245.086h22.04V384.931z M334.96,384.931h-11.458V245.086h11.458V384.931z			 M334.96,240.399h-13.802h-26.728h-16.146h-27.341h-16.146h-26.727h-13.802v-7.031h140.689v7.031H334.96z M334.96,215.139v12.303			l-63.302-27.668h63.302V215.139z M356.835,187.274h18.229v25.521h-18.229V187.274z M339.647,217.482h14.844h22.916h135.678v13.542			H339.662c0-0.065-0.01-0.127-0.015-0.191V217.482L339.647,217.482z M513.085,384.931H339.647V245.086h173.438V384.931z			 M524.543,240.399h-9.113H339.647v-4.688h175.78h9.114L524.543,240.399L524.543,240.399z"/>		<path d="M437.955,297.626h17.188c1.295,0,2.344-1.049,2.344-2.344v-30.86c0-1.294-1.049-2.344-2.344-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.86C435.611,296.577,436.66,297.626,437.955,297.626z M440.299,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M397.59,297.626h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.86c0-1.294-1.05-2.344-2.344-2.344H397.59			c-1.295,0-2.344,1.049-2.344,2.344v30.86C395.246,296.577,396.295,297.626,397.59,297.626z M399.935,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M357.227,297.626h17.188c1.295,0,2.344-1.049,2.344-2.344v-30.86c0-1.294-1.049-2.344-2.344-2.344h-17.188			c-1.295,0-2.345,1.049-2.345,2.344v30.86C354.882,296.577,355.932,297.626,357.227,297.626z M359.569,266.766h12.5v26.172h-12.5			V266.766z"/>		<path d="M478.319,358.954h17.188c1.295,0,2.345-1.049,2.345-2.344v-30.859c0-1.295-1.05-2.344-2.345-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.859C475.977,357.905,477.024,358.954,478.319,358.954z M480.663,328.095h12.5v26.172h-12.5			V328.095z"/>		<path d="M437.955,358.954h17.188c1.295,0,2.344-1.049,2.344-2.344v-30.859c0-1.295-1.049-2.344-2.344-2.344h-17.188			c-1.295,0-2.344,1.049-2.344,2.344v30.859C435.611,357.905,436.66,358.954,437.955,358.954z M440.299,328.095h12.5v26.172h-12.5			V328.095z"/>		<path d="M397.59,358.954h17.188c1.294,0,2.344-1.049,2.344-2.344v-30.859c0-1.295-1.05-2.344-2.344-2.344H397.59			c-1.295,0-2.344,1.049-2.344,2.344v30.859C395.246,357.905,396.295,358.954,397.59,358.954z M399.935,328.095h12.5v26.172h-12.5			V328.095z"/>		<path d="M357.227,358.954h17.188c1.295,0,2.344-1.049,2.344-2.344v-30.859c0-1.295-1.049-2.344-2.344-2.344h-17.188			c-1.295,0-2.345,1.049-2.345,2.344v30.859C354.882,357.905,355.932,358.954,357.227,358.954z M359.569,328.095h12.5v26.172h-12.5			V328.095z"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`

window.SVGS
 = SVGS
;



function Icons(name, size) {
  const rawSvg = SVGS[name]
  const svg = rawSvg.substr(4)
  const prefix = `<svg width="${size}" height="${size}" class="SVGIcon" `
  return prefix + svg
}

window.Icons
 = Icons
;










const ThemeConstants = {}
ThemeConstants.dark = "dark"
ThemeConstants.workshop = "workshop"
ThemeConstants.white = "white"
ThemeConstants.glass = "glass"
ThemeConstants.clearGlass = "clearGlass"

class Theme {
  constructor(options = {}) {
    const { backgroundColor = "rgb(255,255,255)", foregroundColor = "black", fn = "lighten", selectionColor = "rgb(42, 89, 178)" } = options

    let grayStartColor = options.grayStartColor || foregroundColor
    this.backgroundColor = backgroundColor
    this.solidBackgroundColorOrTransparent = options.hasSolidBackground ? backgroundColor : "transparent"
    this.menuBackground = backgroundColor
    this.tabBackground = backgroundColor
    this.programsBackground = backgroundColor
    this.bodyBackground = backgroundColor
    this.wallBackground = backgroundColor
    this.contextMenuBackground = backgroundColor
    this.tileBackgroundColor = backgroundColor
    this.tileShadow = "none"
    this.tileOpacity = 1

    this.menuTreeComponentColor = foregroundColor
    this.foregroundColor = foregroundColor

    this.lineColor = tinycolor(foregroundColor)
      .setAlpha(0.075)
      .toString()
    this.boxShadow = tinycolor(foregroundColor)
      .setAlpha(0.1)
      .toString()
    this.slightlyDarkerBackground = tinycolor(backgroundColor)
      .darken(5)
      .toString()
    this.darkerBackground = tinycolor(backgroundColor)
      .darken(10)
      .toString()

    this.activeTabColor = this.darkerBackground

    const alterGrayShades = amount =>
      tinycolor(grayStartColor)
        [fn](amount)
        .toString()

    this.darkBlack = alterGrayShades(20)
    this.mediumBlack = alterGrayShades(40)
    this.midGray = alterGrayShades(60)
    this.greyish = options.greyish || alterGrayShades(82)
    this.lightGrey = alterGrayShades(93)
    this.lightGrey = options.lightGrey || alterGrayShades(93)
    this.veryLightGrey = options.veryLightGrey || alterGrayShades(97)

    this.borderColor = this.greyish

    this.hoverBackground = selectionColor
    this.linkColor = selectionColor
    this.selectedOutline = tinycolor(selectionColor)
      .setAlpha(0.8)
      .toString()
    this.selectionBackground = tinycolor(selectionColor)
      .setAlpha(0.1)
      .toString()

    this.errorColor = "rgb(226, 120, 121)"
    this.successColor = "#4CAF50"
    this.warningColor = "orange"
    this.white = "#fff"

    this.fonts = `'San Francisco', 'Myriad Set Pro', 'Lucida Grande', 'Helvetica Neue', Helvetica, Arial, Verdana, sans-serif`

    this.modalDimmerBackground = tinycolor("#000")
      .setAlpha(0.4)
      .toString()

    // Pass values overwrite all
    Object.assign(this, options)

    // todo: cleanup
    this.enableTextSelect1 = this._enableTextSelect(1)
    this.enableTextSelect2 = this._enableTextSelect(2)
  }

  _enableTextSelect(indent) {
    return new jtree.TreeNode(`-moz-user-select text
-webkit-user-select text
-ms-user-select text
user-select text`).toString(indent)
  }

  getHeatColor(percent) {
    return `hsl(200, ${25 + percent * 75}%, ${20 + percent * 25}%)`
  }

  disableTextSelect(indent) {
    return new jtree.TreeNode(
      `-webkit-touch-callout none
-webkit-user-select none
-khtml-user-select none
-moz-user-select none
-ms-user-select none
user-select none`
    ).toString(indent)
  }

  hakonToCss(str) {
    const hakonProgram = new hakonNode(str)
    // console.log(hakonProgram.getAllErrors())
    return hakonProgram.compile()
  }
}

const Themes = {}

Themes[ThemeConstants.dark] = new Theme({
  hasSolidBackground: true,
  backgroundColor: "rgb(16, 16, 16)",
  foregroundColor: "#fff",
  fn: "darken"
})

Themes[ThemeConstants.workshop] = new Theme({
  hasSolidBackground: true,
  wallBackgroundImage: "url('images/transparenttextures.com/wine-cork.png')",
  wallBackground: "rgba(244,216,105,.4)",
  menuBackground: "#3B539A",
  tileOpacity: 0.95,
  tileShadow: "0 3px 5px rgba(33,33,33,.3)",
  menuTreeComponentColor: "white"
})

const glassColors = {
  hasSolidBackground: false,
  selectionColor: "rgba(46, 195, 212, .9)",
  bodyBackground: "linear-gradient(130deg, rgb(56, 114, 127), rgb(28, 98, 151) 45%, rgb(62, 73, 135))",
  backgroundColor: "rgba(0,0,0,.12)",
  contextMenuBackground: "rgba(0,0,0,.90)",
  tileBackgroundColor: "rgba(0,0,0,.12)",
  programsBackground: "transparent",
  boxShadow: "transparent",
  wallBackground: "transparent",
  activeTabColor: "transparent",
  lightGrey: "rgba(0,0,0,.16)",
  greyish: "rgba(0,0,0,.20)",
  veryLightGrey: "rgba(0,0,0,.12)",
  borderColor: "transparent",
  foregroundColor: "#eee"
}

const whiteColors = Object.assign({}, glassColors)
whiteColors.bodyBackground = "white"
whiteColors.foregroundColor = "black"
whiteColors.tileBackgroundColor = "transparent"

Themes[ThemeConstants.white] = new Theme(whiteColors)

Themes[ThemeConstants.glass] = new Theme(glassColors)

glassColors.tileBackgroundColor = "transparent"
Themes[ThemeConstants.clearGlass] = new Theme(glassColors)


class ThemeTreeComponent extends AbstractTreeComponent {
  toStumpCode() {
    const theme = this.getTheme()
    return `styleTag ${CodeMirrorCss} .CodeMirror{color: ${theme.mediumBlack};} .CodeMirror .CodeMirror-gutters,.cm-s-oceanic-next .CodeMirror-gutters {background: ${theme.solidBackgroundColorOrTransparent}}`
  }
  toHakonCode() {
    const theme = this.getTheme()
    return `html,body,h1,h2,h3,h4,h5,h6,table,tr,td
 margin 0
 padding 0

html,body
 width 100%
 height 100%
 font-family ${theme.fonts}
 color ${theme.mediumBlack}

body
 overscroll-behavior-x none

code
 white-space pre

html
 background ${theme.bodyBackground}

table
 border-collapse collapse
 border-spacing 0
 table-layout fixed

.ThemeTreeComponent
 display none

a
 cursor pointer
 text-decoration none
 color ${theme.linkColor}

::-webkit-scrollbar
 display none

.ui-resizable-handle
 position absolute
 font-size 0.1px
 display block
 -ms-touch-action none
 touch-action none

.ui-resizable-disabled
 .ui-resizable-handle
  display none

.ui-resizable-autohide
 .ui-resizable-handle
  display none

.leftButton,.rightButton
 background transparent
 border 0

.LintError,.LintErrorWithSuggestion,.LintCellTypeHints
 white-space pre
 color red
 background #e5e5e5

.LintCellTypeHints
 color black

.LintErrorWithSuggestion
 cursor pointer

.TileTextArea
 padding 5px
 width 100%
 height 100%
 box-sizing border-box
 outline 0
 border 0
 font-size 14px
 font-family ${theme.fonts}
 resize none

.rightButton
 float right

.LargeLabel
 font-size 12px
 color ${theme.midGray}
 position absolute
 left 26px
 top 2px

.LargeTileInput
 display block
 width 100%
 height 34px
 margin-top 4px
 padding 2px 20px
 font-size 14px
 line-height 1.428571429
 vertical-align middle
 box-sizing border-box
 color ${theme.darkBlack}
 background ${theme.backgroundColor}
 border 0

.dragOver
 opacity 0.5

#dragOverHelp
 position absolute
 font-size 36px
 width 100%
 height 100%
 z-index 300
 display flex
 align-items center
 justify-content center
 top 0
 left 0

.noTransition
 transition none

.SVGIcon
 fill ${theme.foregroundColor}
 cursor pointer

.buttonPrimary
 border-radius 2px
 cursor pointer
 border none
 padding 15px 32px
 text-align center
 text-decoration none
 font-size 16px
 color white
 background ${theme.successColor}

.divider
 background ${theme.lineColor}
 height 1px
 margin 10px 0
 width 100%

input,textarea
 background transparent
 color ${theme.foregroundColor}

.abstractTileTreeComponentNode
 position absolute
 box-shadow ${theme.tileShadow}
 opacity ${theme.tileOpacity}
 background ${theme.tileBackgroundColor}
 border 1px solid ${theme.borderColor}
 ol
  height 100%
  width 100%
  overflow scroll
  box-sizing border-box
  margin 0
 z-index 1
 ${theme.disableTextSelect(1)}
 &.TileMaximized
  z-index 2
 .TilePencilButton
  svg
   opacity 0
 .ui-resizable-se
  cursor se-resize
  width 36px
  height 36px
  box-sizing border-box
  right 1px
  bottom 1px
  opacity 0
  border-right 4px solid ${theme.darkerBackground}
  border-bottom 4px solid ${theme.darkerBackground}
  &:hover
   opacity 1
 &:hover
  background ${theme.backgroundColor}
  z-index 2
  .ui-resizable-se
   opacity .5
  .TilePencilButton
   svg
    opacity 1
    cursor pointer
    fill ${theme.greyish}
    &:hover
     fill ${theme.foregroundColor}
 .TileHeader,.TileFooter
  height 30px
  line-height 30px
  padding-left 5px
 .TileSelectable
${theme.enableTextSelect2}
 .TileBody
  padding 5px
  width 100%
  height calc(100% - 50px)
  box-sizing border-box
  overflow scroll
  &.HeaderLess
   height calc(100% - 20px)
 .TileGrabber
  width 100%
  height 10px
  cursor move
 .TileHeader
  font-size 14px
  text-transform uppercase
  text-align center
  border-bottom 1px solid ${theme.borderColor}
  overflow hidden
  text-overflow ellipsis
 .TileFooter
  font-size 12px
  white-space nowrap
  color ${theme.midGray}
  background ${theme.tileBackgroundColor}
  overflow hidden
  position absolute
  max-width 100%
  box-sizing border-box
  bottom 0
  left 0
 iframe
  width 100%
  height 100%
  border 0`
  }
}

ThemeTreeComponent.defaultTheme = ThemeConstants.workshop
ThemeTreeComponent.Themes = Themes
ThemeTreeComponent.ThemeConstants = ThemeConstants

window.ThemeTreeComponent
 = ThemeTreeComponent
;



class TileDimension {
  constructor(tile, obj) {
    const suggestedSize = tile.getSuggestedSize()
    this.width = suggestedSize.width
    this.height = suggestedSize.height
    Object.assign(this, obj) // allow overrides.
  }

  getScaledCss(factor = 1) {
    return this._toCss({
      width: this.width * factor,
      height: this.height * factor,
      left: this.left * factor,
      top: this.top * factor
    })
  }

  get right() {
    return this.width + (this.left || 0)
  }

  get bottom() {
    return this.height + (this.top || 0)
  }

  toCss() {
    return this._toCss(this)
  }

  _toCss(obj) {
    return `width: ${obj.width}px; height: ${obj.height}px; left: ${obj.left}px; top: ${obj.top}px`
  }
}

class BinPacker {
  fit(tiles) {
    const len = tiles.length
    const width = len > 0 ? tiles[0].width : 0
    const height = len > 0 ? tiles[0].height : 0
    this.root = { xcc: 0, ycc: 0, width: width, height: height }
    for (let index = 0; index < len; index++) {
      const tile = tiles[index]
      const node = this.findNode(this.root, tile.width, tile.height)
      tile.fit = node ? this.splitNode(node, tile.width, tile.height) : this.growNode(tile.width, tile.height)
    }
  }

  findNode(root, width, height) {
    if (root.used) return this.findNode(root.right, width, height) || this.findNode(root.down, width, height)

    return width <= root.width && height <= root.height ? root : null
  }

  splitNode(node, width, height) {
    node.used = true
    node.down = { xcc: node.xcc, ycc: node.ycc + height, width: node.width, height: node.height - height }
    node.right = { xcc: node.xcc + width, ycc: node.ycc, width: node.width - width, height: height }
    return node
  }

  growNode(width, height) {
    const rootNode = this.root
    const canGrowDown = width <= rootNode.width
    const canGrowRight = height <= rootNode.height

    const shouldGrowRight = canGrowRight && rootNode.height >= rootNode.width + width // attempt to keep square-ish by growing right when height is much greater than width
    const shouldGrowDown = canGrowDown && rootNode.width >= rootNode.height + height // attempt to keep square-ish by growing down  when width  is much greater than height

    if (shouldGrowRight) return this.growRight(width, height)
    else if (shouldGrowDown) return this.growDown(width, height)
    else if (canGrowRight) return this.growRight(width, height)
    else if (canGrowDown) return this.growDown(width, height)
    else return null // need to ensure sensible root starting size to avoid this happening
  }

  growRight(width, height) {
    const oldRoot = this.root
    this.root = {
      used: true,
      xcc: 0,
      ycc: 0,
      width: oldRoot.width + width,
      height: oldRoot.height,
      down: oldRoot,
      right: { xcc: oldRoot.width, ycc: 0, width: width, height: oldRoot.height }
    }
    const node = this.findNode(this.root, width, height)
    return node ? this.splitNode(node, width, height) : null
  }

  growDown(width, height) {
    const oldRoot = this.root
    this.root = {
      used: true,
      xcc: 0,
      ycc: 0,
      width: oldRoot.width,
      height: oldRoot.height + height,
      down: { xcc: 0, ycc: oldRoot.height, width: oldRoot.width, height: height },
      right: oldRoot
    }
    const node = this.findNode(this.root, width, height)
    return node ? this.splitNode(node, width, height) : null
  }
}

class AbstractLayoutStrategy {
  constructor(tilesProgram, wallViewPortWidth = 1400, wallViewPortHeight = 1400) {
    this._tilesProgram = tilesProgram
    this._wallViewPortWidth = wallViewPortWidth
    this._wallViewPortHeight = wallViewPortHeight
  }

  _getZoomLevel() {
    const zoomLevel = this._tilesProgram.get("zoom")
    return zoomLevel ? parseFloat(zoomLevel) : 1.0
  }

  _getVisibleTiles() {
    return this._getTilesProgram()
      .getTiles()
      .filter(tile => tile.isVisible())
  }

  _getVisibleRootTiles() {
    return this._getTilesProgram()
      .getRootLevelTiles()
      .filter(tile => tile.isVisible())
  }

  _getTilesProgram() {
    return this._tilesProgram
  }

  _getWallViewPortWidth() {
    return this._wallViewPortWidth
  }

  _getWallViewPortHeight() {
    return this._wallViewPortHeight
  }
}

class CustomLayout extends AbstractLayoutStrategy {
  makeTileDimensionMap() {
    const tiles = this._getVisibleTiles()
    const needLocations = []
    const dimensionMap = new Map()
    const zoomLevel = this._getZoomLevel()
    tiles.forEach((tile, index) => {
      if (!tile.getLeft()) return needLocations.push(tile)

      dimensionMap.set(tile, CustomLayout._getTileDimension(tile, zoomLevel, tile.getLeft(), tile.getTop()))
    })

    let _top = 0
    needLocations.forEach((tile, index) => {
      const dimension = CustomLayout._getTileDimension(tile, zoomLevel, 0, _top)
      dimensionMap.set(tile, dimension)
      _top += dimension.height / 20
    })

    return dimensionMap
  }
  static _getTileDimension(tile, zoomLevel, left, _top) {
    const gridSize = 20
    const width = Math.floor(zoomLevel * tile.getWidth())
    const height = Math.floor(zoomLevel * tile.getHeight())
    const dimension = {}
    if (left) dimension.left = parseInt(left) * gridSize
    if (_top) dimension.top = parseInt(_top) * gridSize
    if (width) dimension.width = parseInt(width) * gridSize
    if (height) dimension.height = parseInt(height) * gridSize
    return new TileDimension(tile, dimension)
  }
}

const treeLayoutAddTileDimensionToMap = (tile, dimensionMap, left, _top, padding) => {
  // Todo: handle invisibles.
  const suggestedSize = tile.getDefinedOrSuggestedSize()
  const requiredSpace = tile.getRequiredDimensionsForTreeLayout(padding)

  const dimension = new TileDimension(tile, {
    width: suggestedSize.width,
    height: suggestedSize.height,
    left: left + Math.floor(requiredSpace.width - suggestedSize.width) / 2,
    top: _top
  })
  dimensionMap.set(tile, dimension)

  const newTop = _top + suggestedSize.height + padding

  let newLeft = left
  let maxBottom = newTop
  // todo: handle invisibles?
  tile.getChildTiles().forEach(childTile => {
    const result = treeLayoutAddTileDimensionToMap(childTile, dimensionMap, newLeft, newTop, padding)
    newLeft = result.left
    if (result._top > maxBottom) maxBottom = result._top
  })

  return { left: left + requiredSpace.width, _top: maxBottom, dimension: dimension }
}

class TreeLayout extends AbstractLayoutStrategy {
  makeTileDimensionMap() {
    const padding = 10
    const dimensionMap = new Map()

    // Todo: handle invisibles.
    const tiles = this._getTilesProgram().getRootLevelTiles()

    let left = 0
    let _top = 0
    tiles.forEach(tile => {
      const result = treeLayoutAddTileDimensionToMap(tile, dimensionMap, left, _top, padding)
      //left = result.left
      _top = result._top
    })

    return dimensionMap
  }
}

class ColumnLayout extends AbstractLayoutStrategy {
  makeTileDimensionMap() {
    let _top = 0
    const width = 800
    const padding = 10
    const zoomLevel = this._getZoomLevel()
    const boxWidth = Math.max(800, this._getWallViewPortWidth())
    const left = Math.floor((boxWidth - 800) / 2)

    const dimensionMap = new Map()
    this._getVisibleTiles().forEach(tile => {
      const size = tile.getDefinedOrSuggestedSize()
      const height = Math.floor(size.height * zoomLevel)
      const dimension = new TileDimension(tile, {
        width,
        height,
        left,
        top: _top
      })
      dimensionMap.set(tile, dimension)
      _top += height + padding
    })

    return dimensionMap
  }
}

class TiledLayout extends AbstractLayoutStrategy {
  makeTileDimensionMap() {
    let _top = 10
    let left = 10
    const increment = 30
    const zoomLevel = this._getZoomLevel()

    const dimensionMap = new Map()
    this._getVisibleTiles().forEach(tile => {
      const size = tile.getDefinedOrSuggestedSize()
      const dimension = new TileDimension(tile, {
        width: Math.floor(size.width * zoomLevel),
        height: Math.floor(size.height * zoomLevel),
        left: left,
        top: _top
      })
      dimensionMap.set(tile, dimension)
      left += increment
      _top += increment
    })

    return dimensionMap
  }
}

class BinLayout extends AbstractLayoutStrategy {
  makeTileDimensionMap() {
    const dimensionMap = new Map()
    const zoomLevel = this._getZoomLevel()
    const unsortedTiles = this._getVisibleTiles().map(tile => {
      const size = tile.getDefinedOrSuggestedSize()
      return {
        width: Math.floor(size.width * zoomLevel),
        height: Math.floor(size.height * zoomLevel),
        tile: tile
      }
    })

    const sortedTiles = lodash.sortBy(unsortedTiles, tile => Math.max(tile.width, tile.height)).reverse()
    new BinPacker().fit(sortedTiles)
    sortedTiles.forEach(tile => {
      const dimension = new TileDimension(tile.tile, {
        width: tile.width,
        height: tile.height,
        left: tile.fit.xcc,
        top: tile.fit.ycc
      })
      dimensionMap.set(tile.tile, dimension)
    })

    return dimensionMap
  }
}

class Layout {
  constructor() {}

  getTileDimensionMap(sourceTree, strategyName, wallViewPortWidth, wallViewPortHeight) {
    const LayoutStrategies = {
      custom: CustomLayout,
      column: ColumnLayout,
      tree: TreeLayout,
      tiled: TiledLayout,
      bin: BinLayout
    }
    const strategyClass = LayoutStrategies[strategyName] || TreeLayout
    const dimensionMap = new strategyClass(sourceTree, wallViewPortWidth, wallViewPortHeight)
    const map = dimensionMap.makeTileDimensionMap()
    map.forEach((value, key, map) => {
      if (key._isMaximized()) {
        // todo: should be wall viewport width/height?
        value.width = wallViewPortWidth
        value.height = wallViewPortHeight
        value.left = 0
        value.top = 0
      }
    })
    return map
  }
}

window.Layout
 = Layout
;

const TilesConstants = {}
TilesConstants.left = "left"
TilesConstants.top = "top"
TilesConstants.width = "width"
TilesConstants.height = "height"
TilesConstants.tileCssScript = "tileCssScript"
TilesConstants.tileScript = "tileScript"
TilesConstants.tileSize = "tileSize"
TilesConstants.abstractTileSetting = "abstractTileSetting"


TilesConstants.defaultHidden = "doc.defaultHidden"

TilesConstants.layout = "doc.layout"
TilesConstants.layouts = {}
TilesConstants.layouts.custom = "custom"
TilesConstants.layouts.tiled = "tiled"
TilesConstants.layouts.tree = "tree"
TilesConstants.layouts.bin = "bin"
TilesConstants.layouts.column = "column"
TilesConstants.noPicker = "noPicker"

TilesConstants.selectedClass = "ui-selected"
TilesConstants.staySelectedClass = "staySelected"

TilesConstants.maximized = "maximized"
TilesConstants.pickerTile = "doc.picker"

TilesConstants.abstractTileTreeComponentNode = "abstractTileTreeComponentNode"

window.TilesConstants
 = TilesConstants
;

{
  class defaultRootNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(BlobNode, undefined, undefined)
    }
    getGrammarProgram() {
      if (!this._cachedGrammarProgramRoot)
        this._cachedGrammarProgramRoot = new jtree.GrammarProgram(`defaultRootNode
 root
 catchAllNodeType BlobNode
BlobNode
 baseNodeType blobNode`)
      return this._cachedGrammarProgramRoot
    }
    static getNodeTypeMap() {
      return { defaultRootNode: defaultRootNode, BlobNode: BlobNode }
    }
  }

  class BlobNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(this._getBlobNodeCatchAllNodeType())
    }
    getErrors() {
      return []
    }
  }

  window.defaultRootNode = defaultRootNode
}
;

{
  class abstractTileTreeComponentNode extends AbstractTreeComponent {
    createParser() {
      return new jtree.TreeNode.Parser(
        catchAllErrorNode,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          hidden: hiddenNode,
          visible: visibleNode,
          maximized: maximizedNode,
          left: leftNode,
          top: topNode,
          width: widthNode,
          height: heightNode
        }),
        [{ regex: /^$/, nodeConstructor: tileBlankLineNode }]
      )
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get tileStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div {header}
  class TileHeader
 div
  style {bodyStyle}
  class TileBody
  {body}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get errorStateStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div ERROR
  class TileHeader
 div
  class TileBody
  {content}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get inspectionStumpTemplate() {
      return `div TileConstructor: {constructorName} ParentConstructor: {parentConstructorName}
div Messages:
ol
 {messages}
div Tree:
pre
 bern
  {sourceCode}
div All Tile Settings:
pre
 bern
  {settings}`
    }
    get pencilStumpTemplate() {
      return `span {icon}
 class TilePencilButton
 clickCommand toggleToolbarCommand`
    }
    get visibleKey() {
      return `visible`
    }
    get hiddenKey() {
      return `hidden`
    }
    get footerHeight() {
      return 30
    }
    get headerHeight() {
      return 30
    }
    getProgramTemplate(id) {}
    getSnippetTemplate(id) {}
    getExampleTemplate(index) {
      // todo: right now we only have 1 example per tile.
      const exampleNode = this.getDefinition().getNode(jtree.GrammarConstants.example)
      return exampleNode ? exampleNode.childrenToString() : ""
    }
    emitLogMessage(message) {
      const tab = this.getTab()
      if (tab) tab.addStumpCodeMessageToLog(message)
      else if (this.isNodeJs()) console.log(message)
    }
    getTheme() {
      return this.getTab().getTheme()
    }
    qFormat(str, obj) {
      return new jtree.TreeNode(str).templateToString(obj)
    }
    scrollIntoView() {
      const el = this.getStumpNode()
        .getShadow()
        .getShadowElement()
      if (el) el.scrollIntoView()
    }
    async loadRequirements() {
      const loadingMap = this.getTab()
        .getRootNode()
        .getDefinitionLoadingPromiseMap()
      if (!loadingMap.has(this.constructor)) loadingMap.set(this.constructor, this._makeLoadRequirementsPromise(loadingMap))
      await loadingMap.get(this.constructor)
    }
    async _makeLoadRequirementsPromise(loadingMap) {
      const app = this.getWebApp()
      const cssScript = this[TilesConstants.tileCssScript]
      if (cssScript) this._loadTileCss(cssScript)
      const scriptPath = this[TilesConstants.tileScript]
      if (scriptPath) await app.getWillowBrowser().appendScript(scriptPath)
      loadingMap.set(this.constructor, true)
    }
    _loadTileCss(css) {
      const app = this.getWebApp()
      app
        .getWillowBrowser()
        .getBodyStumpNode()
        .insertChildNode(
          css
            .split(" ")
            .map(
              url => `link
 rel stylesheet
 media screen
 href ${url}`
            )
            .join("\n")
        )
    }
    _hasRequirements() {
      return this.tileScript
    }
    _areRequirementsLoaded() {
      const loadingMap = this.getTab()
        .getRootNode()
        .getDefinitionLoadingPromiseMap()
      return !this._hasRequirements() || loadingMap.get(this.constructor) === true
    }
    isLoaded() {
      return this._areRequirementsLoaded()
    }
    getErrorMessageHtml() {
      const errors = Object.values(this.getRunTimePhaseErrors())
      return errors.length ? ` <span style="color: ${this.getTheme().errorColor};">${errors.join(" ")}</span>` : "" //todo: cleanup
    }
    toStumpErrorStateCode(err) {
      return this.qFormat(this.errorStateStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        id: this.getTreeComponentId(),
        content: `div ` + err,
        footer: this.getTileToolbarButtonStumpCode()
      })
    }
    // todo: delete this
    makeDirty() {
      delete this._cache_settingsObject
      delete this._bodyStumpCodeCache // todo: cleanup
      this._setLastRenderedTime(0)
    }
    toggleToolbar() {
      if (!this._tileToolbar) {
        const TileToolbarTreeComponent = this.require(
          "TileToolbarTreeComponent",
          this._getProjectRootDir() + "ohayoWebApp/treeComponents/TileToolbarTreeComponent.js"
        )
        this._tileToolbar = new TileToolbarTreeComponent("", undefined, this)
        this._tileToolbar.renderAndGetRenderReport(this.getStumpNode())
      } else this._tileToolbar = this._tileToolbar.unmount()
    }
    getAllTileSettingsDefinitions() {
      const def = this.getDefinition()
      return Object.values(def.getFirstWordMapWithDefinitions()).filter(def => def.isOrExtendsANodeTypeInScope([TilesConstants.abstractTileSetting]))
    }
    getTab() {
      return this.getRootNode().getTab()
    }
    getChildTiles() {
      return this.getChildInstancesOfNodeTypeId("abstractTileTreeComponentNode")
    }
    selectTile() {
      this.selectNode()
      if (this.isMounted()) this.getStumpNode().addClassToStumpNode(TilesConstants.selectedClass)
    }
    unselectNode() {
      super.unselectNode()
      if (this.isMounted()) this.getStumpNode().removeClassFromStumpNode(TilesConstants.selectedClass)
    }
    getCssClassNames() {
      const classNames = super.getCssClassNames()
      if (this._isMaximized()) classNames.push("TileMaximized")
      return classNames
    }
    toStumpCode() {
      return this.qFormat(this.tileStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        id: this.getTreeComponentId(),
        header: this.getTileHeaderBern(),
        bodyStyle: this.customBodyStyle || "",
        body: this._getBodyStumpCodeCache() || "",
        footer: this.getTileFooterStumpCode()
      })
    }
    _getBodyStumpCodeCache() {
      if (!this._bodyStumpCodeCache) this._bodyStumpCodeCache = this.getTileBodyStumpCode()
      return this._bodyStumpCodeCache
    }
    getTileHeaderBern() {
      return `${this.getFirstWord()}`
    }
    cloneAndOffset() {
      const clone = this.duplicate()
      const left = this.getLeft()
      const _top = this.getTop()
      if (left) clone.touchNode(TilesConstants.left).setContent(parseInt(left) + 1)
      if (_top) clone.touchNode(TilesConstants.top).setContent(parseInt(_top) + 1)
      return clone
    }
    getTileBodyStumpCode() {
      return ``
    }
    _getCss() {
      const selector = "#" + this.getTreeComponentId()
      const theme = this.getTheme()
      const visibleCss = this.isVisible() ? "" : "display: none"
      const dimensions = this.getTileDimensionIfAny()
      const dimensionCss = dimensions ? dimensions.toCss() : ""
      const hakonCode = this.hakonTemplate ? new jtree.TreeNode(theme).evalTemplateString(this.hakonTemplate) : this.toHakonCode()
      return `${selector} { ${visibleCss} ${dimensionCss} }
      ${theme.hakonToCss(hakonCode)}`
    }
    getContextMenuStumpCode() {
      return ""
    }
    handleTileError(err) {
      if (!this._errorCount) this._errorCount = 0
      this._errorCount++
      this.getRootNode().goRed(err)
    }
    getWall() {
      return this.getWebApp().getAppWall()
    }
    getWebApp() {
      return this.getTab().getRootNode()
    }
    getTileDimensionIfAny() {
      const dimensions = this.getWall().getWallViewPortDimensions()
      return this.getRootNode()
        .getTileDimensionMap(dimensions.width, dimensions.height)
        .get(this)
    }
    getTileBodyDimension() {
      const dimension = this.getTileDimensionIfAny()
      dimension.height = dimension.height - this.headerHeight - this.footerHeight
      return dimension
    }
    getDependencies() {
      return []
    }
    async runAndrenderAndGetRenderReport() {
      await this.execute()
      return this.renderAndGetRenderReport()
    }
    getTimeToLoad() {
      return this._timeToLoad || 0
    }
    toHakonCode() {
      return ""
    }
    getTileFooterStumpCode() {
      return this.getTileToolbarButtonStumpCode()
    }
    getTileToolbarButtonStumpCode() {
      return this.qFormat(this.pencilStumpTemplate, { icon: Icons("pencil", 16) })
    }
    getDefinedOrSuggestedSize() {
      const size = this.getSuggestedSize()
      const width = this.getWidth()
      const height = this.getHeight()
      return {
        width: width ? width * 20 : size.width,
        height: height ? height * 20 : size.height
      }
    }
    getSuggestedSize() {
      const tileSize = this.tileSize || "280 220"
      const parts = tileSize.split(" ").map(tileSize => parseInt(tileSize))
      return {
        width: parts[0],
        height: parts[1]
      }
    }
    getRequiredDimensionsForTreeLayout(padding = 0) {
      const size = {
        width: 0,
        height: 0
      }
      const children = this.getChildTiles()
      const suggestedSize = this.getDefinedOrSuggestedSize()
      children.forEach(child => {
        const childSize = child.getRequiredDimensionsForTreeLayout(padding)
        size.width += childSize.width
        size.height = childSize.height > size.height ? childSize.height : size.height
      })
      size.width += children.length * padding
      size.width = Math.max(size.width, suggestedSize.width)
      size.height = suggestedSize.height + (children.length ? padding + size.height : 0)
      return size
    }
    getLeft() {
      return this.get(TilesConstants.left)
    }
    getTop() {
      return this.get(TilesConstants.top)
    }
    getWidth() {
      return this.get(TilesConstants.width)
    }
    getHeight() {
      return this.get(TilesConstants.height)
    }
    // Tile child rendering is done at the wall flex level.
    _getChildTreeComponents() {
      return []
    }
    getStumpNodeForChildren() {
      // We render all Tiles on the Wall.
      return this.getStumpNode().getParent()
    }
    async treeComponentDidMount() {
      super.treeComponentDidMount()
      if (this._tileToolbar) this._tileToolbar.renderAndGetRenderReport()
    }
    toInspectionStumpCode() {
      const messages = this.getMessageBuffer().map(message => `li ${moment(message.getLineModifiedTime()).fromNow()} - ${message.childrenToString()}`)
      const settingsDefinitions = this.getAllTileSettingsDefinitions()
        .map(setting => `${setting.getFirstWord()} ${setting.getDescription()}`)
        .join("\n")
      const parentConstructorName = this.getParent().constructor.name
      const constructorName = this.constructor.name
      const sourceCode = this.toString()
      const settings = settingsDefinitions
      return this.qFormat(this.inspectionStumpTemplate, {
        constructorName,
        parentConstructorName,
        sourceCode,
        messages,
        settings
      })
    }
    isVisible() {
      if (this.visible === false) return false
      return this.has(this.visibleKey) || (this.getRootNode().tilesAreVisible() && !this.has(this.hiddenKey))
    }
    _isMaximized() {
      return this.has(TilesConstants.maximized)
    }
    async _executeChildNodes() {
      await this._runChildTiles()
    }
    async _runChildTiles() {
      await Promise.all(this.getChildTiles().map(tile => tile.execute()))
    }
    async execute() {
      try {
        this.setRunTimePhaseError("execute")
        await this._executeChildNodes()
      } catch (err) {
        this.setRunTimePhaseError("execute", err)
        console.error(err)
        const theme = this.getTheme()
        this.emitLogMessage(`div
   bern
    Error occurred. See console.
   style color: ${theme.errorColor};`)
      }
      return this
    }
    cloneTileCommand() {
      this.cloneAndOffset()
      return this.getTab().autosaveAndRender()
    }
    async toggleTileMaximizeCommand() {
      if (this.has(TilesConstants.maximized)) this.delete(TilesConstants.maximized)
      else this.touchNode(TilesConstants.maximized)
      await this._runAfterTileUpdate(this)
    }
    async triggerTileMethodCommand(value, methodName) {
      await this[methodName](value)
      await this._runAfterTileUpdate(tile)
    }
    // todo: refactor.
    async changeTileTypeCommand(newValue) {
      this.setFirstWord(newValue)
      const newNode = this.duplicate()
      // todo: destroy or something? how do we reparse.
      this.unmountAndDestroy()
      const app = this.getTab().getRootNode()
      await this.getRootNode().loadRequirements()
      await this.getTab().autosaveAndRender()
      newNode.runAndrenderAndGetRenderReport()
    }
    changeParentCommand(pathVector) {
      // if (tile.getFirstWordPath() === value) return; // todo: do we need this line?
      const program = this.getRootNode()
      const indexPath = pathVector ? pathVector.split(" ").map(num => parseInt(num)) : ""
      const destinationTree = indexPath ? program.nodeAt(indexPath) : program
      // todo: on jtree should we make copyTo second param optional?
      this.copyTo(destinationTree, destinationTree.length)
      this.unmountAndDestroy()
      return this.getTab().autosaveAndRender()
    }
    async openTileContextMenuCommand() {
      this.getTab()
        .getRootNode()
        .setTargetNode(this)
        .toggleAndRender(OhayoConstants.tileContextMenu)
    }
    destroyTileCommand() {
      this.unmountAndDestroy()
      return this.getTab().autosaveAndRender()
    }
    getNewDataCommand() {
      // todo: have some type of paging system to fetch new data.
    }
    async changeTileSettingAndRenderCommand(value, settingName) {
      // note the unusual ordering of params.
      this.touchNode(settingName).setContent(value.toString())
      // todo: sometimes size needs to be redone (maximize, for example)
      await this._runAfterTileUpdate(this)
    }
    // todo: remove
    async changeTileSettingMultilineCommand(val, settingName) {
      this.touchNode(settingName).setChildren(val)
      await this._runAfterTileUpdate(this)
    }
    async changeTileSettingCommand(settingName, value) {
      this.touchNode(settingName).setContent(value)
    }
    async changeWordAndRenderCommand(value, index) {
      this.setWord(parseInt(index), value)
      await this._runAfterTileUpdate(this)
    }
    async changeWordsAndRenderCommand(value, index) {
      index = parseInt(index)
      const edgeSymbol = this.getEdgeSymbol()
      const words = this.getWords().slice(0, index)
      this.setLine(words.concat(value.split(edgeSymbol)).join(edgeSymbol))
      await this._runAfterTileUpdate(this)
    }
    async updateChildrenCommand(val) {
      this.setChildren(val)
      // reload the whole doc for now.
      await this._runAfterTileUpdate(this)
    }
    async _runAfterTileUpdate(tile) {
      tile.makeDirty() // ugly!
      tile.getChildTiles().forEach(tile => {
        tile.makeDirty() // todo: ugly!
      })
      // todo: what if you have a tile that has a contextare that allows editing of its children/
      // if you edit a child, then that parent tile needs to update to...should we allow that or ban that?
      await tile.getTab().autosaveTab()
      await tile.runAndrenderAndGetRenderReport()
      tile
        .getTab()
        .getRootNode()
        .renderApp() // Need to render full app because of code editor
    }
    // todo: downstream data changes?
    async changeTileContentAndRenderCommand(value) {
      this.setContent(value)
      await this._runAfterTileUpdate(this)
    }
    async copyTileCommand() {
      // todo: remove cousin tiles?
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(this.getFirstAncestor().toString())
    }
    async createProgramFromTileExampleCommand(index) {
      const template = this.getExampleTemplate(index)
      if (!template) return undefined
      const fileExtension = "maia" // todo: generalize
      const tab = await this.getTab()
        .getRootNode()
        ._createAndOpen(template, `help-for-${this.getFirstWord()}.${fileExtension}`)
      tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
    }
    async inspectTileCommand() {
      if (!this.isNodeJs()) {
        console.log("Tile available at window.tile")
        window.tile = this
        console.log(this)
      }
      this.getTab().addStumpCodeMessageToLog(this.toInspectionStumpCode())
      this.getTab()
        .getRootNode()
        .renderApp()
    }
    async toggleToolbarCommand() {
      this.toggleToolbar()
    }
    async createProgramFromTemplateCommand(id) {
      const programTemplate = this.getProgramTemplate(id)
      if (!programTemplate) return undefined
      const tab = await this.getTab()
        .getRootNode()
        ._createAndOpen(programTemplate.template, programTemplate.name)
      tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
    }
    async appendSnippetTemplateCommand(id) {
      const snippet = this.getSnippetTemplate(id)
      if (!snippet) return undefined
      const tab = this.getTab()
      const tabProgram = tab.getTabProgram()
      const newNodes = tabProgram.concat(snippet)
      const newTiles = newNodes.filter(tile => tile.doesExtend && tile.doesExtend("abstractTileTreeComponentNode"))
      tab.autosaveTab()
      tabProgram.clearSelection()
      tab.getTabWall().unmount()
      await tabProgram.loadAndIncrementalRender()
      newTiles.forEach(tile => tile.selectTile())
      newTiles[0].scrollIntoView()
    }
    async copyDataCommand(delimiter) {
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(this.getOutputOrInputTable().toDelimited(delimiter))
    }
    async copyDataAsJavascriptCommand() {
      const table = this.getOutputOrInputTable()
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(JSON.stringify(table.toTree().toDataTable(table.getColumnNames()), null, 2))
    }
    async copyDataAsTreeCommand() {
      const text = this.getOutputOrInputTable()
        .toTree()
        .toString()
      this.getRootNode()
        .getWillowBrowser()
        .copyTextToClipboard(text)
    }
    async exportTileDataCommand(format = "csv") {
      // todo: figure this out. use the browsers filename? tile title? id?
      let extension = "csv"
      let type = "text/csv"
      let str = this.getOutputOrInputTable().toDelimited(",")
      if (format === "tree") {
        extension = "tree"
        type = "text"
        str = this.getOutputOrInputTable()
          .toTree()
          .toString()
      }
      this.getRootNode()
        .getWillowBrowser()
        .downloadFile(str, this.getTab().getFileName() + "." + extension, type)
    }
  }

  class basicRecursiveTileNode extends abstractTileTreeComponentNode {
    get hakonTemplate() {
      return `.BasicRecursiveTile
 input
 textarea
  border 0
  font-size 14px
  height 100%
  width 100%`
    }
    getTileBodyStumpCode() {
      const edgeSymbol = " "
      const definition = this.getDefinition()
      const requiredCellIds = definition.getRequiredCellTypeIds()
      const catchAllIndex = requiredCellIds.length
      const catchAllCellTypeId = definition.getCatchAllCellTypeId()
      if (catchAllCellTypeId) requiredCellIds.push(catchAllCellTypeId)
      const cellInputs = requiredCellIds.map((cellTypeId, index) => {
        const isCatchAll = cellTypeId === catchAllCellTypeId && index === catchAllIndex
        const value = isCatchAll ? this.getWordsFrom(index + 1).join(edgeSymbol) : this.getWord(index + 1)
        return ` input
  placeholder ${cellTypeId}
  value ${value}
  name ${index + 1}
  changeCommand ${isCatchAll ? "changeWordsAndRenderCommand" : "changeWordAndRenderCommand"}`
      })
      return `div ${definition.getDescription()}
div
${cellInputs.join("\n")}`
    }
  }

  class DidYouMeanTileNode extends abstractTileTreeComponentNode {
    get bodyStumpTemplate() {
      return `div
 span No tile '{input}' found. Line {lineNo}. Did you mean
 a {closestTile}
  collapse
  tabindex -1
  value {closestTile}
  clickCommand changeTileTypeCommand
 span ?`
    }
    getTileBodyStumpCode() {
      const input = this.getFirstWord()
      const lineNo = this.getLineNumber()
      const closestTile = jtree.Utils.didYouMean(
        input,
        this.getRootNode()
          .getGrammarProgram()
          .getTopNodeTypeDefinitions()
          .map(def => def.get("crux"))
      )
      if (!closestTile) {
        if (!input) return `div Your program has a blank line on line ${lineNo}.`
        return `div No tile '${input}' found.`
      }
      return this.qFormat(this.bodyStumpTemplate, { input, lineNo, closestTile })
    }
    getErrors() {
      return [new jtree.UnknownNodeTypeError(this)]
    }
    getTileHeaderBern() {
      return ""
    }
  }

  class abstractDocTileNode extends abstractTileTreeComponentNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get tileStumpTemplate() {
      return `div
 class {classes}
 id {id}
 contextMenuCommand openTileContextMenuCommand
 div
  class TileGrabber
  doubleClickCommand toggleTileMaximizeCommand
 div
  class TileBody HeaderLess
  {body}
 div
  class TileFooter
  {footer}
 div
  class TileGrabber`
    }
    get bodyStumpTemplate() {
      return `{tagName}
 bern
  {content}`
    }
    get headerHeight() {
      return 0
    }
    get footerHeight() {
      return 0
    }
    _getBody() {
      return this.qFormat(this.bodyStumpTemplate, { content: this.getContent() || "", tagName: this.tagName })
    }
    toStumpCode() {
      return this.qFormat(this.tileStumpTemplate, {
        classes: this.getCssClassNames().join(" "),
        footer: this.getTileToolbarButtonStumpCode(),
        id: this.getTreeComponentId(),
        body: this._getBody()
      })
    }
  }

  class docTitleNode extends abstractDocTileNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get stringCell() {
      return this.getWordsFrom(1)
    }
    get tagName() {
      return `h1`
    }
    get tileSize() {
      return `600 75`
    }
  }

  class docSubtitleNode extends docTitleNode {
    get tagName() {
      return `h2`
    }
  }

  class docSectionNode extends abstractDocTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), {
          subtitle: docSectionSubtitleNode,
          paragraph: docSectionParagraphNode,
          link: docSectionLinkNode,
          code: docSectionCodeNode
        }),
        undefined
      )
    }
    _getBody() {
      return this.compile()
    }
    _getCompiledLine() {
      return ""
    }
  }

  class docReferenceNode extends abstractDocTileNode {
    createParser() {
      return new jtree.TreeNode.Parser(
        undefined,
        Object.assign(Object.assign({}, super.createParser()._getFirstWordMapAsObject()), { url: docReferenceUrlNode }),
        undefined
      )
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get referenceIdCell() {
      return this.getWord(1)
    }
    get tagName() {
      return `p`
    }
  }

  class docCommentNode extends abstractTileTreeComponentNode {
    createParser() {
      return new jtree.TreeNode.Parser(commentLineNode, undefined, undefined)
    }
    get commentKeywordCell() {
      return this.getWord(0)
    }
    get commentCell() {
      return this.getWordsFrom(1)
    }
    get visible() {
      return false
    }
  }

  class abstractPickerTileNode extends abstractTileTreeComponentNode {
    get tileHeader() {
      return `Gallery`
    }
    get categoryBreakStumpTemplate() {
      return `div {category}
 class PickerCategory`
    }
    get itemStumpTemplate() {
      return `{categoryBreak}
a {name}
 br
  span {description}
 title {description}
 tabindex -1
 value {value}
 clickCommand {command}`
    }
    get hakonTemplate() {
      return `.PickerTileNode
 .PickerCategory
  width 100%
  margin-top 20px
  text-align center
 .TileBody
  display flex
  flex-flow row wrap
  a
   &:hover
    background-color {borderColor}
   padding 10px
   margin 5px
   height 30px
   background-color {backgroundColor}
   border 1px solid {borderColor}
   overflow hidden
   text-align center
   text-overflow ellipsis
   font-size 14px
   width 120px
   span
    font-size 70%`
    }
    get tileSize() {
      return `480 420`
    }
    async fetchTableInputs() {
      return { rows: this.getChoices().map(obj => obj.toObject()) }
    }
    getTileBodyStumpCode() {
      let lastCat = ""
      return this.getChoices()
        .map(choice => {
          choice.categoryBreak = lastCat !== choice.category ? this.qFormat(this.categoryBreakStumpTemplate, { category: choice.category }) : ""
          lastCat = choice.category
          return this.qFormat(this.itemStumpTemplate, choice)
        })
        .join("\n")
    }
    getTileHeaderBern() {
      return this.tileHeader
    }
  }

  class PickerTileNode extends abstractPickerTileNode {
    get tileHeader() {
      return `Tile Gallery`
    }
    getChoices() {
      const allChoices = this.getRootNode()
        .getGrammarProgram()
        .getTopNodeTypeDefinitions()
      const filteredChoices = allChoices.filter(nodeDef => !(nodeDef.get(jtree.GrammarConstants.tags) || "").includes(TilesConstants.noPicker))
      const theChoices = filteredChoices.length ? filteredChoices : allChoices
      return theChoices.map(nodeDefinition => {
        const nodeId = nodeDefinition.get("crux") || nodeDefinition.getNodeTypeIdFromDefinition()
        const name = nodeId.split(".")[1] || ""
        const category = lodash.upperFirst(nodeId.split(".")[0])
        const description = nodeDefinition.getDescription()
        return { name, category, description, value: nodeId, command: "changeTileTypeCommand" }
      })
    }
  }

  class tileBlankLineNode extends jtree.GrammarBackedNode {
    get emptyCell() {
      return this.getWord(0)
    }
    get visible() {
      return false
    }
  }

  class abstractDocSettingNode extends jtree.GrammarBackedNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get visible() {
      return false
    }
  }

  class docCategoriesNode extends abstractDocSettingNode {
    get documentCategoryCell() {
      return this.getWordsFrom(0)
    }
  }

  class docAuthorNode extends abstractDocSettingNode {
    get stringCell() {
      return this.getWordsFrom(0)
    }
  }

  class docDefaultHiddenNode extends abstractDocSettingNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
  }

  class docDateNode extends abstractDocSettingNode {
    get dateCell() {
      return this.getWordsFrom(0)
    }
  }

  class docZoomNode extends abstractDocSettingNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get zoomCell() {
      return parseFloat(this.getWord(1))
    }
  }

  class docLayoutNode extends abstractDocSettingNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get docLayoutOptionCell() {
      return this.getWord(1)
    }
  }

  class abstractDocSectionComponentNode extends jtree.GrammarBackedNode {}

  class docSectionSubtitleNode extends abstractDocSectionComponentNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get stringCell() {
      return this.getWordsFrom(1)
    }
    compile() {
      return `h2 ${this.getContent()}`
    }
  }

  class docSectionParagraphNode extends abstractDocSectionComponentNode {
    createParser() {
      return new jtree.TreeNode.Parser(docParagraphLineNode, undefined, undefined)
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get stringCell() {
      return this.getWordsFrom(1)
    }
    get stumpTemplate() {
      return `p
 bern
  {content}`
    }
    compile() {
      return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getContentWithChildren() })
    }
  }

  class docSectionLinkNode extends abstractDocSectionComponentNode {
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
    get stringCell() {
      return this.getWordsFrom(2)
    }
    get stumpTemplate() {
      return `a {content}
 href {url}`
    }
    compile() {
      return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getWordsFrom(2).join(" "), url: this.getWord(1) })
    }
  }

  class docSectionCodeNode extends abstractDocSectionComponentNode {
    createParser() {
      return new jtree.TreeNode.Parser(docLineOfCodeNode, undefined, undefined)
    }
    get tileKeywordCell() {
      return this.getWord(0)
    }
    get programmingLanguageNameCell() {
      return this.getWord(1)
    }
    get stumpTemplate() {
      return `code
 bern
  {content}`
    }
    compile() {
      return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.childrenToString().replace(/</g, "&lt;") })
    }
  }

  class docLineOfCodeNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(docLineOfCodeNode, undefined, undefined)
    }
    get codeCell() {
      return this.getWordsFrom(0)
    }
  }

  class docParagraphLineNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(docParagraphLineNode, undefined, undefined)
    }
    get stringCell() {
      return this.getWordsFrom(0)
    }
  }

  class commentLineNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(commentLineNode, undefined, undefined)
    }
    get commentCell() {
      return this.getWordsFrom(0)
    }
  }

  class docReferenceUrlNode extends jtree.GrammarBackedNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get urlCell() {
      return this.getWord(1)
    }
  }

  class catchAllErrorNode extends jtree.GrammarBackedNode {
    getErrors() {
      return this._getErrorNodeErrors()
    }
    get errorCell() {
      return this.getWordsFrom(0)
    }
  }

  class hashBangNode extends jtree.GrammarBackedNode {
    get hashBangWordCell() {
      return this.getWordsFrom(0)
    }
  }

  class tilesNode extends AbstractTreeComponent {
    createParser() {
      return new jtree.TreeNode.Parser(DidYouMeanTileNode, undefined, undefined)
    }
    get wallType() {
      return `wall`
    }
    getTileClosestToLine(lineIndex) {
      let current = this.nodeAtLine(lineIndex)
      while (current) {
        if (current.doesExtend("abstractTileTreeComponentNode")) return current
        current = current.getParent()
      }
    }
    setTab(tab) {
      this._tab = tab
    }
    getTheme() {
      const tab = this.getTab()
      return tab ? tab.getTheme() : super.getTheme()
    }
    getTab() {
      return this._tab
    }
    tilesAreVisible() {
      return !this.has(TilesConstants.defaultHidden)
    }
    canUseCustomLayout() {
      const definedLayout = this.get(TilesConstants.layout)
      if (definedLayout === TilesConstants.layouts.custom) return true
      if (this.getTiles().some(tile => tile.has(TilesConstants.left) || tile.has(TilesConstants.top))) return true
      return false
    }
    _getLayoutStrategy() {
      const definedLayout = this.get(TilesConstants.layout)
      return (
        definedLayout ||
        (this.wallType === OhayoConstants.flex
          ? this.canUseCustomLayout()
            ? TilesConstants.layouts.custom
            : TilesConstants.layouts.tiled
          : TilesConstants.layouts.tree)
      )
    }
    getTileDimensionMap(width, height) {
      // todo: cache?
      return new Layout().getTileDimensionMap(this, this._getLayoutStrategy(), width, height)
    }
    async loadAndIncrementalRender() {
      const app = this.getTab().getRootNode()
      await Promise.all(this.getTiles().map(tile => tile.loadRequirements()))
      await Promise.all(
        this.getRootLevelTiles().map(async tile => {
          await tile.execute()
          app.renderApp()
        })
      )
      app.renderApp() // this one might be superfluous
      return this
    }
    getTiles() {
      return this.getTopDownArray().filter(node => node.doesExtend("abstractTileTreeComponentNode"))
    }
    getRootLevelTiles() {
      return this.filter(node => node.doesExtend("abstractTileTreeComponentNode"))
    }
    _getProjectRootDir() {
      return this.isNodeJs() ? jtree.Utils.findProjectRoot(__dirname, "ohayo") : ""
    }
    toRunTimeStats() {
      const tiles = this.getTiles()
      const stats = {
        tiles: tiles.length,
        treeLanguage: this.getGrammarProgram().getExtensionName(),
        url: this.getTab().getFileName()
      }
      stats.timeToLoad = this.getTiles()
        .map(tile => tile.getTimeToLoad())
        .sort()
        .reverse()[0]
      stats.timeToRender = this.getTiles()
        .map(tile => tile.getNewestTimeToRender())
        .sort()
        .reverse()[0]
      return stats
    }
    getGrammarProgram() {
      if (!this._cachedGrammarProgramRoot)
        this._cachedGrammarProgramRoot = new jtree.GrammarProgram(`emptyCell
programmingLanguageNameCell
 enum javascript latex css html ruby rust python csv tsv xml php typescript lisp swift java c cpp markdown bash
 highlightScope constant
codeCell
 highlightScope string
documentCategoryCell
 highlightScope constant
 enum shopping chemistry programming socialMedia math parenting writing dataScience ohayo
zoomCell
 extends numberCell
referenceIdCell
 highlightScope string
docLayoutOptionCell
 enum custom bin tree column tiled
 highlightScope constant
commentCell
 highlightScope comment
commentKeywordCell
 highlightScope comment
errorCell
 highlightScope invalid
hashBangWordCell
 highlightScope comment
stringCell
 highlightScope string
urlCell
 highlightScope constant
dateCell
 highlightScope string
intCell
 regex \\-?[0-9]+
numberCell
 regex \\-?[0-9]*\\.?[0-9]*
tileKeywordCell
 highlightScope keyword
intCell
tileSettingKeywordCell
 highlightScope variable.language
abstractTileTreeComponentNode
 abstract
 cells tileKeywordCell
 _extendsJsClass AbstractTreeComponent
 inScope tileBlankLineNode abstractCoreTileSettingTerminalNode
 catchAllNodeType catchAllErrorNode
 int headerHeight 30
 int footerHeight 30
 string hiddenKey hidden
 string visibleKey visible
 string pencilStumpTemplate
  span {icon}
   class TilePencilButton
   clickCommand toggleToolbarCommand
 string inspectionStumpTemplate
  div TileConstructor: {constructorName} ParentConstructor: {parentConstructorName}
  div Messages:
  ol
   {messages}
  div Tree:
  pre
   bern
    {sourceCode}
  div All Tile Settings:
  pre
   bern
    {settings}
 string errorStateStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div ERROR
    class TileHeader
   div
    class TileBody
    {content}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div {header}
    class TileHeader
   div
    style {bodyStyle}
    class TileBody
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  getProgramTemplate(id) {}
  getSnippetTemplate(id) {}
  getExampleTemplate(index) {
   // todo: right now we only have 1 example per tile.
   const exampleNode = this.getDefinition().getNode(jtree.GrammarConstants.example)
   return exampleNode ? exampleNode.childrenToString() : ""
  }
  emitLogMessage(message) {
   const tab = this.getTab()
   if (tab) tab.addStumpCodeMessageToLog(message)
   else if (this.isNodeJs()) console.log(message)
  }
  getTheme() {
   return this.getTab().getTheme()
  }
  qFormat(str, obj) {
   return new jtree.TreeNode(str).templateToString(obj)
  }
  scrollIntoView() {
   const el = this.getStumpNode()
    .getShadow()
    .getShadowElement()
   if (el) el.scrollIntoView()
  }
  async loadRequirements() {
   const loadingMap = this.getTab()
    .getRootNode()
    .getDefinitionLoadingPromiseMap()
   if (!loadingMap.has(this.constructor)) loadingMap.set(this.constructor, this._makeLoadRequirementsPromise(loadingMap))
   await loadingMap.get(this.constructor)
  }
  async _makeLoadRequirementsPromise(loadingMap) {
   const app = this.getWebApp()
   const cssScript = this[TilesConstants.tileCssScript]
   if (cssScript) this._loadTileCss(cssScript)
   const scriptPath = this[TilesConstants.tileScript]
   if (scriptPath) await app.getWillowBrowser().appendScript(scriptPath)
   loadingMap.set(this.constructor, true)
  }
  _loadTileCss(css) {
   const app = this.getWebApp()
   app
    .getWillowBrowser()
    .getBodyStumpNode()
    .insertChildNode(
     css
      .split(" ")
      .map(
       url => \`link
   rel stylesheet
   media screen
   href \${url}\`
      )
      .join("\\n")
    )
  }
  _hasRequirements() {
   return this.tileScript
  }
  _areRequirementsLoaded() {
   const loadingMap = this.getTab()
    .getRootNode()
    .getDefinitionLoadingPromiseMap()
   return !this._hasRequirements() || loadingMap.get(this.constructor) === true
  }
  isLoaded() {
   return this._areRequirementsLoaded()
  }
  getErrorMessageHtml() {
   const errors = Object.values(this.getRunTimePhaseErrors())
   return errors.length ? \` <span style="color: \${this.getTheme().errorColor};">\${errors.join(" ")}</span>\` : "" //todo: cleanup
  }
  toStumpErrorStateCode(err) {
   return this.qFormat(this.errorStateStumpTemplate, { classes: this.getCssClassNames().join(" "), id: this.getTreeComponentId(), content: \`div \` + err, footer: this.getTileToolbarButtonStumpCode() })
  }
  // todo: delete this
  makeDirty() {
   delete this._cache_settingsObject
   delete this._bodyStumpCodeCache // todo: cleanup
   this._setLastRenderedTime(0)
  }
  toggleToolbar() {
   if (!this._tileToolbar) {
    const TileToolbarTreeComponent = this.require("TileToolbarTreeComponent", this._getProjectRootDir() + "ohayoWebApp/treeComponents/TileToolbarTreeComponent.js")
    this._tileToolbar = new TileToolbarTreeComponent("", undefined, this)
    this._tileToolbar.renderAndGetRenderReport(this.getStumpNode())
   } else this._tileToolbar = this._tileToolbar.unmount()
  }
  getAllTileSettingsDefinitions() {
   const def = this.getDefinition()
   return Object.values(def.getFirstWordMapWithDefinitions()).filter(def => def.isOrExtendsANodeTypeInScope([TilesConstants.abstractTileSetting]))
  }
  getTab() {
   return this.getRootNode().getTab()
  }
  getChildTiles() {
   return this.getChildInstancesOfNodeTypeId("abstractTileTreeComponentNode")
  }
  selectTile() {
   this.selectNode()
   if (this.isMounted()) this.getStumpNode().addClassToStumpNode(TilesConstants.selectedClass)
  }
  unselectNode() {
   super.unselectNode()
   if (this.isMounted()) this.getStumpNode().removeClassFromStumpNode(TilesConstants.selectedClass)
  }
  getCssClassNames() {
   const classNames = super.getCssClassNames()
   if (this._isMaximized()) classNames.push("TileMaximized")
   return classNames
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, {
    classes: this.getCssClassNames().join(" "),
    id: this.getTreeComponentId(),
    header: this.getTileHeaderBern(),
    bodyStyle: this.customBodyStyle || "",
    body: this._getBodyStumpCodeCache() || "",
    footer: this.getTileFooterStumpCode()
   })
  }
  _getBodyStumpCodeCache() {
   if (!this._bodyStumpCodeCache) this._bodyStumpCodeCache = this.getTileBodyStumpCode()
   return this._bodyStumpCodeCache
  }
  getTileHeaderBern() {
   return \`\${this.getFirstWord()}\`
  }
  cloneAndOffset() {
   const clone = this.duplicate()
   const left = this.getLeft()
   const _top = this.getTop()
   if (left) clone.touchNode(TilesConstants.left).setContent(parseInt(left) + 1)
   if (_top) clone.touchNode(TilesConstants.top).setContent(parseInt(_top) + 1)
   return clone
  }
  getTileBodyStumpCode() {
   return \`\`
  }
  _getCss() {
   const selector = "#" + this.getTreeComponentId()
   const theme = this.getTheme()
   const visibleCss = this.isVisible() ? "" : "display: none"
   const dimensions = this.getTileDimensionIfAny()
   const dimensionCss = dimensions ? dimensions.toCss() : ""
   const hakonCode = this.hakonTemplate ? new jtree.TreeNode(theme).evalTemplateString(this.hakonTemplate) : this.toHakonCode()
   return \`\${selector} { \${visibleCss} \${dimensionCss} }
        \${theme.hakonToCss(hakonCode)}\`
  }
  getContextMenuStumpCode() {
   return ""
  }
  handleTileError(err) {
   if (!this._errorCount) this._errorCount = 0
   this._errorCount++
   this.getRootNode().goRed(err)
  }
  getWall() {
   return this.getWebApp().getAppWall()
  }
  getWebApp() {
   return this.getTab().getRootNode()
  }
  getTileDimensionIfAny() {
   const dimensions = this.getWall().getWallViewPortDimensions()
   return this.getRootNode()
    .getTileDimensionMap(dimensions.width, dimensions.height)
    .get(this)
  }
  getTileBodyDimension() {
   const dimension = this.getTileDimensionIfAny()
   dimension.height = dimension.height - this.headerHeight - this.footerHeight
   return dimension
  }
  getDependencies() {
   return []
  }
  async runAndrenderAndGetRenderReport() {
   await this.execute()
   return this.renderAndGetRenderReport()
  }
  getTimeToLoad() {
   return this._timeToLoad || 0
  }
  toHakonCode() {
   return ""
  }
  getTileFooterStumpCode() {
   return this.getTileToolbarButtonStumpCode()
  }
  getTileToolbarButtonStumpCode() {
   return this.qFormat(this.pencilStumpTemplate, { icon: Icons("pencil", 16) })
  }
  getDefinedOrSuggestedSize() {
   const size = this.getSuggestedSize()
   const width = this.getWidth()
   const height = this.getHeight()
   return {
    width: width ? width * 20 : size.width,
    height: height ? height * 20 : size.height
   }
  }
  getSuggestedSize() {
   const tileSize = this.tileSize || "280 220"
   const parts = tileSize.split(" ").map(tileSize => parseInt(tileSize))
   return {
    width: parts[0],
    height: parts[1]
   }
  }
  getRequiredDimensionsForTreeLayout(padding = 0) {
   const size = {
    width: 0,
    height: 0
   }
   const children = this.getChildTiles()
   const suggestedSize = this.getDefinedOrSuggestedSize()
   children.forEach(child => {
    const childSize = child.getRequiredDimensionsForTreeLayout(padding)
    size.width += childSize.width
    size.height = childSize.height > size.height ? childSize.height : size.height
   })
   size.width += children.length * padding
   size.width = Math.max(size.width, suggestedSize.width)
   size.height = suggestedSize.height + (children.length ? padding + size.height : 0)
   return size
  }
  getLeft() {
   return this.get(TilesConstants.left)
  }
  getTop() {
   return this.get(TilesConstants.top)
  }
  getWidth() {
   return this.get(TilesConstants.width)
  }
  getHeight() {
   return this.get(TilesConstants.height)
  }
  // Tile child rendering is done at the wall flex level.
  _getChildTreeComponents() {
   return []
  }
  getStumpNodeForChildren() {
   // We render all Tiles on the Wall.
   return this.getStumpNode().getParent()
  }
  async treeComponentDidMount() {
   super.treeComponentDidMount()
   if (this._tileToolbar) this._tileToolbar.renderAndGetRenderReport()
  }
  toInspectionStumpCode() {
   const messages = this.getMessageBuffer().map(message => \`li \${moment(message.getLineModifiedTime()).fromNow()} - \${message.childrenToString()}\`)
   const settingsDefinitions = this.getAllTileSettingsDefinitions()
    .map(setting => \`\${setting.getFirstWord()} \${setting.getDescription()}\`)
    .join("\\n")
   const parentConstructorName = this.getParent().constructor.name
   const constructorName = this.constructor.name
   const sourceCode = this.toString()
   const settings = settingsDefinitions
   return this.qFormat(this.inspectionStumpTemplate, {
    constructorName,
    parentConstructorName,
    sourceCode,
    messages,
    settings
   })
  }
  isVisible() {
   if (this.visible === false) return false
   return this.has(this.visibleKey) || (this.getRootNode().tilesAreVisible() && !this.has(this.hiddenKey))
  }
  _isMaximized() {
   return this.has(TilesConstants.maximized)
  }
  async _executeChildNodes() {
   await this._runChildTiles()
  }
  async _runChildTiles() {
   await Promise.all(this.getChildTiles().map(tile => tile.execute()))
  }
  async execute() {
   try {
    this.setRunTimePhaseError("execute")
    await this._executeChildNodes()
   } catch (err) {
    this.setRunTimePhaseError("execute", err)
    console.error(err)
    const theme = this.getTheme()
    this.emitLogMessage(\`div
     bern
      Error occurred. See console.
     style color: \${theme.errorColor};\`)
   }
   return this
  }
  cloneTileCommand() {
   this.cloneAndOffset()
   return this.getTab().autosaveAndRender()
  }
  async toggleTileMaximizeCommand() {
   if (this.has(TilesConstants.maximized)) this.delete(TilesConstants.maximized)
   else this.touchNode(TilesConstants.maximized)
   await this._runAfterTileUpdate(this)
  }
  async triggerTileMethodCommand(value, methodName) {
   await this[methodName](value)
   await this._runAfterTileUpdate(tile)
  }
  // todo: refactor.
  async changeTileTypeCommand(newValue) {
   this.setFirstWord(newValue)
   const newNode = this.duplicate()
   // todo: destroy or something? how do we reparse.
   this.unmountAndDestroy()
   const app = this.getTab().getRootNode()
   await this.getRootNode().loadRequirements()
   await this.getTab().autosaveAndRender()
   newNode.runAndrenderAndGetRenderReport()
  }
  changeParentCommand(pathVector) {
   // if (tile.getFirstWordPath() === value) return; // todo: do we need this line?
   const program = this.getRootNode()
   const indexPath = pathVector ? pathVector.split(" ").map(num => parseInt(num)) : ""
   const destinationTree = indexPath ? program.nodeAt(indexPath) : program
   // todo: on jtree should we make copyTo second param optional?
   this.copyTo(destinationTree, destinationTree.length)
   this.unmountAndDestroy()
   return this.getTab().autosaveAndRender()
  }
  async openTileContextMenuCommand() {
   this.getTab()
    .getRootNode()
    .setTargetNode(this)
    .toggleAndRender(OhayoConstants.tileContextMenu)
  }
  destroyTileCommand() {
   this.unmountAndDestroy()
   return this.getTab().autosaveAndRender()
  }
  getNewDataCommand() {
   // todo: have some type of paging system to fetch new data.
  }
  async changeTileSettingAndRenderCommand(value, settingName) {
   // note the unusual ordering of params.
   this.touchNode(settingName).setContent(value.toString())
   // todo: sometimes size needs to be redone (maximize, for example)
   await this._runAfterTileUpdate(this)
  }
  // todo: remove
  async changeTileSettingMultilineCommand(val, settingName) {
   this.touchNode(settingName).setChildren(val)
   await this._runAfterTileUpdate(this)
  }
  async changeTileSettingCommand(settingName, value) {
   this.touchNode(settingName).setContent(value)
  }
  async changeWordAndRenderCommand(value, index) {
   this.setWord(parseInt(index), value)
   await this._runAfterTileUpdate(this)
  }
  async changeWordsAndRenderCommand(value, index) {
   index = parseInt(index)
   const edgeSymbol = this.getEdgeSymbol()
   const words = this.getWords().slice(0, index)
   this.setLine(words.concat(value.split(edgeSymbol)).join(edgeSymbol))
   await this._runAfterTileUpdate(this)
  }
  async updateChildrenCommand(val) {
   this.setChildren(val)
   // reload the whole doc for now.
   await this._runAfterTileUpdate(this)
  }
  async _runAfterTileUpdate(tile) {
   tile.makeDirty() // ugly!
   tile.getChildTiles().forEach(tile => {
    tile.makeDirty() // todo: ugly!
   })
   // todo: what if you have a tile that has a contextare that allows editing of its children/
   // if you edit a child, then that parent tile needs to update to...should we allow that or ban that?
   await tile.getTab().autosaveTab()
   await tile.runAndrenderAndGetRenderReport()
   tile
    .getTab()
    .getRootNode()
    .renderApp() // Need to render full app because of code editor
  }
  // todo: downstream data changes?
  async changeTileContentAndRenderCommand(value) {
   this.setContent(value)
   await this._runAfterTileUpdate(this)
  }
  async copyTileCommand() {
   // todo: remove cousin tiles?
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(this.getFirstAncestor().toString())
  }
  async createProgramFromTileExampleCommand(index) {
   const template = this.getExampleTemplate(index)
   if (!template) return undefined
   const fileExtension = "maia" // todo: generalize
   const tab = await this.getTab()
    .getRootNode()
    ._createAndOpen(template, \`help-for-\${this.getFirstWord()}.\${fileExtension}\`)
   tab.addStumpCodeMessageToLog(\`div Created '\${tab.getFullTabFilePath()}'\`)
  }
  async inspectTileCommand() {
   if (!this.isNodeJs()) {
    console.log("Tile available at window.tile")
    window.tile = this
    console.log(this)
   }
   this.getTab().addStumpCodeMessageToLog(this.toInspectionStumpCode())
   this.getTab()
    .getRootNode()
    .renderApp()
  }
  async toggleToolbarCommand() {
   this.toggleToolbar()
  }
  async createProgramFromTemplateCommand(id) {
   const programTemplate = this.getProgramTemplate(id)
   if (!programTemplate) return undefined
   const tab = await this.getTab()
    .getRootNode()
    ._createAndOpen(programTemplate.template, programTemplate.name)
   tab.addStumpCodeMessageToLog(\`div Created '\${tab.getFullTabFilePath()}'\`)
  }
  async appendSnippetTemplateCommand(id) {
   const snippet = this.getSnippetTemplate(id)
   if (!snippet) return undefined
   const tab = this.getTab()
   const tabProgram = tab.getTabProgram()
   const newNodes = tabProgram.concat(snippet)
   const newTiles = newNodes.filter(tile => tile.doesExtend && tile.doesExtend("abstractTileTreeComponentNode"))
   tab.autosaveTab()
   tabProgram.clearSelection()
   tab.getTabWall().unmount()
   await tabProgram.loadAndIncrementalRender()
   newTiles.forEach(tile => tile.selectTile())
   newTiles[0].scrollIntoView()
  }
  async copyDataCommand(delimiter) {
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(this.getOutputOrInputTable().toDelimited(delimiter))
  }
  async copyDataAsJavascriptCommand() {
   const table = this.getOutputOrInputTable()
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(JSON.stringify(table.toTree().toDataTable(table.getColumnNames()), null, 2))
  }
  async copyDataAsTreeCommand() {
   const text = this.getOutputOrInputTable()
    .toTree()
    .toString()
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(text)
  }
  async exportTileDataCommand(format = "csv") {
   // todo: figure this out. use the browsers filename? tile title? id?
   let extension = "csv"
   let type = "text/csv"
   let str = this.getOutputOrInputTable().toDelimited(",")
   if (format === "tree") {
    extension = "tree"
    type = "text"
    str = this.getOutputOrInputTable()
     .toTree()
     .toString()
   }
   this.getRootNode()
    .getWillowBrowser()
    .downloadFile(str, this.getTab().getFileName() + "." + extension, type)
  }
basicRecursiveTileNode
 extends abstractTileTreeComponentNode
 string hakonTemplate
  .BasicRecursiveTile
   input
   textarea
    border 0
    font-size 14px
    height 100%
    width 100%
 javascript
  getTileBodyStumpCode() {
   const edgeSymbol = " "
   const definition = this.getDefinition()
   const requiredCellIds = definition.getRequiredCellTypeIds()
   const catchAllIndex = requiredCellIds.length
   const catchAllCellTypeId = definition.getCatchAllCellTypeId()
   if (catchAllCellTypeId) requiredCellIds.push(catchAllCellTypeId)
   const cellInputs = requiredCellIds.map((cellTypeId, index) => {
    const isCatchAll = cellTypeId === catchAllCellTypeId && index === catchAllIndex
    const value = isCatchAll ? this.getWordsFrom(index + 1).join(edgeSymbol) : this.getWord(index + 1)
    return \` input
    placeholder \${cellTypeId}
    value \${value}
    name \${index + 1}
    changeCommand \${isCatchAll ? "changeWordsAndRenderCommand" : "changeWordAndRenderCommand"}\`
   })
   return \`div \${definition.getDescription()}
  div
  \${cellInputs.join("\\n")}\`
  }
DidYouMeanTileNode
 tags noPicker
 description Provides suggestions for misspelled tiles.
 extends abstractTileTreeComponentNode
 crux tiles.didyoumean
 string bodyStumpTemplate
  div
   span No tile '{input}' found. Line {lineNo}. Did you mean
   a {closestTile}
    collapse
    tabindex -1
    value {closestTile}
    clickCommand changeTileTypeCommand
   span ?
 javascript
  getTileBodyStumpCode() {
   const input = this.getFirstWord()
   const lineNo = this.getLineNumber()
   const closestTile = jtree.Utils.didYouMean(
    input,
    this.getRootNode()
     .getGrammarProgram()
     .getTopNodeTypeDefinitions()
     .map(def => def.get("crux"))
   )
   if (!closestTile) {
    if (!input) return \`div Your program has a blank line on line \${lineNo}.\`
    return \`div No tile '\${input}' found.\`
   }
   return this.qFormat(this.bodyStumpTemplate, { input, lineNo, closestTile })
  }
  getErrors() {
   return [new jtree.UnknownNodeTypeError(this)]
  }
  getTileHeaderBern() {
   return ""
  }
abstractDocTileNode
 int footerHeight 0
 int headerHeight 0
 cells tileKeywordCell
 extends abstractTileTreeComponentNode
 abstract
 string bodyStumpTemplate
  {tagName}
   bern
    {content}
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div
    class TileBody HeaderLess
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  _getBody() {
   return this.qFormat(this.bodyStumpTemplate, { content: this.getContent() || "", tagName: this.tagName })
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, { classes: this.getCssClassNames().join(" "), footer: this.getTileToolbarButtonStumpCode(), id: this.getTreeComponentId(), body: this._getBody() })
  }
docTitleNode
 catchAllCellType stringCell
 description A title
 example A doc
  doc.title A Tale of Two Cities
 string tileSize 600 75
 extends abstractDocTileNode
 cells tileKeywordCell
 crux doc.title
 string tagName h1
docSubtitleNode
 extends docTitleNode
 description A subheader
 string tagName h2
 crux doc.subtitle
docSectionNode
 description A section containing subtitles, paragraphs, code blocks, etc.
 crux doc.section
 extends abstractDocTileNode
 inScope abstractDocSectionComponentNode
 javascript
  _getBody() {
   return this.compile()
  }
  _getCompiledLine() {
   return ""
  }
 example
  doc.section
   subtitle Subtitle
   paragraph Paragraph
   code python
    # some code
docReferenceNode
 crux doc.ref
 cells tileKeywordCell referenceIdCell
 inScope docReferenceUrlNode
 string tagName p
 doc.ref someRefId
  url https://en.wikipedia.org/wiki/Note_(typography)
 description A reference to an external source
 extends abstractDocTileNode
docCommentNode
 description A comment node
 cells commentKeywordCell
 extends abstractTileTreeComponentNode
 boolean visible false
 frequency 0
 example An example program with comments
  doc.comment get iris data
  samples.iris
   doc.comment filter is
   filter.where Species = virginica
    doc.comment display results
    tables.basic
 catchAllCellType commentCell
 catchAllNodeType commentLineNode
 crux doc.comment
abstractPickerTileNode
 extends abstractTileTreeComponentNode
 string tileSize 480 420
 abstract
 string hakonTemplate
  .PickerTileNode
   .PickerCategory
    width 100%
    margin-top 20px
    text-align center
   .TileBody
    display flex
    flex-flow row wrap
    a
     &:hover
      background-color {borderColor}
     padding 10px
     margin 5px
     height 30px
     background-color {backgroundColor}
     border 1px solid {borderColor}
     overflow hidden
     text-align center
     text-overflow ellipsis
     font-size 14px
     width 120px
     span
      font-size 70%
 string itemStumpTemplate
  {categoryBreak}
  a {name}
   br
    span {description}
   title {description}
   tabindex -1
   value {value}
   clickCommand {command}
 string categoryBreakStumpTemplate
  div {category}
   class PickerCategory
 string tileHeader Gallery
 javascript
  async fetchTableInputs() {
   return { rows: this.getChoices().map(obj => obj.toObject()) }
  }
  getTileBodyStumpCode() {
   let lastCat = ""
   return this.getChoices()
    .map(choice => {
     choice.categoryBreak = lastCat !== choice.category ? this.qFormat(this.categoryBreakStumpTemplate, { category: choice.category }) : ""
     lastCat = choice.category
     return this.qFormat(this.itemStumpTemplate, choice)
    })
    .join("\\n")
  }
  getTileHeaderBern() {
   return this.tileHeader
  }
PickerTileNode
 extends abstractPickerTileNode
 description Displays list of available tiles.
 crux doc.picker
 string tileHeader Tile Gallery
 javascript
  getChoices() {
   const allChoices = this.getRootNode()
    .getGrammarProgram()
    .getTopNodeTypeDefinitions()
   const filteredChoices = allChoices.filter(nodeDef => !(nodeDef.get(jtree.GrammarConstants.tags) || "").includes(TilesConstants.noPicker))
   const theChoices = filteredChoices.length ? filteredChoices : allChoices
   return theChoices.map(nodeDefinition => {
    const nodeId = nodeDefinition.get("crux") || nodeDefinition.getNodeTypeIdFromDefinition()
    const name = nodeId.split(".")[1] || ""
    const category = lodash.upperFirst(nodeId.split(".")[0])
    const description = nodeDefinition.getDescription()
    return { name, category, description, value: nodeId, command: "changeTileTypeCommand" }
   })
  }
tileBlankLineNode
 boolean visible false
 pattern ^$
 tags doNotSynthesize
 cells emptyCell
abstractDocSettingNode
 cells tileKeywordCell
 abstract
 boolean visible false
docCategoriesNode
 extends abstractDocSettingNode
 crux doc.categories
 description Add some categories to the document for organization.
 catchAllCellType documentCategoryCell
docAuthorNode
 extends abstractDocSettingNode
 catchAllCellType stringCell
 crux doc.author
 description Add one author per line.
docDefaultHiddenNode
 crux doc.defaultHidden
 example
  doc.defaultHidden
  samples.portals
   tables.basic
    visible
 description Change default tile visibility to hidden.
 cells tileKeywordCell
 extends abstractDocSettingNode
docDateNode
 description Date published.
 extends abstractDocSettingNode
 crux doc.date
 catchAllCellType dateCell
docZoomNode
 crux doc.zoom
 description Enlarge or shrink all tiles
 cells tileKeywordCell zoomCell
 extends abstractDocSettingNode
docLayoutNode
 cells tileKeywordCell docLayoutOptionCell
 extends abstractDocSettingNode
 crux doc.layout
abstractDocSectionComponentNode
 abstract
docSectionSubtitleNode
 extends abstractDocSectionComponentNode
 crux subtitle
 cells tileKeywordCell
 catchAllCellType stringCell
 javascript
  compile() {
   return \`h2 \${this.getContent()}\`
  }
docSectionParagraphNode
 extends abstractDocSectionComponentNode
 crux paragraph
 cells tileKeywordCell
 catchAllCellType stringCell
 catchAllNodeType docParagraphLineNode
 string stumpTemplate
  p
   bern
    {content}
 javascript
  compile() {
   return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getContentWithChildren() })
  }
docSectionLinkNode
 extends abstractDocSectionComponentNode
 crux link
 cells tileKeywordCell urlCell
 catchAllCellType stringCell
 string stumpTemplate
  a {content}
   href {url}
 javascript
  compile() {
   return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.getWordsFrom(2).join(" "), url: this.getWord(1) })
  }
 example
  doc.section
   link http://ohayo.computer Ohayo
docSectionCodeNode
 extends abstractDocSectionComponentNode
 crux code
 cells tileKeywordCell programmingLanguageNameCell
 catchAllNodeType docLineOfCodeNode
 string stumpTemplate
  code
   bern
    {content}
 javascript
  compile() {
   return new jtree.TreeNode(this.stumpTemplate).templateToString({ content: this.childrenToString().replace(/</g, "&lt;") })
  }
 example
  doc.section
   subtitle Some Code
   code latex
    E_0 &= mc^2
    E &= \\frac{mc^2}{\\sqrt{1-\\frac{v^2}{c^2}}}
docLineOfCodeNode
 catchAllCellType codeCell
 catchAllNodeType docLineOfCodeNode
docParagraphLineNode
 catchAllCellType stringCell
 catchAllNodeType docParagraphLineNode
commentLineNode
 catchAllCellType commentCell
 catchAllNodeType commentLineNode
docReferenceUrlNode
 crux url
 cells tileSettingKeywordCell urlCell
 description URL for the reference
catchAllErrorNode
 catchAllCellType errorCell
 baseNodeType errorNode
hashBangNode
 crux #!
 description Standard bash hashBang line.
 catchAllCellType hashBangWordCell
tilesNode
 root
 todo skipBlankLines
 _rootNodeJsHeader
  const projectRootDir = jtree.Utils.findProjectRoot(__dirname, "ohayo")
  const { AbstractTreeComponent } = require(projectRootDir + "node_modules/jtree/products/TreeComponentFramework.node.js")
  const TilesConstants = require(projectRootDir + "ohayoWebApp/tiles/TilesConstants.js")
  const OhayoConstants = require(projectRootDir + "ohayoWebApp/treeComponents/OhayoConstants.js")
  const Layout = require(projectRootDir + "ohayoWebApp/tiles/Layout.js")
  const Icons = require(projectRootDir + "ohayoWebApp/themes/Icons.js")
  const lodash = require(projectRootDir + "node_modules/lodash")
 _extendsJsClass AbstractTreeComponent
 catchAllNodeType DidYouMeanTileNode
 string wallType wall
 javascript
  getTileClosestToLine(lineIndex) {
   let current = this.nodeAtLine(lineIndex)
   while (current) {
    if (current.doesExtend("abstractTileTreeComponentNode")) return current
    current = current.getParent()
   }
  }
  setTab(tab) {
   this._tab = tab
  }
  getTheme() {
   const tab = this.getTab()
   return tab ? tab.getTheme() : super.getTheme()
  }
  getTab() {
   return this._tab
  }
  tilesAreVisible() {
   return !this.has(TilesConstants.defaultHidden)
  }
  canUseCustomLayout() {
   const definedLayout = this.get(TilesConstants.layout)
   if (definedLayout === TilesConstants.layouts.custom) return true
   if (this.getTiles().some(tile => tile.has(TilesConstants.left) || tile.has(TilesConstants.top))) return true
   return false
  }
  _getLayoutStrategy() {
   const definedLayout = this.get(TilesConstants.layout)
   return definedLayout || (this.wallType === OhayoConstants.flex ? (this.canUseCustomLayout() ? TilesConstants.layouts.custom : TilesConstants.layouts.tiled) : TilesConstants.layouts.tree)
  }
  getTileDimensionMap(width, height) {
   // todo: cache?
   return new Layout().getTileDimensionMap(this, this._getLayoutStrategy(), width, height)
  }
  async loadAndIncrementalRender() {
   const app = this.getTab().getRootNode()
   await Promise.all(this.getTiles().map(tile => tile.loadRequirements()))
   await Promise.all(
    this.getRootLevelTiles().map(async tile => {
     await tile.execute()
     app.renderApp()
    })
   )
   app.renderApp() // this one might be superfluous
   return this
  }
  getTiles() {
   return this.getTopDownArray().filter(node => node.doesExtend("abstractTileTreeComponentNode"))
  }
  getRootLevelTiles() {
   return this.filter(node => node.doesExtend("abstractTileTreeComponentNode"))
  }
  _getProjectRootDir() {
   return this.isNodeJs() ? jtree.Utils.findProjectRoot(__dirname, "ohayo") : ""
  }
  toRunTimeStats() {
   const tiles = this.getTiles()
   const stats = {
    tiles: tiles.length,
    treeLanguage: this.getGrammarProgram().getExtensionName(),
    url: this.getTab().getFileName()
   }
   stats.timeToLoad = this.getTiles()
    .map(tile => tile.getTimeToLoad())
    .sort()
    .reverse()[0]
   stats.timeToRender = this.getTiles()
    .map(tile => tile.getNewestTimeToRender())
    .sort()
    .reverse()[0]
   return stats
  }
abstractTileSettingNode
 cells tileSettingKeywordCell
 abstract
abstractTileSettingTerminalNode
 javascript
  getSettingValue() {
   return this.getContent()
  }
 extends abstractTileSettingNode
 abstract
abstractCoreTileSettingTerminalNode
 abstract
 extends abstractTileSettingTerminalNode
hiddenNode
 extends abstractCoreTileSettingTerminalNode
 crux hidden
visibleNode
 extends abstractCoreTileSettingTerminalNode
 crux visible
maximizedNode
 extends abstractCoreTileSettingTerminalNode
 crux maximized
abstractPagePositionNode
 frequency .2
 cells tileSettingKeywordCell intCell
 extends abstractCoreTileSettingTerminalNode
 abstract
leftNode
 extends abstractPagePositionNode
 crux left
topNode
 extends abstractPagePositionNode
 crux top
widthNode
 extends abstractPagePositionNode
 crux width
heightNode
 extends abstractPagePositionNode
 crux height
abstractTileSettingNonTerminalNode
 javascript
  getSettingValue() {
   return this.childrenToString()
  }
 extends abstractTileSettingNode
 catchAllNodeType tileSettingNonTerminalContentNode
 abstract
tileSettingNonTerminalContentNode
 baseNodeType blobNode`)
      return this._cachedGrammarProgramRoot
    }
    static getNodeTypeMap() {
      return {
        abstractTileTreeComponentNode: abstractTileTreeComponentNode,
        basicRecursiveTileNode: basicRecursiveTileNode,
        DidYouMeanTileNode: DidYouMeanTileNode,
        abstractDocTileNode: abstractDocTileNode,
        docTitleNode: docTitleNode,
        docSubtitleNode: docSubtitleNode,
        docSectionNode: docSectionNode,
        docReferenceNode: docReferenceNode,
        docCommentNode: docCommentNode,
        abstractPickerTileNode: abstractPickerTileNode,
        PickerTileNode: PickerTileNode,
        tileBlankLineNode: tileBlankLineNode,
        abstractDocSettingNode: abstractDocSettingNode,
        docCategoriesNode: docCategoriesNode,
        docAuthorNode: docAuthorNode,
        docDefaultHiddenNode: docDefaultHiddenNode,
        docDateNode: docDateNode,
        docZoomNode: docZoomNode,
        docLayoutNode: docLayoutNode,
        abstractDocSectionComponentNode: abstractDocSectionComponentNode,
        docSectionSubtitleNode: docSectionSubtitleNode,
        docSectionParagraphNode: docSectionParagraphNode,
        docSectionLinkNode: docSectionLinkNode,
        docSectionCodeNode: docSectionCodeNode,
        docLineOfCodeNode: docLineOfCodeNode,
        docParagraphLineNode: docParagraphLineNode,
        commentLineNode: commentLineNode,
        docReferenceUrlNode: docReferenceUrlNode,
        catchAllErrorNode: catchAllErrorNode,
        hashBangNode: hashBangNode,
        tilesNode: tilesNode,
        abstractTileSettingNode: abstractTileSettingNode,
        abstractTileSettingTerminalNode: abstractTileSettingTerminalNode,
        abstractCoreTileSettingTerminalNode: abstractCoreTileSettingTerminalNode,
        hiddenNode: hiddenNode,
        visibleNode: visibleNode,
        maximizedNode: maximizedNode,
        abstractPagePositionNode: abstractPagePositionNode,
        leftNode: leftNode,
        topNode: topNode,
        widthNode: widthNode,
        heightNode: heightNode,
        abstractTileSettingNonTerminalNode: abstractTileSettingNonTerminalNode,
        tileSettingNonTerminalContentNode: tileSettingNonTerminalContentNode
      }
    }
  }

  class abstractTileSettingNode extends jtree.GrammarBackedNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
  }

  class abstractTileSettingTerminalNode extends abstractTileSettingNode {
    getSettingValue() {
      return this.getContent()
    }
  }

  class abstractCoreTileSettingTerminalNode extends abstractTileSettingTerminalNode {}

  class hiddenNode extends abstractCoreTileSettingTerminalNode {}

  class visibleNode extends abstractCoreTileSettingTerminalNode {}

  class maximizedNode extends abstractCoreTileSettingTerminalNode {}

  class abstractPagePositionNode extends abstractCoreTileSettingTerminalNode {
    get tileSettingKeywordCell() {
      return this.getWord(0)
    }
    get intCell() {
      return parseInt(this.getWord(1))
    }
  }

  class leftNode extends abstractPagePositionNode {}

  class topNode extends abstractPagePositionNode {}

  class widthNode extends abstractPagePositionNode {}

  class heightNode extends abstractPagePositionNode {}

  class abstractTileSettingNonTerminalNode extends abstractTileSettingNode {
    createParser() {
      return new jtree.TreeNode.Parser(tileSettingNonTerminalContentNode, undefined, undefined)
    }
    getSettingValue() {
      return this.childrenToString()
    }
  }

  class tileSettingNonTerminalContentNode extends jtree.GrammarBackedNode {
    createParser() {
      return new jtree.TreeNode.Parser(this._getBlobNodeCatchAllNodeType())
    }
    getErrors() {
      return []
    }
  }

  window.tilesNode = tilesNode
}
;





class AbstractContextMenuTreeComponent extends AbstractTreeComponent {
  toHakonCode() {
    const theme = this.getTheme()
    return `.AbstractContextMenuTreeComponent
 position fixed
 overflow scroll
 max-height 100%
 z-index 221
 background ${theme.contextMenuBackground}
 border 1px solid ${theme.borderColor}
 box-shadow 0 1px 3px 0 ${theme.boxShadow}
 font-size 14px
 a
  display block
  padding 3px
  font-size 14px
  text-decoration none
  color ${theme.darkBlack}
  &:hover
   color ${theme.white}
   background ${theme.hoverBackground}`
  }

  toStumpCode() {
    return new jtree.TreeNode(`div
 class AbstractContextMenuTreeComponent {constructorName}
 {body}`).templateToString({ constructorName: this.constructor.name, body: this.getContextMenuBodyStumpCode() })
  }

  treeComponentDidMount() {
    const container = this.getStumpNode()
    const that = this
    const app = this.getRootNode()
    const willowBrowser = app.getWillowBrowser()
    const bodyShadow = willowBrowser.getBodyStumpNode().getShadow()
    const unmountOnClick = function() {
      bodyShadow.offShadowEvent("click", unmountOnClick) // todo: should we move this to before unmount?
      app.closeAllContextMenus()
    }
    setTimeout(() => bodyShadow.onShadowEvent("click", unmountOnClick), 100) // todo: fix this.
    const event = app.getMouseEvent()
    const windowSize = willowBrowser.getWindowSize()
    container.setStumpNodeCss(this._getContextMenuPosition(windowSize.width, windowSize.height, event.clientX, event.clientY, container.getShadow()))
  }

  _getContextMenuPosition(windowWidth, windowHeight, x, y, shadow) {
    let boxTop = y
    let boxLeft = x
    const boxWidth = shadow.getShadowOuterWidth()
    const boxHeight = shadow.getShadowOuterHeight()
    const boxHeightOverflow = boxHeight + boxTop - windowHeight
    const boxRightOverflow = boxWidth + boxLeft - windowWidth

    // todo: instead of this change orientation
    if (boxHeightOverflow > 0) boxTop -= boxHeightOverflow

    if (boxRightOverflow > 0) boxLeft = x - boxWidth - 5

    if (boxTop < 0) boxTop = 0

    return {
      left: boxLeft,
      top: boxTop
    }
  }
}

window.AbstractContextMenuTreeComponent
 = AbstractContextMenuTreeComponent
;





class AbstractDropDownMenuTreeComponent extends AbstractTreeComponent {
  toHakonCode() {
    const theme = this.getTheme()
    return `
.subdued
 color ${theme.midGray}

.dropdownMenu
 min-width 200px
 position absolute
 top 0
 left 0
 z-index 100
 padding 7px 0
 background ${theme.contextMenuBackground}
 border 1px solid ${theme.borderColor}
 box-shadow 0 1px 3px 0 ${theme.boxShadow}
 .message
  line-height 30px
  padding 0 10px
 a
  color ${theme.foregroundColor}
  display block
  line-height 30px
  padding 0 10px
  &:hover
   background ${theme.hoverBackground}
   color ${theme.white}`
  }

  treeComponentDidMount() {
    const app = this.getRootNode()
    const willowBrowser = app.getWillowBrowser()
    const bodyStumpNode = willowBrowser.getBodyStumpNode()
    const bodyShadow = bodyStumpNode.getShadow()
    const unmountOnClick = function() {
      bodyShadow.offShadowEvent("click", unmountOnClick)
      app.closeAllDropDownMenusCommand()
    }
    setTimeout(() => bodyShadow.onShadowEvent("click", unmountOnClick), 100) // todo: fix this.
  }

  toStumpCode() {
    const anchorId = this.getAnchorId()
    const buttonStumpNode = this.getParent()
      .getStumpNode()
      .findStumpNodeByChild("id " + anchorId)
    const buttonStumpNodeShadow = buttonStumpNode.getShadow()

    return new jtree.TreeNode(`div
 style top: 30px; left: {left}px;
 class dropdownMenu
 {dropDownStump}`).templateToString({ left: buttonStumpNodeShadow.getShadowPosition().left, dropDownStump: this.getDropDownStumpCode() })
  }
}

window.AbstractDropDownMenuTreeComponent
 = AbstractDropDownMenuTreeComponent
;





class AbstractModalTreeComponent extends AbstractTreeComponent {
  toHakonCode() {
    const theme = this.getTheme()
    return `${super.toHakonCode()}
.modalBackground
 position fixed
 top 0
 left 0
 width 100%
 height 100%
 z-index 1000
 display flex
 padding-top 50px
 align-items baseline
 justify-content center
 box-sizing border-box
 background ${theme.modalDimmerBackground}

.modalContent
 background ${theme.contextMenuBackground}
 color ${theme.foregroundColor}
 box-shadow 0px 0px 2px ${theme.boxShadow}
 padding 20px
 position relative
 min-width 600px
 max-width 800px
 max-height 90%
 white-space nowrap
 text-overflow ellipsis
 overflow-x hidden
 overflow-y scroll
 textarea
  margin-bottom 10px
  white-space pre
 pre
${theme.enableTextSelect2}

.modalClose
 position absolute
 top 10px
 right 10px
 cursor pointer`
  }

  toStumpCode() {
    return new jtree.TreeNode(`section
 clickCommand unmountAndDestroyCommand
 class modalBackground
 section
  clickCommand stopPropagationCommand
  class modalContent
  a X
   id closeModalX
   clickCommand unmountAndDestroyCommand
   class modalClose
  {modelStumpCode}`).templateToString({ modelStumpCode: this.getModalStumpCode() })
  }
}

window.AbstractModalTreeComponent
 = AbstractModalTreeComponent
;





class BasicTerminalTreeComponent extends AbstractTreeComponent {
  toHakonCode() {
    return `.sourceTextarea
 height ${this._getHeight()}px
 font-size 110%
 border 0
 white-space nowrap
 width 100%`
  }

  async saveChangesCommand() {
    // tood: this is broken. needs to unmount first.
    // todo: add a patch method to tree.
    if (this.hasChanges()) await this._getTab().autosaveAndReloadWith(this.getCode())
  }

  async executeLineCommand(lineNumber) {
    const program = this._makeProgramFromLineNumber(lineNumber)
    let result = await program.execute(this.getRootNode())

    if (typeof result !== "string") result = result.join("\n")

    this._getTab().logMessageText(encodeURIComponent(result))
    this.getRootNode().renderApp()
  }

  async executeFirstLineCommand() {
    return this.executeLineCommand(0)
  }

  async compileFirstLineCommand() {
    return this.compileLineCommand(0)
  }

  _compileLine(lineNumber) {
    const program = this._makeProgramFromLineNumber(lineNumber)
    const grammarProgram = program.getDefinition()
    return program.compile()
  }

  async compileLineCommand(lineNumber) {
    this._getTab().logMessageText(this._compileLine(lineNumber))
    this.getRootNode().renderApp()
  }

  _getHeight() {
    return Math.floor((this.getRootNode().getBodyShadowDimensions().height - 60) * 0.7)
  }

  _getProgramSource() {
    const tab = this._getTab()
    return tab ? tab.getTabProgram().childrenToString() : ""
  }

  _getProgram() {
    const mountedTab = this._getTab()
    return mountedTab && mountedTab.getTabProgram()
  }

  _getTab() {
    return this.getRootNode().getMountedTab()
  }

  toStumpCode() {
    return new jtree.TreeNode(`div
 style font-size: 16px;
 class TerminalDiv
 textarea
  class sourceTextarea
  blurCommand saveChangesCommand
  lineClickCommand executeFirstLineCommand
  lineShiftClickCommand compileFirstLineCommand
  bern
   {lines}`).templateToString({ lines: this._getProgramSource() })
  }

  _getTextareaShadow() {
    return this.getStumpNode()
      .getNode("textarea")
      .getShadow()
  }

  _makeProgramFromLineNumber(lineNumber) {
    this._updateTA() // todo: cleanup
    const programClass = this._getProgram().constructor
    const code = this.getCode()
    return new programClass(new jtree.TreeNode(code).nodeAtLine(lineNumber).toString())
  }

  _updateTA() {
    if (this._getTextareaShadow()) this._getTextareaShadow().setInputOrTextAreaValue(this._getProgramSource())
  }

  treeComponentDidUpdate() {
    this._updateTA()
    super.treeComponentDidUpdate()
  }

  getDependencies() {
    const gutter = this.getParent()
    const deps = gutter.getDependencies()
    const panel = gutter.getParent()
    const tab = this._getTab()
    const tabProgram = tab && tab.getTabProgram()
    if (tabProgram && this._getProgramSource() !== this.getCode()) deps.push({ getLineModifiedTime: () => tabProgram.getLineOrChildrenModifiedTime() })
    deps.push(panel)
    return deps
  }

  _updateHtml() {
    // noop. todo: is this a good pattern? we noop it because of codemirror.
  }

  getCode() {
    const ta = this._getTextareaShadow()
    return ta ? ta.getShadowValue() : ""
  }

  hasChanges() {
    const program = this._getProgram()
    return program && this.getCode() !== program.childrenToString()
  }

  getWhetherToUpdateAndReason() {
    if (this.hasFocus())
      return {
        shouldUpdate: false,
        reason: "should NOT Update because currently has focus"
      }
    // NEVER UPDATE IF THIS HAS CHANGES.
    // todo: add tests!
    return super.getWhetherToUpdateAndReason()
  }

  hasFocus() {
    return false
  }
}

window.BasicTerminalTreeComponent
 = BasicTerminalTreeComponent
;





// TODO!!!! UNDO/REDO HISTORY IS SAVED ACROSS TAB SWITCHES.

const CodeMirrorConstants = {}

CodeMirrorConstants.options = {}
CodeMirrorConstants.options.theme = "theme"
CodeMirrorConstants.themes = {}
CodeMirrorConstants.themes.oceanicNext = "oceanic-next"
CodeMirrorConstants.themes.default = "default"
CodeMirrorConstants.events = {}
CodeMirrorConstants.events.blur = "blur"
CodeMirrorConstants.events.gutterClick = "gutterClick"
CodeMirrorConstants.keyMap = {}
CodeMirrorConstants.keyMap.cmdEnter = "Cmd-Enter"
CodeMirrorConstants.keyMap.shiftCmdEnter = "Shift-Cmd-Enter"
CodeMirrorConstants.keyMap.cmdBackSlash = "Cmd-\\"
CodeMirrorConstants.keyMap.cmdS = "Cmd-S"
CodeMirrorConstants.keyMap.ctrlS = "Ctrl-S"

class CodeMirrorTerminalTreeComponent extends BasicTerminalTreeComponent {
  getCode() {
    // todo: this is buggy! figure it out. when toggling pane, it comes back w/o highlighting.
    // probably shouldn't need this if check
    const cm = this._getCMEditorInstance()
    return cm ? cm.getValue() : ""
  }

  _getCMEditorInstance() {
    return this._CMEditorInstance
  }

  hasFocus() {
    const cm = this._getCMEditorInstance()
    return cm && cm.hasFocus()
  }

  treeComponentDidMount() {
    this._loadCodeMirror()
    super.treeComponentDidMount()
  }

  _updateTheme() {
    const cm = this._getCMEditorInstance()
    if (cm.getOption(CodeMirrorConstants.options.theme) !== this._getCMThemeToUse()) cm.setOption(CodeMirrorConstants.options.theme, this._getCMThemeToUse())
  }

  _updateTA() {}

  treeComponentDidUpdate() {
    const cm = this._getCMEditorInstance()
    // todo: perf problems here.
    if (cm) {
      this._updateTheme()
      cm.setValue(this._getProgramSource())
    }
    super.treeComponentDidUpdate()
  }

  _getKeyMap() {
    const cm = this._getCMEditorInstance()
    const keyMap = {}

    keyMap[CodeMirrorConstants.keyMap.cmdEnter] = () => {
      const range = cm.listSelections()[0]
      const line = range.head.line
      this.executeLineCommand(line)
    }
    keyMap[CodeMirrorConstants.keyMap.shiftCmdEnter] = () => {
      const range = cm.listSelections()[0]
      const line = range.head.line
      this.compileLineCommand(line)
    }
    keyMap[CodeMirrorConstants.keyMap.cmdBackSlash] = () => {
      this.getRootNode().clearTabMessagesCommand()
    }

    keyMap[CodeMirrorConstants.keyMap.cmdS] = async () => {
      await this.saveChangesCommand()
      // todo: scroll to proper tile
      const tile = this._getClosestTileAtCurrentLine()
      if (tile) tile.scrollIntoView()
    }

    keyMap[CodeMirrorConstants.keyMap.ctrlS] = keyMap[CodeMirrorConstants.keyMap.cmdS]

    return keyMap
  }

  _getClosestTileAtCurrentLine() {
    const cm = this._getCMEditorInstance()
    const range = cm.listSelections()[0]
    const line = range && range.head.line
    const app = this.getRootNode()
    const tab = app.getMountedTab()
    const tabProgram = tab.getTabProgram()
    return tabProgram && line !== false ? tabProgram.getTileClosestToLine(line) : undefined
  }

  _getCMThemeToUse() {
    return this.getRootNode().isGlassTheme() ? CodeMirrorConstants.themes.oceanicNext : CodeMirrorConstants.themes.default
  }

  _loadCodeMirror() {
    if (!CodeMirrorTerminalTreeComponent._cMMode) {
      const app = this.getRootNode()

      CodeMirrorTerminalTreeComponent._cMMode = new jtree.TreeNotationCodeMirrorMode(
        "tree",
        () => {
          const tab = app.getMountedTab()
          return tab ? tab.getProgramConstructorForTab() : app.getProgramConstructorFromFileExtension() // get default
        },
        () => (app.getMountedTab() ? this.getCode() : undefined),
        CodeMirror
      ).register()
    }

    const cmInstance = CodeMirrorTerminalTreeComponent._cMMode.fromTextAreaWithAutocomplete(this._getTextareaShadow().getShadowElement(), {
      theme: this._getCMThemeToUse()
    })

    this._CMEditorInstance = cmInstance

    cmInstance.setSize(undefined, this._getHeight())

    cmInstance.on(CodeMirrorConstants.events.gutterClick, (instance, line, gutter, clickEvent) => {
      this.executeLineCommand(line)
    })

    cmInstance.on(CodeMirrorConstants.events.blur, () => {
      // note: if you have changes in terminal/gutter, they will be saved. no cancel yet.
      this.saveChangesCommand()
    })
    cmInstance.addKeyMap(this._getKeyMap())

    let waiting
    const codeWidgets = []
    cmInstance.on("keyup", () => {
      clearTimeout(waiting)
      waiting = setTimeout(() => this._updateHints(cmInstance, codeWidgets), 100)
    })
  }

  _updateHints(codeInstance, codeWidgets) {
    const app = this.getRootNode()
    const tab = app.getMountedTab()
    const programConstructor = tab ? tab.getProgramConstructorForTab() : app.getProgramConstructorFromFileExtension() // get default

    const program = new programConstructor(this.getCode())
    const errs = program.getAllErrors()
    const cursor = codeInstance.getCursor()

    // todo: what if 2 errors?
    codeInstance.operation(function() {
      codeWidgets.forEach(widget => codeInstance.removeLineWidget(widget))
      codeWidgets.length = 0

      errs
        .filter(err => !err.isCursorOnWord(cursor.line, cursor.ch))
        .slice(0, 1) // Only show 1 error at a time. Otherwise UX is not fun.
        .forEach(err => {
          const el = err.getCodeMirrorLineWidgetElement(() => {
            codeInstance.setValue(program.toString())
            // todo: do we need to trigger update?
          })
          codeWidgets.push(codeInstance.addLineWidget(err.getLineNumber() - 1, el, { coverGutter: false, noHScroll: false }))
        })
      const info = codeInstance.getScrollInfo()
      const after = codeInstance.charCoords({ line: cursor.line + 1, ch: 0 }, "local").top
      if (info.top + info.clientHeight < after) codeInstance.scrollTo(null, after - info.clientHeight + 3)
    })
  }
}

window.CodeMirrorTerminalTreeComponent
 = CodeMirrorTerminalTreeComponent
;





class ConsoleTreeComponent extends AbstractTreeComponent {
  _getConsoleOutput() {
    const logLines = this._getMessageBuffer().map(message => message.childrenToString())
    logLines.reverse()
    return logLines.join("\n")
  }

  _getHeight() {
    return Math.floor((this.getRootNode().getBodyShadowDimensions().height - 60) * 0.3)
  }

  toHakonCode() {
    return `.consoleOutput
 height ${this._getHeight()}px
 overflow scroll
 font-family monospace
 white-space nowrap
 div
  margin-top 2px`
  }

  _getMessageBuffer() {
    const app = this.getRootNode()
    const tab = app.getMountedTab()
    return tab ? tab.getMessageBuffer() : app.getMessageBuffer()
  }

  getDependencies() {
    // 2 dependencies. the program and the programs message buffer.
    // let's call the latter the panel buffer for now.
    const deps = this.getParent().getDependencies()
    const messages = this._getMessageBuffer()
    if (messages.length) deps.push(messages.nodeAt(-1))
    else deps.push(new jtree.TreeNode())

    deps.push(this.getParent().getParent())
    return deps
  }

  toStumpCode() {
    return new jtree.TreeNode(`div
 class consoleOutput
 {messageBuffer}`).templateToString({ messageBuffer: this._getConsoleOutput() })
  }
}

window.ConsoleTreeComponent
 = ConsoleTreeComponent
;



class NewDropDownMenuTreeComponent extends AbstractDropDownMenuTreeComponent {
  getDropDownStumpCode() {
    const newProgram = `a New File
 clickCommand createNewBlankProgramCommand
 value untitled.maia
a New From Url
 clickCommand openCreateNewProgramFromUrlDialogCommand`
    const program = this.getRootNode().getMountedTab()
    if (!program) return newProgram

    return `${newProgram}
div
 class divider
a Clone File
 clickCommand cloneTabCommand`
  }

  getAnchorId() {
    return "newToggle"
  }
}

window.NewDropDownMenuTreeComponent
 = NewDropDownMenuTreeComponent
;

const OhayoConstants = {}

OhayoConstants.gutter = "gutter"
OhayoConstants.terminal = "terminal"
OhayoConstants.console = "console"
OhayoConstants.theme = "theme"
OhayoConstants.menu = "menu"
OhayoConstants.wall = "wall"
OhayoConstants.flex = "flex"
OhayoConstants.newDropDownMenu = "newDropDownMenu"
OhayoConstants.windowSize = "windowSize"
OhayoConstants.panel = "panel"
OhayoConstants.tabs = "tabs"
OhayoConstants.helpModal = "helpModal"
OhayoConstants.tileContextMenu = "tileContextMenu"
OhayoConstants.tabContextMenu = "tabContextMenu"
OhayoConstants.DropDownMenuSubstring = "DropDownMenu"

OhayoConstants.productName = "ohayo"
OhayoConstants.githubLink = "https://github.com/treenotation/ohayo"
OhayoConstants.subredditLink = "https://www.reddit.com/r/ohayocomputer"
OhayoConstants.slogan = "a fast and free data science studio"

OhayoConstants.fileExtensions = {}
OhayoConstants.fileExtensions.maia = ".maia"

OhayoConstants.deepLinks = {}
OhayoConstants.deepLinks.filename = "filename"
OhayoConstants.deepLinks.data = "data"
OhayoConstants.deepLinks.edgeSymbol = "edgeSymbol"
OhayoConstants.deepLinks.nodeBreakSymbol = "nodeBreakSymbol"

window.OhayoConstants
 = OhayoConstants
;










class GutterTreeComponent extends AbstractTreeComponent {
  createParser() {
    return new jtree.TreeNode.Parser(undefined, {
      console: ConsoleTreeComponent,
      terminal: this.isNodeJs() || !this.getRootNode().getPerfSettings().codeMirrorEnabled ? BasicTerminalTreeComponent : CodeMirrorTerminalTreeComponent
    })
  }

  toHakonCode() {
    const theme = this.getTheme()
    const width = this.getParent().getGutterWidth()
    return `${super.toHakonCode()}
.Gutter
 width ${width}px
 left 0
 background ${theme.backgroundColor}
 border-color ${theme.borderColor}
 position absolute
 border-right-width 1px
 border-right-style solid
 box-sizing border-box
 top 0
 bottom 0
 padding 20px
 .closeGutter
  cursor pointer
  position absolute
  top 10px
  right 5px
  display block
  font-size 12px
  line-height 10px
  text-align center
  opacity .25
  &:hover
   opacity 1`
  }

  getDependencies() {
    // todo: cleanup
    return [this.getParent().getNode(OhayoConstants.tabs), this.getParent()]
  }

  toStumpCode() {
    return `div
 class Gutter
 span <>
  class closeGutter
  clickCommand toggleGutterWidthCommand`
  }
}

window.GutterTreeComponent
 = GutterTreeComponent
;






class HelpModal extends AbstractModalTreeComponent {
  getMomentHelp() {
    return `Char;Example;Description
YYYY;2014;4 or 2 digit year
YY;14;2 digit year
Y;-25;Year with any number of digits and sign
Q;1..4;Quarter of year. Sets month to first month in quarter.
M MM;1..12;Month number
MMM MMMM;Jan..December;Month name in locale set by moment.locale()
D DD;1..31;Day of month
Do;1st..31st;Day of month with ordinal
DDD DDDD;1..365;Day of year
X;1410715640.579;Unix timestamp
x;1410715640579;Unix ms timestamp
H HH;0..23;24 hour time
h hh;1..12;12 hour time used with a A.
a/p A/P;am pm;Post or ante meridiem
m mm;0..59;Minutes
s ss;0..59;Seconds
S SS SSS;0..999;Fractional seconds
Z ZZ;+12:00;Offset from UTC as +-HH:mm, +-HHmm, or Z
w ww;1..53;Locale week of year
e;0..6;Locale day of week
ddd dddd;Mon...Sunday;Day name in locale set by moment.locale()
E;1..7;ISO day of week`
      .split("\n")
      .map(line => {
        const parts = line.split(";")
        return `<tr><td>${parts[0]}</td><td>${parts[1]}</td><td>${parts[2]}</td></tr>`
      })
      .join("")
  }

  toHakonCode() {
    return `${super.toHakonCode()}
p
 width 100%
 white-space normal
.helpToggle
 display block
.helpSection
.helpCategory
 font-weight bold
#shortcutsHelp td
 padding-right 10px`
  }

  _getShortcutsHelpStumpCode() {
    let lastCat = ""
    const app = this.getRootNode()
    const shortcutRows = app
      .getKeyboardShortcuts()
      .map(shortcut => {
        const category = shortcut.getCategory()
        let cat = ""
        if (category !== lastCat) {
          cat = ` tr
  td <br>${category}
   class helpCategory
  td
`
          lastCat = category
        }
        const description = shortcut.getDescription()
        return `${cat} tr
  style ${description ? "" : "display: none;"}
  td ${shortcut.getKeyCombo() || "-"}
  td &nbsp;&nbsp;
   ${shortcut.isEnabled(app) ? "a" : "span"} ${description}
    clickCommand ${shortcut.getFn()}`
      })
      .join("\n")
    return `table
 id shortcutsHelp
 class helpSection
${shortcutRows}`
  }

  getModalStumpCode() {
    const app = this.getRootNode()
    return `h4 About ${OhayoConstants.productName}
p ${OhayoConstants.productName} is ${OhayoConstants.slogan}.
p
 span ${OhayoConstants.productName} is on
 a GitHub
  href ${OhayoConstants.githubLink}
 span and
 a Reddit
  href ${OhayoConstants.subredditLink}
p Current working folder: ${app.getDefaultDisk().getPathBase()}
p Version ${app.getVersion()} ${app.constructor.name}
p
 a Welcome Page
  id welcomePageButton
  clickCommand openOhayoProgramCommand
  value ohayo.maia
a Keyboard Shortcuts
 class helpToggle
 clickCommand toggleShadowByIdCommand
 value shortcutsHelp
${this._getShortcutsHelpStumpCode()}`
  }
}

window.HelpModal
 = HelpModal
;







class MenuTreeComponent extends AbstractTreeComponent {
  createParser() {
    return new jtree.TreeNode.Parser(undefined, {
      newDropDownMenu: NewDropDownMenuTreeComponent
    })
  }

  getDependencies() {
    return [{ getLineModifiedTime: () => this.getParent().getWindowSizeMTime() }]
  }

  toHakonCode() {
    const theme = this.getTheme()
    return `.MenuTreeComponent
 ${theme.disableTextSelect(1)}
 font-size 14px
 padding-left 5px
 box-sizing border-box
 right 0
 left 0
 position relative
 height 30px
 z-index 92
 white-space nowrap
 background ${theme.menuBackground}
 color ${theme.darkBlack}
 display flex
 a
  padding-right 5px
  line-height 30px
  display inline-block
  color ${theme.menuTreeComponentColor}`
  }

  toStumpCode() {
    return `div
 class MenuTreeComponent ${this.constructor.name}
 a ${OhayoConstants.productName}
  clickCommand toggleHelpCommand
 a New ▾
  id newToggle
  clickCommand toggleAndRenderNewDropDownCommand`
  }
}

window.MenuTreeComponent
 = MenuTreeComponent
;

// rename lodash
if (!window.lodash) window.lodash = _

// Shim window.console for IE.
if (!window.console) window.console = { log: () => {}, time: () => {}, error: () => {}, debug: () => {} }

// Safari polyfill:
if (!Object.values) Object.values = obj => Object.keys(obj).map(key => obj[key])

const d3format = {}
d3format.format = d3.format
;



class TabContextMenuTreeComponent extends AbstractContextMenuTreeComponent {
  getContextMenuBodyStumpCode() {
    return this.getRootNode()
      .getMountedTab()
      .getContextMenuCommandsStumpCode()
  }
}

window.TabContextMenuTreeComponent
 = TabContextMenuTreeComponent
;








class TabTreeComponent extends AbstractTreeComponent {
  toStumpCode() {
    const index = this.getIndex()
    const fullPath = this.getFullTabFilePath()
    const filename = this.getFileName()
    const isMounted =
      this.getParent()
        .getParent()
        .getMountedTabName() === fullPath
    return `a ${filename}
 clickCommand mountTabByIndexCommand
 collapse
 value ${index}
 title ${fullPath}
 class TabStub ${isMounted ? "mountedTab" : ""}
 span x
  collapse
  clickCommand closeTabByIndexCommand
  value ${index}
  class closeTabButton`
  }

  getDependencies() {
    return [this.getParent().getParent()]
  }

  getDeepLink() {
    const obj = {}
    obj[OhayoConstants.deepLinks.filename] = this.getFileName()
    return this.getRootNode()
      .getWillowBrowser()
      .toPrettyDeepLink(this.getTabProgram().childrenToString(), obj)
  }

  getContextMenuCommandsStumpCode() {
    const grammarProgram = this.getTabProgram().getGrammarProgram()

    return `a Save File
 clickCommand saveTabAndNotifyCommand
a Rename File
 clickCommand showTabRenameFilePromptCommand
a Move File
 clickCommand showTabMoveFilePromptCommand
a Clone File
 clickCommand cloneTabCommand
a Delete File
 clickCommand showDeleteFileConfirmDialogCommand
a Copy program as link
 clickCommand copyDeepLinkCommand
a Log program stats
 clickCommand printProgramStatsCommand
a Close all other files
 clickCommand closeAllTabsExceptFocusedTabCommand
a Save compiled '${grammarProgram.getTargetExtension()}' file
 tabindex -1
 clickCommand saveCompiledCommand`
  }

  autosaveAndRender() {
    const savingPromise = this.autosaveTab()
    this.getRootNode().renderApp()
    return savingPromise
  }

  async autosaveAndReloadWith(str) {
    this.getTabProgram().setChildren(str)
    await this.autosaveTab()
    this.getTabWall().unmount() //ugly!
    await this._initProgramRenderAndRun(str)
    this.getRootNode().renderApp()
  }

  _getPanel() {
    return this.getParent().getParent()
  }

  async _initProgramRenderAndRun(source, shouldMount) {
    const programConstructor = this.getProgramConstructorForTab()
    this._program = new programConstructor(source)
    this._program.saveVersion()
    this._program.setTab(this)

    if (shouldMount) this._getPanel().setMountedTab(this)

    this.getRootNode().renderApp()
    await this._program.loadAndIncrementalRender()
    return this
  }

  async reloadFromDisk() {
    const source = await this.getRootNode().readFile(this.getFullTabFilePath())
    return this.autosaveAndReloadWith(source)
  }

  async _fetchTabInitProgramRenderAndRun(shouldMount) {
    const source = await this.getRootNode().readFile(this.getFullTabFilePath())
    const res = await this._initProgramRenderAndRun(source, shouldMount)
    return res
  }

  async autosaveTab() {
    this.getTabProgram().saveVersion()
    const app = this.getRootNode()
    if (!app.isAutoSaveEnabled()) return undefined

    await this.forceSaveToFile()
    this.addStumpCodeMessageToLog(`div Saved ${this.getFileName()}
 title Saved ${this.getFullTabFilePath()}`)
  }

  forceSaveToFile() {
    const newVersion = this.getTabProgram().toString()
    return this.getRootNode().writeFile(this.getFullTabFilePath(), newVersion)
  }

  getFullTabFilePath() {
    return this.getWordsFrom(1).join(" ")
  }

  getFileName() {
    return jtree.Utils.getFileName(this.getFullTabFilePath())
  }

  getProgramConstructorForTab() {
    return this.getRootNode().getProgramConstructorFromFileExtension(jtree.Utils.getFileExtension(this.getFullTabFilePath()))
  }

  getTabWall() {
    return this.getParent().getWall()
  }

  async appendFromPaste(pastedText) {
    const tabProgram = this.getTabProgram()
    const newNodes = tabProgram.concat(pastedText)
    const newTiles = newNodes.filter(tile => tile.doesExtend && tile.doesExtend("abstractTileTreeComponentNode"))
    this.addStumpCodeMessageToLog(`div Pasted ${newTiles.length} nodes`)
    await this.autosaveTab()
    tabProgram.clearSelection()
    this.getTabWall().unmount()

    // todo: catch if a tile throws so that we still render the terminal.
    await tabProgram.loadAndIncrementalRender()
    newTiles.forEach(tile => tile.selectTile())
  }

  getTabProgram() {
    return this._program
  }

  async unlinkTab() {
    return this.getRootNode().unlinkFile(this.getFullTabFilePath())
  }
}

window.TabTreeComponent
 = TabTreeComponent
;



class TileContextMenuTreeComponent extends AbstractContextMenuTreeComponent {
  getContextMenuBodyStumpCode() {
    const targetTile = this.getRootNode().getTargetNode()
    return `a Reload
 clickCommand fetchAndReloadFocusedTabCommand
a Copy tile with inputs
 tabindex -1
 clickCommand copyTargetTileCommand
a Copy data as tree
 clickCommand copyTargetTileDataAsTreeCommand
a Copy data as javascript
 clickCommand copyTargetTileDataAsJavascriptCommand
a Copy data as tsv
 clickCommand copyTargetTileDataCommand
 value \t
a Copy data as csv
 clickCommand copyTargetTileDataCommand
 value ,
a Export data to csv file
 clickCommand exportTargetTileDataCommand
a Export data to tree file
 clickCommand exportTargetTileDataCommand
 value tree
${targetTile.getContextMenuStumpCode()}`
  }
}

window.TileContextMenuTreeComponent
 = TileContextMenuTreeComponent
;







class TileToolbarTreeComponent extends AbstractTreeComponent {
  toHakonCode() {
    const theme = this.getTheme()
    return `.TileToolbarTreeComponent
 background ${theme.contextMenuBackground}
 border 1px solid ${theme.lineColor}
 font-size 12px
 position absolute
 padding 8px
 z-index 991
 min-width 300px
 top 100%
 left 0
 cursor pointer
 .TableInspection
  margin-top 5px
  border 1px solid ${theme.lineColor}
  td
   padding 2px 8px
   text-align left
  tr:nth-child(odd)
   background-color ${theme.veryLightGrey}
 svg
  fill ${theme.greyish}
  padding 1px 3px 3px 3px
  &:hover
   fill ${theme.foregroundColor}`
  }

  getTargetTile() {
    return this.getParent()
  }

  createProgramFromFocusedTileExampleCommand(uno, dos) {
    return this.getTargetTile().createProgramFromTileExampleCommand(uno, dos)
  }

  cloneFocusedTileCommand(uno, dos) {
    return this.getTargetTile().cloneTileCommand(uno, dos)
  }
  destroyFocusedTileCommand(uno, dos) {
    return this.getTargetTile().destroyTileCommand(uno, dos)
  }
  inspectFocusedTileCommand(uno, dos) {
    return this.getTargetTile().inspectTileCommand(uno, dos)
  }
  changeFocusedTileTypeCommand(uno, dos) {
    return this.getTargetTile().changeTileTypeCommand(uno, dos)
  }
  changeFocusedTileParentCommand(uno, dos) {
    return this.getTargetTile().changeParentCommand(uno, dos)
  }
  changeFocusedTileContentAndRenderCommand(uno, dos) {
    return this.getTargetTile().changeTileContentAndRenderCommand(uno, dos)
  }

  toStumpCode() {
    const tile = this.getTargetTile()
    const suggestions = this._getSuggestionsStumpCode()
    const exampleTile = tile.getExampleTemplate()
    let tileHelp = ""
    if (exampleTile) {
      tileHelp = `
 span ${Icons("function", 20)}
  title See an example program with '${tile.getFirstWord()}'
  clickCommand createProgramFromTileExampleCommand`
    }
    const hints = tile.getDefinition().getLineHints()

    // todo: cleanup

    return (
      `div
 class TileToolbarTreeComponent
 span ${Icons("copy", 20)}
  title Duplicate Tile
  clickCommand cloneTileCommand
 span ${Icons("trash", 20)}
  title Delete Tile
  clickCommand destroyTileCommand
 span ${Icons("inspector", 20)}
  title Debug Tile
  clickCommand inspectTileCommand` +
      tileHelp +
      `
 div ${hints}` +
      jtree.TreeNode.nest(this._getFormStumpCode(), 1)
    )
  }

  _getTileTypeDropdownStumpCode() {
    const tile = this.getTargetTile()
    const tileNames = tile
      .getRootNode()
      .getGrammarProgram()
      ._getInScopeNodeTypeIds()
      .filter(name => !name.includes("_") && !name.startsWith("@"))
    tileNames.sort()
    const selectedValue = tile.getFirstWord()
    const options = tileNames
      .map(
        option =>
          ` option ${option}
  value ${option}
  ${selectedValue === option ? "selected" : ""}`
      )
      .join("\n")
    return `select
 changeCommand changeTileTypeCommand
${options}`
  }

  _getParentDropdownStumpCode() {
    const tile = this.getTargetTile()
    const tilesProgram = tile.getRootNode()
    const tilesParent = tile.getParent()

    const options = tilesProgram
      .getTiles()
      .filter(t => t !== tile)
      .map(tile => {
        return {
          name: tile.getFirstWordPathRelativeTo(tilesProgram),
          value: tile.getPathVectorRelativeTo(tilesProgram).join(" "),
          isParent: tile === tilesParent
        }
      })
      .map(
        option =>
          ` option ${option.name}
  value ${option.value}
  ${option.isParent ? "selected" : ""}`
      )
      .join("\n")

    return `select
 changeCommand changeParentCommand
 option (top)
  value 
  ${tilesParent.isRoot() ? "selected" : ""}${options ? "\n" + options : ""}`
  }

  _getSuggestionsStumpCode() {
    //return `div Add Suggested:`
    return "" //todo:
  }

  _getFormStumpCode() {
    const tile = this.getTargetTile()

    const formFields = []
    formFields.unshift(["parent", this._getParentDropdownStumpCode()])
    formFields.unshift(["type", this._getTileTypeDropdownStumpCode()])
    formFields.unshift([
      "content",
      `input
 changeCommand changeTileContentAndRenderCommand
 value ${tile.getContent() || ""}`
    ])

    const html = formFields
      .map(
        control =>
          `  tr
   td ${control[0]}
   td${jtree.TreeNode.nest(control[1], 4)}`
      )
      .join("\n")

    let colTable = !tile.getOutputOrInputTable
      ? ""
      : tile
          .getOutputOrInputTable()
          .getColumnNamesAndTypes()
          .map(
            col => `  tr
  td ${col.Column}
  td ${col.JTableType}
  td ${col.JavascriptType}`
          )
          .join("\n")

    return `form
 table${html ? "\n" + html : html}
div Output Table Columns:
table
 class TableInspection
 thead
  tr
   th Column
   th Type
   th JavascriptType
 tbody
${colTable}`
  }
}

window.TileToolbarTreeComponent
 = TileToolbarTreeComponent
;

const Version = "16.0.1"
if (typeof exports !== "undefined") module.exports = Version
;





class WallTreeComponent extends AbstractTreeComponent {
  // pin?
  // duplicate?
  // reload?
  toHakonCode() {
    const theme = this.getTheme()
    return `.WallTreeComponent
 background-color ${theme.wallBackground}
 background-image ${theme.wallBackgroundImage || "none"}
 display block
 position relative
 height 100%
 overflow scroll

.ui-selectable-helper
 position absolute
 z-index 100
 border-radius 2px
 background ${theme.selectionBackground}

.ui-selecting,.${TilesConstants.selectedClass},.${TilesConstants.staySelectedClass}
 outline 3px solid ${theme.selectedOutline}`
  }

  getPickerBlock(event) {}

  async openWallContextMenuCommand() {
    this.getRootNode().toggleAndRender("tabContextMenu")
  }

  async insertAdjacentTileCommand() {
    const app = this.getRootNode()
    const tilesProgram = app.getMountedTilesProgram()
    // todo: it seems like we don't want to have that insert multiple behavior. removed it for now.
    const newTiles = app
      .getNodeCursors()
      .slice(0, 1)
      .map(cursor => cursor.appendLine(TilesConstants.pickerTile))
    const promise = await app.getMountedTab().autosaveAndRender()
    tilesProgram.clearSelection()
    newTiles.forEach(tile => tile.selectTile())
    return promise
  }

  async insertPickerTileCommand() {
    const app = this.getRootNode()
    const evt = app.getMouseEvent()
    const tilesProgram = app.getMountedTilesProgram()

    if (!evt.shiftKey) {
      tilesProgram.clearSelection()
    }
    // todo: it seems like we don't want to have that insert multiple behavior. removed it for now.
    const newTiles = app
      .getNodeCursors()
      .slice(0, 1)
      .map(cursor => cursor.appendLineAndChildren(TilesConstants.pickerTile, this.getPickerBlock(evt)))
    await app.getMountedTab().autosaveAndRender()
    tilesProgram.clearSelection()
    newTiles.forEach(tile => {
      tile.selectTile()
    })
  }

  getDependencies() {
    return [{ getLineModifiedTime: () => this.getRootNode().getWindowSizeMTime() }]
  }

  selectTilesByShadowClass(className = TilesConstants.selectedClass) {
    this.getRootNode()
      .getWillowBrowser()
      .findStumpNodesByShadowClass(className)
      .forEach(stumpNode => stumpNode.getStumpNodeTreeComponent().selectTile())
  }

  getWallViewPortDimensions() {
    // depends on window.resize and whether gutter is open
    const bodyShadowDimensions = this.getRootNode().getBodyShadowDimensions()

    return {
      width: bodyShadowDimensions.width - this.getParent().getGutterWidth(),
      height: bodyShadowDimensions.height
    }
  }

  treeComponentDidUpdate() {
    // todo: I don't think this ever gets called. actually seems to get called when you toggle gutter
    this._makeSelectable()
  }

  _getChildTreeComponents() {
    const tilesProgram = this.getRootNode().getMountedTilesProgram()
    return tilesProgram ? tilesProgram.getTiles() : []
  }

  treeComponentDidMount() {
    this.treeComponentDidUpdate()
  }

  toStumpCode() {
    return `div
 class WallTreeComponent
 contextMenuCommand openWallContextMenuCommand
 doubleClickCommand insertPickerTileCommand`
  }

  _getSelectedTileStumpNodes() {
    return this.getRootNode()
      .getWillowBrowser()
      .getBodyStumpNode()
      .findStumpNodesWithClass(TilesConstants.selectedClass) // todo: also filter by .abstractTileTreeComponentNode?
  }

  _makeSelectable() {
    const app = this.getRootNode()
    const stumpNode = this.getStumpNode()
    const willowBrowser = app.getWillowBrowser()
    const selector = "." + TilesConstants.abstractTileTreeComponentNode
    const shadow = stumpNode.getShadow()

    // I think we need this because jquery selectable breaks click behavior otherwise?
    shadow.onShadowEvent("click", function(evt) {
      // Only if this is the direct target
      if (evt.target === shadow.getShadowElement()) willowBrowser.blurFocusedInput()
    })

    // todo: can we delay this a bit? getting a perf hit.
    // can we move off jquery ui?
    // todo: https://bugs.jqueryui.com/ticket/15044
    //todo: SPEED!!!

    if (app.getPerfSettings().bodyDragSelect) {
      let wasAdded = false

      // NOTE: SHADOW AND STUMP GET OUT OF SYNC HERE....NEED TESTS. NEED TO MVOE SHADOW AND STUMP
      // TO THEIR OWN TESTED REPO.
      shadow.onShadowEvent("mouseover", function(evt) {
        if (wasAdded) return true
        wasAdded = true
        shadow.makeSelectable({
          cancel: selector,
          distance: 10,
          filter: selector,
          start: function(evt) {
            if (evt.shiftKey)
              willowBrowser
                .getBodyStumpNode()
                .findStumpNodesWithClass(TilesConstants.selectedClass)
                .forEach(stumpNode => {
                  stumpNode.addClassToStumpNode(TilesConstants.staySelectedClass)
                })
            else app.clearSelectionCommand()
          },
          stop: function() {
            willowBrowser
              .getBodyStumpNode()
              .findStumpNodesWithClass(TilesConstants.staySelectedClass)
              .forEach(stumpNode => {
                stumpNode.removeClassFromStumpNode(TilesConstants.staySelectedClass)
                stumpNode.addClassToStumpNode(TilesConstants.selectedClass)
              })
            app.selectTilesByShadowClassCommand()
            return true
          }
        })
      })
    }
  }
}

window.WallTreeComponent = WallTreeComponent
;







class WallFlexTreeComponent extends WallTreeComponent {
  _resizeTiles(stumpNode) {
    const selected = this._getSelectedTileStumpNodes()
    selected.length > 1 ? selected.forEach(stumpNode => this._resizeStumpNode(stumpNode)) : this._resizeStumpNode(stumpNode)
    this.setLayoutToCustomCommand()
  }

  setLayoutToCustomCommand() {
    const app = this.getRootNode()
    const tab = app.getMountedTab()
    const tabProgram = tab.getTabProgram()
    tabProgram.touchNode(TilesConstants.layout).setContent(TilesConstants.custom)
    return tab.autosaveAndRender()
  }

  moveTilesFromShadowsCommand() {
    // todo: remove this. ditch jqery ui.
    const app = this.getRootNode()
    app
      .getWillowBrowser()
      .getBodyStumpNode()
      .findStumpNodesWithClass(TilesConstants.abstractTileTreeComponentNode)
      .filter(stumpNode => stumpNode.getStumpNodeTreeComponent().isVisible())
      .forEach(stumpNode => this._moveStumpNode(stumpNode))
    return this.setLayoutToCustomCommand()
  }

  _getLayoutOptions(mountedProgram) {
    // only include custom IF there are custom properties.
    const toggleOptions = Object.keys(TilesConstants.layouts).filter(key => key !== TilesConstants.layouts.custom)
    if (mountedProgram.canUseCustomLayout()) toggleOptions.push(TilesConstants.layouts.custom)
    return toggleOptions
  }

  async toggleLayoutCommand() {
    const mountedProgram = this.getRootNode().getMountedTilesProgram()
    const currentLayoutNode = mountedProgram.touchNode(TilesConstants.layout)
    const currentLayout = currentLayoutNode.getContent() || TilesConstants.layouts.tiled
    const newLayout = jtree.Utils.toggle(currentLayout, this._getLayoutOptions(mountedProgram))
    currentLayoutNode.setContent(newLayout)
    mountedProgram.getTiles().forEach(tile => tile.makeDirty()) // todo: delete this
    const tab = mountedProgram.getTab()
    tab.addStumpCodeMessageToLog(`div Layout changed to '${newLayout}'.`)
    await tab.autosaveAndRender()
  }

  _resizeStumpNode(stumpNode) {
    const tile = stumpNode.getStumpNodeTreeComponent()
    const shadow = stumpNode.getShadow()
    const gridSize = this.getGridSize()
    const position = shadow.getPositionAndDimensions(gridSize)
    tile.changeTileSettingCommand(TilesConstants.width, position.width)
    tile.changeTileSettingCommand(TilesConstants.height, position.height)
  }

  getPickerBlock(event) {
    const offset = 0 // todo: take into account navigator.
    const gridSize = 20
    const left = Math.floor((event.offsetX - offset) / gridSize)
    const _top = Math.floor(event.offsetY / gridSize)
    return `${TilesConstants.left} ${left}
${TilesConstants.top} ${_top}`
  }

  _moveStumpNode(stumpNode) {
    const tile = stumpNode.getStumpNodeTreeComponent()
    const shadow = stumpNode.getShadow()
    const gridSize = this.getGridSize()
    const position = shadow.getPositionAndDimensions(gridSize)
    tile.changeTileSettingCommand(TilesConstants.left, position.left)
    tile.changeTileSettingCommand(TilesConstants.top, position.top)
  }

  getGridSize() {
    return 20
  }

  treeComponentDidMount() {
    this._makeTilesMoveableAndResizableAndEditable()
    super.treeComponentDidMount()
  }

  _tileMouseOverHandler(tileStumpNode) {
    const shadow = tileStumpNode.getShadow()
    if (!shadow.isShadowResizable()) this._makeShadowResizable(shadow)
    if (!shadow.isShadowDraggable()) this._makeGroupDraggable(tileStumpNode)
  }

  _makeShadowResizable(shadow) {
    const gridSize = this.getGridSize()
    const app = this.getRootNode()
    const that = this
    const willowBrowser = app.getWillowBrowser()
    shadow.makeResizable({
      handles: "se",
      grid: gridSize,
      resize: evt => {
        //  otherwise will trigger a window resize
        evt.stopPropagation()
        evt.preventDefault()
        return false
      },
      stop: ui => that._resizeTiles(willowBrowser.getStumpNodeFromElement(ui.target))
    })
  }

  _makeTilesMoveableAndResizableAndEditable() {
    const app = this.getRootNode()
    const that = this
    this.getStumpNode()
      .getShadow()
      .onShadowEvent("mouseover", "." + TilesConstants.abstractTileTreeComponentNode, function() {
        const tileStumpNode = app.getWillowBrowser().getStumpNodeFromElement(this)
        that._tileMouseOverHandler(tileStumpNode)
      })
  }

  _updateSelectedOnMove(draggedStumpNode, change) {
    this._getSelectedTileStumpNodes()
      .filter(stumpNode => stumpNode !== draggedStumpNode)
      .forEach(stumpNode => {
        const position = {
          top: parseFloat(stumpNode.getStumpNodeCss("top")),
          left: parseFloat(stumpNode.getStumpNodeCss("left"))
        }
        const newCss = {
          transform: "",
          top: position.top + change.top + "px",
          left: position.left + change.left + "px"
        }
        stumpNode.setStumpNodeCss(newCss)
      })
  }

  _getElementChangeInPixels(ui, offset) {
    return {
      left: ui.offset.left - offset.left,
      top: ui.offset.top - offset.top
    }
  }

  _makeGroupDraggable(stumpNode) {
    const shadow = stumpNode.getShadow()
    let offset
    let originalLeft
    let originalTop
    let newLeft
    let newTop
    const that = this
    const app = this.getRootNode()
    const gridSize = this.getGridSize()

    const options = {
      stop: function(event, ui) {
        shadow.removeClassFromShadow("noTransition")
        shadow.setShadowAttr("data-translate", newLeft + " " + newTop)
        const change = that._getElementChangeInPixels(ui, offset)
        that._updateSelectedOnMove(stumpNode, change)
        offset = ui // todo: what does this do?
        app.moveTilesFromShadowsCommand()
      },
      grid: [gridSize, gridSize],
      handle: ".TileGrabber",
      drag: function(event, ui) {
        if (!shadow.shadowHasClass(TilesConstants.selectedClass)) return
        // move entire selection
        const change = that._getElementChangeInPixels(ui, offset)
        that
          ._getSelectedTileStumpNodes()
          .filter(selectedStumpNode => selectedStumpNode !== stumpNode)
          .forEach(selectedStumpNode => selectedStumpNode.setStumpNodeCss({ transform: `translate(${change.left}px, ${change.top}px)` }))
      },
      start: function(event, ui) {
        offset = ui.offset
        shadow.addClassToShadow("noTransition")
        const translate = shadow.getShadowAttr("data-translate")
        if (translate) {
          originalLeft = parseInt(translate.split(" ")[0])
          originalTop = parseInt(translate.split(" ")[1])
        } else {
          originalLeft = 0
          originalTop = 0
        }
      }
    }

    shadow.addClassToShadow("draggable").makeDraggable(options)
  }
}

window.WallFlexTreeComponent
 = WallFlexTreeComponent
;











class TabsTreeComponent extends AbstractTreeComponent {
  createParser() {
    return new jtree.TreeNode.Parser(undefined, {
      tab: TabTreeComponent,
      wall: WallTreeComponent,
      flex: WallFlexTreeComponent
    })
  }

  removeWall() {
    const wall = this.getWall()
    if (wall) wall.unmountAndDestroy()
  }

  getDependencies() {
    // todo: cleanup
    return [this.getParent()]
  }

  getOpenTabs() {
    return this.getChildrenByNodeConstructor(TabTreeComponent)
  }

  getWall() {
    return this.getNode(OhayoConstants.wall) || this.getNode(OhayoConstants.flex)
  }

  addWall(type = OhayoConstants.wall) {
    this.removeWall()
    return this.appendLine(type)
  }

  addTab(url) {
    const line = `tab ${new FullDiskPath(url).toString()}`
    // todo: add before wall
    return this.getWall() ? this.insertLine(line, -1) : this.appendLine(line)
  }

  getGutterWidth() {
    return this.getParent().getGutterWidth()
  }

  toHakonCode() {
    const theme = this.getTheme()
    const left = this.getGutterWidth()

    // todo: add comments to Hakon? So we can annotate why we have valignTop
    const valignTop = "vertical-align top" // https://stackoverflow.com/questions/23529369/why-does-x-overflowhidden-cause-extra-space-below
    // todo: make tab cell width dynamic? smaller as more tabs open?s

    return `.TabsTreeComponent
 left ${left}px
 width calc(100% - ${left}px)
 height calc(100% - 30px)
 position absolute
.TabStub
 background ${theme.tabBackground}
 height 30px
 display inline-block
 max-width 150px
 text-overflow ellipsis
 white-space nowrap
 ${valignTop}
 overflow-x hidden
 box-sizing border-box
 position relative
 font-size 13px
 padding 0 15px
 color ${theme.foregroundColor}
 line-height 30px
 border-right 1px solid ${theme.borderColor}
 border-bottom 1px solid ${theme.borderColor}
 &:hover
  background ${theme.slightlyDarkerBackground}
 &:active
  background ${theme.activeTabColor}
 span
  position absolute
  top 10px
  right 5px
  display block
  font-size 12px
  line-height 10px
  text-align center
  opacity .25
  &:hover
   opacity 1
 &.mountedTab
  background ${theme.activeTabColor}
  border-bottom 0`
  }
}

window.TabsTreeComponent
 = TabsTreeComponent
;










class PanelTreeComponent extends AbstractTreeComponent {
  createParser() {
    return new jtree.TreeNode.Parser(undefined, {
      tabs: TabsTreeComponent,
      gutter: GutterTreeComponent
    })
  }

  toggleGutter() {
    // todo: this is UI buggy! toggling resets scroll states
    const gutter = this.getNode(OhayoConstants.gutter)
    if (gutter) gutter.unmountAndDestroy()
    else {
      const node = this.touchNode(OhayoConstants.gutter)
      node.appendLine(OhayoConstants.terminal)
      node.appendLine(OhayoConstants.console)
    }
  }

  toHakonCode() {
    const _top = this.getParent().getMenuTreeComponent() ? "30" : "0"
    const theme = this.getTheme()
    return `.PanelTreeComponent
 left 0
 position relative
 right 0
 bottom 0
 height calc(100% - ${_top}px)`
  }

  getGutterWidth() {
    return parseInt(this.getWord(1))
  }

  setGutterWidth(newWidth) {
    return this.setWord(1, newWidth)
  }

  toggleGutterWidth() {
    this.setGutterWidth(this.getGutterWidth() === 50 ? 400 : 50)
    return this
  }

  mountTabByIndex(index) {
    this.setMountedTab(this.getTabs()[index])
    this.getRootNode().renderApp()
    return this
  }

  getMountedTab() {
    return this._getMountedTab()
  }

  _getMountedTab() {
    return this._focusedTab
  }

  getOpenTabByFullFilePath(fullPath) {
    return this.getTabs().find(tab => tab.getFullTabFilePath() === fullPath)
  }

  setMountedTabName(tabName) {
    if (tabName) this.setWord(2, tabName)
    else this.deleteWordAt(2)
  }

  getMountedTabName() {
    return this.getWord(2)
  }

  setMountedTab(tab) {
    const currentTab = this._getMountedTab()
    if (currentTab === tab) return this
    else if (currentTab) this._getTabsNode().removeWall()
    this._focusedTab = tab
    this.setMountedTabName(tab.getFullTabFilePath())
    const wallType = tab.getTabProgram().wallType
    this._getTabsNode().addWall(wallType)
    this._updateLocationForRestoreOnRefresh()
    return this
  }

  _getTabsNode() {
    return this.getNode("tabs")
  }

  async getAlreadyOpenTabOrOpenFullFilePathInNewTab(filePath, andMount = false) {
    const existingTab = this.getOpenTabByFullFilePath(new FullDiskPath(filePath).toString())
    if (existingTab) {
      if (andMount) {
        this.setMountedTab(existingTab)
        this.getRootNode().renderApp()
      }
      return existingTab
    }

    const tab = this._getTabsNode().addTab(new FullDiskPath(filePath).toString())

    await tab._fetchTabInitProgramRenderAndRun(andMount)

    this.getRootNode().renderApp()
    return tab
  }

  closeTabByIndex(index) {
    return this.closeTab(this.getTabs()[index])
  }

  closeTab(tab) {
    if (tab.isMounted()) {
      const tabToMountNext = jtree.Utils.getNextOrPrevious(this.getTabs())
      this._getTabsNode().removeWall()
      tab.unmountAndDestroy()
      delete this._focusedTab
      if (tabToMountNext) this.setMountedTab(tabToMountNext)
      else this.setMountedTabName()
    } else tab.destroy()
    this._updateLocationForRestoreOnRefresh()
  }

  _updateLocationForRestoreOnRefresh() {
    this.getRootNode().saveAppState()
  }

  closeAllTabs() {
    this._getTabsNode()
      .getOpenTabs()
      .forEach(tab => {
        this.closeTab(tab)
      })
  }

  closeAllTabsExceptFocusedTab() {
    const mountedTab = this.getMountedTab()
    this._getTabsNode()
      .getOpenTabs()
      .forEach(tab => {
        if (tab !== mountedTab) this.closeTab(tab)
      })
  }

  mountPreviousTab() {
    const tabs = this.getTabs()
    const mountedTab = this._getMountedTab()
    if (tabs.length < 2 || !mountedTab) return this
    const index = tabs.indexOf(mountedTab)
    return this.mountTabByIndex(index === 0 ? tabs.length - 1 : index - 1)
  }

  mountNextTab() {
    const tabs = this.getTabs()
    const mountedTab = this._getMountedTab()
    if (tabs.length < 2 || !mountedTab) return this
    const index = tabs.indexOf(mountedTab)
    return this.mountTabByIndex(index === tabs.length - 1 ? 0 : index + 1)
  }

  getTabs() {
    return this._getTabsNode().getOpenTabs()
  }
}

window.PanelTreeComponent
 = PanelTreeComponent
;








































class GlobalShortcutNode extends jtree.TreeNode {
  getKeyCombo() {
    return this.getWord(3)
  }

  getFn() {
    return this.getWord(2)
  }

  getCategory() {
    return this.getWord(1)
  }

  getDescription() {
    return this.getWordsFrom(4).join(" ")
  }

  isEnabled() {
    return true
  }

  execute(app) {
    if (!this.isEnabled(app)) return false
    const fn = this.getFn()
    app.addToCommandLog(fn)
    app[fn]()
  }
}

class MountedShortcutNode extends GlobalShortcutNode {
  isEnabled(app) {
    return !!app.getMountedTab()
  }
}

class DrumsProgram extends jtree.TreeNode {
  createParser() {
    return new jtree.TreeNode.Parser(undefined, {
      panel: GlobalShortcutNode,
      mounted: MountedShortcutNode
    })
  }
}

class OhayoWebApp extends AbstractTreeComponent {
  treeComponentWillMount() {
    this._startVisitCounter()
    const state = this.getFromStore(StorageKeys.appState)
    if (state) this.setChildren(state)

    this._restoreTabs()

    this._makeProgramLinksOpenImmediately()
    this._makeDocumentCopyableAndCuttable()
    this._bindKeyboardShortcuts()

    const willowDoc = this.getWillowBrowser()

    willowDoc.setResizeEndHandler(event => this._onResizeEndEvent(event))
    willowDoc.setPasteHandler(event => this._onPasteEvent(event))
    willowDoc.setLoadedDroppedFileHandler(files => {
      files.forEach(file => this.createProgramFromFileCommand(file.filename, file.data))
    }, "Drop to create a new program.")

    this._setErrorHandlers()
    this.addStumpCodeMessageToLog(`div Ohayo!`)

    const deepLink = this._getDeepLink()
    if (deepLink) this.createAndOpenNewProgramFromDeepLinkCommand(deepLink)
    else if (this._getVisitCount() === 1) this.playFirstVisitCommand()
  }

  _getDeepLink() {
    if (this.isNodeJs()) return false
    return window.location.href.includes(OhayoConstants.deepLinks.filename) ? window.location.href : ""
  }

  async _onPasteEvent(event) {
    // Return true if worker is editing an input
    if (this.terminalHasFocus() || this.getWillowBrowser().someInputHasFocus()) return true
    if (event.clipboardData && event.clipboardData.getData) await this.pasteCommand(event.clipboardData.getData("text/plain"))
  }

  _onResizeEndEvent(event) {
    this.touchNode(OhayoConstants.windowSize).setContent(`${event.width} ${event.height}`)
    delete this._bodyShadowDimensionsCache
    this.renderApp()
  }

  _restoreTabs() {
    const panel = this.getFocusedPanel()
    const tabToMount = panel.getMountedTabName()
    panel.getTabs().forEach(async tab => {
      await tab._fetchTabInitProgramRenderAndRun(tab.getFullTabFilePath() === tabToMount)
      this.renderApp()
    })
  }

  _getProjectRootDir() {
    return this.isNodeJs() ? jtree.Utils.findProjectRoot(__dirname, "ohayo") : ""
  }

  getPerfSettings() {
    if (!this._perfSettings)
      this._perfSettings = {
        codeMirrorEnabled: true,
        bodyDragSelect: true,
        max10tiles: false
      }
    return this._perfSettings
  }

  terminalHasFocus() {
    const terminalNode = this.getFocusedPanel().getNode(`${OhayoConstants.gutter} ${OhayoConstants.terminal}`)
    return terminalNode && terminalNode.hasFocus()
  }

  initLocalDataStorage(key, value) {
    key = jtree.Utils.stringToPermalink(key)
    key = this.getUnusedStoreKey(key)
    this.getRootNode().storeValue(key, value)
    return key
  }

  getBodyShadowDimensions() {
    if (!this._bodyShadowDimensionsCache) this._bodyShadowDimensionsCache = this._getBodyShadowDimensions()
    return this._bodyShadowDimensionsCache
  }

  _getBodyShadowDimensions() {
    // depends on window.resize and whether gutter is open

    const bodyStumpNode = this.getWillowBrowser().getBodyStumpNode()
    const bodyShadow = bodyStumpNode.getShadow()

    return {
      width: bodyShadow.getShadowWidth(),
      height: bodyShadow.getShadowHeight()
    }
  }

  getWindowSizeMTime() {
    const node = this.getNode(OhayoConstants.windowSize)
    return node ? node.getLineModifiedTime() : 0
  }

  static getDefaultStartState() {
    return `${OhayoConstants.theme} ${ThemeTreeComponent.defaultTheme}
${OhayoConstants.menu}
${OhayoConstants.panel} 400
 ${OhayoConstants.tabs}
 ${OhayoConstants.gutter}
  ${OhayoConstants.terminal}
  ${OhayoConstants.console}`
  }

  saveAppState() {
    this.storeValue(StorageKeys.appState, this.toString())
  }

  resetAppState() {
    this.removeValue(StorageKeys.appState)
    return this
  }

  executeCommandLine(args) {
    this.addToCommandLog(args.join(" "))
    return this[args[0]].apply(this, args.slice(1))
  }

  getProgramConstructorFromFileExtension(treeLanguageName) {
    const grammars = this.getGrammars()
    return grammars[treeLanguageName] || grammars.maia
  }

  getMaiaGrammarAsTree() {
    if (!this._maiaGrammarTree) this._maiaGrammarTree = new maiaNode().getGrammarProgram()
    return this._maiaGrammarTree
  }

  getGrammars() {
    if (!this._grammars) {
      this._grammars = {}
      this._grammars["maia"] = maiaNode // todo: do the same as the others?
      this._grammars["tiles"] = tilesNode
      // todo: do the below on demand? is this slow?
      this._combineWithTilesAndRegisterGrammar("fire", new fireNode().getGrammarProgram().toTreeNode())
      this._combineWithTilesAndRegisterGrammar("hakon", new hakonNode().getGrammarProgram().toTreeNode())
      this._combineWithTilesAndRegisterGrammar("stump", new stumpNode().getGrammarProgram().toTreeNode())
    }
    return this._grammars
  }

  _combineWithTilesAndRegisterGrammar(extension, grammarCode) {
    const rootNode = grammarCode.getNode(extension + "Node")
    rootNode.set("extends", "tilesNode")
    grammarCode
      .filter(node => node.getLine().endsWith("Node") && !node.has("extends"))
      .forEach(node => {
        // todo: probably a better way
        if (node.toString().includes("boolean isTileAttribute true")) node.set("extends", "abstractTileSettingTerminalNode")
        else node.set("extends", "abstractTileTreeComponentNode")
      })
    const grammarProgram = new jtree.GrammarProgram(
      new tilesNode()
        .getGrammarProgram()
        .toString()
        .trim() +
        "\n" +
        grammarCode.toString()
    )
    if (this.isNodeJs()) grammarProgram._setDirName(__dirname) // todo: hacky, remove
    this._grammars[extension] = grammarProgram.getRootConstructor()
  }

  getTargetNode() {
    return this._targetNode
  }

  setTargetNode(node) {
    this._targetNode = node
    return this
  }

  getVersion() {
    return Version
  }

  getDefinitionLoadingPromiseMap() {
    if (!this._loadingPromiseMap) this._loadingPromiseMap = new Map()
    return this._loadingPromiseMap
  }

  _startVisitCounter() {
    let visitCount = this._getVisitCount()

    visitCount++
    this.setVisitCount(visitCount)
  }

  setVisitCount(visitCount) {
    // exposed for unit testing
    this.storeValue(StorageKeys.visitCount, visitCount)
  }

  _getVisitCount() {
    const visitCountStr = this.getFromStore(StorageKeys.visitCount)
    return visitCountStr ? parseInt(visitCountStr) : 0
  }

  createParser() {
    const map = {}
    map[OhayoConstants.tileContextMenu] = TileContextMenuTreeComponent
    map[OhayoConstants.tabContextMenu] = TabContextMenuTreeComponent
    map[OhayoConstants.panel] = PanelTreeComponent
    map[OhayoConstants.menu] = MenuTreeComponent
    map[OhayoConstants.theme] = ThemeTreeComponent
    map[OhayoConstants.helpModal] = HelpModal
    map["TreeComponentFrameworkDebuggerComponent"] = TreeComponentFrameworkDebuggerComponent

    return new jtree.TreeNode.Parser(jtree.TreeNode, map)
  }

  toHakonCode() {
    const theme = this.getTheme()
    return `.OhayoWebApp
 height 100%
 width 100%
.OhayoError
 color ${theme.errorColor}`
  }

  isConnectedToOhayoServerApp() {
    return typeof isConnectedToOhayoServerApp !== "undefined"
  }

  isUrlGetProxyAvailable() {
    return this.isConnectedToOhayoServerApp()
  }

  goRed(err) {
    const tab = this.getMountedTab()
    const message = err ? err.reason || err : ""
    if (tab) tab.addStumpErrorMessageToLog(`Error: ${message}.`)
    else this.addStumpErrorMessageToLog(`Error on tab: ${tab ? tab.getFullTabFilePath() : ""}: ${message}`)
    this.renderApp()
  }

  _setErrorHandlers() {
    const that = this
    this.getWillowBrowser().setErrorHandler((message, file, line) => {
      that.goRed(message)
      console.error(message)
    })
  }

  closeModal() {
    this.getOpenModals().forEach(node => node.unmountAndDestroy())
  }

  getOpenModals() {
    return this.filter(node => node instanceof AbstractModalTreeComponent)
  }

  closeAllContextMenus() {
    this.filter(node => node instanceof AbstractContextMenuTreeComponent).forEach(node => node.unmountAndDestroy())
  }

  // todo: delete this
  makeAllDirty() {
    this.getTopDownArray()
      .filter(child => child instanceof AbstractTreeComponent)
      .forEach(child => {
        child._setLastRenderedTime(0)
      })
  }

  renderApp() {
    const report = this.renderAndGetRenderReport(this.getWillowBrowser().getBodyStumpNode())
    // console.log(report.toString())
    // console.log(this.toString())
  }

  _appendTiles(line, children) {
    return this.getNodeCursors().map(cursor => cursor.appendLineAndChildren(line, children))
  }

  getNodeCursors() {
    const tilesProgram = this.getMountedTilesProgram()
    const selectedNodes = tilesProgram.getSelectedNodes()
    return selectedNodes.length ? selectedNodes : [tilesProgram]
  }

  async _openOhayoProgram(name) {
    const panel = this.getFocusedPanel()
    const disk = this.getDefaultDisk()
    const fullPath = disk.getPathBase() + name
    const openTab = panel.getOpenTabByFullFilePath(fullPath)

    if (openTab) {
      panel.setMountedTab(openTab)
      return undefined
    }

    const fullDiskFilePath = new FullDiskPath(fullPath)

    const result = await disk.exists(fullDiskFilePath.getFilePath())
    if (result) return this.openFullPathInNewTabAndFocus(fullPath)

    return this._createAndOpen(new jtree.TreeNode(DemoTemplates).getNode(name).childrenToString(), name)
  }

  async createFileOnDefaultDisk(filename, sourceStr) {
    const disk = this.getDefaultDisk()
    const permalink = jtree.Utils.stringToPermalink(filename)
    const newName = await disk.getAvailablePermalink(permalink)

    await disk.writeFile(newName, sourceStr)
    return disk.getDisplayName() + newName
  }

  async _createAndOpen(sourceStr, filename) {
    const newName = await this.createFileOnDefaultDisk(filename, sourceStr)
    const res = await this.openFullPathInNewTabAndFocus(newName)
    return res
  }

  getFocusedPanel() {
    return this.getNode(OhayoConstants.panel)
  }

  getMountedTab() {
    return this.getFocusedPanel().getMountedTab()
  }

  getMountedTilesProgram() {
    const mountedTab = this.getMountedTab()
    return mountedTab && mountedTab.getTabProgram()
  }

  getMenuTreeComponent() {
    return this.getNode(OhayoConstants.menu)
  }

  async _openFullDiskFilePathInNewTab(fullDiskFilePath) {
    const res = await this.getFocusedPanel().getAlreadyOpenTabOrOpenFullFilePathInNewTab(new FullDiskPath(fullDiskFilePath).toString())
    return res
  }

  async openFullPathInNewTabAndFocus(fullDiskFilePath) {
    const tab = await this.getFocusedPanel().getAlreadyOpenTabOrOpenFullFilePathInNewTab(new FullDiskPath(fullDiskFilePath).toString(), true)
    return tab
  }

  isAutoSaveEnabled() {
    return this.getFromStore(StorageKeys.autoSave) !== "false"
  }

  getLanguageBestGuess(sourceCode) {
    const grammars = this.getGrammars()

    const getErrorCount = (extension, rootConstructor) => {
      const program = new rootConstructor(sourceCode)
      return {
        name: extension,
        errorCount: program.getAllErrors().length
      }
    }

    const guesses = lodash.sortBy(Object.keys(grammars).map(extension => getErrorCount(extension, grammars[extension])), ["errorCount"])
    const bestGuess = guesses[0].name
    return bestGuess
  }

  generateProgram(sourceCode, treeLanguage) {
    const programConstructor = this.getProgramConstructorFromFileExtension(treeLanguage)
    return new programConstructor(sourceCode)
  }

  getThemeName() {
    return this.get(OhayoConstants.theme)
  }

  isGlassTheme() {
    const name = this.getThemeName()
    return name === ThemeTreeComponent.ThemeConstants.glass || name === ThemeTreeComponent.ThemeConstants.clearGlass
  }

  getTheme() {
    return ThemeTreeComponent.Themes[this.getThemeName()] || ThemeTreeComponent.Themes.glass
  }

  _toggleTheme() {
    const newThemeName = jtree.Utils.toggle(this.getThemeName(), Object.keys(ThemeTreeComponent.Themes))
    this.addStumpCodeMessageToLog(`div Switched to ${newThemeName} theme`)
    this.set(OhayoConstants.theme, newThemeName)
    this.saveAppState()
    this.makeAllDirty() // todo:remove
    this.renderApp()
  }

  async promptToMoveFile(existingFullDiskFilePath, suggestedNewFilename, isRenameOp = false) {
    const path = new FullDiskPath(existingFullDiskFilePath)
    const suggestedFullDiskFilePath = suggestedNewFilename ? path.getWithoutFilename() + suggestedNewFilename : existingFullDiskFilePath

    let newFullDiskFilePath

    if (isRenameOp) {
      const newNameOnly = await this.getWillowBrowser().promptThen("Enter new name for file", suggestedNewFilename || path.getFilename())
      newFullDiskFilePath = newNameOnly ? path.getWithoutFilename() + newNameOnly : newNameOnly
    } else newFullDiskFilePath = await this.getWillowBrowser().promptThen("Enter new name for file", suggestedFullDiskFilePath || existingFullDiskFilePath)

    if (!newFullDiskFilePath || newFullDiskFilePath === existingFullDiskFilePath) return undefined

    newFullDiskFilePath = new FullDiskPath(newFullDiskFilePath)

    newFullDiskFilePath = newFullDiskFilePath.getWithoutFilename() + jtree.Utils.stringToPermalink(newFullDiskFilePath.getFilename())
    if (!newFullDiskFilePath) return undefined
    const resultingName = await this.moveFileCommand(existingFullDiskFilePath, newFullDiskFilePath)

    this.addStumpCodeMessageToLog(`div Moved`)
    return resultingName
  }

  getKeyboardShortcuts() {
    if (!this._shortcuts)
      this._shortcuts = new DrumsProgram(
        typeof OhayoDrums === "undefined" ? jtree.TreeNode.fromDisk(this._getProjectRootDir() + "ohayoWebApp/treeComponents/Ohayo.drums") : new jtree.TreeNode(OhayoDrums)
      )
    return this._shortcuts
  }

  _getMousetrap() {
    return this.getWillowBrowser().getMousetrap()
  }

  _bindKeyboardShortcuts() {
    const mouseTrap = this._getMousetrap()
    const willowBrowser = this.getWillowBrowser()

    mouseTrap._originalStopCallback = mouseTrap.prototype.stopCallback
    mouseTrap.prototype.stopCallback = function(evt, element, shortcut) {
      const stumpNode = willowBrowser.getStumpNodeFromElement(element)
      if (stumpNode && shortcut === "command+s" && stumpNode.stumpNodeHasClass("savable")) {
        stumpNode.getShadow().triggerShadowEvent("change")
        evt.preventDefault()
        return true
      }
      if (mouseTrap._pause) return true
      return mouseTrap._originalStopCallback.call(this, evt, element)
    }

    const app = this

    this.getKeyboardShortcuts().forEach(shortcut => {
      const keyCombo = shortcut.getKeyCombo()
      if (!keyCombo) return true
      mouseTrap.bind(keyCombo, function(evt) {
        shortcut.execute(app)
        // todo: handle the below when we need to
        if (evt.preventDefault) evt.preventDefault()
        return false
      })
    })
  }

  pauseShortcutListener() {
    this._getMousetrap()._pause = true
  }

  resumeShortcutListener() {
    this._getMousetrap()._pause = false
  }

  getStore() {
    return this.getWillowBrowser().getStore()
  }

  getUnusedStoreKey(key) {
    return jtree.Utils.getAvailablePermalink(key, key => this.getFromStore(key) !== undefined)
  }

  getStoreKeys() {
    const prefix = this.constructor.name
    const prefixLength = prefix.length
    const keys = []
    this.getStore().each((value, key) => {
      if (key.startsWith(prefix)) keys.push(key.substr(prefixLength))
    })
    return keys
  }

  dumpStore() {
    this.getStore().each((value, key) => {
      console.log(key)
    })
    return this
  }

  getStoreDiskUsage() {
    // todo: is there a way to do this?
    let bytes = 0
    this.getStore().each((value, key) => {
      bytes += value.toString().length + key.toString().length
    })
    return bytes / 5000000
  }

  getFromStore(key) {
    return this.getStore().get(this.constructor.name + key.toString())
  }

  storeValue(key, value) {
    // todo: handle quotaexceeded
    return this.getStore().set(this.constructor.name + key.toString(), value)
  }

  removeValue(key) {
    return this.getStore().remove(this.constructor.name + key.toString())
  }

  _makeDocumentCopyableAndCuttable() {
    const app = this
    this.getWillowBrowser()
      .setCopyHandler(evt => app.copySelectionCommand(evt))
      .setCutHandler(evt => app.cutSelectionCommand(evt))
  }

  _handleLinkClick(stumpNode, evt) {
    if (!stumpNode) return undefined
    const link = stumpNode.getStumpNodeAttr("href")
    if (!link || stumpNode.getStumpNodeAttr("target")) return undefined
    evt.preventDefault()
    if (this.getWillowBrowser().isExternalLink(link)) {
      this.openExternalLink(link)
      return false
    }
  }

  openExternalLink(link) {
    this.getWillowBrowser().openUrl(link)
  }

  getAppWall() {
    return this.getFocusedPanel()
      .getNode(OhayoConstants.tabs)
      .getWall()
  }

  // for tests
  getRenderedTilesDiagnostic() {
    return this.getMountedTilesProgram()
      .getTiles()
      .filter(tile => tile.isVisible() && tile.isMounted())
  }

  // for tests
  getMountedTilesDiagnostic() {
    return jtree.Utils.flatten(
      this.getFocusedPanel()
        .getNode(OhayoConstants.tabs)
        .getOpenTabs()
        .map(tab =>
          tab
            .getTabProgram()
            .getTiles()
            .filter(tile => tile.isMounted())
        )
    )
  }

  async _createProgramFromPaste(pastedText) {
    await this._createAndOpen(pastedText, `untitled${OhayoConstants.fileExtensions.maia}`) // todo: guess language!
  }

  // for tests and debugging
  // todo: only relevant for MaiaTiles with tables
  dumpTablesDiagnostic() {
    return this.getRenderedTilesDiagnostic().forEach(tile => {
      console.log(tile.getLine())
      console.log(tile.getOutputOrInputTable())
    })
  }

  getDisks() {
    if (!this._disks) this._mountDisks()
    return this._disks
  }

  writeFile(fullDiskFilePath, newVersion) {
    return new FileHandle(fullDiskFilePath, this).writeFile(newVersion)
  }

  readFile(fullDiskFilePath) {
    return new FileHandle(fullDiskFilePath, this).readFile()
  }

  unlinkFile(fullDiskFilePath) {
    return new FileHandle(fullDiskFilePath, this).unlinkFile()
  }

  async moveFile(existingFullDiskFilePath, newFullDiskFilePath) {
    const content = await this.readFile(existingFullDiskFilePath)
    // Todo: check to make sure we arent overwriting
    // Todo: check to make sure things worked before unlinking.
    await this.writeFile(newFullDiskFilePath, content)
    await this.unlinkFile(existingFullDiskFilePath)
    return newFullDiskFilePath
  }

  _mountDisks() {
    this._disks = {}
    const localDisk = new LocalStorageDisk(this)
    this._defaultDisk = localDisk
    this._disks[localDisk.getDisplayName()] = localDisk
    const addServerDisk = this.isNodeJs() ? false : this.isConnectedToOhayoServerApp()
    let serverDisk
    if (addServerDisk) {
      serverDisk = new ServerStorageDisk(this)
      this._disks[serverDisk.getDisplayName()] = serverDisk
    }

    const cwd = typeof DefaultServerCurrentWorkingDirectory === "undefined" ? "/" : DefaultServerCurrentWorkingDirectory
    const workingFolder = this.getFromStore(StorageKeys.workingFolderFullDiskFolderPath)
    if (workingFolder) this.setWorkingFolder(workingFolder)
    else this.setWorkingFolder(addServerDisk ? serverDisk.getDisplayName() + cwd : localDisk.getDisplayName() + "/")
  }

  setWorkingFolder(newWorkingFolder) {
    const path = new FullFolderPath(newWorkingFolder)
    this.setDefaultDisk(path.getDiskId())
    this.getDefaultDisk().setFolder(path.getFolderPath())

    this.storeValue(StorageKeys.workingFolderFullDiskFolderPath, newWorkingFolder)
  }

  getDefaultDisk() {
    const disks = this.getDisks()
    return this._defaultDisk
  }

  setDefaultDisk(id) {
    if (!this._disks[id]) throw new Error(`Disk ${id} not found.`)
    this._defaultDisk = this._disks[id]
    return this
  }

  // todo: remove this crap?
  _makeProgramLinksOpenImmediately() {
    const app = this
    const willowBrowser = this.getWillowBrowser()
    willowBrowser
      .getBodyStumpNode()
      .getShadow()
      .onShadowEvent("click", "a", function(evt) {
        app._handleLinkClick(willowBrowser.getStumpNodeFromElement(this), evt)
      })
  }

  _onCommandWillRun() {
    this.closeAllContextMenus() // todo: move these to a body handler?
    this.closeAllDropDownMenusCommand()
  }

  async _executeCommandByStumpNodeChild(commandName, stumpNodeChild) {
    const willowBrowser = this.getWillowBrowser()
    const stumpNode = willowBrowser.getBodyStumpNode().findStumpNodeByChild(stumpNodeChild)
    await this._executeCommandOnStumpNode(stumpNode, stumpNode.getStumpNodeAttr(commandName))
  }

  async _executeCommandByStumpNodeString(commandName, str) {
    const willowBrowser = this.getWillowBrowser()
    const stumpNode = willowBrowser.getBodyStumpNode().findStumpNodeByChildString(str)
    await this._executeCommandOnStumpNode(stumpNode, stumpNode.getStumpNodeAttr(commandName))
  }

  async playFirstVisitCommand() {
    // await this.openOhayoProgramCommand("faq.maia")
    // todo: make this create in memory?
    await this.openOhayoProgramCommand(OhayoConstants.productName + OhayoConstants.fileExtensions.maia)
  }

  copyTargetTileCommand(uno, dos) {
    return this.getTargetNode().copyTileCommand(uno, dos)
  }

  copyTargetTileDataAsTreeCommand(uno, dos) {
    return this.getTargetNode().copyDataAsTreeCommand(uno, dos)
  }

  copyTargetTileDataAsJavascriptCommand(uno, dos) {
    return this.getTargetNode().copyDataAsJavascriptCommand(uno, dos)
  }

  copyTargetTileDataCommand(uno, dos) {
    return this.getTargetNode().copyDataCommand(uno, dos)
  }

  exportTargetTileDataCommand(uno, dos) {
    return this.getTargetNode().exportTileDataCommand(uno, dos)
  }

  moveTilesFromShadowsCommand() {
    return this.getAppWall().moveTilesFromShadowsCommand()
  }

  async toggleLayoutCommand() {
    const wall = this.getAppWall()
    return wall.toggleLayoutCommand && wall.toggleLayoutCommand() // todo: cleanup
  }

  async togglePerfModeCommand() {
    const settings = this.getPerfSettings()
    Object.keys(settings).forEach(key => {
      settings[key] = !settings[key]
    })

    // todo: what is this?.. ah, codeMirror vs terminal should be different.
    this.getFocusedPanel().toggleGutter()
    this.getFocusedPanel().toggleGutter()
    this.renderApp()
  }

  async cellCheckProgramCommand() {
    const program = this.mountedTab.getTabProgram()
    const errors = program.getAllErrors().map(err => err.getMessage())
    this.mountedTab.addStumpCodeMessageToLog(
      `strong ${errors.length} errors in ${this.mountedTab.getFileName()}
div - ${errors.join("\ndiv - ")}`
    )
    this.renderApp()
  }

  async printProgramStatsCommand() {
    const stats = new jtree.TreeNode(this.mountedProgram.toRunTimeStats()).toString()
    this.mountedTab.logMessageText(stats)
    this.renderApp()
  }

  createProgramFromFileCommand(filename, data) {
    // todo: how do we handle multi-table-csv?
    // there are multiple types of CSVs.
    const extension = jtree.Utils.getFileExtension(filename)
    if (this.getGrammars()[extension]) return this._createAndOpen(data, filename)

    const templateFn = MaiaTemplates[extension]
    const program = templateFn ? templateFn(filename, data, this) : `html.h1 No visualization templates for ${filename}`
    return this._createAndOpen(program, filename + OhayoConstants.fileExtensions.maia)
  }

  async toggleShadowByIdCommand(id) {
    this.willowBrowser
      .getBodyStumpNode()
      .findStumpNodeByChild("id " + id)
      .getShadow()
      .toggleShadow()
  }

  async fillShadowInputOrTextAreaByClassNameCommand(className, value) {
    this.willowBrowser
      .getBodyStumpNode()
      .findStumpNodesWithClass(className)
      .forEach(stumpNode => {
        stumpNode.getShadow().setInputOrTextAreaValue(value)
      })
  }

  async openDeleteAllTabsPromptCommand() {
    const tabs = this.focusedPanel.getTabs()

    const shouldProceed = await this.willowBrowser.confirmThen(`Are you sure you want to delete ${tabs.length} open files?`)

    return shouldProceed ? Promise.all(tabs.map(tab => tab.unlinkTab())) : false
  }

  async toggleAndRenderNewDropDownCommand() {
    this.getNode(OhayoConstants.menu).toggleAndRender(OhayoConstants.newDropDownMenu)
  }

  async closeAllDropDownMenusCommand() {
    this.getTopDownArray().forEach(treeComponent => {
      if (treeComponent.getLine().includes(OhayoConstants.DropDownMenuSubstring)) treeComponent.unmountAndDestroy()
    })
  }

  async appendTileAndSelectCommand(line, children) {
    const tiles = this._appendTiles(line, children)
    tiles.forEach(tile => tile.execute())
    this.mountedProgram.clearSelection()
    await this.mountedProgram.getTab().autosaveAndRender()

    tiles.forEach(tile => tile.selectTile())
  }

  insertPickerTileCommand() {
    return this.getAppWall().insertPickerTileCommand()
  }

  insertAdjacentTileCommand() {
    return this.getAppWall().insertAdjacentTileCommand()
  }

  async appendTileCommand(line, children) {
    // Todo: we just removed race condition. But does UI suffer?
    await Promise.all(this._appendTiles(line, children).map(tile => tile.execute()))
    return this.mountedTab.autosaveAndRender()
  }

  async deleteAllRowsInTargetTileCommand() {
    const inputTable = this.getTargetNode().getParentOrDummyTable()
    await Promise.all(inputTable.getRows().map(row => row.destroyRow(this)))
    this.renderApp() // todo: cleanup
  }

  openOhayoProgramCommand(names) {
    return Promise.all(names.split(" ").map(name => this._openOhayoProgram(name)))
  }

  deleteFileCommand(filepath) {
    return this.unlinkFile(filepath)
  }

  async moveFileCommand(existingFullDiskFilePath, newFullDiskFilePath) {
    return this.moveFile(existingFullDiskFilePath, newFullDiskFilePath)
  }

  async createNewBlankProgramCommand(filename = "untitled" + OhayoConstants.fileExtensions.maia) {
    const tab = await this._createAndOpen("", filename)
    tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }

  async copyDeepLinkCommand() {
    this.getWillowBrowser().copyTextToClipboard(this.mountedTab.getDeepLink())
  }

  async createAndOpenNewProgramFromDeepLinkCommand(deepLink) {
    const uri = new URLSearchParams(new URL(deepLink).search)
    const fileName = decodeURIComponent(uri.get(OhayoConstants.deepLinks.filename))
    let sourceCode = decodeURIComponent(uri.get(OhayoConstants.deepLinks.data))
    if (uri.get(OhayoConstants.deepLinks.edgeSymbol)) sourceCode = sourceCode.replace(new RegExp(uri.get(OhayoConstants.deepLinks.edgeSymbol), "g"), " ")
    if (uri.get(OhayoConstants.deepLinks.nodeBreakSymbol)) sourceCode = sourceCode.replace(new RegExp(uri.get(OhayoConstants.deepLinks.nodeBreakSymbol), "g"), "\n")

    // todo: sec scan

    await this._createAndOpen(sourceCode, fileName)
    // Now remove the current page from history.
    // todo: cleanup by moving to willow
    if (typeof window !== "undefined") window.history.replaceState({}, document.title, location.pathname)
  }

  async openCreateNewProgramFromUrlDialogCommand() {
    const url = await this.willowBrowser.promptThen(`Enter the url to clone and edit`, "")

    if (!url) return undefined

    const res = await this.willowBrowser.httpGetUrl(url)

    const tab = await this._createAndOpen(res.text, "untitled" + OhayoConstants.fileExtensions.maia)
    tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }

  async openFolderPromptCommand() {
    const folder = await this.willowBrowser.promptThen(`Enter a folder path to open multiple files`, this.getDefaultDisk().getPathBase())
    return folder ? this.openFolderCommand(folder) : undefined
  }

  async changeWorkingFolderPromptCommand() {
    const current = this.getDefaultDisk().getPathBase()
    const newWorkingFolder = await this.willowBrowser.promptThen(`Enter a folder path`, current)
    if (!newWorkingFolder || current === newWorkingFolder) return undefined
    return this.changeWorkingFolderCommand(newWorkingFolder)
  }

  async changeWorkingFolderCommand(newWorkingFolder) {
    newWorkingFolder = newWorkingFolder.replace(/\/$/, "") + "/"
    this.setWorkingFolder(newWorkingFolder)
  }

  async openFullDiskFilePathPromptCommand(suggestion) {
    const fullPath = await this.willowBrowser.promptThen(`Enter a full path to open`, suggestion || this.getDefaultDisk().getPathBase())

    if (!fullPath) return undefined
    new FullDiskPath(fullPath)
    // Todo: what if it does not exist.
    return this.openFullPathInNewTabAndFocus(fullPath)
  }

  async openFolderCommand(fullFolderPath) {
    fullFolderPath = new FullFolderPath(fullFolderPath, this)
    const files = await fullFolderPath.getFiles()

    return Promise.all(files.map(file => this._openFullDiskFilePathInNewTab(file.getFileLink())))
  }

  async confirmAndResetAppStateCommand() {
    const result = await this.willowBrowser.confirmThen(`Are you sure you want to reset the Ohayo UI? Your files will not be lost.`)
    if (!result) return undefined
    this.resetAppState()
    this.willowBrowser.reload()
  }

  openUrlInNewTabCommand(url) {
    return this._openFullDiskFilePathInNewTab(new FullDiskPath(url).toString())
  }

  async mountTabByIndexCommand(index) {
    this.focusedPanel.mountTabByIndex(index)
  }

  async closeTabByIndexCommand(index) {
    this.focusedPanel.closeTabByIndex(index)
    this.renderApp()
  }

  async toggleAutoSaveCommand() {
    const newSetting = !this.isAutoSaveEnabled()
    if (!newSetting) this.storeValue(StorageKeys.autoSave, "false")
    else this.removeValue(StorageKeys.autoSave)
    this.addStumpCodeMessageToLog(`div Autosave is ${newSetting}`)
  }

  async saveCompiledCommand() {
    const grammarProgram = this.mountedProgram.getGrammarProgram()
    const outputExtension = grammarProgram.getTargetExtension()
    const filename = jtree.Utils.stringToPermalink(jtree.Utils.removeFileExtension(this.mountedTab.getFileName())) + "." + outputExtension
    this.willowBrowser.downloadFile(this.mountedProgram.compile(), filename, "text/" + outputExtension)
  }

  async executeProgramCommand() {
    // todo: sec considerations? prevent someone from triggering this command w/o user input.
    let result = await this.mountedTab.getTabProgram().execute()
    if (typeof result !== "string") result = result.join("\n")
    this.mountedTab.logMessageText(encodeURIComponent(result))
    this.renderApp()
  }

  get focusedPanel() {
    return this.getFocusedPanel()
  }

  get willowBrowser() {
    return this.getWillowBrowser()
  }

  get mountedProgram() {
    return this.getMountedTilesProgram()
  }

  get mountedTab() {
    return this.getMountedTab()
  }

  async toggleThemeCommand() {
    this._toggleTheme()
  }

  openFullPathInNewTabAndFocusCommand(url) {
    return this.openFullPathInNewTabAndFocus(url)
  }

  async _showTabMoveFilePromptCommand(suggestedNewFilename, isRenameOp = false) {
    const mountedTab = this.mountedTab

    const newName = await this.promptToMoveFile(mountedTab.getFullTabFilePath(), suggestedNewFilename, isRenameOp)
    if (!newName) return false
    await this.focusedPanel.closeTab(mountedTab)
    const tab = await this.openFullPathInNewTabAndFocus(newName)
    this.renderApp()
  }

  async showTabMoveFilePromptCommand(suggestedNewFilename) {
    await this._showTabMoveFilePromptCommand(suggestedNewFilename)
  }

  async showTabRenameFilePromptCommand(suggestedNewFilename) {
    await this._showTabMoveFilePromptCommand(suggestedNewFilename, true)
  }

  async toggleOfflineModeCommand() {
    this.willowBrowser.toggleOfflineMode()
  }

  async sleepCommand(ms = 1000) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  async toggleHelpCommand() {
    this.toggleAndRender(OhayoConstants.helpModal)
  }

  async closeMountedProgramCommand() {
    this.focusedPanel.closeTab(this.mountedTab)
    this.renderApp()
  }

  fetchAndReloadFocusedTabCommand() {
    return this.mountedTab.reloadFromDisk()
  }

  async selectAllTilesCommand() {
    // todo: bug. they are not showing selected state.
    this.mountedProgram.getTiles().forEach(tile => tile.selectTile())
  }

  async selectTilesByShadowClassCommand(className) {
    this.addToCommandLog("app selectTilesByShadowClassCommand") // todo: what is this?
    this.mountedTab.getTabWall().selectTilesByShadowClass(className)
  }

  async clearSelectionCommand() {
    this.addToCommandLog("app clearSelectionCommand") // todo: what is this?
    this.mountedProgram.clearSelection()
  }

  async deleteSelectionCommand() {
    this._deleteSelection()
    await this.mountedProgram.getTab().autosaveAndRender()
    // Todo: need to reposition all tiles if not using a custom layout
    // todo: makes me think we should put css top/left/width/height separately from css and stump (so mount 3 things)
  }

  _deleteSelection() {
    const tiles = this.mountedProgram.getSelectedNodes()
    if (!tiles.length) return undefined
    tiles.forEach(tile => {
      // New behavior is: shift children left 1. Dont delete them along with parent.
      tile
        .filter(tile => tile.doesExtend("abstractTileTreeComponentNode") && !tile.isSelected())
        .forEach(child => {
          child.unmount()
          child.shiftLeft()
        })
      tile.unmountAndDestroy()
    })
  }

  async duplicateSelectionCommand() {
    const newTiles = this.mountedProgram.getSelectedNodes().map(tile => tile.cloneAndOffset())
    await this.renderApp()
    this.mountedProgram.clearSelection()
    newTiles.forEach(tile => tile.selectTile())
    await this.mountedProgram.getTab().autosaveAndRender()
  }

  async showDeleteFileConfirmDialogCommand() {
    const filename = this.mountedTab.getFileName()
    // todo: make this an undo operation. on web should be easyish. on desktop via move to trash.
    const result = await this.willowBrowser.confirmThen(`Are you sure you want to delete ${filename}?`)
    return result ? this.deleteFocusedTabCommand() : undefined
  }

  async deleteFocusedTabCommand() {
    const tab = this.mountedTab
    await tab.unlinkTab()

    this.focusedPanel.closeTab(tab)
    this.renderApp()
  }

  async mountPreviousTabCommand() {
    this.focusedPanel.mountPreviousTab()
  }

  async mountNextTabCommand() {
    this.focusedPanel.mountNextTab()
  }

  async closeAllTabsCommand() {
    this.focusedPanel.closeAllTabs() // todo: confirm before closing if unsaved changes?
    this.renderApp()
  }

  async closeAllTabsExceptFocusedTabCommand() {
    this.focusedPanel.closeAllTabsExceptFocusedTab() // todo: confirm before closing if unsaved changes?
    this.renderApp()
  }

  async toggleFullScreenCommand() {
    this.willowBrowser.toggleFullScreen()
  }

  toggleFocusedModeCommand() {
    this.toggle(OhayoConstants.menu)
    return this.toggleFullScreenCommand()
  }

  // TODO: make it slidable.?
  async toggleGutterWidthCommand() {
    this.focusedPanel.toggleGutterWidth()
    this.renderApp()
  }

  async toggleGutterCommand() {
    this.getFocusedPanel().toggleGutter()
    this.renderApp()
  }

  async selectNextTileCommand() {
    this._selectTileByDelta(1)
  }

  _selectTileByDelta(delta) {
    const program = this.mountedProgram
    const arr = program.getTiles()
    if (arr.length < 2) return true
    let currentIndex = arr.indexOf(program.getSelectedNodes()[0])
    const potentialNewIndex = currentIndex + delta
    program.clearSelection()
    arr[potentialNewIndex > arr.length - 1 ? 0 : potentialNewIndex === -1 ? arr.length - 1 : potentialNewIndex].selectTile()
  }

  async selectFirstTileCommand() {
    const firstTile = this.mountedProgram.getTiles()[0]
    firstTile && firstTile.selectTile()
  }

  async selectPreviousTileCommand() {
    this._selectTileByDelta(-1)
  }

  async createNewSourceCodeVisualizationProgramCommand() {
    // todo: make this create in memory? but then a refresh will end it.
    const sourceCode = this.mountedProgram.childrenToString()
    const template = MaiaCodeEditorTemplate(sourceCode, this.mountedTab.getFileName(), OhayoConstants.fileExtensions.maia.substr(1))
    const tab = await this._createAndOpen(template, this.mountedTab.getFileName() + "-source-code-vis.maia")

    tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }

  async createMiniMapCommand() {
    // todo: make this create in memory? but then a refresh will end it.
    const tab = await this._createAndOpen(MiniTemplate, "myPrograms" + OhayoConstants.fileExtensions.maia)

    tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }

  async clearTabMessagesCommand() {
    await this.mountedTab.clearMessageBufferCommand()

    this.renderApp()
  }

  async undoFocusedProgramCommand() {
    return this._undoOrRedo()
  }

  async redoFocusedProgramCommand() {
    return this._undoOrRedo(false)
  }

  async _undoOrRedo(undo = true) {
    this.mountedTab.getTabWall().unmount()
    undo ? this.mountedProgram.undo() : this.mountedProgram.redo()
    await this.mountedProgram.loadAndIncrementalRender()
  }

  async closeModalCommand() {
    this.closeModal()
  }

  async clearStoreCommand() {
    // todo: only clear this app values?
    return this.getStore().disabled ? undefined : this.getStore().clearAll()
  }

  async copySelectionCommand(evt) {
    if (!this.mountedProgram) return true

    const str = this._copySelection(evt)
    if (!str) return undefined
    this.mountedProgram.getRootNode().addStumpCodeMessageToLog(`div Items copied`)
    return str
  }

  async cutSelectionCommand(evt) {
    const str = this._copySelection(evt)
    if (!str) return undefined
    this._deleteSelection()
    this.mountedProgram.getRootNode().addStumpCodeMessageToLog(`div Items cut`)
    await this.mountedProgram.getTab().autosaveAndRender()
  }

  _copySelection(evt) {
    const willowBrowser = this.getWillowBrowser()
    if (this.terminalHasFocus() || willowBrowser.someInputHasFocus()) return ""
    // copy selected tiles
    const str = this.mountedProgram.selectionToString()
    if (!str) return ""
    willowBrowser.setCopyData(evt, str)
    return str
  }

  async echoCommand(...words) {
    this.addStumpCodeMessageToLog(`div ${words.join(" ")}`)
  }

  async saveTabAndNotifyCommand() {
    const tab = this.mountedTab
    await tab.forceSaveToFile()
    tab.addStumpCodeMessageToLog(`div Saved ${tab.getFileName()}
 title Saved ${tab.getFullTabFilePath()}`)
    this.renderApp()
  }

  cloneTabCommand() {
    return this._createAndOpen(this.mountedTab.getTabProgram().childrenToString(), this.mountedTab.getFileName())
  }

  async pasteCommand(pastedText) {
    if (this.mountedTab) await this.mountedTab.appendFromPaste(pastedText)
    else await this._createProgramFromPaste(pastedText)
  }

  async executeCommandOnStumpWithIdCommand(commandName, stumpNodeId) {
    await this._executeCommandByStumpNodeChild(commandName, "id " + stumpNodeId)
  }

  async executeCommandOnStumpWithClassCommand(commandName, stumpNodeClass) {
    await this._executeCommandByStumpNodeChild(commandName, "class " + stumpNodeClass)
  }

  async executeCommandByStumpNodeStringCommand(commandName, str) {
    await this._executeCommandByStumpNodeString(commandName, str)
  }

  async executeCommandOnFirstSelectedTileCommand(command, valueParam, nameParam) {
    const tile = this.mountedProgram.getSelectedNodes()[0]
    return tile[command](valueParam, nameParam)
  }

  async executeCommandOnLastSelectedTileCommand(command, valueParam, nameParam) {
    const tile = this.mountedProgram.getSelectedNodes()[this.mountedProgram.getSelectedNodes().length - 1]
    return tile[command](valueParam, nameParam)
  }

  async _doTileQualityCheckCommand() {
    // Note: currently required a mountedProgram
    const grammarProgram = this.mountedProgram.getGrammarProgram()
    const topNodeTypes = grammarProgram.getTopNodeTypeDefinitions().map(def => def.get("crux"))

    const sourceCode = topNodeTypes.join("\n") + `\n${TilesConstants.layout} ${TilesConstants.layouts.column}`
    const tab = await this._createAndOpen(sourceCode, "all-tiles" + OhayoConstants.fileExtensions.maia)
    const data = tab
      .getTabProgram()
      .getTiles()
      .filter(tile => tile.getTileQualityCheck) // only check Maia tiles
      .map(tile => tile.getTileQualityCheck())

    tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
    const sourceCode2 = new jtree.TreeNode(`data.inline
 tables.basic Quality Check Results`)
    sourceCode2.getNode("data.inline").appendLineAndChildren("content", new jtree.TreeNode(data).toCsv())
    const tab2 = await this._createAndOpen(sourceCode2.toString(), "tiles-quality-check-results" + OhayoConstants.fileExtensions.maia)

    tab2.addStumpCodeMessageToLog(`div Created '${tab2.getFullTabFilePath()}'`)
  }

  async _runSpeedTestCommand() {
    const files = await this.getDefaultDisk().readFiles()
    const startTime = Date.now()
    const focusedPanel = this.focusedPanel

    const timePromises = files.map(async file => {
      const url = file.getFileLink()
      const newTab = await this._openFullDiskFilePathInNewTab(url)
      const mountedTab = focusedPanel.getMountedTab()
      focusedPanel.setMountedTab(newTab)
      if (mountedTab) focusedPanel.closeTab(mountedTab)
      this.renderApp()
      return newTab.getTabProgram().toRunTimeStats()
    })

    const times = await Promise.all(timePromises)
    // todo: trigger shift+w shortcut instead of this if clause.
    if (focusedPanel.getMountedTab()) this.closeMountedProgramCommand()
    const rowsAsCsv = new jtree.TreeNode(times)
    const runTime = Date.now() - startTime
    const title = `Program Load Times ${moment().format("MM/DD/YYYY")} version ${this.getVersion()}. Run time: ${runTime}`
    return this._createAndOpen(SpeedTestTemplate(title, rowsAsCsv.toCsv()), "program-load-times" + OhayoConstants.fileExtensions.maia)
  }
}

window.OhayoWebApp
 = OhayoWebApp
