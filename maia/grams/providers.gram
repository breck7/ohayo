tooling onsave jtree build produceMaiaGrammar
abstractProviderNode
 string tileSize 140 60
 extends abstractMaiaTileNode
 abstract
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div
    class TileBody HeaderLess
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  getTileFooterStumpCode() {
   const table = this.getOutputOrInputTable()
   const time = (this.getTimeToLoad() / 1000).toFixed(1)
   const parserId = this.getParserId()
   return `${this.getTileToolbarButtonStumpCode()}
  span Rows Out: ${table.getRowCount()} Columns Out: ${table.getColumnCount()} Time: ${time}s Parser: ${parserId || "?"}${this.getErrorMessageHtml()}`
  }
  getRowClass() {
   return Row
  }
  getTileBodyStumpCode() {
   const description = this.getDefinition().get("description")
   return "div " + (description ? jtree.Utils.linkify(description) : "")
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, {classes:this.getCssClassNames().join(" "), id : this.getTreeComponentId(), body: this._getBodyStumpCodeCache(), footer : this.getTileFooterStumpCode()})
  }
  getParserId() {
   return this.getSettingsStruct().parser
  }
  async fetchTableInputs() {
   return {
    rows: []
   }
  }
  async _execute() {
   const timeLoadStarted = this._getProcessTimeInMilliseconds()
   this._timeLastLoadStarted = timeLoadStarted
   const fetchedTableInputs = await this.fetchTableInputs()
   // If a new request happened after this one, abort this one.
   // todo: what happens to children?
   // todo: add testing for this.
   if (this._timeLastLoadStarted !== timeLoadStarted) {
    console.log("superceded")
    return null
   }
   this._outputTable = new Table(fetchedTableInputs.rows, fetchedTableInputs.columnDefinitions, this.getRowClass())
   this._timeToLoad = this._getProcessTimeInMilliseconds() - timeLoadStarted
   this.setIsDataLoaded(true)
   await this._executeChildNodes()
  }
useCacheNode
 cells tileSettingKeywordCell booleanCell
 extends abstractTileSettingTerminalNode
 crux useCache
abstractUrlNoCellsNode
 boolean useCache true
 inScope parserNode useCacheNode
 string tileSize 300 150
 extends abstractProviderNode
 abstract
 javascript
  getUrl() {
   const struct = Object.assign(this.getSettingsStruct(), this.getDefinition().getConstantsObject())
   if (struct.urlTemplate && this.getContent()) return new jtree.TreeNode({ content: this.getContent() }).evalTemplateString(struct.urlTemplate)
   if (struct.urlPrefix && this.getContent()) return struct.urlPrefix + this.getContent()
   return struct.urlCell || this.getContent() || this.url || ""
  }
  getParserId() {
   const url = this.getUrl()
   if (super.getParserId()) return super.getParserId()
   const extension = jtree.Utils.getFileExtension(url)
   if (new TableParser().getAllTableParserIds().includes(extension)) return extension
  }
  getWillowHttpResponse() {
   return this._willowHttpResponse
  }
  _setWillowHttpResponse(willowHttpResponse) {
   this._willowHttpResponse = willowHttpResponse
   return this
  }
  // todo: add support for Arrow.
  // todo: remove this cache. use higher level.
  async _getData(url) {
   const useCache = this.getSettingsStruct().useCache !== "false" || this.useCache
   const willowBrowser = this.getWebApp().getWillowBrowser()
   let response
   if (useCache) response = await willowBrowser.httpGetUrlFromCache(url)
   else response = await willowBrowser.httpGetUrl(url)
   if (response.fromCache)
    this.emitLogMessage(`div
  bern
   Loading from cache: ${url}`)
   this._setWillowHttpResponse(response)
   return response.getParsedDataOrText()
  }
  async fetchTableInputs() {
   let url = this.getUrl()
   if (!url) return { rows: [] }
   url = encodeURI(url)
   const parserId = this.getParserId()
   this.setRunTimePhaseError("fetchUrl")
   try {
    const data = await this._getData(url)
    const parser = new TableParser()
    return typeof data === "string" ? parser.parseTableInputsFromString(data, parserId) : parser.parseTableInputsFromObject(data, parserId)
   } catch (err) {
    // todo: solve the superagent not throwing response message thing.
    const txt = (err.text || err.toString()).substr(0, 280)
    this.emitLogMessage(`Error getting url: ${url}<br>
   ${txt}`)
    this.setRunTimePhaseError("fetchUrl", txt)
    return { rows: [] }
   }
  }
abstractUrlNode
 cells tileKeywordCell urlCell
 string tileSize 300 100
 extends abstractUrlNoCellsNode
 abstract
abstractFixedDatasetFromUrlNode
 description A dataset that generally is fixed and will never change.
 extends abstractUrlNoCellsNode
 abstract
abstractDummyNode
 javascript
  async _execute() {
   this.setIsDataLoaded(true)
   await this._executeChildNodes()
  }
 string tileSize 300 150
 extends abstractProviderNode
 abstract
abstractFixedDatasetFromMaiaCollectionNode
 description A dataset that ships with Ohayo.
 string tileSize 300 150
 javascript
  async _getData(url) {
   if (!this.isNodeJs()) return super._getData(url)
   const fs = require("fs")
   const filepath = __dirname + "/../" + url
   return fs.readFileSync(filepath, "utf8")
  }
 extends abstractFixedDatasetFromUrlNode
 abstract