tooling onsave jtree build produceTilesGrammar
tileNameCell
 highlightScope variable.function
abstractTileTreeComponentNode
 abstract
 cells tileNameCell
 _extendsJsClass AbstractTreeComponent
 inScope hashBangNode abstractTileTreeComponentNode abstractCoreTileSettingTerminalNode commentNode
 catchAllNodeType catchAllErrorNode
 int headerHeight 30
 int footerHeight 30
 string hiddenKey hidden
 string visibleKey visible
 string pencilStumpTemplate
  span {icon}
   class TilePencilButton
   clickCommand toggleToolbarCommand
 string inspectionStumpTemplate
  div TileConstructor: {constructorName} ParentConstructor: {parentConstructorName}
  div Messages:
  ol
   {messages}
  div Tree:
  pre
   bern
    {sourceCode}
  div All Tile Settings:
  pre
   bern
    {settings}
 string errorStateStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div ERROR
    class TileHeader
   div
    class TileBody
    {content}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div {header}
    class TileHeader
   div
    style {bodyStyle}
    class TileBody
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  getProgramTemplate(id) {}
  getSnippetTemplate(id) {}
  getExampleTemplate(index) {
   // todo: right now we only have 1 example per tile.
   const exampleNode = this.getDefinition().getNode(jtree.GrammarConstants.example)
   return exampleNode ? exampleNode.childrenToString() : ""
  }
  emitLogMessage(message) {
   const tab = this.getTab()
   if (tab) tab.addStumpCodeMessageToLog(message)
   else if (this.isNodeJs()) console.log(message)
  }
  getTheme() {
   return this.getTab().getTheme()
  }
  qFormat(str, obj) {
    return new jtree.TreeNode(str).templateToString(obj)
  }
  scrollIntoView() {
   const el = this.getStumpNode()
    .getShadow()
    .getShadowElement()
   if (el) el.scrollIntoView()
  }
  async loadRequirements() {
   const loadingMap = this.getTab()
    .getRootNode()
    .getDefinitionLoadingPromiseMap()
   if (!loadingMap.has(this.constructor)) loadingMap.set(this.constructor, this._makeLoadRequirementsPromise(loadingMap))
   await loadingMap.get(this.constructor)
  }
  async _makeLoadRequirementsPromise(loadingMap) {
   const app = this.getWebApp()
   const cssScript = this[TilesConstants.tileCssScript]
   if (cssScript) this._loadTileCss(cssScript)
   const scriptPath = this[TilesConstants.tileScript]
   if (scriptPath) await app.getWillowBrowser().appendScript(scriptPath)
   loadingMap.set(this.constructor, true)
  }
  _loadTileCss(css) {
   const app = this.getWebApp()
   app
    .getWillowBrowser()
    .getBodyStumpNode()
    .insertChildNode(
     css
      .split(" ")
      .map(
       url => `link
   rel stylesheet
   media screen
   href ${url}`
      )
      .join("\n")
    )
  }
  _hasRequirements() {
   return this.tileScript
  }
  _areRequirementsLoaded() {
   const loadingMap = this.getTab()
    .getRootNode()
    .getDefinitionLoadingPromiseMap()
   return !this._hasRequirements() || loadingMap.get(this.constructor) === true
  }
  isLoaded() {
   return this._areRequirementsLoaded()
  }
  getErrorMessageHtml() {
   const errors = Object.values(this.getRunTimePhaseErrors())
   return errors.length ? ` <span style="color: ${this.getTheme().errorColor};">${errors.join(" ")}</span>` : "" //todo: cleanup
  }
  toStumpErrorStateCode(err) {
   return this.qFormat(this.errorStateStumpTemplate, {classes: this.getCssClassNames().join(" "), id: this.getTreeComponentId(), content: `div ` +  err, footer: this.getTileToolbarButtonStumpCode()})
  }
  // todo: delete this
  makeDirty() {
   delete this._cache_settingsObject
   delete this._bodyStumpCodeCache // todo: cleanup
   this._setLastRenderedTime(0)
  }
  toggleToolbar() {
   if (!this._tileToolbar) {
    const TileToolbarTreeComponent = this.require("TileToolbarTreeComponent", this._getProjectRootDir() + "ohayoWebApp/treeComponents/TileToolbarTreeComponent.js")
    this._tileToolbar = new TileToolbarTreeComponent("", undefined, this)
    this._tileToolbar.renderAndGetRenderReport(this.getStumpNode())
   } else this._tileToolbar = this._tileToolbar.unmount()
  }
  getAllTileSettingsDefinitions() {
   const def = this.getDefinition()
   return Object.values(def.getFirstWordMapWithDefinitions()).filter(def => def.isOrExtendsANodeTypeInScope([TilesConstants.abstractTileSetting]))
  }
  getTab() {
   return this.getRootNode().getTab()
  }
  getChildTiles() {
   return this.getChildInstancesOfNodeTypeId("abstractTileTreeComponentNode")
  }
  selectTile() {
   this.selectNode()
   if (this.isMounted()) this.getStumpNode().addClassToStumpNode(TilesConstants.selectedClass)
  }
  unselectNode() {
   super.unselectNode()
   if (this.isMounted()) this.getStumpNode().removeClassFromStumpNode(TilesConstants.selectedClass)
  }
  getCssClassNames() {
   const classNames = super.getCssClassNames()
   if (this._isMaximized()) classNames.push("TileMaximized")
   return classNames
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, {classes: this.getCssClassNames().join(" "), id: this.getTreeComponentId(), header: this.getTileHeaderBern(), bodyStyle: this.customBodyStyle || "", body: this._getBodyStumpCodeCache() || "", footer: this.getTileFooterStumpCode()})
  }
  _getBodyStumpCodeCache() {
   if (!this._bodyStumpCodeCache) this._bodyStumpCodeCache = this.getTileBodyStumpCode()
   return this._bodyStumpCodeCache
  }
  getTileHeaderBern() {
   return `${this.getFirstWord()}`
  }
  cloneAndOffset() {
   const clone = this.duplicate()
   const left = this.getLeft()
   const _top = this.getTop()
   if (left) clone.touchNode(TilesConstants.left).setContent(parseInt(left) + 1)
   if (_top) clone.touchNode(TilesConstants.top).setContent(parseInt(_top) + 1)
   return clone
  }
  getTileBodyStumpCode() {
   return ``
  }
  _getCss() {
   const selector = "#" + this.getTreeComponentId()
   const theme = this.getTheme()
   const visibleCss = this.isVisible() ? "" : "display: none"
   const dimensions = this.getTileDimensionIfAny()
   const dimensionCss = dimensions ? dimensions.toCss() : ""
   const hakonCode = this.hakonTemplate ? new jtree.TreeNode(theme).evalTemplateString(this.hakonTemplate) : this.toHakonCode()
   return `${selector} { ${visibleCss} ${dimensionCss} }
        ${theme.hakonToCss(hakonCode)}`
  }
  getContextMenuStumpCode() {
   return ""
  }
  handleTileError(err) {
   if (!this._errorCount) this._errorCount = 0
   this._errorCount++
   this.getRootNode().goRed(err)
  }
  getWall() {
   return this.getWebApp().getAppWall()
  }
  getWebApp() {
   return this.getTab().getRootNode()
  }
  getTileDimensionIfAny() {
   const dimensions = this.getWall().getWallViewPortDimensions()
   return this.getRootNode()
    .getTileDimensionMap(dimensions.width, dimensions.height)
    .get(this)
  }
  getTileBodyDimension() {
   const dimension = this.getTileDimensionIfAny()
   dimension.height = dimension.height - this.headerHeight - this.footerHeight
   return dimension
  }
  getDependencies() {
   return []
  }
  async runAndrenderAndGetRenderReport() {
   await this.execute()
   return this.renderAndGetRenderReport()
  }
  getTimeToLoad() {
   return this._timeToLoad || 0
  }
  toHakonCode() {
   return ""
  }
  getTileFooterStumpCode() {
   return this.getTileToolbarButtonStumpCode()
  }
  getTileToolbarButtonStumpCode() {
   return this.qFormat(this.pencilStumpTemplate, {icon: Icons("pencil", 16)})
  }
  getDefinedOrSuggestedSize() {
   const size = this.getSuggestedSize()
   const width = this.getWidth()
   const height = this.getHeight()
   return {
    width: width ? width * 20 : size.width,
    height: height ? height * 20 : size.height
   }
  }
  getSuggestedSize() {
   const tileSize = this.tileSize || "280 220"
   const parts = tileSize.split(" ").map(tileSize => parseInt(tileSize))
   return {
    width: parts[0],
    height: parts[1]
   }
  }
  getRequiredDimensionsForTreeLayout(padding = 0) {
   const size = {
    width: 0,
    height: 0
   }
   const children = this.getChildTiles()
   const suggestedSize = this.getDefinedOrSuggestedSize()
   children.forEach(child => {
    const childSize = child.getRequiredDimensionsForTreeLayout(padding)
    size.width += childSize.width
    size.height = childSize.height > size.height ? childSize.height : size.height
   })
   size.width += children.length * padding
   size.width = Math.max(size.width, suggestedSize.width)
   size.height = suggestedSize.height + (children.length ? padding + size.height : 0)
   return size
  }
  getLeft() {
   return this.get(TilesConstants.left)
  }
  getTop() {
   return this.get(TilesConstants.top)
  }
  getWidth() {
   return this.get(TilesConstants.width)
  }
  getHeight() {
   return this.get(TilesConstants.height)
  }
  // Tile child rendering is done at the wall flex level.
  _getChildTreeComponents() {
   return []
  }
  getStumpNodeForChildren() {
   // We render all Tiles on the Wall.
   return this.getStumpNode().getParent()
  }
  async treeComponentDidMount() {
   super.treeComponentDidMount()
   if (this._tileToolbar) this._tileToolbar.renderAndGetRenderReport()
  }
  toInspectionStumpCode() {
   const messages = this.getMessageBuffer().map(message => `li ${moment(message.getLineModifiedTime()).fromNow()} - ${message.childrenToString()}`)
   const settingsDefinitions = this.getAllTileSettingsDefinitions()
    .map(setting => `${setting.getFirstWord()} ${setting.getDescription()}`)
    .join("\n")
   const parentConstructorName = this.getParent().constructor.name
   const constructorName = this.constructor.name
   const sourceCode = this.toString()
   const settings = settingsDefinitions
   return this.qFormat(this.inspectionStumpTemplate, {
    constructorName,
    parentConstructorName,
    sourceCode,
    messages,
    settings
    })
  }
  isVisible() {
   return this.has(this.visibleKey) || this.getRootNode().tilesAreVisible() && !this.has(this.hiddenKey)
  }
  _isMaximized() {
   return this.has(TilesConstants.maximized)
  }
  async _executeChildNodes() {
   await this._runChildTiles()
  }
  async _runChildTiles() {
   await Promise.all(this.getChildTiles().map(tile => tile.execute()))
  }
  async execute() {
   try {
    this.setRunTimePhaseError("execute")
    await this._executeChildNodes()
   } catch (err) {
    this.setRunTimePhaseError("execute", err)
    console.error(err)
    const theme = this.getTheme()
    this.emitLogMessage(`div
     bern
      Error occurred. See console.
     style color: ${theme.errorColor};`)
   }
   return this
  }
  cloneTileCommand() {
    this.cloneAndOffset()
    return this.getTab().autosaveAndRender()
  }
  async toggleTileMaximizeCommand() {
    if (this.has(TilesConstants.maximized)) this.delete(TilesConstants.maximized)
    else this.touchNode(TilesConstants.maximized)
    await this._runAfterTileUpdate(this)
  }
  async triggerTileMethodCommand(value, methodName) {
    await this[methodName](value)
    await this._runAfterTileUpdate(tile)
  }
  // todo: refactor.
  async changeTileTypeCommand(newValue) {
    this.setFirstWord(newValue)
    const newNode = this.duplicate()
    // todo: destroy or something? how do we reparse.
    this.unmountAndDestroy()
    const app = this.getTab().getRootNode()
    await this.getRootNode().loadRequirements()
    await this.getTab().autosaveAndRender()
    newNode.runAndrenderAndGetRenderReport()
  }
  changeParentCommand(pathVector) {
    // if (tile.getFirstWordPath() === value) return; // todo: do we need this line?
    const program = this.getRootNode()
    const indexPath = pathVector ? pathVector.split(" ").map(num => parseInt(num)) : ""
    const destinationTree = indexPath ? program.nodeAt(indexPath) : program
    // todo: on jtree should we make copyTo second param optional?
    this.copyTo(destinationTree, destinationTree.length)
    this.unmountAndDestroy()
    return this.getTab().autosaveAndRender()
  }
  async openTileContextMenuCommand() {
    this
      .getTab()
      .getRootNode()
      .setTargetNode(this)
      .toggleAndRender(OhayoConstants.tileContextMenu)
  }
  destroyTileCommand() {
    this.unmountAndDestroy()
    return this.getTab().autosaveAndRender()
  }
  getNewDataCommand() {
    // todo: have some type of paging system to fetch new data.
  }
  async changeTileSettingAndRenderCommand(value, settingName) {
    // note the unusual ordering of params.
    this.touchNode(settingName).setContent(value.toString())
    // todo: sometimes size needs to be redone (maximize, for example)
    await this._runAfterTileUpdate(this)
  }
  // todo: remove
  async changeTileSettingMultilineCommand(val, settingName) {
    this.touchNode(settingName).setChildren(val)
    await this._runAfterTileUpdate(this)
  }
  async changeTileSettingCommand(settingName, value) {
    this.touchNode(settingName).setContent(value)
  }
  async changeWordAndRenderCommand(value, index) {
    this.setWord(parseInt(index), value)
    await this._runAfterTileUpdate(this)
  }
  async changeWordsAndRenderCommand(value, index) {
    index = parseInt(index)
    const edgeSymbol = this.getEdgeSymbol()
    const words = this.getWords().slice(0, index)
    this.setLine(words.concat(value.split(edgeSymbol)).join(edgeSymbol))
    await this._runAfterTileUpdate(this)
  }
  async updateChildrenCommand(val) {
    this.setChildren(val)
    // reload the whole doc for now.
    await this._runAfterTileUpdate(this)
  }
  async _runAfterTileUpdate(tile) {
    tile.makeDirty() // ugly!
    tile.getChildTiles().forEach(tile => {
      tile.makeDirty() // todo: ugly!
    })
    // todo: what if you have a tile that has a contextare that allows editing of its children/
    // if you edit a child, then that parent tile needs to update to...should we allow that or ban that?
    await tile.getTab().autosaveTab()
    await tile.runAndrenderAndGetRenderReport()
    tile
      .getTab()
      .getRootNode()
      .renderApp() // Need to render full app because of code editor
  }
  // todo: downstream data changes?
  async changeTileContentAndRenderCommand(value) {
    this.setContent(value)
    await this._runAfterTileUpdate(this)
  }
  async copyTileCommand() {
    // todo: remove cousin tiles?
    this
      .getRootNode()
      .getWillowBrowser()
      .copyTextToClipboard(this.getFirstAncestor().toString())
  }
  async createProgramFromTileExampleCommand(index) {
    const template = this.getExampleTemplate(index)
    if (!template) return undefined
    const fileExtension = "maia" // todo: generalize
    const tab = await this
      .getTab()
      .getRootNode()
      ._createAndOpen(template, `help-for-${this.getFirstWord()}.${fileExtension}`)
    tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }
  async inspectTileCommand() {
    if (!this.isNodeJs()) {
      console.log("Tile available at window.tile")
      window.tile = this
      console.log(this)
    }
    this.getTab().addStumpCodeMessageToLog(this.toInspectionStumpCode())
    this
      .getTab()
      .getRootNode()
      .renderApp()
  }
  async toggleToolbarCommand() {
    this.toggleToolbar()
  }
  async createProgramFromTemplateCommand(id) {
    const programTemplate = this.getProgramTemplate(id)
    if (!programTemplate) return undefined
    const tab = await this
      .getTab()
      .getRootNode()
      ._createAndOpen(programTemplate.template, programTemplate.name)
    tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }
  async appendSnippetTemplateCommand(id) {
    const snippet = this.getSnippetTemplate(id)
    if (!snippet) return undefined
    const tab = this.getTab()
    const tabProgram = tab.getTabProgram()
    const newNodes = tabProgram.concat(snippet)
    const newTiles = newNodes.filter(tile => tile.doesExtend && tile.doesExtend("abstractTileTreeComponentNode"))
    tab.autosaveTab()
    tabProgram.clearSelection()
    tab.getTabWall().unmount()
    await tabProgram.loadAndIncrementalRender()
    newTiles.forEach(tile => tile.selectTile())
    newTiles[0].scrollIntoView()
  }
  async copyDataCommand(delimiter) {
    this
      .getRootNode()
      .getWillowBrowser()
      .copyTextToClipboard(this.getOutputOrInputTable().toDelimited(delimiter))
  }
  async copyDataAsJavascriptCommand() {
    const table = this.getOutputOrInputTable()
    this
      .getRootNode()
      .getWillowBrowser()
      .copyTextToClipboard(JSON.stringify(table.toTree().toDataTable(table.getColumnNames()), null, 2))
  }
  async copyDataAsTreeCommand() {
    const text = this
      .getOutputOrInputTable()
      .toTree()
      .toString()
    this
      .getRootNode()
      .getWillowBrowser()
      .copyTextToClipboard(text)
  }
  async exportTileDataCommand(format = "csv") {
    // todo: figure this out. use the browsers filename? tile title? id?
    let extension = "csv"
    let type = "text/csv"
    let str = this.getOutputOrInputTable().toDelimited(",")
    if (format === "tree") {
      extension = "tree"
      type = "text"
      str = this
        .getOutputOrInputTable()
        .toTree()
        .toString()
    }
    this
      .getRootNode()
      .getWillowBrowser()
      .downloadFile(str, this.getTab().getFileName() + "." + extension, type)
  }