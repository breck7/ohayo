tooling onsave jtree build produceTilesGrammar
tileKeywordCell
 highlightScope keyword
abstractTileTreeComponentNode
 abstract
 cells tileKeywordCell
 _extendsJsClass AbstractTreeComponent
 inScope tileBlankLineNode abstractCoreTileSettingTerminalNode
 catchAllNodeType catchAllErrorNode
 int headerHeight 30
 int footerHeight 30
 string hiddenKey hidden
 string visibleKey visible
 string errorLogMessageStumpTemplate
  div Error occurred. See console.
   class OhayoError
 string pencilStumpTemplate
  span {icon}
   class TilePencilButton
   clickCommand toggleToolbarCommand
 string inspectionStumpTemplate
  div TileConstructor: {constructorName} ParentConstructor: {parentConstructorName}
  div Messages:
  ol
   {messages}
  div Tree:
  pre
   bern
    {sourceCode}
  div All Tile Settings:
  pre
   bern
    {settings}
 string errorStateStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div ERROR
    class TileHeader
   div
    class TileBody
    {content}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 string tileStumpTemplate
  div
   class {classes}
   id {id}
   contextMenuCommand openTileContextMenuCommand
   div
    class TileGrabber
    doubleClickCommand toggleTileMaximizeCommand
   div {header}
    class TileHeader
   div
    style {bodyStyle}
    class TileBody
    {body}
   div
    class TileFooter
    {footer}
   div
    class TileGrabber
 javascript
  getProgramTemplate(id) {}
  getSnippetTemplate(id) {}
  getExampleTemplate(index) {
   // todo: right now we only have 1 example per tile.
   const exampleNode = this.getDefinition().getNode(jtree.GrammarConstants.example)
   return exampleNode ? exampleNode.childrenToString() : ""
  }
  emitLogMessage(message) {
   const tab = this.getTab()
   if (tab) tab.addStumpCodeMessageToLog(message)
   else if (this.isNodeJs()) console.log(message)
  }
  getTheme() {
   return this.getTab().getTheme()
  }
  qFormat(str, obj) {
   return new jtree.TreeNode(str).templateToString(obj)
  }
  scrollIntoView() {
   const el = this.getStumpNode()
    .getShadow()
    .getShadowElement()
   if (el) el.scrollIntoView()
  }
  async loadBrowserRequirements() {
   const loadingMap = this.getTab()
    .getRootNode()
    .getDefinitionLoadingPromiseMap()
   if (!loadingMap.has(this.constructor)) loadingMap.set(this.constructor, this._makeBrowserLoadRequirementsPromise(loadingMap))
   await loadingMap.get(this.constructor)
  }
  async _makeBrowserLoadRequirementsPromise(loadingMap) {
   const app = this.getWebApp()
   const cssScript = this[TilesConstants.tileCssScript]
   if (cssScript) this._loadTileCss(cssScript)
   const def = this.getDefinition()
   const scriptPaths = def.nodesThatStartWith("string " + TilesConstants.tileScript).map(node => node.getWord(2))
   const thisScript = this[TilesConstants.tileScript]
   if (thisScript && !scriptPaths.includes(thisScript))
    scriptPaths.push(thisScript)
   if (scriptPaths.length) await Promise.all(scriptPaths.map(scriptPath => app.getWillowBrowser().appendScript(scriptPath)))
   loadingMap.set(this.constructor, true)
  }
  _loadTileCss(css) {
   const app = this.getWebApp()
   app
    .getWillowBrowser()
    .getBodyStumpNode()
    .insertChildNode(
     css
      .split(" ")
      .map(
       url => `link
   rel stylesheet
   media screen
   href ${url}`
      )
      .join("\n")
    )
  }
  _hasBrowserRequirements() {
   return this.tileScript
  }
  _areBrowserRequirementsLoaded() {
   if (this.isNodeJs()) return true
   // todo: cleanup. assumes app is here in browser.
   const loadingMap = app.getDefinitionLoadingPromiseMap()
   return !this._hasBrowserRequirements() || loadingMap.get(this.constructor) === true
  }
  isLoaded() {
   return this._areBrowserRequirementsLoaded()
  }
  getErrorMessageHtml() {
   const errors = Object.values(this.getRunTimePhaseErrors())
   return errors.length ? ` <span style="color: ${this.getTheme().errorColor};">${errors.join(" ")}</span>` : "" //todo: cleanup
  }
  toStumpErrorStateCode(err) {
   return this.qFormat(this.errorStateStumpTemplate, { classes: this.getCssClassNames().join(" "), id: this.getTreeComponentId(), content: `div ` + err, footer: this.getTileToolbarButtonStumpCode() })
  }
  // todo: delete this
  makeDirty() {
   delete this._cache_settingsObject
   delete this._bodyStumpCodeCache // todo: cleanup
   this._setLastRenderedTime(0)
  }
  toggleToolbar() {
   if (!this._tileToolbar) {
    const TileToolbarTreeComponent = this.require("TileToolbarTreeComponent", this._getProjectRootDir() + "ohayoWebApp/treeComponents/TileToolbarTreeComponent.js")
    this._tileToolbar = new TileToolbarTreeComponent("", undefined, this)
    this._tileToolbar.renderAndGetRenderReport(this.getStumpNode())
   } else this._tileToolbar = this._tileToolbar.unmount()
  }
  getAllTileSettingsDefinitions() {
   const def = this.getDefinition()
   return Object.values(def.getFirstWordMapWithDefinitions()).filter(def => def.isOrExtendsANodeTypeInScope([TilesConstants.abstractTileSetting]))
  }
  getTab() {
   return this.getRootNode().getTab()
  }
  getChildTiles() {
   return this.getChildInstancesOfNodeTypeId("abstractTileTreeComponentNode")
  }
  selectTile() {
   this.selectNode()
   if (this.isMounted()) this.getStumpNode().addClassToStumpNode(TilesConstants.selectedClass)
  }
  unselectNode() {
   super.unselectNode()
   if (this.isMounted()) this.getStumpNode().removeClassFromStumpNode(TilesConstants.selectedClass)
  }
  getCssClassNames() {
   const classNames = super.getCssClassNames()
   if (this._isMaximized()) classNames.push("TileMaximized")
   return classNames
  }
  toStumpCode() {
   return this.qFormat(this.tileStumpTemplate, {
    classes: this.getCssClassNames().join(" "),
    id: this.getTreeComponentId(),
    header: this.getTileHeaderBern(),
    bodyStyle: this.customBodyStyle || "",
    body: this._getBodyStumpCodeCache() || "",
    footer: this.getTileFooterStumpCode()
   })
  }
  _getBodyStumpCodeCache() {
   if (!this._bodyStumpCodeCache) this._bodyStumpCodeCache = this.getTileBodyStumpCode()
   return this._bodyStumpCodeCache
  }
  getTileHeaderBern() {
   return `${this.getFirstWord()}`
  }
  cloneAndOffset() {
   const clone = this.duplicate()
   const left = this.getLeft()
   const _top = this.getTop()
   if (left) clone.touchNode(TilesConstants.left).setContent(parseInt(left) + 1)
   if (_top) clone.touchNode(TilesConstants.top).setContent(parseInt(_top) + 1)
   return clone
  }
  getTileBodyStumpCode() {
   return ``
  }
  _getCss() {
   const selector = "#" + this.getTreeComponentId()
   const theme = this.getTheme()
   const visibleCss = this.isVisible() ? "" : "display: none"
   const dimensions = this.getTileDimensionIfAny()
   const dimensionCss = dimensions ? dimensions.toCss() : ""
   const hakonCode = this.hakonTemplate ? new jtree.TreeNode(theme).evalTemplateString(this.hakonTemplate) : this.toHakonCode()
   return `${selector} { ${visibleCss} ${dimensionCss} }
        ${theme.hakonToCss(hakonCode)}`
  }
  getContextMenuStumpCode() {
   return ""
  }
  handleTileError(err) {
   if (!this._errorCount) this._errorCount = 0
   this._errorCount++
   this.getRootNode().goRed(err)
  }
  getWall() {
   return this.getWebApp().getAppWall()
  }
  getWebApp() {
   return this.getTab().getRootNode()
  }
  getTileDimensionIfAny() {
   const dimensions = this.getWall().getWallViewPortDimensions()
   return this.getRootNode()
    .getTileDimensionMap(dimensions.width, dimensions.height)
    .get(this)
  }
  getTileBodyDimension() {
   const dimension = this.getTileDimensionIfAny()
   dimension.height = dimension.height - this.headerHeight - this.footerHeight
   return dimension
  }
  getDependencies() {
   return []
  }
  async runAndrenderAndGetRenderReport() {
   await this.execute()
   return this.renderAndGetRenderReport()
  }
  getTimeToLoad() {
   return this._timeToLoad || 0
  }
  toHakonCode() {
   return ""
  }
  getTileFooterStumpCode() {
   return this.getTileToolbarButtonStumpCode()
  }
  getTileToolbarButtonStumpCode() {
   return this.qFormat(this.pencilStumpTemplate, { icon: Icons("pencil", 16) })
  }
  getDefinedOrSuggestedSize() {
   const size = this.getSuggestedSize()
   const width = this.getWidth()
   const height = this.getHeight()
   return {
    width: width ? width * 20 : size.width,
    height: height ? height * 20 : size.height
   }
  }
  getSuggestedSize() {
   const tileSize = this.tileSize || "280 220"
   const parts = tileSize.split(" ").map(tileSize => parseInt(tileSize))
   return {
    width: parts[0],
    height: parts[1]
   }
  }
  getRequiredDimensionsForTreeLayout(padding = 0) {
   const size = {
    width: 0,
    height: 0
   }
   const children = this.getChildTiles()
   const suggestedSize = this.getDefinedOrSuggestedSize()
   children.forEach(child => {
    const childSize = child.getRequiredDimensionsForTreeLayout(padding)
    size.width += childSize.width
    size.height = childSize.height > size.height ? childSize.height : size.height
   })
   size.width += children.length * padding
   size.width = Math.max(size.width, suggestedSize.width)
   size.height = suggestedSize.height + (children.length ? padding + size.height : 0)
   return size
  }
  getLeft() {
   return this.get(TilesConstants.left)
  }
  getTop() {
   return this.get(TilesConstants.top)
  }
  getWidth() {
   return this.get(TilesConstants.width)
  }
  getHeight() {
   return this.get(TilesConstants.height)
  }
  // Tile child rendering is done at the wall flex level.
  _getChildTreeComponents() {
   return []
  }
  getStumpNodeForChildren() {
   // We render all Tiles on the Wall.
   return this.getStumpNode().getParent()
  }
  async treeComponentDidMount() {
   super.treeComponentDidMount()
   if (this._tileToolbar) this._tileToolbar.renderAndGetRenderReport()
  }
  toInspectionStumpCode() {
   const messages = this.getMessageBuffer().map(message => `li ${moment(message.getLineModifiedTime()).fromNow()} - ${message.childrenToString()}`)
   const settingsDefinitions = this.getAllTileSettingsDefinitions()
    .map(setting => `${setting.getFirstWord()} ${setting.getDescription()}`)
    .join("\n")
   const parentConstructorName = this.getParent().constructor.name
   const constructorName = this.constructor.name
   const sourceCode = this.toString()
   const settings = settingsDefinitions
   return this.qFormat(this.inspectionStumpTemplate, {
    constructorName,
    parentConstructorName,
    sourceCode,
    messages,
    settings
   })
  }
  isVisible() {
   if (this.visible === false) return false
   return this.has(this.visibleKey) || (this.getRootNode().tilesAreVisible() && !this.has(this.hiddenKey))
  }
  _isMaximized() {
   return this.has(TilesConstants.maximized)
  }
  async _executeChildNodes() {
   await Promise.all(this.getChildTiles().map(tile => tile.execute()))
  }
  async _execute() {
   await this._executeChildNodes()
  }
  async execute() {
   try {
    this.setRunTimePhaseError("execute")
    await this._execute()
   } catch (err) {
    this.setRunTimePhaseError("execute", err)
    console.error(err)
    this.emitLogMessage(this.errorLogMessageStumpTemplate)
   }
   return this
  }
  cloneTileCommand() {
   this.cloneAndOffset()
   return this.getTab().autosaveAndRender()
  }
  async toggleTileMaximizeCommand() {
   if (this.has(TilesConstants.maximized)) this.delete(TilesConstants.maximized)
   else this.touchNode(TilesConstants.maximized)
   await this._runAfterTileUpdate(this)
  }
  async triggerTileMethodCommand(value, methodName) {
   await this[methodName](value)
   await this._runAfterTileUpdate(this)
  }
  // todo: refactor.
  async changeTileTypeCommand(newValue) {
   this.setFirstWord(newValue)
   const newNode = this.duplicate()
   // todo: destroy or something? how do we reparse.
   this.unmountAndDestroy()
   const app = this.getTab().getRootNode()
   await Promise.all(this.getRootNode().getTiles().map(tile => tile.loadBrowserRequirements()))
   await this.getTab().autosaveAndRender()
   newNode.runAndrenderAndGetRenderReport()
  }
  changeParentCommand(pathVector) {
   // if (tile.getFirstWordPath() === value) return; // todo: do we need this line?
   const program = this.getRootNode()
   const indexPath = pathVector ? pathVector.split(" ").map(num => parseInt(num)) : ""
   const destinationTree = indexPath ? program.nodeAt(indexPath) : program
   // todo: on jtree should we make copyTo second param optional?
   this.copyTo(destinationTree, destinationTree.length)
   this.unmountAndDestroy()
   return this.getTab().autosaveAndRender()
  }
  async openTileContextMenuCommand() {
   this.getTab()
    .getRootNode()
    .setTargetNode(this)
    .toggleAndRender(OhayoConstants.tileContextMenu)
  }
  destroyTileCommand() {
   this.unmountAndDestroy()
   return this.getTab().autosaveAndRender()
  }
  getNewDataCommand() {
   // todo: have some type of paging system to fetch new data.
  }
  async changeTileSettingAndRenderCommand(value, settingName) {
   // note the unusual ordering of params.
   this.touchNode(settingName).setContent(value.toString())
   // todo: sometimes size needs to be redone (maximize, for example)
   await this._runAfterTileUpdate(this)
  }
  // todo: remove
  async changeTileSettingMultilineCommand(val, settingName) {
   this.touchNode(settingName).setChildren(val)
   await this._runAfterTileUpdate(this)
  }
  async changeTileSettingCommand(settingName, value) {
   this.touchNode(settingName).setContent(value)
  }
  async changeWordAndRenderCommand(value, index) {
   this.setWord(parseInt(index), value)
   await this._runAfterTileUpdate(this)
  }
  async changeWordsAndRenderCommand(value, index) {
   index = parseInt(index)
   const edgeSymbol = this.getEdgeSymbol()
   const words = this.getWords().slice(0, index)
   this.setLine(words.concat(value.split(edgeSymbol)).join(edgeSymbol))
   await this._runAfterTileUpdate(this)
  }
  async updateChildrenCommand(val) {
   this.setChildren(val)
   // reload the whole doc for now.
   await this._runAfterTileUpdate(this)
  }
  async _runAfterTileUpdate(tile) {
   tile.makeDirty() // ugly!
   tile.getChildTiles().forEach(tile => {
    tile.makeDirty() // todo: ugly!
   })
   // todo: what if you have a tile that has a contextare that allows editing of its children/
   // if you edit a child, then that parent tile needs to update to...should we allow that or ban that?
   await tile.getTab().autosaveTab()
   await tile.runAndrenderAndGetRenderReport()
   tile
    .getTab()
    .getRootNode()
    .renderApp() // Need to render full app because of code editor
  }
  // todo: downstream data changes?
  async changeTileContentAndRenderCommand(value) {
   this.setContent(value)
   await this._runAfterTileUpdate(this)
  }
  async copyTileCommand() {
   // todo: remove cousin tiles?
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(this.getFirstAncestor().toString())
  }
  async createProgramFromTileExampleCommand(index) {
   const template = this.getExampleTemplate(index)
   if (!template) return undefined
   const fileExtension = "maia" // todo: generalize
   const tab = await this.getTab()
    .getRootNode()
    ._createAndOpen(template, `help-for-${this.getFirstWord()}.${fileExtension}`)
   tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }
  async inspectTileCommand() {
   if (!this.isNodeJs()) {
    console.log("Tile available at window.tile")
    window.tile = this
    console.log(this)
   }
   this.getTab().addStumpCodeMessageToLog(this.toInspectionStumpCode())
   this.getTab()
    .getRootNode()
    .renderApp()
  }
  async toggleToolbarCommand() {
   this.toggleToolbar()
  }
  async createProgramFromTemplateCommand(id) {
   const programTemplate = this.getProgramTemplate(id)
   if (!programTemplate) return undefined
   const tab = await this.getTab()
    .getRootNode()
    ._createAndOpen(programTemplate.template, programTemplate.name)
   tab.addStumpCodeMessageToLog(`div Created '${tab.getFullTabFilePath()}'`)
  }
  async appendSnippetTemplateCommand(id) {
   const snippet = this.getSnippetTemplate(id)
   if (!snippet) return undefined
   const tab = this.getTab()
   const tabProgram = tab.getTabProgram()
   const newNodes = tabProgram.concat(snippet)
   const newTiles = newNodes.filter(tile => tile.doesExtend && tile.doesExtend("abstractTileTreeComponentNode"))
   tab.autosaveTab()
   tabProgram.clearSelection()
   tab.getTabWall().unmount()
   await tabProgram.loadAndIncrementalRender()
   newTiles.forEach(tile => tile.selectTile())
   newTiles[0].scrollIntoView()
  }
  async copyDataCommand(delimiter) {
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(this.getOutputOrInputTable().toDelimited(delimiter))
  }
  async copyDataAsJavascriptCommand() {
   const table = this.getOutputOrInputTable()
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(JSON.stringify(table.toTree().toDataTable(table.getColumnNames()), null, 2))
  }
  async copyDataAsTreeCommand() {
   const text = this.getOutputOrInputTable()
    .toTree()
    .toString()
   this.getRootNode()
    .getWillowBrowser()
    .copyTextToClipboard(text)
  }
  async exportTileDataCommand(format = "csv") {
   // todo: figure this out. use the browsers filename? tile title? id?
   let extension = "csv"
   let type = "text/csv"
   let str = this.getOutputOrInputTable().toDelimited(",")
   if (format === "tree") {
    extension = "tree"
    type = "text"
    str = this.getOutputOrInputTable()
     .toTree()
     .toString()
   }
   this.getRootNode()
    .getWillowBrowser()
    .downloadFile(str, this.getTab().getFileName() + "." + extension, type)
  }